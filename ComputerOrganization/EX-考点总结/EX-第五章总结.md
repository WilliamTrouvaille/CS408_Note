# EX-第五章 中央处理器$(CPU)$总结

## 导读

### 【考纲内容】

1. **CPU 的功能和基本结构**                                                       
2. **指令执行过程**
3. **数据通路的功能和基本结构**
4. **控制器的功能和工作原理**
5. **异常和中断机制**
    +   异常和中断的基本概念
    +   异常和中断的分类
    +   异常和中断的检测与响应

6. **指令流水线异常**
    + 指令流水线的基本概念
    + 指令流水线的基本实现
    + 结构冒险、数据冒险和控制冒险的处理
    + 超标量和动态流水线的基本概念

7. **多处理器基本概念**
    + $SISD$、$SIMD$、$MIMD$、向量处理器的基本概念
    + 硬件多线程的基本概念
    + 多核$multi-core$处理器的基本概念
    + 共享内存多处理器$SMP$的基本概念

### 【复习提示】

1.   选择题：关于各种寄存器的特点、指令执行的各种周期与特点、控制器的相关概念、流水线的相关概念。

2.   综合题：数据通路的分析，指令执行阶段的节拍与控制信号的安排、流水线技术与性能分析。

## 考点总结

### $CPU$基本概念

1.   $CPU$构成：中央处理器$CPU$由**运算器**和**控制器**组成。其中控制器的功能是负责协调并控制计算机各部件执行程序的指令序列，包括取指令、分析指令和执行指令。运算器的功能是对数据进行加工。

     一台数字计算机基本上可以划分为两大部分：控制部件（控制器）和执行部件（运算器、存储器、外围设备）。

2.   $CPU$总功能：

     1.   指令控制：完成取指令、分析指令和执行指令的操作，即程序的顺序控制。
     2.   操作控制：一条指令的功能往往是由若干操作信号的组合来实现的，$CPU$管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作。
     3.   时间控制：对各种操作加以时间上的控制。时间控制要为每条指令按时间顺序提供应有的控制信号。
     4.   数据加工：对数据进行算术和逻辑运算。
     5.   中断处理：对计算机运行过程中出现的异常情况和特殊请求进行处理。

3.   运算器结构和功能：运算器是计算机对数据进行加工处理的中心，它主要由算术逻辑单元$ALU$、暂存寄存器、累加寄存器$ACC$、 通用寄存器组、程序状态字寄存器$PSW$、移位器、计数器$CT$等组成。

     1.   算术逻辑单元$ALU$：进行算术/逻辑运算。
     2.   暂存寄存器$R$：用于暂存**从主存读来的数据**，该数据不能存放在通用寄存器中，否则会破坏其原有内容。**暂存寄存器对应用程序员是透明的**。
     3.   累加寄存器$ACC$：也是通用寄存器，用于暂时存放$ALU$运算的结果信息，运算的结果信息，用于实现加法运算。
     4.   通用寄存器组$X$：如$AX、BX、CX、DX、SP$等，用于存放操作数（包括源操作数、目的操作数及中间结果）和各种地址信息等。**内容可由程序员指定**。$SP$是堆栈指针，用于指示栈顶的地址。
     5.   程序状态字寄存器$PSW$：保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息，内容可由程序员指定。
     6.   移位器/移位寄存器：对操作数或运算结果进行移位运算。
     7.   计数器$CT$：控制乘除运算的操作步数。
     8.   内部总线：见下数据通路处。

4.   控制器结构和功能：控制器的基本功能是执行指令，每条指令的执行一组微操作实现的。 $PC$(取指令)$\to$$IR$(分析指令)$\to$$CU$(执行指令)。

     1.   程序计数器$PC(Program\;Counter)$：用于指出**下一条执行的指令**在主存中的**存放地址**。$CPU$根据$PC$的内容去主存中取指令。**内容可由程序员指定**。因程序中指令（通常）是顺序执行的，所以$PC$有自增功能。$PC$的位数取决于存储器的**存储单元个数**。
          +   执行转移指令时，需要判别转移是否成功，若成功则$PC$修改为转移指令的目标地址，否则下一条指令的地址仍然为$PC$自增后的地址。
     2.   指令寄存器$IR(Instruction\;Register)$：用于保存**当前正在执行指令**。指令寄存器$IR$中存放当前执行的指令，不需要用户的任何干预，**所以对用户是透明的**。$IR$保存当前正在执行的指令，所以其位数取决于指令字长。
     3.   指令译码器$ID(Instruction\;Decoder)$。仅对**操作码**字段进行译码，向控制器提供特定的操作信号。
     4.   存储器地址寄存器$MAR$：用于存放要访问的主存单元的地址。$MAR$位数取决于存储器的**存储单元个数**。
     5.   存储器数据寄存器$MDR$：用于存放向主存写入的信息或从主存读出的信息。$MDR$位数取决于存储器的**存储字长**。
     6.   时序系统$TG(Timing\;Generator)$：用于产生各种时序信号，它们都由统一时钟$CLOCK$分频得到。
     7.   微操作信号发生器：根据$IR$的内容（**指令**）、$PSW$的内容（**状态信息**）及**时序信号**，产生控制整个计算机系统所需的各种控制信号，其结构有组合逻辑型和存储逻辑型两种。

5.   ※※某部件是否透明：取决于该部件的功能是否有必要被用户操作。

     1.   对所有用户/程序员可见：程序计数器$PC$，通用寄存器组$X$，累加寄存器$ACC$。
     2.   对汇编程序/汇编程序员可见：编写汇编程序需要的，用户可见的汇编程序员也可见。
          +   中断字寄存器：可以修改中断的优先级。
          +   中断保存的现场信息：由中断服务程序（操作系统）保存。
          +   基址寄存器：基址寻址，可由用户决定哪个寄存器作为基址寄存器，**但内容由操作系统决定**。
          +   变址寄存器：变址寻址，可由用户决定内容。常用于数组的访问需要。
          +   程序状态字寄存器$PSW$：有无进位$CF$、有无溢出$OF$、结果正负$SF$、结果是否为零$ZF$。
     3.   完全透明，对所有用户不可见。
          +   **指令寄存器$IR$**，最常考。
          +   微指令寄存器$\mu IR$，包括它的好朋友们$\mu MAR,\mu MDR$。微指令相关基本不可见。
          +   暂存寄存器$R$。
          +   高速缓存$Cache$。
          +   存储器地址寄存器$MAR$，存储器数据寄存器$MDR$。
          +   微程序的结构和功能。

### 指令执行

#### 指令执行概述

1.   每个指令周期内机器周期数可以不等，每个机器周期内的节拍数也可以不等。以下所有工作周期都有$CPU$访存操作，只是访存的目的不同（取指周期是为了取指令，间址周期是为了取有效地址，执行周期是为了取操作数，中断周期是为了保存程序断点）。
2.   执行周期：任务是根据$IR$中的指令字的操作码和操作数通过$ALU$操作产生执行结果。不同指令的执行周期操作不同，因此没有统一的数据流向。
3.   指令执行方案：一个指令周期通常要包括多个时间段（执行步骤），每个步骤完成指令的一部分功能，几个依次执行的步骤完成这条指令的全部功能。
     1.   单指令周期：**每条指令都在一个时钟周期内完成**，指令之间**串行执行**，即下一条指令只能在前一条指令执行结束后才能启动**。指令周期取决于**执行时间最长的指令的执行时间**。执行周期内控制信号不变。
          1.   缺点：对于那些本来可以在更短时间内完成的指令，要使用这个较长的周期来完成，会降低整个系统的运行速度。
          2.   优点：实施简单，只用程序计数器$PC$就能实现。
     2.   多指令周期：**不要求所有指令占用相同的执行时间**，对不同类型的指令选用不同的执行步骤来完成，可选用不同个数的时钟周期来完成不同指令的执行过程，指令需要几个周期就为其分配几个周期。指令之间**串行执行**，即下一条指令只能在前一条指令执行结束后才能启动。
          1.   缺点：需要更复杂的硬件设计。
          2.   优点：系统运行速度更高，效率更高。
     3.   流水线方案：指令之间可以**并行执行**，力争在每个时钟脉冲周期完成一条指令的执行过程（理想情况）。在每一个时钟周期启动一条指令，尽量让多条指令同时运行，但各自处在不同的执行步骤中。

#### 取值周期

取指周期：根据$PC$内容（无论是普通指令还是转移指令）从内存中取出指令代码/指令字并放入$IR$中。**所有指令**在取指令的同时，$PC$内容`+1`。

1.   $PC\stackrel{(1)}{\longrightarrow}MAR\stackrel{(2)}{\longrightarrow}$地址总线$\stackrel{(3)}{\longrightarrow}$主存

     1.   当前指令地址送至存储器地址寄存器，记做：$(PC)\rightarrow MAR$。
     2.   $MAR$将地址码发送到地址总线。
     3.   地址总线将地址发送给存储器，等待使用地址。
2.   $CU$发出读命令$\stackrel{(4)}{\longrightarrow}$控制总线$\stackrel{(5)}{\longrightarrow}$主存。

     4.   $CU$发出控制读信号给控制总线。
     5.   控制总线将控制读的信号发送给存储器。启动存储器做读操作，这是是**读信号**，记做：$1\rightarrow R$。
          + $R$（头上没有横杠）表示高电平激活，这里$1$表示高电平。

3.   主存$\stackrel{(6)}{\longrightarrow}$数据总线$\stackrel{(7)}{\longrightarrow}MDR\stackrel{(8)}{\longrightarrow}IR$ （存放指令）。

     6.   存储器根据**地址总线**传来的地址信息和**控制总线**传来的控制读信息来进行读操作，从中读出数据，并将地址所指的数据发送给数据总线。
     7.   数据总线将数据送入$MDR$，记做：$M(MAR)\rightarrow MDR$。
          + $M(MAR)$指主存$(Memory)$中$MAR$存储地址所指的数据。

     8.   将$MDR$中数据（此时是指令内容）**复制**送入$IR$，记做：$(MDR)\rightarrow IR$。

4.   $CU$发出控制信号$\stackrel{(9)}{\longrightarrow}PC$内容`+1`

     9.   $CU$发出控制信号，控制$PC$形成下一条指令地址，默认是加一，记做：$(PC)+1\rightarrow PC$。

#### 间址周期

间址周期：根据间接地址取操作数有效地址。将指令中的地址码送到$MAR$并送至地址总线，此后$CU$向存储器发读命令，以获取有效地址并存至$MDR$。 

1.   $Ad(IR){\tiny \mathbb{OR}}   MDR\stackrel{(1)}{\longrightarrow}MAR\stackrel{(2)}{\longrightarrow}$地址总线$\stackrel{(3)}{\longrightarrow}$主存。

     1.   $IR$将指令的地址码送入$MAR$，记做：$Ad(IR)\rightarrow MAR {\tiny \mathbb{OR}}  Ad(MDR)\rightarrow MAR$。
          + 由于取指周期$(MDR)\rightarrow IR$时，$MDR$是复制一份地址码送入$IR$的，此时$MDR$中还留有地址码。
     2.   $MAD$将地址码发送到地址总线。
     3.   地址总线将地址发送给存储器，等待使用地址。
2.   $CU$发出读命令$\stackrel{(4)}{\longrightarrow}$控制总线$\stackrel{(5)}{\longrightarrow}$主存。

     4.   $CU$发出控制读信号给控制总线。
     5.   控制总线将控制读信息发送到存储器中，启动主存做**读操作**，记做：$1\rightarrow R$。
3.   主存$\stackrel{(6)}{\longrightarrow}$数据总线$\stackrel{(7)}{\longrightarrow}MDR$ （存放有效地址）$\underline{\stackrel{(8)}{\longrightarrow}Ad(IR)} $。

     6.   存储器根据地址总线传来的地址信息和控制总线传来的控制读信息来进行读操作，从中读出数据，并将地址所指的数据发送给数据总线。
     7.   数据总线将数据送入$MDR$，记做：$M(MAR)\rightarrow MDR$。

          +   此时$MDR$保存的是操作数的地址而不是操作数本身。
     8.   将有效地址送至指令的地址码字段，记做：$MDR\rightarrow Ad(IR)$。

          + 这一步只有部分$CPU$会有，且会将有效地址覆盖于原指令的间接地址。

#### 中断周期

当$CPU$采用**中断方式**实现**主机和I/O设备的信息交换**时，$CPU$在每条指令执行结束前，都要发中断查询信号，若有中断请求，则$CPU$进入中断响应阶段，即**中断周期**。

中断周期：是处理中断请求。一般使用**堆栈**来保存断点，这里用$SP$表示栈顶地址，假设$SP$指向栈顶元素，进栈操作是先修改指针，后存入数据。

1.   $CU$控制将$SP$减1，然后$SP\stackrel{(1)}{\longrightarrow}MAR\stackrel{(2)}{\longrightarrow}$地址总线$\stackrel{(3)}{\longrightarrow}$主存。

     1.   $CU$控制将**$SP$减$1$**，即将一个空元素进栈然后对其操作，并修改后的地址送入$MAR$，记做：$(SP)-1\rightarrow SP$，$(SP)\rightarrow MAR$。本质上是将断点存入某个存储单元，假设其地址为$a$，故可记做：$a\rightarrow MAR$。
          + 计算机的堆栈中**从高向低地址增加**，进栈操作是减$1$而不是加$1$，中断周期中的进栈操作是将$SP$减$1$。
     2.   $MAR$将地址码发送到地址总线。
     3.   地址总线将地址发送给存储器，等待使用地址。

2.   $CU$发出写命令$\stackrel{(4)}{\longrightarrow}$控制总线$\stackrel{(5)}{\longrightarrow}$主存。

     4.   $CU$发出控制写信号给控制总线。

     5.   控制总线将控制写信息发送到存储器中，启动主存做**写操作**，记做：$1\rightarrow W$。

3.   $PC\stackrel{(6)}{\longrightarrow}MDR\stackrel{(7)}{\longrightarrow}$数据总线$\stackrel{(8)}{\longrightarrow}$主存（程序断点存入主存）。

     6.   将断点（$PC$内容）送入$MDR$，记做：$(PC)\rightarrow MDR$。

     7.   将$MDR$内容传入数据总线。
     8.   数据总结将内容发送存储器，存储器将内容写入其中，记为$(MDR)\rightarrow M$。

4.   $CU $（中断服务程序的入口地址）$\stackrel{(9)}{\longrightarrow}PC$

     9.   $CU$控制将中断服务程序的入口地更新（由向量地址形成部件产生）送入$PC$：向量地址$\rightarrow PC$。

### 数据通路

1.   数据通路的功能：实现$CPU$内部的运算器与寄存器及寄存器之间的数据交换。

2.   数据通路的组成：数据通路上流经的部件，如$ALU$、$Cache$、**内存管理单元$MMU$**、通用寄存器、状态寄存器、**异常和中断处理逻辑**等都是指令执行过程中**数据流经**的部件，都属于数据通路的一部分。

3.   数据通路的基本结构$CPU$内部单总线方式、$CPU$内部多总线方式、专用数据通路方式。

     1.   $CPU$内部单总线方式：将所有寄存器的输入端和输出端都连接到一条公共的通路上。结构简单，容易实现，但数据传输存在较多冲突的现象，性能较低。

          为什么单总线的输入输出端分别设置一个暂存器？

          1.   因为**在单总线结构中，同一时刻总线上只有一个数据有效**，而$ALU$有两个输入端和一个输出端。
          2.   因此，当$ALU$运算时，需要先用暂存器$Y$缓存其中一个输入端的数据，再通过总线传送另一个输入端的数据。
          3.   与此同时，$ALU$的输出端产生运算结果，但由于总线正被占用，因此需要暂存器$Z$，以缓存$ALU$的输出端数据。

     2.   专用数据通路方式：根据指令执行过程中的数据和地址的流动方向安排多条连接线路。寄存器有多少位就有多少根线连着$ALU$，寄存器将操作数的所有位并行的传输到$ALU$中。性能较高，基本不存在数据冲突现象，但结构复杂，硬件量大，不易实现。如果直接用导线连接，相当于多个寄存器同时并且一直向$ALU$传输数据，会发生**总线冲突**，解决方法：

          1. 使用**多路选择器$MUX$**根据控制信号选择单独一路输出。
          2. 使用**三态门**可以控制每一路是否输出，$1$允许，$0$不允许。

     3. $CPU$内部多总线方式：将所有寄存器的输入端和输出端都连接到多条公共通路上。可以同时在多个总线上传送不同的数据，提高效率。效率相对于单总线而言得到了提升。使用多根总线连接部件的输入和输出。

4.   控制信号：控制单元$CU$根据指令操作码发出的信号。

     1.   对于**单周期处理器在每个时钟周期内控制信号并不会变化**（每条指令的执行只有一个时钟周期）。
     2.   若是**多周期处理器在每个时钟周期内控制器会发出不同信号**（指令的执行需要多个时钟周期）。

5.   控制信号分类

     1.   寄存器之间的数据传送：通过$CPU$内部总线完成。例如$(PC) \to MAR$控制信号为：$PC_{out}$ 和 $MAR_{in} $有效。
     2.   主存与$CPU$之间的数据传送：也要借助$CPU$内部总线完成。例如$CPU$从主存读取指令
          1.   $(PC)\to MAR$：$PC_{out}$和$MAR_{in}$有效。
          2.   $1\to R$：$Read$。
          3.   $MEM(MAR)\to MDR$ ：$MDR_{in}$和$MAR_{out}$有效。
          4.   $(MDR) \to IR$：$MDR_{out}$和$IR_{in}$有效。
     3.   执行算术或逻辑运算：由于**$ALU$本身是没有内部存储功能的组合电路**，因此如要执行加法运算，**相加的两个数必须在$ALU$的两个输入端同时有效**。先将一个操作数经$CPU$内部总线送入在总线和$ALU$之间的暂存器$Y$处保存，$Y$的内容在$ALU$的一输入端**始终有效**，再将另一个操作数经总线直接送到$ALU$的另一输入端。执行运算后运算结果暂存在暂存器$Z$中（避免总线冲突）。
          1.   $(MDR) \to MAR$：$MDR_{out}$和$MAR_{in}$有效。
          2.   $1\to R$：$Read$。
          3.   $MEM(MAR)\to MDR$ ：$MDR_{in}$和$MAR_{out}$有效。
          4.   $(MDR)\to Y$ ：$MDR_{out}$和$Y_{in}$有效
          5.   $(ACC) + (Y)\to Z $：$ACC_{out}$和$ALU_{in}$有效，$Add$。
          6.   $(Z)\to ACC $：$Z_{out}$和$ACC_{in}$有效

### 控制器的工作原理和功能

#### 控制器概述

微程序比较重要，硬布线了解即可

1.   控制器的结构：控制器和其余功能部件通过数据总线、地址总线和控制总线连接在一起。
     1.   运算器部件通过**数据总线**与内存储器、输入设备和输出设备传送数据。
     2.   输入设备和输出设备通过**接口电路**与总线相连接。
     3.   内存储器、输入设备和输出设备从**地址总线**接地址信息，从**控制总线**得到控制信号， 通过**数据总线**与其他部件传送数据。
     4.   控制器部件从**数据总线**接收指令信息，从运算器部件接收指令转移地址，送出指令地址到地址总线，还要向系统中的部件提供它们运行所需要的控制信号。
2.   控制器的主要功能
     1.   从主存中取出一条指令，并指出下一条指令在主存中的位置。
     2.   对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作。
     3.   指挥并控制$CPU$、主存、输入和输出设备之间的数据流动方向。 
3.   硬布线控制器的特点
     1.   指令越多，设计和实现就越复杂，因此一般用于**精简指令集系统$RISC$**。
     2.   扩充指令较困难：如果需要扩充一条新的指令，控制器的设计就必须大改。
     3.   执行速度很快：使用**纯硬件实现**控制。
4.   微程序控制器的特点：和组合逻辑控制器相比，微程序控制器具有规整性、灵活性、可维护性等一系列优点；缺点是由于微程序控制器采用了存储程序原理，所以每条指令都要从控制存储器中取一次，影响速度

#### 硬布线控制器

硬布线控制器的基本原理是根据指令的要求、当前的时序及外部和内部的状态，按时间的顺序发送一系列微操作控制信号。

硬布线控制器由复杂的组合逻辑门电路和一些触发器构成，因此又称**组合逻辑控制器**。

1.   $CU$的输入信号来源：前两者是主要因素
     1.   经指令译码器译码产生的指令信息：指令寄存器：$OP(IR)\rightarrow CU$，控制信号的产生与**操作码**有关。
     2.   时序系统产生的机器周期信号和节拍信号：一个时钟脉冲使控制单元发送一个操作命令，或发送一组需要同时执行的操作命令。
     3.   来自执行单元的反馈信息，即标志：根据上条指令的结果来产生不同的控制信号。 可能来自运算器的$PSW$、$ACC$的符号位等。也可能来自$I/O$设备、主存。
2.   硬布线控制器的时序系统及微操作
     1.   时钟周期：用时钟信号控制**节拍发生器**产生节拍，**每个节拍的宽度正好对应一个时钟周期**。在每个节拍内机器可完成一个或几个需同时执行的操作。
     2.   机器周期：机器周期可视为所有指令执行过程中的一个基准时间。不同指令的操作不同， 指令周期也不同。
          1.   访问一次存储器的时间是固定的，因此通常**以存取周期作为基准时间**， 即内存中读取一个指令字的最短时间作为机器周期。
          2.   在存储字长等于指令字长的前提下，取指周期也可视为机器周期。 
          3.   在一个机器周期里可完成若干微操作，每个微操作都需一定的时间，可用时钟信号来控制产生每个微操作命令。
     3.   指令周期。见指令周期
     4.   微操作命令分析：控制单元具有发出各种操作命令（控制信号）序列的功能。这些命令与指令有关，而且必须按一定次序发出，才能使机器有序地工作。 
3.   $CPU$的控制方式：控制单元$CU$控制一条指令执行的过程，实质上是依次执行一个确定的微操作序列的过程。由于不同指令所对应的微操作数及复杂程度不同，因此每条指令和每个微操作所需的执行时间也不同。主要有以下3种控制方式。
     1.   同步控制方式：系统有一个统一的时钟，所有的控制信号均来源于统一的时钟信号。**通常以最长的微操作序列和最烦琐的微操作作为标准**，采取完全统一的、具有相同时间间隔和相同数目的节拍作为机器周期来运行不同的指令。优点是控制电路简单，缺点是运行速度慢。

     2.   异步控制方式：异步控制方式**不存在基准时标信号**，各部件按自身固有的速度工作，通过**应答方式**进行联络。 异步控制方式的优点是运行速度快，缺点是控制电路比较复杂。
     3.   联合控制方式：大部分采用同步控制、小部分采用异步控制。
4.   设计步骤
     1.   列出微操作命令的操作时间表：根据微操作节拍安排，列出微操作命令的操作时间表。 操作时间表中包括各个机器周期、节拍下的每条指令完成的微操作控制信号。
     2.   进行微操作信号综合，写出微操作指令的逻辑表达式。表达式即微操作控制信号=机器周期$\and$节拍$\and$脉冲$\and$操作码$\and$机器状态条件。
     3.   画出微操作命令的逻辑图：根据逻辑表达式可画出对应每个微操作信号的逻辑电路图， 并用逻辑门电路实现。

#### 微程序控制器

目前，大多数计算机都采用微程序设计技术。

1.   相关概念：微命令<微指令<微程序。

     1.   微命令：在微程序控制的计算机中，将控制部件向执行部件发出的各种控制命令称为**微命令**，它是**构成控制序列的最小单位**。
     2.   微指令：微指令是微程序的**最小执行单位**，是对硬件层面的微操作进行编码的指令，包含了对$CPU$中各个部件的控制信号、操作码和地址等信息。**微指令是若干微命令的集合**。一条微指令通常至少包含两大部分信息： 
          1.   操作控制字段/微操作码字段：产生某一步操作所需的各种操作控制信号。 
          2.   顺序控制字段/微地址码字段：控制产生下一条要执行的微指令地址。 
     3.   微程序：微程序是一系列微指令的集合，用于实现特定的指令集和操作序列。微程序通常以存储器的形式存在，存储着每条指令对应的微指令序列。**一个微程序的周期对应一个指令周期**。
     4.   微操作：一条机器指令可以分解成一个微操作序列，微操作是对硬件中的某个具体操作进行编码的指令，它是微指令的**基本执行单位**。
     5.   微周期：从中读取一条**微指令**并执行相应的**微操作**所需的时间，通常为**一个时钟周期**。
     6.   **控制存储器**$CM$：$CM$用于存放微程序，在$CPU$内部，用$ROM$实现。决定了$CPU$对指令集的支持和执行效率。
     7.   微地址寄存器$CMAR$（别名$\mu PC$）：接收微地址形成部件送来的微地址，为在**控制存储器**$CM$中读取微指令作准备。决定的是微指令执行顺序，无法决定指令执行顺序
     8.   微指令寄存器$CMDR$（别名$\mu IR$）：用于存放从**控制存储器**$CM$中取出的微指令，它的位数**与微指令字长**相等。

2.   微程序控制器的工作过程：实际上就是在微程序控制器的控制下计算机执行机器指令的过程。

     1.   执行取微指令公共操作。在机器开始运行时，自动将取指微程序的入口地址送入**微地址寄存器**$CMAR(\mu PC)$，并从**控制存储器**$CM$中读出相应的微指令送入**微指令寄存器**$CMDR(\mu IR)$。
          +   取指微程序的入口地址一般为**控制存储器**$CM$的0号单元，当取指微程序执行完后，从主存中取出的机器指令就已存入指令寄存器中。 
     2.   由机器指令的操作码字段通过微地址形成部件产生该机器指令所对应的微程序的入口地址，并送入**微地址寄存器**$CMAR(\mu PC)$。
     3.   从**控制存储器**$CM$中逐条取出对应的微指令并执行。 
     4.   执行完对应于一条机器指令的一个微程序后，又回到取指微程序的入口地址，继续第`1.`步，以完成取下一条机器指令的公共操作。

3.   微程序和机器指令的个数对应关系

     1.   通常，**一条机器指令对应一个微程序**。
          + 物理上，取指址周期、执行周期看起来像是两个微程序，但由于任何机器指令的取指令操作都是相同的，因此可将取指令操作的微命令统一编成一个微程序，逻辑上应该把它们看作一个整体。
     2.   取指周期微程序默认是公共的（即单独拿出来公用），故如果某指令系统中有$n$条机器指令，则**控制存储器**$CM$中**微程序段**的个数至少是$n+1$个（加一个取指的公共微程序）。
          + 也可以说**微程序**的个数至少是$n$个
     3.   间址周期微程序和中断周期微程序不一定是公共的。
          + 若是公共的，如果这台计算机指令系统中有$n$条机器指令，则**控制存储器**$CM$中**微程序**的个数是$n+3$个
          + 若题目中没有提到间址，就不考虑间址，所以是$n+2$个。

4.   微指令编码：指如何对微指令的控制字段进行编码，以形成控制信号。编码的目标是在保证速度的情况下，尽量缩短微指令字长。

     1.   直接编码（直接控制）方式：在微指令的操作控制字段中，每一位二进制位代表一个微操作命令。设计微指令时，选用或不选用某个微命令，只要将表示该微命令的对应位设置成$1$（有效，同时执行）或$0$（不运行）即可

          优点：简单、直观，执行速度快，操作并行性好。

          缺点：微指令字长过长，$n$个微命令就要求微指令的操作字段有$n$位，造成控存容量极大。

     2.   字段直接编码方式：将微指令的控制字段分成若干“段”，每段经译码后发出控制信号。每个字段独立编码，每种编码代表一个微命令且各字段编码含义单独定义，与其他字段无关。

          微命令字段分段的原则为**把互斥性微命令组合在同一字段中，把相容性微命令组合在不同字段中**。

          1. 因为每组译码后可以通过每位$1\&0$的不同来让每组中的操作互斥，而不同组则很难完成互斥，所以**互斥性微命令分在同一段内**，因为命令在不同的组可以同时执行，所以**相容性微命令分在不同段内**。
              +   例如$001\&011$是相容性微命令，可以并行发出；$001\&100$是互斥性微命令，不可以并行发出。
          2. 每个小段中包含的信息位不能太多，否则将增加译码线路的复杂性和译码时间。
          3. 一般每个小段还要留出一个状态，表示本字段不发出任何微命令。通常用$000$表示不操作。
              +   因此，当某字段的长度为$3$位时，最多只能表示$2^3-1=7$个互斥的微命令

          优点：可以缩短微指令字长。

          缺点：要通过译码电路后再发出微命令，因此比直接编码方式慢。

     3.   字段间接编码方式：一个字段的某些微命令需由另一个字段中的某些微命令来解释（两层译码），由于不是靠字段直接译码发出的微命令，故称为字段间接编码，又称隐式编码。

          优点：可进一步缩短微指令字长。

          缺点：运行速度更慢；削弱了微指令的并行控制能力，故通常作为字段直接编码方式的辅助手段。

5.   微指令地址形成方式

     1.   直接由微指令的**下地址字段**指出：微指令格式中设置一个下地址字段，由微指令的下地址字段直接指出后继微指令的地址，这种方式又称为**断定方式**。
     2.   根据机器指令的**操作码**形成：当机器指令取至指令寄存器后，微指令的地址由操作码经微地址形成部件形成。
     3.   **增量计数器法**：$(CMAR)+1 \rightarrow CMAR$，适用于指令**连续存放**的情况。
     4.   分支转移：指令分为三个字段：操作控制字段（指明操作控制类型）、转移方式（指明判别条件）、转移地址（指明转移成功后的去向）。
     5.   通过测试网络。
     6.   由硬件直接产生微程序入口地址。

6.   微指令的格式

     1.   水平型微指令：一次能定义并执行多个并行操作。从编码方式看，直接编码、字段直接编码、字段间接编码和混合编码都属于水平型微指令。指令字中的一位对应一个控制信号，有输出时为1，否则为0。

          +   基本格式：操作控制+判别测试+后继地址。

          优点：微程序短，执行速度快。

          缺点：操作控制字段比较长导致微指令长，编写微程序较麻烦。

     2.   垂直型微指令：类似机器指令操作码的方式，由微操作码字段规定指令的功能，一条指令对应一个操作。采用**微操作码编译法**，由微操作码规定微指令的功能。**一条垂直型微指令只能定义并执行一种基本操作**。

          + 基本格式：微操作码+目的地址+源地址。

          优点：微操作码短导致微指令短、简单、规整，便于编写微程序。

          缺点：微程序长，执行速度慢，工作效率低。

     3.   混合型微指令：在垂直型的基础上增加一些不太复杂的并行操作。微指令较短，仍便于编写。微程序也不长，执行速度加快。

7.   微程序控制单元设计设计步骤

     1.   分析每个阶段的微操作序列。
     2.   写出对应机器指令的微操作命令及节拍安排：写出每个周期所需要的微操作（参照硬布线）并补充微程序控制器特有的微操作：
          1.   取指周期：$Ad(CMDR)\rightarrow CMAR$；$OP(IR)\rightarrow CMAR$。
          2.   执行周期：$Ad(CMDR)\rightarrow CMAR$。
     3.   确定微指令格式：根据**微操作数**和**微指令数**确定微指令的**操作控制字段**和**顺序控制字段**的位数。最后按操作控制字段位数和顺序控制字段位数就可确定微指令字长。
     4.   编写微指令码点：根据操作控制字段每一位代表的微操作命令，编写每一条微指令的码点。

8.   微程序设计分类

     1.   静态微程序设计：无需改变，采用$ROM$。
     2.   动态微程序设计动态通过改变微指令和微程序改变机器指令，有利于仿真，采用$EPROM$。
     3.   毫微程序设计：微程序设计用微程序解种机器指令，毫微程序设计用毫微程序解释微程序。

### 指令流水线

#### 流水线概述

1.   指令流水线：将一个任务分解为几个不同的子阶段，每个阶段在不同的功能部件上并行执行，以便在**同一时刻能够同时执行多个任务**，进而提升系统性能和处理机的并行性。

     1.   将一条指令的执行过程分为如下$5$个阶段（也称功能段或流水段），把第$k+1$条指令的**取指阶段**$IF$提前到第$k$条指令的**译码阶段**$ID$，从而将第$k+1$条指令的译码阶段与第$k$条指令的执行阶段同时进行。

          1.   取指$IF$：从指令存储器或$Cache$中取指令。
          2.   译码/读寄存器$ID$：操作控制器对指令进行译码，同时从寄存器堆中取操作数。
          3.   执行/计算地址$EX$：执行运算操作或计算地址。
          4.   访存$MEM$：对存储器进行读写操作。
          5.   写回$$WB$$：将指令执行结果写回寄存器堆。
     2.   理想情况下，每个时钟周期都有一条指令进入流水线，每个时钟周期都有一条指令完成，每条指令的时钟周期数$CPI$都为$1$。
     3.   ※指令流水段个数以**最复杂指令所用的功能段个数**为准，流水段的长度以**最复杂的操作所花的时间**为准。**若有寄存器延时还应该加上寄存器延时**。
     4.   流水线方式并不能缩短**单条指令**的执行时间， 但对于整个程序来说，执行效率得到了大幅增高，主要用于密集型应用。
     5.   为了利于实现指令流水线，指令集应具有如下特征：与**精简指令集计算机**$RISC$相契合，~~本来也是开发给$RISC$ 的~~。

          1.   指令长度应尽量一致，有利于简化取指令和指令译码操作。
          2.   指令格式应尽量规整，尽量保证源寄存器的位置相同，有利于在指令未知时就可取寄存器操作数。
          3.   让$Load/Store$指令唯一访问存储器。
          4.   数据和指令在存储器中对齐存放。

2.   流水线的数据通路：**※※不包括控制部件**。

     1.   取指$IF$：程序计数器$PC$、指令存储器、 下条指令地址的计算逻辑。
     2.   译码$ID$：操作控制器、取操作数逻辑、立即数符号扩展模块。
     3.   执行$EX$：算术逻辑单元$ALU$、分支地址计算模块。
     4.   访存$MEM$：数据存储器读写模块。
     5.   写回$$WB$$：寄存器写入控制模块。

     每个流水段后面都需要增加一个**流水寄存器/锁存器**，用于锁存本段处理完成的数据和控制信号，给下一阶段用。

     各种寄存器和数据存储器均采用统一时钟$CLK$进行同步。

3.   流水线的控制信号：由$ID$段负责译码生成控制信号，并分别在随后的各个时钟周期内使用。控制信号的来源并不一致，可以来自其他段（不一定来自之前的段），其他控制信号通过控制器产生。

4.   **流水寄存器/锁存器**中保存的信息：

     1.   后面流水段需要用到的数据信息，均为前面阶段执行的结果：包括$PC$自增、指令、立即数、目的寄存器、$ALU$运算结果、标志信息等。
     2.   后面各流水段要用到的所有控制信号：前面阶段传递过来的。

5.   ※流水线的冒险和处理：在指令流水线中，可能会遇到一些情况使得流水线无法正确执行后续指令而引起流水线**阻塞或停顿**。

     1.   结构冒险/资源冲突：属于互斥问题。由于多条指令**在同一时刻争用同一资源**而形成的冲突。解决办法为

          1.   暂停：前一指令访存时，使后一条相关指令以及其后续指令均暂停一个时钟周期。
          2.   数据$Cache$和指令$Cache$分离：单独设置数据存储器和指令存储器，使取数和取指令操作各自在不同的存储器中进行。 事实上，现代计算机都引入了 $Cache$机制，而$L1\; Cache$默认采用数据$Cache$和指令$Cache$分离的方式，因而也就避免了资源冲突的发生

     2.   数据冒险/数据冲突：属于同步问题。对于两条指令，存在必须等前一条指令执行完才能执行后一条指令的情况，即**上一个指令想要写的存储器会被下一条指令读**。

          数据冲突的基本类型

          1.   写后读$RAW$：没有写完就读取，按序发射，按序完成只会出现写后读的错误。
          2.   读后写$WAR$：乱序发射，优化手段导致指令顺序不符合编写程序时预想的逻辑顺序。
          3.   写后写$WAW$：存在多个功能部件时，后一条指令先于前一条指令完成。

          解决办法为

          1.   暂停：把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行。可分为**硬件阻塞**$stall$和软件插入**空指令**$NOP$两种方法。

               +   每个**空指令**$NOP$也有单独的完整的所有阶段（一般是五个）。
          2.   数据旁路技术：属于硬件措施。计算**得到结果后不写回**，直接当作输入使用。
          3.   编译优化：通过编译器调整指令顺序使**后续指令不依赖之前的计算结果时提前执行**。

     3.   控制冒险/控制冲突：主要针对转移指令。改变指令执行顺序（执行转移、调用或返回等指令）时，会改变$PC$值造成断流。解决办法为

          1.   分支预测，尽早判别转移是否发生，尽早生成转移目标地址。
               1. 简单预测：永远猜$True$或$False$
               2. 动态预测：根据历史情况动态调整，有较高的预测准确率
          2.   预取转移成功和不成功两个控制流方向上的目标指令。
          3.   加快和提前形成条件码。
          4.   提高转移方向的猜准率。

6.   流水线阻塞：真题中常出现流水线的阻塞现象。可能需要解释原因。

     1.   资源冲突：上一条指令的$WB$写回的寄存器与本指令对应的寄存器相同。如图，原因如下

          ![image-20230910213933096](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309102139314.png)

          第三条指令$I_3$由于$I_1$与$I_2$和$I_3$都存在数据相关，需等到$I_1$和$I_2$将结果写回寄存器后，$I_3$才能读寄存器内容，所以阻塞了$ 3$个时钟周期

          第四条指令$I_4$由于其前一条指令$I_3$在ID段被阻塞，所以$I_4$的$IF$段被阻塞。

     2.   控制冲突：使用跳转指令$jmp$等时，在没有分支预测的情况下，默认有$3$个时钟周期的阻塞使本指令$ID$应在上一条$WB$后。

7.   流水线的性能指标：最理想情况，即**取一个机器周期等于一个时钟周期**。

     1.   吞吐率：指在单位时间内流水线所**完成的任务数量**，或是输出结果的数量。第一个指令执行阶段称为装入时间，最后一个指令执行的阶段称为排空时间。

          1.   设任务数为$n$，处理完成$n$个任务所用的总时间为$T_k$，则$TP$​的最基本的公式为
               $$
               TP=\dfrac{n}{T_k}
               $$

          2.   在最理想情况下，令每个指令分为$k$个阶段，每个阶段所需时间为$\Delta t$，则$T_k=(k+n-1)\Delta t$，故
               $$
               TP=\dfrac{n}{(k+n-1)\Delta t}
               $$
               且当连续输入的任务$n\to \infty$时，得最大吞吐率为$TP_{max}=\dfrac{1}{\Delta t}$。

     2.   加速比：完成同样一批任务，不使用流水线所用的时间与使用流水线**所用的时间之比**。

          1.   设$T_0$表示不使用流水线时的执行时间，即顺序执行所用的时间，$T_k$表示使用流水线时的执行时间，则计算流水线加速比$S$​的基本公式为
               $$
               S=\dfrac{T_0}{T_k}
               $$

          2.   在最理想情况下，单独完成一个任务需要$k\Delta t$，则顺序完成时间$T_0=nk\Delta t$，则$T_k=(k+n-1)\Delta t$​，故
               $$
               S=\dfrac{n\cdot k\cdot \Delta t}{(k+n-1)\Delta t}=\dfrac{k\cdot n}{k+n-1}
               $$
               且当连续输入的任务$n\to \infty$时，得最大加速比为$S_{max}=k$。

8.   两种增加指令级并行的策略：

     1.   **动态多发射技术/超标量流水线技术**：采用多个内部功能部件，使流水线功能段能同时处理多条指令，处理机一次可以发射多条指令进入流水线执行。
     2.   超流水线技术：通过增加流水线级数来使更多的指令同时在流水线中重叠执行。

9.   高级流水线技术：使用上面两种增加指令级并行的策略以提高流水线并行性能。

     1.   **超标量流水线技术/动态多发射技术**：**每个时钟周期内可并发多条独立指令**。不能调整指令的执行顺序。在简单的超标量$CPU$中，指令是按顺序发射执行的。为了更好地提高并行性能，多数超标量$CPU$都结合动态流水线调度技术，通过动态分支预测等手段，指令不按顺序执行，这种执行方式称为**乱序执行**。
     2.   **超长指令字技术/静态多发射技术**：由**编译程序**挖掘出指令间潜在的并行性，将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字。需要采用多个处理部件更大的$Cache$。
     3.   超流水技术：通过在一个时钟周期内再分段，以**提高流水线主频**的方式来提升流水线性能。在一个时钟周期内单个功能部件使用多次。

### 多处理器

$M,Multiple$，多；$S,Single$，单。

1.   指令数据流结构：基于指令流的数量和数据流的数量，$Flynn$分类法将计算机体系结构分为$SISD$、$SIMD$、$MISD$和$MIMD$四类。常规的单处理器属于$SISD$，而常规的多处理器属于$MIMD$。
     1.   单指令流单数据流$SISD(Single \;Instruction \;Single\;Data)$：单指令流和单数据流系统，即传统冯·诺依曼体系结构。
          1.   只有一个处理器和存储器，在一段时间内一次性只执行一条指令。
          2.   使用流水线技术，所以设置多个功能部件，采用**多模块交叉组织存储器**。
     2.   单指令流多数据流$SIMD(Single\; Instruction \;Multiple\; Data)$：一个指令流同时对多个数据进行处理，一般称为数据级并行技术。有**一个指令控制部件**和**多个处理单元**。
          1.   每个处理单元虽然执行的都是同一条指令，但是每个单元都有自己的地址寄存器，这样每个单元就都有不同的数据地址。因此，不同处理单元执行的同一条指令所处理的数据是不同的。
          2.   包括阵列处理器和向量处理器系统。
          3.   适合循环结构，不适合选择结构。
     3.   多指令流单数据流$MISD(Multiple\;Instruction\;Single\;Data)$：仅作为理论模型，**实际上不存在**。**多指令流必定多数据流**。
     4.   多指令流多数据流$MIMD(Multiple\;Instruction\;Multiple\;Data)$：多条指令分别处理多个不同的数据，是一种并行程度更高的线程级并行或线程级以上并行计算模式。包括多处理器和多计算机系统。
          1.   消息传递$MIMD$：多计算机系统中的每个计算机节点都具有各自的私有存储器，并且具有独立的主存地址空间，**不能通过存取指令访问**不同节点的私有存储器，而要**通过消息传递进行数据传送**。
          2.   共享存储$MIMD$/多处理器系统$SMP$：具有共享的单一地址空间，通过存取指令来访问系统中的所有存储器。
2.   硬件多线程：为减少线程切换的开销，产生硬件多线程。在支持便件多线程的$CPU$中，必须为每个线程提供单独的通用寄存器组、单独的程序计数器等，线程的切换只需激活选中的寄存器，从而省略了与存储器数据交换的环节，大大减少了线程切换的开销。
     1.   细粒度多线程：多个线程之间轮流交叉执行指令，多个线程之间的指令是不相关的，可以乱序并行执行。在这种方式下，处理器能在每个时钟周期切换线程。
     2.   粗粒度多线程：仅在一个线程出现了较大开销的阻塞时，才切换线程，如$Cache$缺失。在这种方式下，当发生流水线阻塞时，必须**清除被阻塞的流水线**，新线程的指令开始执行前需要重载流水线，因此，**线程切换的开销比细粒度多线程更大**。
     3.   同时多线程$SMT$：上述两种多线程技术的变体。在实现指令级并行的同时，实现线程级并行。即在同一个时钟周期中，发射多个不同线程中的多条指令执行。
          +   $Intel$处理器中的超线程$HT(Hyper\;Threading)$就是同时多线程$SMT$，即在一个单处理器或单个核中设置了两套线程状态部件，共享高速缓存和功能部件
3.   多核处理器：多核处理器是指将多个处理单元集成到单个$CPU$中，每个处理单元称为一个核，可以同时执行多个运算。每个核可以有自己的$Cache$，也可以共享同一个$Cache$。可以使每个核在同一时刻都有线程在执行，是真正意义上的**并行**执行。
4.   共享存储$MIMD$/多处理器系统$SMP$：处理器通过存储器中的共享变量互相通信，所有处理器都能通过存取指今访向任何存储器的位置。即使这些系统共享同一个物理地址空间，它们仍然可在自己的虚拟地址空间中单独地运行程序。
     1.   统一存储访问多处理器$UMA$：每个处理器对所有存储单元的访问时间是大致相同的，即**访问时间与哪个处理器提出访存请求及访问哪个字无关**。
     2.   非统一存储访问多处理器$NUMA$：某些访存请求要比其他的快，具体**取决于哪个处理器提出了访问请求以及访问哪个字**，这是由于主存被分割并分配给了同一机器上的不同处理器或内存控制器。