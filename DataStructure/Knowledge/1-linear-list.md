# 第二章 线性表

## 导读

### 【考纲内容】

1. 线性表的基本概念
2. 线性表的实现
    + 顺序存储
    + 链式存储
3. 线性表的应用

### 【知识导图】



### 【复习提示】

+ 线性表是算法题命题的重点。
+ 这类算法题实现起来比较容易且代码量较少，但是要求具有最优的性能（时间复杂度、空间复杂度），才能获得满分
+ 因此，应牢固掌握线性表的各种基本操作（基于两种存储结构），在平时的学习中多注重培养动手能力
+ 另外，需要提醒的是，算法最重要的是思想！考场上的时间紧迫，在试卷上不一定要求代码具有实际的可执行性，因此应尽力表达出算法的思想和步骤，而不必过于拘泥每个细节。注意算法题只能用`C++`语言实现。

## 基本概念

### 逻辑结构

是具有相同数据类型的$n$个数据元素的有限序列。$n$表示表长。

$L=(a_1,a_2,\cdots,a_i,\cdots,a_n)$，其中$i$表示元素在线性表中的位序，从一开始。

+ 存在唯一的第一个元素。
+ 存在唯一的最后一个元素。
+ 除第一个元素（表头元素）之外，每个元素均只有一个直接前驱。
+ 除最后一个元素（表尾元素）之外，每个元素均只有一个直接后继。

### 物理结构

+ 顺序存储结构：顺序表。
+ 链式存储结构：链表。

## 顺序表

把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来实现。$i$是元素$a_i$在线性表中的位序。

### 顺序表特点

1. 随机访问，可以在$O(1)$时间内找到对应元素。
2. 存储密度高，只用存储数据。
3. 拓展容量不方便。
4. 插入删除操作不方便。
5. 表中元素的逻辑地址与物理地址顺序相同。

### 顺序表定义

使用$C$语言的结构体定义顺序表，使用`typedef`定义一个`ElemType`表示数据基本类型，并定义最大长度`MAXSIZE`：

```c
// 初始化最大长度
#define MAXSIZE 25
// 定义默认值
#define DEFAULTELEM 0
// 定义最大值
#define INFINITY 32767
// 定义默认数据类型
typedef char element_type;
```

可以使用静态分配空间：

```c
// 静态顺序表
typedef struct {
    element_type data[MAXSIZE];
    // 长度
    int length;
} StaticSequenceList;
```

也可以使用动态分配空间，动态分配空间还是顺序的，只不过可以替换原来空间：

```c
// 动态顺序表
typedef struct {
    // 给一个指针来分配动态数组
    element_type *data;
    // 已分配的最大容量
    int max_size;
    // 长度
    int length;
} DynamicSequenceList;
```

其中长度是指有数据的长度，而最大容量是指已经分配给动态数组的长度，插入时要考虑这个长度，不能溢出。

### 顺序表操作

#### 顺序表初始化

静态顺序表因为数组部分在创建时就已经设置好了，所以初始化就直接设置数据长度就可以了。

动态顺序表不仅需要设置数据长度与最大长度，还得分配数组初始空间。

#### 顺序表增长数据空间长度

只有动态顺序表才能增加。

#### 顺序表插入

倒序移动元素，最后将数据插入对应索引并长度加一。（这是一个较好的方式，因为如果插入的话其他元素会被挤住，倒序移动元素可以正好空出位置）

插入时间复杂度为：$T(n)=O(n)$，空间复杂度为$S(n)=O(1)$。

平均时间复杂度：假设$p_i$（$n_i=\dfrac{1}{n+1}$）是$i$位置上插入一个结点的概率，则在长度为$n$的线性表中插入一个结点时所需要移动结点的平均次数为$\sum\limits_{i=1}^{n+1}p_i(n-i+1)=\sum\limits_{i=1}^{n+1}\dfrac{1}{n+1}(n-i+1)=\dfrac{1}{n+1}\sum\limits_{i=1}^{n+1}(n-i+1)=\dfrac{1}{n+1}\times\dfrac{n(n+1)}{2}=\dfrac{n}{2}$。

#### 顺序表删除

正序移动元素并长度减一。

顺序表的删除时间复杂度为：$T(n)=O(n)$，空间复杂度为$S(n)=O(1)$。

#### 顺序表查找

按位查找时间复杂度为$T(n)=O(1)$。

按值查找一般都是找到第一个元素等于指定值的元素，返回其位序，如果没有找到就返回$-1$。按位查找时间复杂度为$T(n)=O(n)$。