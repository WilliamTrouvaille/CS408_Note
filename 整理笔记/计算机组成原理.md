# 计算机组成原理

- 程序执行时间=指令条数$\times\mathrm{IPC}\times \mathrm{T}$。某措施对程序执行时间的影响都是通过公式中三个因数发挥作用。
  + 优化数据通路可以使$\mathrm{T}$减小。
- 【$\mathrm{IEEE754}$浮点数特殊用途】：全$0$的$-127$表示**非规格化数**，全$1$的$-128$表示无穷大。
  - $+\infty,-\infty$：尾数全为$0$，阶码全为$1$，正负由符号位决定。
  - $+0,-0$：尾数全为$0$，阶码全为$0$，正负由符号位决定。
  - 非规格化数：尾数非$0$，阶码全为$0$。
  - 非法操作/非数值$NaN$（$Not\;a\;Number$）：尾数非$0$，阶码全为$1$。
- 【$\mathrm{IEEE754}$浮点数规格化】：①原码规格化尾数最高**数值位**一定为$1$，补码规格化尾数符号位与最高数值位一定相反；②当基数为$4$时，原码规格化形式的尾数正数最高两位不全为$0$，负数最高两位不全为$1$；③当基数为$8$时，原码规格化形式的尾数正数最高$3$位不全为$0$，负数正数最高$3$位不全为$1$。
- 【$\mathrm{IEEE754}$浮点数左右规】：①对阶和右规均会引起舍入；②左规即对尾数进行左移操作，阶码减小尾数增加，**仅在尾数小于一时进行（可能会进行多次）**；③右规即对尾数进行右移操作，阶码增加尾数减小，**仅在尾数大于二时进行（只需要一次）**。
- 浮点数计算时结果由尾数符号决定。
- $\mathrm{IEEE754}$浮点数进行乘法运算的结果一定大于一，**一定不需要左规**。
- 【浮点数加减】：**看清楚题上给出的格式**，默认补码表示阶码尾数、**双符号位格式**。
  1. 对阶：使两个数的阶码（**指数**）相等，**小阶右移向大阶看齐**，尾数每**右移**一位，阶码加1。
     + 若采用大阶码向小阶码看齐的原则，则尾数需要左移，最高有效位被移出，会导致结果出错；
     + 若两个数阶码差大于24，则直接取阶码较大的数为最终结果；
  2. 【$\mathrm{IEEE754}$浮点数规格化】：①原码规格化尾数最高**数值位**一定为$1$，补码规格化尾数符号位与最高数值位一定相反；②当基数为$4$时，原码规格化形式的尾数正数最高两位不全为$0$，负数最高两位不全为$1$；③当基数为$8$时，原码规格化形式的尾数正数最高$3$位不全为$0$，负数正数最高$3$位不全为$1$。
  3. 【舍入】：①0舍1入法/就近舍入法，即四舍五入；②恒置0法/截断法，**最简单的方法**。
  4. 判溢出：仅对阶码判定溢出。
- 【※※※标志位】：只有进/借位标志位$CF$是“对于无符号数的整数运算有意义”。
  + 零标志位$ZF$（$Zero\;Flag$）：判断当前数字是否为全0值。
    + **无论是有符号数还是无符号数，$ZF$都有意义**。
  + 符号标志位$SF$（$Symbol\;Flag$）：判断当前结果符号，$SF=F_{i=max}$，其中$F_{i=max}$为运算结果的最高位。
    + **仅对于有符号整数运算有意义**。
  + ※※溢出标志位$OF$（$Overflow\;Flag$）：表示带符号整数运算时结果发生溢出。**仅对于有符号整数运算有意义**。
    1.   采用一位符号位，根据数值位和符号位的进位情况判断溢出：$OF=C_0\oplus C_1$，其中$C_0$、$C_1$分别表示符号位和最高数值位产生的进位。
    2.   采用一位符号位，正正得负或负负得正则为溢出：$OF=A_SB_S\overline{S_S}+\overline{A_S}\cdot\overline{B_S}S_S$。
         +   这里**两个上划线不能连在一起**。
    3.   采用双符号位，采用变形补码思想判断溢出：符号位`01`表示正溢出`10`表示负溢出，逻辑表达式为两个符号位进行或运算$OF=F_0+ F_1$。
  + 进/借位标志位$CF$（$Carry\;Flag$）：表示无符号整数数加/减运算时的进位/借位（溢出），$CF=C_{out}\oplus Sub$，其中$Sub$为加减法控制信号，加法$0$减法$1$，$C_{out}$即为最高位产生的进位。
    +   **仅对于无符号数的整数运算有意义**。
- $A-B$后使用标志位判断$AB$大小：$\mathrm{ZF}=0$时结果为零，$A=B$，下面讨论其他情况。
  + $\mathrm{CF}$和$\mathrm{ZF}$判断无符号数：$\mathrm{CF}=1$时结果溢出，$A<B$；$\mathrm{ZF}=\mathrm{CF}=0$时，$A>B$；
  + $\mathrm{OF}$、$\mathrm{SF}$和$\mathrm{ZF}$判断有符号数：$\mathrm{OF}\oplus\mathrm{SF}=1$时，$A<B$；$\mathrm{OF}\oplus\mathrm{SF}=0$时，$A>B$；
- 【无损转换】：$char$→$int$→$long$（32位）→$double$、$float$→$double$。
- 【精度丢失】：①64位$long\to double$可能会有精度损失，$double$尾数长度为$53$位，多余的部分会丢失，但是不多于$53$位就是无损转换；②$float\to int$，可能会溢出（$float$表示范围更大）及损失精度导致$float$的小数部分会丢失，但是**$float$是整数就是无损转换**；③$int\to float$可能会损失精度，$float$尾数长度为$23$位，同上。
- **$\mathrm{MSB}$为最高有效位，$\mathrm{LSB}$为最低有效位**。
- **类型转换优先级大于加减乘除**。
- 【交叉编址多模块存储器】：有轮流启动和同时启动两种方式，若存储器位数$\times$体数等于总线位宽则一定是**同时启动**，此时总线频率等于存储器频率。
- 【$\mathrm{DRAM}$芯片的行缓冲计算】：每行的列数$\times$每个存储单元的位数，其中对于$A\times B$位的芯片，每行的列数为$\sqrt{A}$、每个存储单元的位数为即为$B$（注意若**其为位拓展的芯片应当选择组成其的基本芯片**）。
- 【固态硬盘$\mathrm{SSD}$】：①属于电可擦除$\mathrm{ROM}$即$\mathrm{EEROM}$，使用$\mathrm{Flash}$芯片**可进行多次快速擦除重写**；②以页$\mathrm{Page}$为单位读/写，以块$\mathrm{Block}$为单位"擦除"；③由于$\mathrm{Flash}$需要先擦除再写入，因此**写速度比读速度要慢**；④进行写操作时必须按**块内页**的顺序写入；⑤其中的闪存翻译层和磁盘控制器一样均用于地址翻译。

----

$\mathrm{Cache\&TLB}$专题
- 【$\mathrm{TLB}$、$\mathrm{Page}$缺失（缺页异常）】：①$\mathrm{TLB}$缺失后会访问**内存**中的$\mathrm{Page}$（访存），若$\mathrm{Page}$中存在页表项则将其加载到$\mathrm{TLB}$且使用更新后的物理地址继续操作；②若$\mathrm{Page}$中不存在页表项或失效则触发缺页异常，从**磁盘或交换区**加载其到$\mathrm{TLB}$和$\mathrm{Page}$并使用更新后的物理地址继续操作；
- 内容寻址存储器$\mathrm{CAM}$：$\mathrm{TLB}$和$\mathrm{Cache}$。
- 【$\mathrm{Cache}$】：①提到缓存寄存器默认等于$\mathrm{Cache}$；②平均访存时间$=Cache$存取时间$+Cache$缺失率$\times$主存存取时间；③$\mathrm{Cache}$缺失引起的时间开销：主存延、层次结构即多级$\mathrm{Cache}$、替换算法；$\mathrm{Cache}$行中的修改位一般指的是回写法的脏位，与$\mathrm{LRU}$替换算法无关；
- 在正常情况下，**查询$\mathrm{TLB}$和查询页表**通常是连续发生的，均为使用虚拟地址查找物理地址的过程；不与$\mathrm{Cache}$连续，查询Cache时已经查询到物理地址需要查找数据。

  + 是$\mathrm{TLB}$页表的快速缓冲，$\mathrm{Cache}$是主存的快速缓冲。
- $\mathrm{TLB}$缺失后有可能直接**在Cache中找到页表内容**。页表存储在主存中，$\mathrm{Cache}$保存主存的副本。
- $\mathrm{Cache}$缺失通常由**硬件**处理，**$\mathrm{TLB}$**缺失可以由 **硬件或软件**处理。
- 【$\mathrm{Cache}$完全由硬件实现】：①对所有程序员透明；②$\mathrm{Cache}$缺失时由硬件进行自动处理，一般不需要切换进程。
- 【三种$\mathrm{Cache}$映射策略】：①直接映射不需要算法位；②全相联映射不需要$\mathrm{Cache}$行号/组号；③三种策略均会出现『刚被替换出的数据又被访问』的情况（**会导致$\mathrm{Cache}$命中率为零**），且其中直接映射发生的概率最高。
- 【回写法和全写法】：回写法加信息位，全部改完了再写回主存；全写法**加访存次数**，把数据**同时写入$\mathrm{Cache}$和主存**。
- $\mathrm{Cache}$缺失率
  1. 明确一条指令会访问几次数据和总共会访问多少次；
     + 对于类似`a[k]=a[k]+1;`的代码会连续访问两次；
  2. 明确一个$\mathrm{Cache}$块一共能存放多少个数据、第一个数据是否在整块的开头；
  3. 仅直接映射或全相联映射在循环条件下可直接对单个块的访问进行分析；
- 指令流水线中，$\mathrm{TLB}$缺失和$\mathrm{Cache}$缺失均只可能在取指$\mathrm{IF}$段和访存$\mathrm{Mem}$段出现，与写回$\mathrm{WB}$段无关。
- 【$\mathrm{L1 \,Cache}$分为指令$\mathrm{Cache}$和数据$\mathrm{Cache}$】：求组数时正常的算一个再乘二（所以一般答案都是偶数）。

  + 计算组号时应该将当个$\mathrm{Cache}$行数$\div$关联度作为组数，相当于$\mathrm{L1 \,Cache}$已经天然分了一组了，但是计算总容量的时候应该把另一个加上。
- 【$\mathrm{Cache}$每行的控制部分】：不加数据部分的总大小，即$\mathrm{TAG+}$替换算法位$+$写回法的修改位$+$有效位。
- 【$\mathrm{k}$路组相联映射的$\mathrm{Cache}$缺失率】：①$k>2$时一般均为两个连续的块放在两个连续的组中，轮转一圈后再会放到同一组中；②务必分析【**是否存在块置换？**】、【**是否存在相互替换？**】。
- **$\mathrm{Cache}$关联度**：一个主存块有可能映射到几个$\mathrm{Cache}$行，对于$\mathrm{k}$路组相联的关联度为$\mathrm{k}$。
  + 关联度决定：①比较器个数；②$LRU$替换算法需要的额外的位数（与总行数和总组数无关）；
  + 关联度可以（**但不一定**）降低$\mathrm{Cache}$缺失率。

---

- 【总线带宽和某种总线事务的数据传输速率】
  - 【总线带宽】：总线在单位时间内能够传输的**最大数据量**，计算方法为**总线带宽=总线位宽$\times$总线工作频率**，其中【上升沿和下降沿各传送一次数据】即为**工作频率等于总线时钟频率的两倍**。
  - 【某总线事务的数据传输速率】：与总线事务的具体行为密切相关，需要根据题给的具体动作计算。
- 【三种$\mathrm{I/O}$控制方式】：①程序查询$\mathrm{I/O}$方式**不会造成中断**；②程序中断$\mathrm{I/O}$，$CPU$会在每个**指令周期的末尾**检查中断、不适用于低速外设；③$\mathrm{DMA}$方式高速外设低速外设均适用**但不适用于键盘和鼠标**（其要求$\mathrm{CPU}$能够立刻响应，而$\mathrm{DMA}$不过$\mathrm{CPU}$）、不用保护和恢复现场（没有中断）。
- 【$\mathrm{DMA}$传输的流程】：①接受请求后，初始化控制器并启动磁盘，其中由初始化主要为设备驱动程序设置**内存地址寄存器**$MAR$（目标地址）、**数据计数器**$DC$（数据块大小）初值和**传送长度计数器**$WC$（剩余传输字节数）；②传输一块数据块到**数据缓冲寄存器**$\mathrm{DR}$；③发送总线请求；④由$DMA$直接控制总线传输；⑤“$DMA$结束”中断，由中断服务程序完成。
  - 【**每次传送一个字，传送整个数据块**】：$\mathrm{I/O}$接口中的数据缓冲区（数据缓冲寄存器）每充满一次，$DMA$控制器就需要发出一次总线请求；
  - $CPU$在每个**存储周期**（总线事务）结束后检查是否有$DMA$请求，**$DMA$请求优先级默认最大**；
- 【$\mathrm{DMA}$冲突处理】：①停止$\mathrm{CPU}$访问主存；②周期挪用，$\mathrm{CPU}$与$\mathrm{DMA}$均有访存（同时访存时$\mathrm{DMA}$优先度更高，但$\mathrm{CPU}$先访存时需**等到存取周期结束后**）、周期挪用指主存的**存取周期**；③$\mathrm{CPU}$与$\mathrm{DMA}$交替访存，一个$\mathrm{CPU}$分成两个用、不需要总线使用权的申请建立和归还过程、适用于CPU的工作周期比主存存取周期长的情况。
- 【结构冒险\资源冲突】：①指令、指令$\mathrm{Cache}$；②**硬件阻塞**或**软件**空指令$\mathrm{NOP}$。
- 【数据冒险】：①**硬件阻塞**或**软件**空指令$\mathrm{NOP}$；②数据旁路；③编译优化。
  - 空指令$\mathrm{NOP}$同样有完整的五个阶段。
  - **数据相关**在**循环**中可能后面相关前面。
- 【控制冒险】：①**分支预测**；②提前形成条件码；③编译优化；④指令预取。
- 【分支预测】：尽早判别转移是否发生，尽早生成转移目标地址。①简单预测，永远猜$\mathrm{True}$或$\mathrm{False}$；②动态预测，根据历史情况动态调整，有较高的预测准确率。
- 【存储器预取】：①$\mathrm{DDR3/4}$使用$8$位预取技术、$\mathrm{DDR2}$使用$4$位预取技术；②通过芯片中的$\mathrm{I/O}$缓冲区实现。
- 【定点数乘法运算】：①尽量直接转换成真值计算；②实现$N$位（**不包括符号位**）补码一位乘时，乘积为$2N+1$位；③原码、补码一位乘法中，最多均需要$N$次移位，$N+1$次加法运算；④原码、补码乘法的符号位都需要**单独进行异或操作**；⑤为了加快运算会有**辅助电路**实现$(-x)$的补码的运算；
- 【$Booth$算法的移位法则】：记$y_n$为$MQ$最低位，$y_{n+1}$为辅助位，则若$y_n\oplus y_{n+1}=0$则部分积右移一位，否则先加或减（$y_n$为一即为加否则为减）当前运算值。
- 【补码乘法溢出判断】：①若用$2n$位保存最终乘积，则不会溢出；②若用$2n$位保存中间结果，$n$位保存最终乘积，则**高$n+1$位相同时不溢出**（对于无符号数乘法当且仅当高$n$位全$0$时才不溢出、对于有符号补码乘法，当且仅当前$n+1$位数值全相同时不溢出）。
- 【补码加减交替法/不恢复余数法】：①符号位参与运算、所有数均采用双符号位；②若字长为$n+1$，则只用左移$n$次，上商$n+1$次，最后一次上商余数不左移；

---

+ **！！！所有需要累加的数据（时间复杂度、地址计算时）好好想清楚从零开始还是从一开始！！！**
+ **补码没有负零**，$\mathrm{8000\,0000H}$表示的是$-2^{31}$，不是零。
+ 计算机内特殊部件
  + 阵列乘法器：所有部分积同时产生并组成一个阵列，可在一个时钟周期内完成乘法运算；
  + 内存管理单元$MMU$：主要是**地址转换**；
  + 栈区$stack$：由编译器自动分配释放 ，实现函数调用，用于存储**函数传递的参数、局部变量**等，从用户空间的高地址向低地址增长；
    + 入栈：$SP\gets (SP)-'1'$；
  + 堆区$heap$：一般由程序员分配释放，程序结束时可能由OS回收，和堆排序的堆不是一个东西，分配方式类似于链表；
  + 浮点字寄存器：位数只由系统中所能表示的最大的浮点数决定；
  + 【虚拟存储器】：容量记为计算机逻辑地址空间的大小，由逻辑地址位数决定，**与主存辅存无关**；
  + 【控制存储器$CM$】：①在CPU中，用于存储微指令，其容量为$2^N\times M \,bit$（$N$为下地址字段长度、$M$为微指令字长）；②**按**微指令**地址访问**；③机器运行时**只读不写**；
  + 【重定位寄存器$=$**基址寄存器**】：存放当前进程**起始物理地址**；
  + 【界地址寄存器】：存放当前进程**最大逻辑地址**；
  + 【多路选择器$\mathrm{MUX}$】：根据控制信号从多个输入中选取输出，一般用于在同一个数据通路中实现多指令。故$\mathrm{MUX}$的输入信号对应于该数据通路能执行的指令；
+ 某部件是否透明
  + 对所有用户：程序计数器$PC$，通用寄存器组$X$，累加寄存器$ACC$；
  + 对汇编程序员可见：中断字寄存器、基址寄存器/变址寄存器、程序状态字寄存器$PSW$；
  + 完全透明：指令寄存器$IR$、微指令相关、高速缓存$Cache$、$MAR$和$MDR$、暂存寄存器$R$。
  + 运算器的大部分部件，包括移位器、乘法器、先行进位链，均为透明。
+ 硬件和软件
  + Cache替换使用硬件实现，主存替换使用软件实现；
  + 磁盘控制器和磁盘驱动器都是硬件，磁盘驱动（程序）以及所有设备驱动都是软件；
+ **冯诺依曼计算机通过程序计数器$PC$，即控制器，依据不同的阶段区分数据和指令**。
+ 【**预处理、编译、汇编、链接**】。
+ 翻译程序将高级语言源程序转换为机器语言程序，分为编译程序（一次性翻译成可执行文件）和解释程序（边解释边执行）。
+ 数据按边界对齐
  + `char`类型占用1字节，起始地址可以是任意地址。
  + `short` 占用 2 字节，`int` 占用 4 字节，`double` 占用 8 字节，起始地址必须在响应的倍数地址上。
+ 【$N$位补码表示范围】：$[-2^{N-1}\sim 2^{N-1}-1]$，其中记正数最大值为$n-1$位一，即$2^0+2^1+\cdots+2^{N-2}=2^{N-1}-1$。
+ 若题上没有明确给出大端还是小端，则说明不论是哪一种，答案都是固定的。
+ 从32位逻辑地址LA中提取页号P等：`(((unsigned int) (LA)) >> N) & M`。其中N为提取的P在多少位，M为与P等长的1构成的字段，通常使用十六进制表示。
+ 算术移位和逻辑移位：**仅算术右移补符号位**，其他（逻辑右移、逻辑左移、算术左移）全补0。
+ 无符号的移位运算使用的是逻辑移位，有符号数的移位运算使用的是算术移位。
+ 正数加负数一定不会溢出。


+ 无符号转有符号：注意有符号数需要根据最高位确定符号，**一般为负**。
+ 【为什么无需对无符号数进行溢出判断】：**无符号数常用于地址运算**，**因超出表示范围而产生的截断等价于取模运算**。
+ 磁盘阵列$RAID$：冗余、纠错（海明码）、校验（位/块交叉奇偶校验）、**可以并行工作改善性能**。
+ 现代内存可以实现在同一时钟周期内在上升沿和下降沿各传送一次数据。
+ 现代磁盘采用固定位密度，外围磁道的信息量大于内圈。
+ 偏移寻址
  + 【基址寻址】：起点为程序的起始存放地址；基址寄存器内容由操作系统管理，用户只可选择基址寄存器；有利于多道程序并发运行，可用于**编制浮动程序**；
  + 【变址寻址】：**起点由用户决定**；适用于**数组处理，编制循环程序**；
  + 【相对寻址】：起点为$(PC)+’1'$；适用于**转移指令**；
  + 【堆栈寻址】：①含有堆栈指针$\mathrm{SP}$的均为堆栈寻址；②$\mathrm{SP}$指向的是寄存器则为硬堆栈、向的是主存则为软堆栈。 
+ 指令执行过程中，基址寄存器的内容不变，变址寄存器的内容可能改变。

  + 基址寄存器内容由操作系统决定，变址寄存器可由用户操作。
+ 除相对寻址偏移量（补码）之外的所有地址都是无符号整数。
+ 单周期CPU：一个时钟周期完成一条指令，时钟周期的时间以执行时间最长的指令为主。CPI为1。控制信号不变，除PC外寄存器值不变。采用多总线，单总线会冲突。
+ 操作数只可能存在于寄存器和主存单元中。
+ M体低位交叉存储器：若一个存储单元为`k bit`，则其在一个连续传输的存储周期内可总共提供`k*M bit`。
+ 【设计芯片求所用数量，根据地址求容量】：某按字节编址的计算机有$\mathrm{4000H}\sim\mathrm{5FFFH}$，则一共$\mathrm{5FFFH}-\mathrm{4000H}+1=\mathrm{2000H}$个存储单元，即$0\times16^{0}+0\times16^{1}+0\times16^{2}+2\times16^{3}=2^{13}\mathrm{B}$。

  + 注意从$0$开始。
+ 主存-外存的映射只能使用全相联映射。
+ 指令格式的题看清楚是求有效地址还是操作数。
+ 在循环中，标号`exit`表示跳出循环通常指向循环后第一条指令地址，标号`loop`表示进入循环通常指向循环的第一条指令地址（如果是`for`循环指的则是赋初值后的那条指令的地址）。
+ 跳转指令的跳转目的地址计算：当前指令的下一条指令地址+指令字长$\times \mathrm{OFFSET}$。
+ `SignExt`部件：符号拓展。输出位数大于输入位数的均为拓展部件。
+ $\mathrm{CPU}$中仅通用寄存器组能够存储数据，所以类似【$\mathrm{CPU}$与寄存器之间进行数据交换】的说法均是错误的。
+ 单周期CPU与多周期CPU：①单周期CPU无需使能信号，依据时钟信号每时钟周期执行一条指令，执行过程中单周期CPU的**控制信号不变**、**每个部件只能使用一次**（多周期CPU的控制信号会发生改变且部件可重复使用）；②单周期CPU的$CPI$始终为一，始终小于多周期CPU的$CPI$；③单周期CPU的时钟周期始终大于多周期CPU；
+ 速度差距较大的两设备间可采用：①异步传输；②缓存，**Buffer**或**Cache**均可；③DMA。
+ 【流水线性能】：①最大吞吐量，最理想情况下与每个流水段耗时成反比；②加速比，最理想情况下等于流水线段数（超标量流水线的原理）。
+ 【指令集$\mathrm{ISA}$规定内容】：①包含指令相关，指令格式、操作数、操作类型；②包含硬件可操作的基本功能，寄存器数量、数据类型；③包含异常和中断的处理方式，如缺页、溢出等；④**不涉及实现细节**，如流水线设计、缓存大小等；⑤**不涉及硬件平台**，如核心数、时钟频率。
+ 定长指令字长度固定可以直接进行$PC$加一，变长指令字则需要通过专门的**$PC$增量器**进行计算。
+ 微程序通常以存储器$ROM$形式存在，**微程序入口地址由机器指令的操作码字段形成**，一条机器指令对应一个微程序。
+ 一般情况下，微程序固定执行一个时钟周期。
+ $\mu\,PC$接受微地址$\to$控制存储器$CM$输出微指令$\to$存储于$\mu \,IR$。
+ 【控制存储器$CM$】：①在CPU中，用于存储微指令，其容量为$2^N\times M \,bit$（$N$为下地址字段长度、$M$为微指令字长）；②**按**微指令**地址访问**；③机器运行时**只读不写**。
+ 【**水平型微指令、下地址字段和控制存储器$CM$**容量】

  + 操作控制字段：①直接编码方式，微命令数等于操作控制字段位数；②字段直接编码方式，对于每个互斥组，$n$位操作控制字段可表示$2^n-1$个微命令；
  + 判别测试字段：①直接编码方式，外部条件等于其位数；②字段直接编码方式，对于$N$个外部条件，需要$n$位表示，其中$2^n\geqslant N+1$，加$1$是因为还有**无条件转移**的情况；
  + 下地址字段：微指令字长$-$操作控制字段长度$-$判别测试字段长度即可，与控制存储器$CM$的容量（可以存储多少微指令）相等。
+ 【水平型微指令和垂直型微指令】：水平型并行能力强、执行时间短，但微指令字长较长；垂直型的微指令字长较短，微程序长度较长。
+ 微指令最大总数由微指令中下地址字段的最大位数决定。

  + 微指令编码分为操作控制字段和下地址字段；
  + 字段直接编码的微指令长度更短，控制存储器$CM$利用率更高，但不如直接控制法快；
  + 垂直型微指令相比于水平型包含的微命令更少、指令更短、微程序更长。
+ $CISC$繁杂：指令长度不固定，采用微程序控制，指令执行时间较大。
+ $RISC$精简、速度快：指令长度固定，只有`Load/Store`（取数/存数）指令访存，硬布线控制，一定采用指令流水线技术，通用寄存器的数量相当多。
+ 流水线周期：最长耗时$+$寄存器延时（锁存器）。
+ 【数据通路】：①$\mathrm{IF}$段，程序计数器$\mathrm{PC}$、指令存储器和下地址的计算逻辑；②$\mathrm{ID}$段，操作控制器、取操作数逻辑和立即数符号扩展模块；③$\mathrm{EX}$段，算术逻辑单元$\mathrm{ALU}$和分支地址计算模块；④$\mathrm{MEM}$段，数据存储器读写模块；⑤$\mathrm{Wb}$段，寄存器写入控制模块。
+ 流水寄存器保存信息：**后面流水段**需要用到的所有**数据信息**、**前面传递来**要用到的所有**控制信号**。
+ 流水线的控制信号：①控制信号在$\mathrm{ID}$段中的指令译码器中产生；②取指$\mathrm{IF}$段和译码$\mathrm{ID}$段所有指令动作一致，不需要控制信号；③每到达一个时钟信号$\mathrm{CLK}$，控制信号即往后传送一段，而**不是统一传送**；
+ 指令流水线中，一般指令均会向最长指令对齐，故部分流水段设置了`nop`操作。
+ 采用n个处理机所获得的加速比不一定是一个处理机的n倍，需要额外资源进行协调。
+ 【$\mathrm{LOAD\cdot USE}$数据冒险】：采用转发后额外需要一个时钟周期的阻塞，不采用转发需要两条$\mathrm{NOP}$指令。
+ 高级流水线
  + **超标量流水线**技术/动态**多发射技术**：每个时钟周期内可并发多条独立指令，$CPI<1$；
  + 超长指令字技术/静态多发射技术：增加流水线级数使更多的指令同时在流水线中并行执行，$CPI<1$；
  + 超流水技术：时钟周期内再分段，**提高流水线主频**的方式来提升流水线性能，$CPI=1$.
+ 超标量流水线的CPU必须设置多个不同的功能部件，利用部件的并行性提高并发度。
+ 若指令流水线中存在根据情况决定是否跳转的指令`JMP`、`JC`，则在没有分支预测的情况下，默认存在三个时钟周期的阻塞使当前指令的ID段在上一条指令的WB之后。
+ 解决指令流水线冲突的阻塞是**硬件阻塞**，插入空指令属于软件，二者不一样。
+ 定长指令字的`PC`可以直接`+‘1’`，而变长指令字的`PC`需要设置专门的增量器辅助。
+ 多指令流单数据流$MISD(Multiple\;Instruction\;Single\;Data)$：不存在，多指令流必定多数据流。
+ 多线程系统的特长需要**任务可分割为多个可并行的小任务**才能发挥完全特长。
+ 仅并行向量处理系统可以确定是多CPU系统，其他的多线程系统、多进程系统、实时系统均不一定是多CPU系统。
+ 【多处理器系统】：①也叫共享存储系统$\mathrm{MIMD}$**，所有主存储器均属于共享的单一地址空间**，通过存取指令来访问系统中的所有存储器；②分为统一访存$\mathrm{UMA}$和非统一访存$\mathrm{NUMA}$，前者访存时间与哪个处理器提出访存请求及访问哪个字无关，后者访存时间则**取决于哪个处理器提出了访问请求以及访问哪个字**（主存被分割并分配给了同一机器上的不同处理器或内存控制器）。
+ 多指令流多数据流$MIMD$中，
  + 消息传递类型$MIMD$不能通过存取指令访问不同节点的私有存储器，而是使用消息传递进行数据传送；
  + 共享存储$MIMD$/多处理器系统$SMP$：具有共享的单一地址空间，通过存取指令来访问系统中的所有存储器。
+ 【$MISD$不存在】：其中$\mathrm{M}$表示【复杂、多个】、$\mathrm{S}$表示【单个】、$\mathrm{I}$和$\mathrm{D}$分别表示【指令】和【数据流】，所以$MISD$不存在（不存在多条指令同时对单一数据流进行操作）。
+ $\mathrm{I/O}$接口：①**选址**功能；②传送命令功能；③传送数据功能；④反映I/O设备工作状态的功能。
+ $\mathrm{I/O}$指令：①执行时，CPU使用地址总线选择$\mathrm{I/O}$端口使用数据总线在CPU通用寄存器和$\mathrm{I/O}$接口之间进行数据传送；②仅独立编址方式才有$\mathrm{I/O}$指令。
+ 地址变换中可能发生的中断或异常有：缺页异常、越界和访问权限错误。
+ 内中断**/异常**（有关）和外中断**/中断**（无关）的最大区别是**与当前执行的命令是否有关**。
+ **内部异常**发生在指令执行过程中，响应时机是立即中止指令；**外部中断**发生在指令执行完成后，响应时机是指令周期执行完毕时。
+ 【缺页异常】：①仅发生在**页表查询**阶段（$MMU$进行地址转换时）；②异常处理后需要重新访问TLB；③可以认为**仅缺页异常会在处理完毕后返回当前指令重新执行**。④可以认为**缺页异常**是唯一的可能产生多次的（广义）中断。
+ 【缺页异常的流程】：①$MMU$生成缺页异常信号；②检查页面是否在外存和交换区、并将其调入内存（依据情况进行页面置换）；③更新页表并将对应有效位置一。
+ 【缺页异常的优化】：①页面置换算法；②降低缺页率；③降低磁盘（默认外存）存取时间。
+ 【缺页率】：工作集大小、物理内存大小、页面置换算法、页面大小、进程的局部性和数量、TLB的性能、页面预取性能。
+ 中断隐指令保存断点（$PC$内容），中断服务程序保存现场（用户可见的寄存器的内容）。\
+ 【时间片轮转】：①时间片用完会触发时钟中断，将进程由运行态转换到就绪态；②时间片轮转实现了对于CPU的虚拟化；③**进程主动让出处理机等价于进程时间片用完**。
+ 外部中断的断点为下一条指令，缺页缺段（故障-内部异常）的断点为当前指令，非法操作码和除数为`0`不能回到断点执行。
+ 【突发传输】：可以显著提高连续数据的传输速率，但对离散数据的提升不明显；
+ 【同步总线】：时钟频率不一定等于工作频率，例如可能在上升和下降沿各传输一次数据。
+ CPU响应外部中断的条件：①中断源有中断请求；②CPU允许开中断，不可屏蔽中断除外；③在每条指令结束后的中断周期响应。
+ **响应中断=中断隐指令**，处理中断=中断服务程序。
+ 中断服务程序的最后一条指令是中断返回程序，其不完全等于无条件转移指令或普通返回指令。

  + 中断服务程序比无条件转移指令多了：恢复现场、恢复程序计数器$PC$和程序状态字寄存器$PSW$；
  + 中断服务程序比普通返回指令多了：恢复程序计数器$PC$（不恢复程序状态字寄存器$PSW$）。
+ 无条件转移指令$\mathrm{J}$、$\mathrm{JMP}$指令可以直接指定绝对跳转地址、**其后跟地址可能即为其目标地址**。

  + 条件转移指令$\mathrm{JE}$和条件分支指令$\mathrm{BE}$、$\mathrm{bne}$等均一定为相对寻址。
+ 中断处理结束和进程阻塞均会导致进程的调度。
+ 中断响应：由CPU（硬件）在中断响应周期自动完成。关中断，保存断点和程序状态字寄存器。
+ 中断处理：由**中断服务程序**即软件完成。保存现场和中断屏蔽字、**在开中断的状态下进行中断事件处理**、恢复现场和中断屏蔽字、中断返回。
+ 【检测溢出的自陷指令】：使CPU自动查询$OF$溢出标志位，在其有效时转异常处理。
+ 时钟中断和网络传输到达的数据包都是外部中断。
+ 内部异常由CPU内部检测，发生异常时立即响应。
+ **中断响应**优先级由硬件或查询程序的查询顺序决定不可动态变化；中断屏蔽字可以确定**中断处理**优先级可动态变化。
+ 中断屏蔽字：`1`表示**屏蔽该中断源的请求**，`0`表示可以正常申请。自己不可以中断自己，自己那位始终为`1`。

  + 其中**屏蔽该中断源的请求**表示若$A>B$（中断处理），则$A$先到达且已经在**广义中断处理**时，无论$B$的中断响应的优先级如何，$\mathrm{CPU}$均无法检测到$B$的中断请求。
+ 广义中断处理中，【由硬件处理】表示中断响应阶段、【由软件处理】表示中断处理阶段。
+ **中断屏蔽字决定中断处理及其处理完毕的次序**。
+ 中断响应持续时间较短，若对于两个中断请求$AB$，中断响应优先级$A>B$，中断处理优先级$B>A$，则开启多种中断的情况下，$A$中断响应完成后正在中断处理时会被进入中断处理的$B$打断。
+ 中断驱动$\mathrm{I/O}$可用于处理随机事件，例如用户突然按下键盘上的某个键等。
+ 采用中断驱动$\mathrm{I/O}$控制打印输出时，CPU与打印机直接交换打印信息，不会交换主存地址；使用DMA方式时DMA控制器可以直接读取主存中的数据块。
+ $\mathrm{I/O}$接口的三根线：不是**信号**都是数据线传的。
  1. 数据线：数据缓冲寄存器，**状态/控制寄存器**（接口和设备的状态**信息**、$CPU$对外设的控制**命令**）；
  2. 地址线：要访问的$\mathrm{I/O}$接口中的寄存器的**地址**和读/写控制**信号**；
  3. 控制线：读/写**信号**，仲裁**信号**和握手**信号**。
+ 总线上，只有数据信号是双向传输的。地址、控制、状态均为单向传输。
+ CPU和主存均通过$\mathrm{I/O}$总线与$\mathrm{I/O}$接口相连，$\mathrm{I/O}$接口通过通信总线与外设相连。
+ 计算机内栈顶指针一般从高位到低位入栈。