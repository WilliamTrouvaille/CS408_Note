# EX-第七章 查找考点总结

## 导读

### 【考纲内容】

1. 查找的基本概念
2. 顺序查找法
3. 分块查找法
4. 折半查找法
5. 树型查找：二叉搜索树、平衡二叉树、红黑树
6. $B$树及其基本操作、$B+$树的基本概念
7. 散列($Hash$)表
8. 查找算法的分析及应用

### 【复习提示】

选择题：折半查找的过程、构造判定树、分析平均查找长度等；二叉排序树、二叉平衡树和红黑树的概念、性质和相关操作等；$B$树插入、删除和查找的操作过程，$B+$树的基本概念和性质；散列表的构造、冲突处理方法（各种方法的处理过程)、查找成功和查找失败的平均查找长度、散列查找的特征和性能分析。

## 选择题考点总结

### 查找概述

1.   查找：在数据集合中寻找满足某种条件的数据元素的过程。

2.   查找表（查找结构）：用于查找的数据集合，由同一类型的数据元素或记录组成。

3.   查找表的常见操作：查找符合条件的数据元素，插入、删除某个数据元素。

4.   关键字：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该唯一。

5.   静态查找表：只需要查找符合条件的数据元素。顺序查找、折半查找、散列查找。

6.   动态查找表：除了查找符合条件的数据元素，还要插入、删除某个数据元素，同时还要考虑插入删除操作是否方便。二叉查找树查找、散列查找。

7.   查找长度：查找运算中，需要对比关键字的次数。

8.   平均查找长度$ASL$（$Average \; Search \;Length$​）：所有查找过程中进行关键字比较次数的平均值。
     $$
     ASL=\sum_{i=1}^nP_iC_i
     $$
     其中$C_i$表示查找第$i$个元素的查找长度，$P_i$表示查找第$i$个元素的概率，通常认为查找任何一个元素的概率都相同，即$P_i=\dfrac{1}{n}$。

### 线性表查找

1.   顺序查找（线性查找）：常用于线性表，从头到尾逐个查找。
     1.   $ASL_{成功}$为$\dfrac{1+2+3+\cdots+n}{n}=\dfrac{n+1}{2}$，$ASL_{失败}$为$n+1$。
     2.   时间复杂度为$O(n)$。
2.   有序数据的顺序查找：在查找之前就已经知道表是关键字有序的，则查找失败时可以不用再比较到表的另一端就能返回查找失败的信息，从而降低顺序查找失败的平均查找长度。此时顺序结构从逻辑上就变成了一个二叉树结构（一般是顺序的）。
     1.   对于顺序查找，无论顺序表还是乱序表，查找成功的时间和$ASL$都是相同的。
          +   一个成功结点的查找长度$=$自身所在层数，失败结点的查找长度$=$其父结点所在层数。
     2.   $ASL$查找失败为$\dfrac{1+2+3+\cdots+n+n}{n+1}=\dfrac{n}{2}+\dfrac{n}{n+1}$。成功结点的查找长度等于自身所在层数，失败结点的查找长度等于其父结点所在层数。
          +   若有$n$个结点，则有$n+1$个查找失败结点，但是失败结点都是不存在的，如果结点失败只会在一个不存在的区间上，所以查找平均概率是$\dfrac{1}{n+1}$而不是$\dfrac{1}{2n+1}$
              +   同理，查找成功查找失败都会在那个区间停下，一旦判断所在区域不存在就会退出
              +   所以查找失败的次数跟最坏查找成功次数一样都是$n$查完所有。
          +   查找情况还要比普通乱序查找加上一个大于最大值的情况。

3.   不等概率的顺序查找：当数据元素查找概率不等时，可以将查找概率更大的元素放在靠前的位置，以减少大概率元素被遍历的时间。$ASL$查找成功为$\sum\limits_{i=1}^nP_ii$，$P_i$为第$i$个元素出现概率。此时数据是乱序的，所以查找失败的时间复杂度与没有优化的是一样的为$O(n)$。
4.   折半查找（二分查找）：只适用于有序的顺序表，**链表无法适用**，因为链表不具备随机存储特性。
     1.   $low$指向查找范围的最小值
     2.   $high$指向查找范围的最大值
     3.   $mid$指向查找范围的中间值，$mid=\lfloor(low+high)\div2\rfloor$，也可以向上取整，过程会有所不同，**向下取整可以直接利用左移**一位$mid= (low+high) <<1;$

5.   折半查找的过程

     1.   初始化：定义左边界$low$，默认为$0$。右边界$high$，默认为$length-1$。
     2.   循环执行折半查找
          1. 计算出$mid=\lfloor\dfrac{(low+high)}{2}\rfloor$。
          2. 判断中间索引值$data\lbrack mid\rbrack$是否与搜索值$target$相等。
              1. 若$data\lbrack mid\rbrack=target$：查找成功，返回中间索引。
              2. 若$data\lbrack mid\rbrack<target$：说明查找数据在右半部分，则将$low=mid+1$。
              3. 若$data\lbrack mid\rbrack>target$：说明查找数据在左半部分，则将$high=mid-1$。

     3.   当查找最后$low>high$则查找失败。

6.    折半公式优化

     1.   变幻公式：$(low+high)\div2\rightarrow low\div2+high\div2$或$\rightarrow low-(low\div2-high\div2)\rightarrow low+(high-low)\div2$。
     2.   无符号右移运算：$mid=(low+hight) >> 1$。直接将除以$2$变为右移运算，速度更快，且舍去了小数位不需要进行取整运算。

7.   折半查找判定树：**折半查找判定树不是完全二叉树**。

     1.   若当前$low$和$high$之间有奇数个元素，则$mid$分割后左右两部分元素个数相等。
     2.   若当前$low$和$high$之间有偶数个元素，则$mid$分割后左部分元素个数小于右部分一个。由$mid=\lfloor\dfrac{(low+high)}{2}\rfloor$可知，右子树结点数$-$左子树结点数$=0$或$1$。
     3.   折半查找判定树一定是一个**平衡二叉树**，也是一个二叉查找树（左<中<右）。
     4.   失败结点数$=n+1$，即成功结点的空链域结点数。
     5.   只有最下面一层不满，元素个数为$n$时树高与完全二叉树相等$h=\lceil\log_2(n+1)\rceil$。树高不包含失败结点。
     6.   查找成功的$ASL$=($\sum\limits_{i=1}^n$第$i$层的成功结点数$\times i$)$\div$成功结点总数。
     7.   查找失败的$ASL$=($\sum\limits_{i=1}^n$第$i$层的失败结点数$\times i$)$\div$失败结点总数。
     8.   **※※折半查找判定树的中序序列应该是一个有序序列。**是二叉查找树。

8.   分块查找：又称为索引顺序查找，它吸取了顺序查找和折半查找各自的优点，既有动态结构，又适于快速查找。需要对数据进行一定的排序，不一定全部是顺序的，但是要求在一个区间内是满足一定条件的，即**块内无序，块间有序**。**可以采用链表**。总的来说分块查找还是一种**静态查找**，动态插入删除的效率较低。

     1.   在查找时先根据关键字遍历索引表，然后找到索引表的分块（可以顺序也可以折半），再到存储数据的顺序表的索引区间中查找。
     2.   若使用折半查找查找索引表的分块，若索引表中不存在目标关键字，则折半查找索引表最终会停在$low>high$，要在$low$所指向分块中查找。

9.   分块查找的效率：$ASL$查找成功失败的情况都十分复杂，所以一般不会考。

     1.   假设长度为$n$的查找表被均匀分为$b$块，每块$s$个元素。假设索引查找和块内查找的平均查找长度$ASL$分别为$L_I$和$L_S$，则分块查找的平均查找长度为$ASL=L_I+L_S$。
     2.   使用顺序查找索引表，则$L_I=\dfrac{(1+2+\cdots+b)}{b}=\dfrac{b+1}{2}$，$L_S=\dfrac{(1+2+\cdots+s)}{s}=\dfrac{s+1}{2}$
          +   所以$ASL=\dfrac{b+1}{2}+\dfrac{s+1}{2}=\dfrac{s^2+2s+n}{2s}$，当$s=\sqrt{n}$时，$ASL_{min}=\sqrt{n}+1$。
     3.   使用折半查找索引表，则$L_I=\lceil\log_2(b+1)\rceil$，$L_S=\dfrac{(1+2+\cdots+s)}{s}=\dfrac{s+1}{2}$
          +   所以$ASL=\lceil\log_2(b+1)\rceil+\dfrac{s+1}{2}$。

### 二叉查找

1.   **二叉查找树/二叉排序树**$BST$：可以是一棵空树，或者是具有三条特性的二叉树：若左子树非空，左子树上所有结点的关键字均小于根结点的关键字；若右子树非空，右子树上所有结点的关键字均大于根结点的关键字；左右子树又各是一棵二叉查找树。

     1.   中序遍历二叉查找树会得到一个递增的有序序列。因为左子树结点值 < 根结点值 < 右子树结点值。
     2.   静态查找时使用顺序表进行二分查找，而动态查找时使用二叉查找树。

2.   二叉查找树查找：递归查找的时间复杂度是$O(\lceil\log_2(n+1)\rceil)$，遍历查找的时间复杂度是$O(\log_2n)$。平均查找长度$ASL$为$O(\log_2n)$，最坏情况是每个结点只有一个分支，平均查找长度为$O(n)$。

     1.   若树非空，目标值与根结点的值比较。
     2.   若相等则查找成功，返回结点指针。
     3.   若小于根结点，则在左子树上查找，否则在右子树上查找。
     4.   遍历结束后仍没有找到则返回$NULL$。

3.   二叉查找树删除：不能把以该结点为根的子树上的结点都删除，必须先把被删除结点从存储二叉排序树的链表上摘下，将因删除结点而断开的二叉链表重新链接起来，同时确保二叉排序树的性质不会丢失。

     1.   若被删除结点$p$是叶子结点：则直接删除，不会破坏二叉查找树的结构。
     2.   若被删除结点只有一棵左子树或右子树，则让该结点的子树称为该结点父结点的子树，来代替其的位置。
     3.   若被删除结点有左子树和右子树，则让其结点的**直接后继或直接前驱**替代该结点，并从二叉查找树中删除该结点的直接后继、直接前驱，这就变成了第一种或第二种情况。

4.   平衡二叉树（$AVL$树）：树上任意一结点的左子树和右子树的高度之差不超过$1$。

     1.   平衡二叉树最多结点数$2^h-1$。即该二叉树为满二叉树。
     2.   平衡二叉树最少结点数（所有非叶结点的平衡因子均为$1$的）的递推公式为$n_0=0$，$n_1=1$，$n_2=2$，$n_h=1+n_{h-1}+n_{h-2}$。此时所有非叶结点的平衡因子均为$1$。
     3.   查找时间复杂度就为$O(\log_{2}n)$，而插入和删除也为$O(\log_{2}n)$。

5.   平衡二叉树插入删除：插入或删除新结点后，要保持二叉排序树的特性不变。

     1.   $LL$：右单旋转。在结点$A$的左孩子$B$的的左子树$BL$上插入了新结点，$A$的平衡因子由$1$变成了$2$，导致以$A$为根的子树失去了平衡，需要进行一次向右的旋转操作。
          1.   将$A$的左孩子$B$向右上旋转代替$A$成为根结点。$f\to lchild=p\to rchild$（让结点$A$的左子树指向$B$的右子树$BR$）。
          2.   将$A$结点向右下旋转为成$B$的右子树的根结点。$p\to rchild=f$（让结点$B$的右子树变为$A$）。
          3.   而$B$的原右子树则作为$A$结点的左子树。$gf\to lchild/rchild=p$（让结点$A$的原双亲$gf$的左/右孩子指向$B$）。
     2.   $RR$：左单旋转。在结点$A$的右孩子$R$的右子树$R$上插入了新结点，$A$的平衡因子由$-1$减至$-2$，导致以$A$为根的子树失去平衡，需要一次向左的旋转操作。
          1.   将$A$的右孩子$B$向左上旋转代替$A$成为根结点。$f->rchild=p->lchild$（让结点$A$的右子树指向$B$的左子树$BR$）。
          2.   将$A$结点向左下旋转成为$B$的左子树的根结点。$p->lchild=f$（让结点$B$的左子树变为$A$）。
          3.   而$B$的原左子树则作为$A$​结点的右子树。$gf->lchild/rchild=p$（让结点$A$的原双亲$gf$的左/右孩子指向$B$）。
     3.   $LR$：先左后右双旋转。在$A$的左孩子$L$的右子树$R$上插入新结点，$A$的平衡因子由$1$增至$2$，导致以$A$为根的子树失去平衡，需要进行两次旋转操作。
          1.   先左旋转：先将$B$的右子树的根结点$C$向左上旋转提升到$B$结点的位置
          2.   后右旋转：然后再把该$C$结点向右上旋转提升到$A$结点的位置。
     4.   $RL$：先右后左双旋转。在$A$的右孩子$R$的左子树$L$. 上插入新结点，$A$的平衡因子由$-1$减至$-2$，导致以$A$为根的子树失去平衡，需要进行两次旋转操作。
          1.   先右旋转：先将$B$的左子树的根结点$C$向右上旋转提升到$B$结点的位置。
          2.   后左旋转：然后再把该$C$结点向左上旋转提升到$A$结点的位置。

6.    红黑树：红黑树是一种含有红黑结点并能自平衡的二叉排序树。

     0.   二叉排序树：左子树结点值$\le$根结点值$\le$右子树结点值。红黑树是二叉排序树，不是平衡二叉树，红黑树是**自平衡排序树**，不是平衡二叉树。

     1.   每个结点或是红色，或是黑色的。
     2.   根结点是黑色的。
     3.   叶结点都是黑色的，保证红黑树的内部结点左右孩子均非空。叶结点为$NULL$结点，和$n+1$个虚构的外部结点
     4.   不存在两个相邻的红结点，即红结点的父结点和孩子结点均是黑色的。插入操作时一般只会破坏这个特性，只检查这个特性是否被破坏即可。
     5.   对每个结点，从该结点到任一叶结点的简单路径上，所含黑结点的数量相同。
          +   从某结点出发（不含该结点）到达任一空叶结点的路径上黑结点总数称为结点的黑高$bh$。

7.   红黑树性质

     1.   从根到叶结点的最长路径不大于最短路径的两倍。
     2.   有$n$个内部结点的红黑树的高度$h\leqslant2\log_2(n+1)$。
     3.   红黑树查找、插入、删除的时间复杂度都是$O(\log_2n)$
     4.   根结点黑高为的红黑树，两部结点数（关键字）至少有$2^h-1$个。

8.   红黑树插入

     1.   先查找，确定插入位置（原理同二叉排序树），插入新结点

          1.   新结点是根一一染为<span style="background-color: black; color: white;">黑色</span>

          2.   新结点非根一一染为<span style="background-color: red; color: white;">红色</span>

               假设新插入的结点初始着为黑色，那么这个结点质在的路径比其他路径多出一个黑结点（几乎每次插入都破坏性质`5.`），调整起来也比较麻烦

               如果插入的结点是红色的，此时所有路径上的黑结点数量不变，仅在出现连续两个红结点时才需要调整，而且这种调整也比较简单。

     2.   若插入新结点后依然满足红黑树定义，即父结点是<span style="background-color: black; color: white;">黑色</span>的，则插入结束。

     3.   若插入新结点后不满足红黑树定义（即父结点是<span style="background-color: red; color: white;">红色</span>的），需要调整，使其重新满足红黑树定义

          1.   叔叔结点为<span style="background-color: black; color: white;">黑色</span>：旋转+染色
               1.   $LL$型：右单旋，父换爷+染色
                    +   父亲结点和祖父结点分别染色
                    +   插入之前是<span style="background-color: black; color: white;">黑色</span>就染色成<span style="background-color: red; color: white;">红色</span>
                    +   插入之前是<span style="background-color: red; color: white;">红色</span>就染色成<span style="background-color: black; color: white;">黑色</span>
                    +   下同
               2.   $RR$型：左单旋，父换爷+染色
               3.   $LR$型：左、右双旋，儿换爷+染色
               4.   $RL$型：右、左双旋，儿换爷+染色
          2.   叔叔结点为<span style="background-color: red; color: white;">红色</span>：染色+变新
               +   叔父爷三个结点染色，祖父结点视为新结点
               +   新结点处理见上`1.1&1.2&2&3`，需要再次检查是否破坏了红黑树特性

9.   红黑树删除：先执行二叉查找树的删除方法。若待删结点有两个孩子，不能直接删除，而要找到该结点的中序后继（或前驱）填补，即右子树中最小的结点，然后转换为删除该后继结点。由于后继结点至多只有一个孩子，这样就转换为待删结点是叶结点或仅有一个孩子的情况。$x$为父亲的左儿子

     1.   兄弟为红色：将兄弟变成黑色，父结点变成红色；对父结点左旋，恢复左子树的黑色高度，左侄子成为新的兄弟。
     2.   兄弟为黑色，左右侄子为黑色：兄弟变成红色，$x$指向父结点，继续进行调整。
     3.   兄弟为黑色，右侄子为黑色（左侄子为红色）：左侄子变成黑色，兄弟变成红色；兄弟右旋，恢复右子树的黑色高度，左侄子成为新的兄弟。
     4.   兄弟为黑色，右侄子为红色：兄弟变成父结点颜色，父结点和右侄子变成黑色；父结点左旋，$x$指向整棵树的根结点，结束循环

10.   红黑树与二叉查找树：对于一棵动态查找树，如果插入和删除操作比较少，查找操作比较多，采用$AVL$树比较合适，否则采用红黑树更合适。

11.   红黑树与$B$树

      1.   将红黑树的所有红色结点上移到和他们的父结点同一高度上组成一个$B$树结点，就会得到一棵四阶$B$树。
      2.   红黑树的黑色结点个数与四阶$B$树的结点总个数相等。
      3.   在所有的$B$树结点中，黑色结点是父结点，红色结点是子结点。黑色结点在中间，红色结点在两边。

### 树表查找

1.   $B$树：即多路平衡查找树。$B$树中所被允许的孩子个数的最大值称$B$树的阶，通常用$m$表示。一棵$m$阶$B$树或为空树或为满足如下特性的**$m$叉平衡树**。（**$m$阶=$m$叉树**）

     1.   树的每个结点至多包含$m$棵子树，至多包含$m-1$个关键字。
     2.   若根结点不是终端结点，则至少有两颗子树，有一个关键字。
     3.   除根结点以外的所有非叶结点至少有$\lceil\dfrac{m}{2}\rceil$棵子树，即至少包含$\lceil\dfrac{m}{2}\rceil-1$个结点。
     4.   所有叶结点都出现在同一个层次上且不带信息。可以视为外部结点或类似于折半查找判定树的查找失败结点，实际上这些结点不存在，指向这些结点的指针为空。

2.    $B$树性质

     1.   根结点的子树数$\in [2,m]$，关键字数$\in [1,m-1]$。
     2.   其他结点的子树数$\in [\lceil\dfrac{m}{2}\rceil,m]$，关键字数$\in [\lceil\dfrac{m}{2}\rceil-1,m-1]$。
     3.   任意结点的每棵子树都是绝对平衡的，即所有结点的平衡因子均等于$0$。
     4.   每个结点中的关键字是有序的：子树$0<$关键字$1<$子树$1<$关键字$2<$子树$2<\cdots$
     5.   具有$n$个关键字的$m$阶$B$树，应有$n+1$个叶结点。
     6.   有$n$个非叶结点的$m$阶$B$树中至少包含$(n-1)(\lceil\dfrac{m}{2}\rceil-1)+1$个关键字。
     7.   最小高度：$h\geqslant\log_m(n+1)$。
     8.   最大高度：$h\leqslant\log_{\lceil\frac{m}{2}\rceil}\dfrac{n+1}{2}+1$。
     9.   对于高度为$h$的$m$阶$B$树最多有$$(m-1)(1+m+m^2+\cdots+m^{h-1})$$个结点。
     10.   对于高度为$h$的$m$阶$B$树最少有$1+2(\lceil\dfrac{m}{2}\rceil^{h-1}-1)$个结点。
     11.   有$n$个非叶结点的$m$阶$B$树中至少包含$(n-1)(\lceil\dfrac{m}{2}\rceil-1)+1$个关键字。

3.   $B$树插入：新元素插入一定是插入到最底层的某个非叶结点，使用$B$树的查找来确定插入位置。

     1.   若导致原结点关键字数量超过上限溢出（超出$m-1$个关键字）：就从中间位置$\lceil\dfrac{m}{2}\rceil$（如果$m$为偶数则默认是$\lceil\dfrac{m}{2}\rceil-1$）的元素将该结点分为三部分
          1.   将**左部分包含的关键字**放在原来结点。
          2.   **中间的一个结点**$\lceil\dfrac{m}{2}\rceil$或$\lceil\dfrac{m}{2}\rceil-1$插入到原结点的父结点上，并考虑在父结点的顺序对指针进行调整保证顺序。

          3.   **右部分包含的关键**字放在一个新结点并插入到原结点的父结点的后一个位置上。
     2.   若父结点插入时也溢出了，则同理在父结点的中间进行分割，左半部分在原来父结点，右半部分新建一个父结点，并把中间结点右边开始的所有连接移动到新父结点上，中间的结点上移到祖父结点，如果没有就新建，然后建立两个指针分别指向原父结点和新父结点。

4.   $B$树删除：

     1.   若被删除关键字在终端结点，且结点关键字个数不低于下限，则直接删除该关键字，并移动后面的关键字。
     2.   若被删除关键字在非终端结点，则用直接前驱或直接后继来替代被删除关键字，然后后面的元素直接前移。
     3.   若被删除关键字在终端结点，但是结点关键字个数删除后低于下限（$\lceil\dfrac{m}{2}\rceil-1$）
          1.   右兄弟够借：若原结点右兄弟结点里的关键字在删除一个后高于下限，则可以用结点的后继以及后继的后继来顶替：
               1. 将原结点在父结点的连接的后一个关键字（后继元素）下移到原结点并放在最后面。

               2. 将原结点右兄弟结点的第一个关键字上移插入到下移的元素的空位。

               3. 原结点右兄弟结点里的关键字全部前移一位。
          2.   左兄弟够借：若原结点里右兄弟的关键字在删除一个后低于下限，但是左兄弟的结点足够，则可以用结点的前驱以及前驱的前驱来顶替：
               1. 将原结点在父结点的连接的前一个关键字（前驱元素）下移到原结点并放在最前面，其余元素后移。

               2. 将原结点左兄弟结点的最后一个关键字上移插入到原结点父结点的连接的前面。

               3. 原结点左兄弟结点里的关键字全部前移一位。
          3.   左右兄弟都不够借：若左右兄弟结点的关键字个数均等于下限值，则将关键字删除后与左或右兄弟结点以及父结点中的关键字进行合并：
               1. 将原结点的父结点连接后的关键字插入到原结点关键字最后面。
               2. 将原结点的左或右兄弟结点的关键字合并到原结点（前插或后插），并将连接也转移到原结点上。
               3. 若父结点的关键字个数又不满于下限，则父结点同样要于与它的兄弟父结点进行合并，并不断重复这个过程。
               4. 若父结点为空则删除父结点。（兄弟合并，父亲下沉）

5.   $B+$树：与分块查找的思想类似，是对$B$树的一种变型，多用于索引结构，例如数据库设计语言。

     1.   每个分支结点最多有$m$棵子树或孩子结点。
     2.   为了保持绝对平衡，非叶根结点至少有两棵子树，其他每个分支结点至少有$\lceil\dfrac{m}{2}\rceil$棵子树
          +   不同于$B$树，$B+$树又重新将最下面的保存的数据定义为叶子结点
     3.   **结点的子树个数与关键字个数相等**，$B$树结点子为树个数与关键字个数加$1$
     4.   所有叶结点包含所有关键字以及指向记录的指针，叶结点中将关键字按大小排序，并且相邻叶子结点按大小顺序相互连接起来
          +   所以**$B+$树支持顺序查找**。
     5.   所有分支结点中仅包含其各子结点中关键字的最大值以及指向其子结点的指针
          +   即分支结点只是索引
     6.   $B+$树可以遍历查找，即从根结点出发，对比每个结点的关键字值，若目标值小于当前关键字值且大于前一个关键字值，则从当前关键字的指针向下查找。
     7.   **无论查找成功与否，$B+$树的查找一定会走到最下面一层结点**。因为对应的信息指针都在最下面的结点，而$B$树查找可以停留在任何一层。

### 散列表查找

1.   散列表：又称哈希表，是一种数据结构，数据元素的关键字与其存储地址直接相关。一个散列结构是一块地址连续的存储空间。
2.   散列函数：记录位置=散列函数(记录关键字)数，记为$Hash(key)=Addr$。
     1.   直接定址法：可表示为$H(key) = key$ 或 $H(key) = a\times key + b$，其中$a$、$b$均为常数。
          + 这种方法计算特别简单，并且不会发生冲突，但当关键字分布不连续时，会出现很多空闲单元，会将造成大量存贮单元的浪费。
     2.   除留余数法：$H(key)= key\mod p$，$p$一般是**不大**于表长的最大质数
          + 这种方法使用较多，关键是选取较理想的$p$值，使得每一个关键字通过该函数转换后映射到散列空间上任一地址的概率都相等，从而尽可能减少发生冲突的可能性
          + 一般情形下，取$p$为一个最接近或等于散列表表长$m$的质数较理想，如果是合数则因为可以被多个数整除从而多个关键字余数相同造成冲突
3.   映射冲突：通常情况下不同的关键字可能会无可避免对应到同一个存储位置，这样就造成了冲突（碰撞）。此时，发生冲突的关键字互为同义词。
     1.   开放定址法：$H_i=(H(key)+d_i)\mod m$。其中$i$表示发生第$i$次冲突，$i=1,2,\cdots,m-1$；$m$为散列表长度，类似于循环队列，**超出表长以后就循环到最左边**；$d_i$为增量序列，是指发生第$i$次冲突的时候，$H(key)$偏移了多少位。
          1.   线性探测法：$d_i=1,2,3,\cdots,m-1$。
          2.   二次（平方）探测法：$di=1,-1,2^2,-2^2\cdots,(\dfrac{m}{2})^2,-(\dfrac{m}{2})^2$。
               +   对比线性探测法更不容易产生聚集问题，但**散列表长度$m$必须是一个可以表示为$4j+3$的素数才能探测到所有位置**。
          3.   再散列法：$d_i=Hash_2(key)$，又称双散列法。需要使用两个散列函数，当通过第一个散列函数$H(key)$得到的地址发生冲突时，则利用第二个散列函数$Hash_2(key)$计算该关键字的地址增量
     2.   链地址法：又称为拉链法或链接法，是把相互发生冲突的同义词用一个单链表链接起来，若干组同义词可以组成若干个单链表。插入操作默认头插法。指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。每次冲突都要重新哈希，计算时间增加。
4.   ※※查找效率：**散列表的查找效率取决于三个因素：散列函数、处理冲突的方法和装填因子**。
     +   装填因子：散列表的装填因子一般记为$\alpha$，定义为一个表的装满程度，即$\alpha=\dfrac{n}{m}$，其中$n$表示表中记录数，$m$表示散列表长度。填装因子的取值范围通常是 $0 \leq \alpha \leq 1$。装填因子代表一个散列表中的满余情况，**越大则查找效率越低**。
         +   若只给出了装填因子$\alpha$，则此时平均查找长度为：$ASL=\dfrac{1}{2}(1+\dfrac{1}{1-\alpha})$。
5.   查找失败的平均查找长度：每次没找到就重新按照散列函数再找一次，直到**当前位置为空**即判断为找不到。若模为$m$，所以数据插入的范围是$0\sim m-1$，所以查找的范围是$0\sim m-1$。
6.   堆积现象：堆积现象因冲突而产生，会对平均查找长度$ASL$产生影响，而对存储效率、装填因子、散列函数等无影响。

