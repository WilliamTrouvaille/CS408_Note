# 第四章 串

## 导读

### 【考纲内容】

1. 字符串模式匹配

### 【知识导图】

![1689255787t-20230713-2107-434.239](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/1689255787t-20230713-2107-434.239.png)

### 【复习提示】

+ 本章是统考大纲第$6$章内容，采纳读者建议单独作为一章
+ 大纲只要求举握字符串模式匹配，重点举握$KMP$匹配算法的原理及`next`数组的推理过程，手工求`next`数组可以先计算出部分匹配值表然后变形，或根据公式来求解
+ 了解`nextval`数组的求解方法。

## 串

重点是字符串匹配模式，其他只做了解。

### 基本概念

+ 串：零个或多个字符组成的有限序列。
    + 一般记为$S=a_1a_2\cdots a_n(n\ge 0)$
    + 其中，$S$是串名，单引号括起来的字符序列是串的值
    + $a_i$可以是字母、数字或其他字符
    + 串中字符的个数$n$称为串的长度

+ 子串：串中任意个连续的字符组成的子序列。
+ 空串：长度为零的串。
    + 使用空集符号$\varnothing$表示

+ 空白串（空格串）：仅由一个或多个空格组成的串。
+ 空串是任意串的子串，任意串是其自身的子串。

串的基本操作是对子串的操作。

### 串定义

#### 顺序串

![1689256016t-20230713-2156-525.201](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/1689256016t-20230713-2156-525.201.png)

顺序串的结构定义方案

![1689256143t-20230713-2103-881.483](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/1689256143t-20230713-2103-881.483.png)

1.   使用串末尾单独的变量$length$保存串长。
2.   使用$data[0]$记录串长
     +   **使得字符位序与数组下标一致**
     +   但是由于$char$类型一个为一字节大小，所以能表示的数字是$0$到$255$
     +   太大的串无法表示，大于的部分会被==截断==。
3.   没有表示串长的变量，使用$\backslash0$表示串结尾，对应$ASCII$码的$0$号字符。
4.   $data[0]$空余，使用单独的变量$length$保存串长
     +   比较常用
     +   默认使用这种方法
5.   以定长分配也可以用堆分配。

#### 链串

![1689256321t-20230713-2101-487.194](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/1689256321t-20230713-2101-487.194.png)

+   如一般的链式存储结构定义一样，定义一个数据与指向下一位的指针。

+   但是如果你只在每个结点定义了一个字节的数据，但是又包含了四个字节的指针，那么存储利用率会很低。

+   如果是顺序表数据类型是整数类型，那么这种利用率低的情况确实无可奈何，但是对于串而言，因为一个字节存储一个字符，所以能一个字节存一个字符类型数据，所以为了提升数据存储利用率，可以每个结点存等多个字符。这就是**块链串**。

    ![1689256400t-20230713-2120-613.198](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/1689256400t-20230713-2120-613.198.png)

    +   如上图,每个结点存放$4$个字符,存储密度提高
    +   没存满的结点可以利用占位符

### 串的基本操作

1.   `StrAssign(&T,chars)`：赋值操作。把串`T`赋值为`chars`。

     1.   使用默认构造函数初始化：

          - 函数签名：`basic_string()`

          - 功能：创建一个空的字符串对象。

          - 返回值：一个空的string对象。

          - 示例：

              ```cpp
              std::string str;  // 初始化一个空的字符串对象
              ```

     2. 使用字符串字面值初始化：

         - 函数签名：`basic_string(const char*)`

         - 功能：使用给定的C风格字符串字面值初始化字符串对象。

         - 参数：一个以空字符（'\0'）结尾的字符数组，表示字符串字面值。

         - 返回值：一个包含了字符串字面值内容的string对象。

         - 示例：

             ```cpp
             std::string str("Hello, world!");  // 使用字符串字面值初始化字符串对象
             ```

     3. 使用部分字符序列初始化：

         - 函数签名：`basic_string(const char*, size_type count)`

         - 功能：使用给定的C风格字符串的前count个字符初始化字符串对象。

         - 参数：一个以空字符（'\0'）结尾的字符数组，表示字符串字面值；count表示要拷贝的字符数量。

         - 返回值：一个包含了部分字符序列的string对象。

         - 示例：

             ```cpp
             const char* source = "Hello, world!";
             std::string str(source, 5);  // 使用字符串的前5个字符初始化字符串对象
             ```

     4. 使用重复字符初始化：

         - 函数签名：`basic_string(size_type count, CharT ch)`

         - 功能：创建一个包含了count个重复字符ch的字符串对象。

         - 参数：count表示要重复的次数；ch表示要重复的字符。

         - 返回值：一个包含了重复字符的string对象。

         - 示例：

             ```cpp
             std::string str(5, 'A');  // 创建一个包含5个重复字符'A'的字符串对象
             ```

     5. 使用迭代器范围初始化：

         - 函数签名：`template <class InputIterator> basic_string(InputIterator first, InputIterator last)`

         - 功能：使用迭代器范围内的字符序列初始化字符串对象。

         - 参数：first和last分别表示字符序列的起始和结束迭代器。

         - 返回值：一个包含了迭代器范围内字符序列的string对象。

         - 示例：

             ```cpp
             std::vector<char> chars = {'H', 'e', 'l', 'l', 'o'};
             std::string str(chars.begin(), chars.end());  // 使用迭代器范围初始化字符串对象
             ```

2.   `StrCopy(&T,S)`：复制操作。由串`S`复制得到串`T`。

3.   `StrEmpty(S)`：判空操作。若`S`为空串，则返回`TRUE`,否则返回`FALSE`。

4.   `StrLength(S)`：求串长。返回串`S`的元素个数。

5.   `StrCompare (S,T)`：比较操作。若`S>T`,则返回值$>0$;若`S=T`,则返回值$=0$;若`S<T`,则返回值$<0$

     +   ![1689256932t-20230713-2212-875.252](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/1689256932t-20230713-2212-875.252.png)

     +   `compare` 函数：

         - 函数签名：`int compare(const string& str) const`

         - 功能：比较当前字符串与参数字符串 `str` 的大小关系。

         - 参数：`str` 是要进行比较的目标字符串。

         - 返回值：

             - 若当前字符串小于 `str`，则返回一个负整数。
             - 若当前字符串等于 `str`，则返回 0。
             - 若当前字符串大于 `str`，则返回一个正整数。

         - 示例：

             ```cpp
             std::string str1 = "apple";
             std::string str2 = "banana";
             
             int result = str1.compare(str2);
             if (result < 0) {
                 std::cout << "str1 小于 str2" << std::endl;
             } else if (result > 0) {
                 std::cout << "str1 大于 str2" << std::endl;
             } else {
                 std::cout << "str1 等于 str2" << std::endl;
             }
             ```

     +  `operator==`、`operator!=`、`operator<`、`operator>`、`operator<=`、`operator>=`：

         - 函数签名：这些是字符串类（`std::string`）重载的比较运算符。

         - 功能：对两个字符串进行比较，得到一个布尔值表示比较结果。

         - 参数：比较运算符的右侧是要进行比较的另一个字符串。

         - 返回值：布尔值 `true` 或 `false`。

         - 示例：

             ```cpp
             std::string str1 = "apple";
             std::string str2 = "banana";
             
             if (str1 == str2) {
                 std::cout << "str1 等于 str2" << std::endl;
             } else if (str1 != str2) {
                 std::cout << "str1 不等于 str2" << std::endl;
             }
             
             if (str1 < str2) {
                 std::cout << "str1 小于 str2" << std::endl;
             } else if (str1 > str2) {
                 std::cout << "str1 大于 str2" << std::endl;
             }
             ```

     

6.   `ClearString(&S)`：清空操作。将`S`清为空串。

7.   `DestroyString(&S)`：销毁串。将串`S`销毁（回收存储空间）

8.   `Concat(&T,S1,S2)`：串联接。用`T`返回由`S1`和`S2`联接而成的新串

9.   `SubString(&Sub,S,pos,len)`：求子串。用`Sub`返回串`S`的第`pos`个字符起长度为`len`的子串。

     ![1689256803t-20230713-2203-593.256](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/1689256803t-20230713-2203-593.256.png)

     +   `substr` 函数：

         - 函数签名：`string substr(size_type pos = 0, size_type count = npos) const`

         - 功能：从当前字符串中提取一个子串。

         - 参数：`pos` 表示子串的起始位置（默认为 0），`count` 表示要提取的字符数量（默认为 `npos`，提取从 `pos` 开始到字符串末尾的所有字符）。

         - 返回值：一个包含指定子串的新字符串对象。

         - 示例：

             ```cpp
             std::string str = "Hello, world!";
             
             std::string substr1 = str.substr(7);        // 提取从位置 7 开始到末尾的子串
             std::string substr2 = str.substr(0, 5);     // 提取从位置 0 开始的 5 个字符的子串
             std::string substr3 = str.substr(7, 5);     // 提取从位置 7 开始的 5 个字符的子串
             std::string substr4 = str.substr(7, 100);   // 提取从位置 7 开始到末尾的子串（超出字符串长度的部分会被忽略）
             ```

10.   `Index(S,T)`：定位操作。若主串`S`中存在与串`T`值相同的子串，则返回它在主串`S`中第一次出现的
      位置；否则函数值为`0`。

### 模式匹配

+   模式匹配指在主串中找到与模式串相同的子串并返回其所在位置。
    +   子串一一主串的一部分，一定存在
    +   模式串一一要找的串,不一定能在主串中找到

#### 朴素模式匹配算法

从主串$T$、模式串$P$（子串）的第一个位置开始比较（$i=0,j=0$），若相等，则$i$，$j$各自$+1$，然后比较下一个字符。若不等，主串指针回溯到上一轮比较位置的下一个位置，子串回溯到$0$，再进行下一次比较。令子串长度为$m$，主串长度为$n$,则最多对比$n-m+1$次

![1689257815t-20230713-2255-483.795](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/1689257815t-20230713-2255-483.795.png)

使用求子串函数的方法

![1689257412t-20230713-2212-746.252](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/1689257412t-20230713-2212-746.252.png)

不使用求子串函数的方法

![1689257483t-20230713-2223-410.362](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/1689257483t-20230713-2223-410.362.png)

+ 匹配成功的最好时间复杂度：$O(m)$：刚好第一个就匹配上了，总对比次数为子串长度。
+ 匹配失败的最好时间复杂度：$O(n-m+1)=O(n-m)=O(n)$：匹配成功之前，每一个与第一个字符都匹配失败。
+ 匹配失败的最坏时间复杂度：$O(nm-m^2+m)= O(nm)$：子串除了最后一个对不上，其余的都能对上，则每次遍历完一边后，又要走回头路；直到匹配成功/失败一共需要比较$m\times(n-m+1)$次。$m$：每次需要移动$m$次，$i$需要移动$n-m+1$次。

暴力匹配算法的最大问题就是对主串一位位进行对比，当后面的匹配失败后只能回溯主串，从主串中下一位字母从头开始匹配模式串

#### KMP算法

##### 原理

+   $KMP$算法是对朴素模式匹配算法的优化。
+   朴素模式匹配算法的缺点就是当某些子串与模式串能部分匹配时，主串的扫描指针$i$经常回溯，从而导致时间开销。
+   主要思想是失配时，只有模式串指针回溯，主串指针不变，找到失配前模式串的最长公共前后缀并跳转到最大公共后缀开始匹配，且最大公共前后缀要小于左端子串长度。
+   那么如何理解？如主串是$12345612346$，模式串为$12346$，那么我们从$1$开始对比到$5$的时候失配。按照默认暴力匹配法不仅模式串要回溯到第一个，主串也要回溯到第二个即$2$重新对比。
+   但是我们一眼就能看出来$2$这个位置不需要进行对比，因为我们之前匹配过，字符串中只有最开始位置为$1$，其他位置都不为$1$，所以应该直接跳到没有对比的主串位置进行对比，而不是重复对比之前的内容。这是我们大脑默认处理的过程，$KMP$就是模拟这个处理过程。

![1689257906t-20230713-2226-740.373](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/1689257906t-20230713-2226-740.373.png)

+   ==不匹配的字符之前，一定是和模式串一致的==

![1689258006t-20230713-2206-741.416](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/1689258006t-20230713-2206-741.416.png)

+   从模式串本身可以看出模式串前缀1号2号位`ab`和4号5号位`ab`相同
+   可以直接跳过2号3号对应的主串直接比对
+   此时可令主串指针`i`不变，模式串指针`j=3`
    +   主串指针`i`通常不变(指向上次匹配失败的字符)
    +   模式串指针指向
        +   当第`1`个元素匹配失败时，匹配下一个相邻子串
            +   模式串匹配指针指向表头
            +   主串匹配指针指向下一位
        +   其他不为第`1`个元素匹配失败时,根据最大公共后缀决定模式串匹配指针后滑动位数

主串是未知的，而**模式串是已知**的，所以对于串匹配的优化必然基于模式串。

由于模式串在最开始就是已知的，所以在失配前主串和模式串必然相等，即我们可以选择模式串中能匹配的部分重新匹配，而不是直接从头开始。

##### 公共前后缀

模式后滑动位数只与模式串本身的最大公共后缀有关，于主串无关。

+ 前缀：对于字符串$A$，$B$，$A=B+S$，且$S$非空，则$B$是$A$的前缀。
+ 后缀：对于字符串$A$，$B$，$A=S+B$，且$S$非空，则$B$是$A$的后缀。
+ $PMT$值：前缀集合和后缀集合的交集中，最长元素的长度。
+ 部分匹配表：$PMT$值集合，字符串所有前后缀的$PMT$值。

当一个位置失配时，那么子串前面的所有字符串都是配对的，所以对于子串前面的部分都是已知的了，需要从模式串的最开始开始对比，而一般的模式匹配要从主串的下一个重新开始匹配，但是如果我们找到了主串当前失配位置的前缀和后缀最大重合的地方，即公共前后缀，$PMT$值，就代表从这里开始就可以匹配了，前面的地方没必要匹配，可以直接多跳几步移动到公共后缀去开始重新匹配。

|  字符串  |         前缀          |         后缀          |   交集    | PMT  |
| :------: | :-------------------: | :-------------------: | :-------: | :--: |
|   'a'    |           ∅           |           ∅           |     ∅     |  0   |
|   'ab'   |          'a'          |          'b'          |     ∅     |  0   |
|  'aba'   |       'a','ab'        |       'ba','a'        |    'a'    |  1   |
|  'abab'  |    'a','ab','aba'     |    'b','ab','bab'     |   'ab'    |  2   |
| 'ababab' | 'a','ab','aba','abab' | 'a','ba','aba','baba' | 'a','aba' |  3   |

所以字符串'$ababa$'的部分匹配值为$00123$，即可以得到部分匹配值表。

![download](https：//trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/download.png)

如图可知在$a$和$c$处失配，由于前面是匹配的，所以可以直接对齐比较。

##### next数组

假设索引值以$0$为开头，如果是以$1$开始则全部加一即可。

失配移动位数$move$=已匹配字符数$j$-对应的部分匹配值$PM[j-1]$。（从而跳到开始有重复公共前缀的地方）

部分匹配值表就是子串应该跳转的索引值。当这个位失配，则子串应该跳转的索引值是失配位置前一位的$PM$值。

因为纯匹配值表要看前一位的值，所以可以把匹配表数据全部右移一位，这就可以直接看失配位置的表值了，定义为$next$。最开始的一位用$-1$表示，最后一位丢弃。

所以$move=j-next[j]$。即移动位数=匹配位数-本位的跳转值。

所以相当于子串的比较指针$j$回到$j=j-move=j-((j-next[j])=next[j]$。

$next$此时就是$j$失配时应该跳转到的索引值。

所以当$j=0$时，恒定$next[0]=-1$（主串加一）$next[1]=0$。因为只有一个字母没有前一位所以是$-1$，只有两个字母前一位只有一个字母没有前后缀。

<!-- 1. 求$next[j+1]$，则已知前面的所有$next$表值$next[1],next[2]\cdots next[j]$。

1. 假设数组值$next[j]=k_1$（跳转索引），则有$P_1\cdots P_{k_1-1}=P_{j-k_1+1}\cdots P_{j-1}$（前$k_1-1$位字符与后$k_1-1$位字符重合）。
2. 如果$P_{k_1}=P_j$（即最后一位也一样，则得到在之前匹配基础上的更长的公共前后缀），则$P_1\cdots P_{k_1-1}P_{k_1}=P_{j-k_1+1}\cdots P_{j-1}P_j$，则$next[j+1]=k_1+1$，否则进入下一步。
3. 假设$next[k_1]=k_2$、则有$P_1\cdots P_{k_2-1}=P_{k_1-k_2+1}\cdots P_{k1-1}$。
4. 第二第三步联合得到$P_1\cdots P_{k_2-1}=P_{k_1-k_2+1}\cdots P_{k1-1} =P_{j-k_1+1}\cdots P_{k_2-k_1+j-1}=P_{j-k_2+1}\cdots P_{j-1}$，即四段重合。
5. 这时候．再判断如果$P_{k_2}=P_j$，则$P_1\cdots P_{k_2-1}P_{k_2}=P_{j-k_2+1}\cdots P_{j-1}P_j$，则$next[j+1]=k_2+1$，否则再取$next[k_2]=k_3$回到四。
6. 如果遇到$0$还没有结果，则表示前面的全部不重合，赋值为$0+1=1$。

可以通过一定关系不用计算最大公共前后缀得到$next$值：

要计算当前位置的$next$值，就看前一位的$next$值所代表的索引指向的字符是否与前一位的字符相等，若相等，则是前一位的$next$值加一，若不等，则继续看前一位的$next$值指向的字符的$next$指向的字符与前一位字符是否相等，若相等则结果就是这个$next$值加一，否则继续按照$next$索引向前寻找。最后都不等则前一位$next$为$0$，当前位置的$next$为$1$。 -->

##### KMP匹配

$KMP$算法在形式上跟简单的模式匹配算法类似，唯一不同的是当失配时指针$i$不动（主串不动）指针$j$回到$next[j]$的位置重新比较（利用$next$数组跳到指定位置后要在这个位置比较一次），当$j=-1$时代表全部失陪，所以$ij$同时加一，即全部后移一位。

<!-- 即主串第$i$个位置与模式串第一个字符不等时应该从主串$i+1$个位置开始匹配。 -->

##### 算法性能

使用$KMP$算法时需要先计算不同模式串$P$的$next$数组，时间复杂度为$O(m)$，然后使用$KMP$算法计算，时间复杂度为$O(n)$，从而平均时间复杂度为$O(m+n)$。

虽然普通模式匹配算法复杂度$O(mn)$，但是一般情况下接近于$O(m+n)$。

$KMP$算法对于重复部分比较多的模式串匹配效果更好。

#### KMP算法优化

$KMP$算法的$next$数组存在一定问题，当当前索引的值匹配失败，那么模式串的其他同样值的地方也一定会匹配失败。

如$goolggoogle$匹配$google$，其中$PMT$表格为：

|  序号   |  0   |  1   |  2   |  3   |  4   |  5   |
| :-----: | :--: | :--: | :--: | :--: | :--: | :--: |
| 模式串  |  g   |  o   |  o   |  g   |  l   |  e   |
| next[j] |  -1  |  0   |  0   |  0   |  1   |  0   |

其中匹配到第四个$l$时与$g$不匹配，按照表格会跳转匹配到第$1$个字符，但是由于序号$1$的字符也是$g$，所以这次跳转就是个浪费的对比。

所以可以直接将模式串所有相同值的部分的$next$值全部取为其$next$值对应索引的$next$值。

所以需要再次递归，将$next[j]$变为$next[next[j]]$直到两者不相等，令更新后数组为$nextval$。

|    序号    |  0   |  1   |  2   |  3   |  4   |  5   |
| :--------: | :--: | :--: | :--: | :--: | :--: | :--: |
|   模式串   |  g   |  o   |  o   |  g   |  l   |  e   |
|  next[j]   |  -1  |  0   |  0   |  0   |  1   |  0   |
| nextval[j] |  -1  |  0   |  0   |  -1  |  1   |  0   |

对于多个字符重复的字符串，则$nextval$的优化程度会更高：

|    序号    |  0   |  1   |  2   |  3   |  4   |
| :--------: | :--: | :--: | :--: | :--: | :--: |
|   模式串   |  a   |  a   |  a   |  a   |  b   |
|  next[j]   |  -1  |  0   |  1   |  2   |  3   |
| nextval[j] |  -1  |  -1  |  -1  |  -1  |  3   |

