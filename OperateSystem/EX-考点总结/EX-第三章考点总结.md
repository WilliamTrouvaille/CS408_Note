# EX-第三章 内存管理考点总结

## 导读

### 【考纲内容】

1. 内存管理基础

    + 内存管理概念：逻辑地址与物理地址空间、地址变换、内存共享、内存保护、内存分配与回收

    + 连续分配管理方式
    + 页式管理
    + 段式管理
    + 段页式管理

2. 虚拟内存管理

    + 虚拟内存基本概念
    + 请求页式管理
    + 页框分配
    + 页置换算法

    + 内存映射文件$MMF$（$Memory-Mapped \;Files$） 
    + 虚拟存储器性能的影响因素及改进方式

### 【复习提示】

选择题：分页机制、内存管理和进程管理、分页管理、虚拟内存

综合题：内存管理和进程管理

## 选择题考点总结

### 内存管理概述

1.   内存：用于存放数据的硬件。程序执行前需要先放到内存中才能被$CPU$处理，用于缓冲$CPU$和硬盘间的速度矛盾。内存地址从$0$开始，每个地址对应一个存储单元。
2.   编址方式/编址单位：按**字节**编址，则每个存储单元大小为一个**字节**即$1B$，$8$个二进制位。按**字**编址，每个存储单元大小为一个**字**，根据计算机的字长确定大小，若字长为$16$位，则一个存储单元大小为$16$个二进制位。
3.   内存管理：目前仍然不可能将所有用户进程和系统所需要的全部程序与数据放入主存。因此操作系统必须对内存空间进行合理的划分和有效的动态分配。操作系统对内存的划分和动态分配，就是内存管理的概念。 
     1.   内存空间的分配与回收：即后面的普通内存管。由操作系统完成主存储器空间的分配和管理。
     2.   地址转换：把逻辑地址转换成相应的物理地址。
     3.   内存空间的扩充：利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存。
     4.   内存共享：允许多个进程访问内存的同一部分。
     5.   存储保护：保证各道作业在各自的存储空间内运行，互不干扰。
4.   地址转换：操作系统提供**地址转换**功能，通过内存管理部件$MMU$，负责程序的**逻辑地址**与**物理地址**的转换。
     1.   相对地址（逻辑地址）：从$0$号开始，程序员只用知道逻辑地址，可有相同逻辑地址。用户程序和程序员只需知道逻辑地址，而内存管理的具体机制则是完全**透明**的。不同进程可以有相同的逻辑地址。
     2.   绝对地址（物理地址）：内存物理单元的集合，是地址转换的最终地址。从逻辑地址到物理地址就是**地址重定位**。
5.   **可重入代码/纯代码**：只有只读区域才能共享。也叫可重入代码/纯代码。即允许多个进程同时访问但是不允许任何进程修改的代码，但**可以复制副本后自己修改**。**一定不是临界资源**。
6.   内存保护：保证各进程在各自存储空间内运行，互不干扰。操作系统提供。加载重定位寄存器和界地址寄存器时必须使用**特权指令**，只有**操作系统内核（内核态）**才可以加载这两个存储器。
     1.   在$CPU$中设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，$CPU$检查是否越界。
     2.   采用**重定位寄存器**（又称基址寄存器，用于地址相加，存放的是进程的**起始物理地址**）和**界地址寄存器**（又称限长寄存器，用于地址比较，存放的是进程的**最大逻辑地址**）进行越界检查。

7.   ※程序载入过程：即将用户程序变为可在内存中执行的程序的步骤。**编译、链接、装入(装载)、（执行）**。
8.   装入：即将逻辑地址转换为物理地址。
     1.   绝对装入：只适用于单道程序阶段、未产生操作系统。**编译时**进行地址转换。不需对程序和数据的地址进行修改。
     2.   静态重定位/**可重定位装入**：适用于多道批处理操作系统。**装入时**进行地址转换（重定位）。地址变换是在装入时一次性完成的。
     3.   动态重定位：适用于现代操作系统。**执行时**进行地址转换（重定位）。程序在内存中若发生移动，则应该采用动态重定位。

### 普通内存管理

#### 分区分配方式

1.   单一连续分配：内存中只能有一道用户程序，用户程序独占整个用户区空间。**无外部碎片**，**有内部碎片**。
2.   固定分区分配：将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业。**无外部碎片**，**有内部碎片**。
3.   动态分区分配（默认）：不会预先划分内存分区，在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。系统分区的大小和数目是可变的。
     1.   记录分区的方法：空闲分区表、空闲分区链。
     2.   **无内部碎片**，**有外部碎片**。
4.   **紧凑/拼接**技术：使用**动态重定位寄存器**克服外部碎片，且相对费时。
5.   回收分区
     1.   若回收区的后面或前面有一个相邻的空闲分区，则两个表项合并为一个。
     2.   若回收区的后面和前面都有一个相邻的空闲分区，则三个表项合并为一个。
     3.   若回收区的后面或前面都没有一个相邻的空闲分区，则新增一个表项。

#### 动态分区分配算法

首次适应法和临近适应法只用简单查找，最佳适应法和最大适应法每次分配后都需要对可用块进行排序和遍历。

1.   首次适应算法$First\;Fit$：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。
     +   排列：按地址递增次序；开销：小。
2.   最佳适应算法$Best\;Fit$：优先使用**更小**的空闲区。虽然称为"最佳”，但是性能通常很差。
     +   排列：容量递增次序；开销：大。会产生最多的**外部碎片**。
3.   最坏适应算法$Worst\;Fit$：优先使用**更大**的空闲区。
     +   排列：容量递减次序；开销：大。可能会导致大进程没有空间。
4.   临近适应算法$Next\;Fit$：每次都**从上次查找结束的位置**开始检索的首次适应算法。
     +   排列：容量地址递增；开销：小。

### 基本页存储管理

#### 请求分页存储管理

其中越界检验次数等于**逻辑地址结构中除偏移量$W$外字段的个数**。页表一次，段表两次，段页表两次。

1.   **页框/页帧/内存块/物理块/物理页面**$Page\;Frame$（物理概念）：将**内存空间**分为一个个大小相等的分区。

2.   页框号/页帧号/内存块号/物理块号：每个页框有一个编号，即“页框号”。页框号从$0$开始。页框过大可能产生内部碎片，过小降低效率。

3.   页/页面$Page$（逻辑概念）：将用户进程的**地址空间**也分为与页框大小相等的一个个区域，称为“页”或“页面”。进程的最后一个页面可能没有一整个页框的大小。**页面离散存储**在内存不同的物理块。

     +   分页是对程序根据内存大小进行分页，所以只对硬件和操作系统是可见的，对于连接装配程序、编译系统、用户都是透明的。

4.   块$Block$：外存中也按上述同样的单位进行划分。

5.   地址结构：分为页面偏移量$W$和页号$P$两个部分。

6.   页表：一个进程对应一张页表和一个逻辑地址。进程的每一页对应一个页表项。每个**页表项**由“页号”和“块号”组成。页表项连续存放，因此页号可以是隐含的，**不占存储空间**。每个页表项的长度是相同的。

7.   ※页式基本地址变换机构：通常会在系统中设置一个**页表寄存器$PTR$**，存放页表在内存中的起始地址$F$和页表长度$M$。进程未执行时，页表的始址和页表长度放在进程控制块$PCB$中，当进程被调度时，操作系统内核会把它们放到**页表寄存器$PTR$**中。

     1.   计算逻辑地址$A$对应的页号$P$与页内偏移量$W$。
     2.   ※检测页号$P$是否越界。越界产生内中断（**越界异常**）。页号$P$范围$0\sim M-1$。
     3.   根据页表中页号$P$求页表寄存器中的页表项地址$PA=$页表起始地址$F+$页号$P\times$页表项长度$PL$，得到页表中对应的页表项，从而确定页面存放的内存块号$B$。
     4.   最后物理地址$E=$内存块号$B\times$×页面大小$L+$页内偏移量$W$。

8.   快表：即**相联寄存器**$TLB$，是一种访问速度比内存快很多的**高速缓冲存储器**，用来存放最近访问的页表项的副本，以加速地址变换的过程。与此对应，内存中的页表常称为慢表$Page$。

     1.   $CPU$给出逻辑地址，由某个硬件算得页号、页内偏移量，进行越界判断无异常后将页号与快表中的所有页号进行比较。
     2.   如果找到匹配的页号且有效位为$1$，说明要访问的页表项在快表中有副本。因此若快表命中则访问某个逻辑地址**仅需一次访存**即可。
     3.   如果没有找到匹配的页号，则需要访问**内存中**的页表，找到对应页表项，得到页面存放的内存块号。再将内存块号与页内偏移量拼接形成物理地址。最后，访问该物理地址对应的内存单元。同时将其**存入快表**，以便后面可能的再次访问。但若快表已满，则必须按照一定的页面置换算法对旧的页表项进行替换。因此，若快表未命中，则访问某个逻辑地址**需要两次访存**。

9.    多级页表：将页表进行分组离散地放入内存块，并为离散分组的页表再建立一张页表，称为**页目录表**、外层页表或顶层页表，页目录表页保存页号和**内存块号**两项。

     1.   ※若采用多级页表机制，则各级页表的大小不能超过**一个**页面。
     2.   每个页面可以存放的页表项等于页面大小除以页表项大小。
     3.   假设没有快表机构时，$n$级页表需要查找$n+1$次内存，最后一次是访问目标内存单元。

#### 请求分段存储管理

1.   分段：以段为单位进行分配，**每个段在内存中占据连续空间**，但各段之间可以不相邻。由于是按逻辑功能模块划分，**用户编程更方便，程序的可读性更高**。同时方便共享和保护，方便编程，方便动态链接和增长。
     +   页式系统中逻辑地址的页号和页内偏移量对用户透明，但是**段式系统段号和段内偏移量必须由用户显式提供**，在高级程序设计语言中一般由编译程序完成。
2.   段表：每个段对应一个段表项，其中记录了段号、基址（该段在内存中的起始位置）、段长（整个段的总长度）。
     1.   各个段表项的长度是相同的：指的是**段表项**的长度，并非**段长**。
     2.   与页表项类似，由于各个段表项的长度是相同的，因此段号可以是隐含的，**不占存储空间**。
     3.   即使段是共享的，但是不同的程序中使用，其段号也是不同的
3.   段式存储地址变换：注意有两次越界检验。
     1.   根据逻辑地址得到段号$S$和段内地址$W$。
     2.   检测段号越界中断：根据段号$S$是否大于等于段表寄存器的段表长度$M$，判断上是否越界，若是则越界中断。段号范围$0\sim M-1$。
     3.   查询段表寄存器中的段表，找到对应的段表项。段表项分为段长$C$和段基址$B$，段表项的存放地址$SA=$段表始值$F+$段号$S\times$段表项长度$SL$。
     4.   检测段长越界中断：检测段内地址$W$是否大于等于段长$C$，若是则越界中断。
     5.   计算得到物理地址$E=$段基址$B+$段内地址$W$。

#### 段页式存储管理

1.   存储过程：将进程按逻辑模块分段，再将各段分页；再将内存空间分为大小相同的内存块/页框/页帧/物理块；进程前将各页面分别装入各内存块中。
2.   段页式系统逻辑地址结构：由段号$S$、页号$P$、页内地址/页内偏移量$W$组成。“分段”对用户是可见的，程序员编程时需要显式地给出段号、段内地址。
3.   段页式的段表和页表：**段表只能有一个**，页表可以有多个。其中每个段表项/页表项长度均相等，段号/页号均是隐含的。
     1.   每个段对应一个**段表项**，每个段表项由段号、页表长度、**页表存放块号/页表起始地址**组成。
     2.   每个页面对应一个**页表项，**每个页表项由页号、页面存放的内存块号组成。

     3.   一个进程对应**一个段表**，对应**一个或多个页表项**，一个段表项就相当于只存一个的页表寄存器。
4.   段页式存储地址变换过程：注意有两次越界检验。
     1.   根据逻辑地址得到段号$S$、页号$P$和页内偏移量$W$。
     2.   检测段号越界中断：根据段号$S$是否大于等于段表寄存器的段表长度$M$，判断上是否越界，若是则越界中断。段表长度至少为$1$。
     3.   查询段表寄存器中的段表，找到对应的段表项.段表项分为段号$S$和页表长度$L$、段基址$F$和页表存放块号$D$。
          + 段表项的存放地址$SA=$段表始值$F+$段号$S\times $段表项长度$SL$。
     4.   检测页号越界中断：检测页号$P$是否大于等于页表项长度$PL$，若是则越界中断。
     5.   根据页表存放块号$D$和页号$P$查询页表，找到对应页表项，页表项分为页号$P$和内存块号$B$。
     6.   计算得到物理地址$E=$内存块号$B+$页内偏移量$W$。
     7.   也可引入快表机构，用段号和页号作为查询快表的关键字，若快表命中则仅两次访存。

### 虚拟内存管理

#### 虚拟内存概述

1.   虚拟内存：在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。虚拟存储技术是基于页或段从内存的调入/调出实现的，需要有请求机制的支持。在用户看来似乎有一个比实际内存大得多的内存，这就是**虚拟存储器/虚拟内存**。是操作系统**虚拟性**的体现。
2.   虚拟内存容量：虚拟内存的**最大容量**由计算机的**地址结构**确定。虚拟内存的**实际容量**$=\min$（内存和外存容量之和，$CPU$寻址范围）。默认虚拟内存容量大于内存和外存容量之和，故默认机器字长决定虚拟内存最大容量。
3.   虚拟内存主要特征
     1.   多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。多次性是虚拟存储器最重要的特征。
     2.   对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。

     3.   虚拟性：从逻辑上扩充可内存的容量，使用户看到的内存容量，远大于实际的容量。是虚拟存储器所表现出的最重要特征，也是实现虚拟存储器的最重要目标。
4.   虚拟内存实现：基于**离散分配**的内存管理方式基础，即上面的分页分段段页式。不管哪种方式，都需要有一定的硬件支持。一般需要的支持共有以下几个方面
     1.   一定容量的内存和外存。
     2.   页表机制：或段表机制，作为主要的数据结构。
     3.   中断机构：当用户程序要访问的部分尚未调入内存时，则产生中断。
     4.   地址变换机构：实现逻辑地址到物理地址的变换。默认内存管理部件$MMU$。
5.   采用页表机制的虚拟内存：基于基本分页系统，增加了**请求调页**功能和**页面置换**功能。
     1.   请求调页：操作系统需要知道每个页面是否已经调入内存。如果还没调入，那么也需要知道该页面在外存中存放的位置。
     2.   页面置换：当内存空间不够时，需要通过某些指标来决定换出哪个页面，有的页面**没有被修改过**，就**不用写回外存**；有的页面修改过，就需要将外存中的旧数据覆盖。因此，操作系统也需要记录各个页面是否被修改的信息。
6.   采用页表机制的虚拟内存的页表项：
     1.   页号：页表项连续存放，因此页号可以是隐含的。
     2.   内存块号/物理块号：与下面的外存地址不同，内存块号记录的是（运行在内存中的）当前程序存放的地址。
     3.   状态位$P$：表示是否已调入内存，供访问时参考。$0$表示未调入，$1$表示已调入。

     4.   访问字段$A$：可记录最近被访问过几次，或记录上次访问的时间。供置换算法选择换出页面时参考。

     5.   修改位$M$：页面调入内存后是否被修改过。$0$表示没有，$1$表示修改过。供置换算法选择换出页面时参考。

     6.   外存地址：页面在外存中的存放地址，一般是物理块号，供调入参考。若程序在外存，则不在运行（还没有调入）。
7.   ※缺页中断机构：每当所要访问的页面不在内存中时，便产生一个**缺页中断**，请求操作系统将所缺的页调入内存。
     1.   ※※缺页中断：和中断一样，处理过程类似保护$CPU$环境、分析中断原因、转入缺页中断处理程序、恢复$CPU$环境等。**缺页中断会同时把页面换到快表$TLB$和满表$Page$中**。
          1.   每当要访问的**页面不在内存**时，即状态位为$0$时，便产生一个缺页中断，由操作系统的缺页中断处理程序处理中断。
          2.   此时缺页的进程**阻塞**，放入阻塞队列。
          3.   如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表$Page$和快表$TLB$中相应的页表项（有效位等）。
          4.   如果内存中**没有空闲块**，则由**页面置换算法**选择一个页面淘汰。若该页面在内存期间**被修改过**，则要将其**写回外存**，未修改过的页面不用写回外存。之后将所缺页面装入该块。
          5.   调页完成后再将进程唤醒，放回**就绪**队列。
     2.   缺页中断在指令执行期间而非一条指令执行完后产生和处理中断信号，属于内部异常。 **缺页中断不是中断，是异常**。
     3.   换入/换出页面都需要启动慢速的$I/O$操作，如果换入/换出太频繁，会有很大的开销。
8.   ※地址变换机构：与普通页表的地址变换机构不同的是，增加了请求调页、页面置换和请求修改内容三个部分。
     1.   计算逻辑地址$A$对应的页号$P$与页内偏移量$W$。
     2.   检测页号$P$是否越界：页号$P$范围为$0\sim M-1$。
     3.   在快表$TLB$中查找对应页号：如果找到匹配的页号且有效位为$1$则取出该页内存块号并与页内偏移量拼接形成物理地址，然后进行访问。
     4.   如果没有找到匹配的页号，则需要访问**内存**中的页表$Page$。找不到就缺页中断，**缺页中断会同时把页面换到快表$TLB$和满表$Page$中**，故之后访问快表$TLB$一定能命中（但需要注意命中后还需要进行访存）。
     5.   找到对应页表项后，计算内存块号$B$和物理地址，并访问目标内存单元取数据。
9.   驻留集：在进程准备执行时，不需要也不可能把一个进程的所有页都读入主存。因此，操作系统必须决定读取多少页，即决定给特定的进程分配几个页框。给一个进程分配的物理页框的集合就是这个进程的**驻留集**，即允许进入内存运行的最大物理块数量。每个进程都有一个对应于自己的驻留集。
10.   页面分配策略
      1.   **固定分配**：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即驻留集大小不变。
      2.   **可变分配**：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即驻留集大小可变。
11.   页面置换策略
      1.   局部置换：发生缺页时只能选进程自己的物理块进行置换。
      2.   全局置换：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。将别的进程持有的物理块置换到外存时，其他进程的缺页率会增加。
12.   结合页面分配策略与页面置换策略
      1.   固定分配局部置换：为每个进程分配一定数量的物理块，在整个运行期间都不改变。
      2.   可变分配全局置换：只要缺页就给分配新物理块。
      3.   可变分配局部置换：要根据发生缺页的频率来动态地增加或减少进程的物理块。
      4.   ※没有固定分配全局置换策略：因为**全局置换意味着进程拥有的物理块数量必然会改变**，因此不可能是固定分配。
13.   物理块调入算法：采用固定分配策略时，将系统中的空闲物理块分配给各个进程。
      1.   平均分配算法，将系统中所有可供分配的物理块平均分配给各个进程。
      2.   按比例分配算法，根据进程的大小按比例分配物理块。
      3.   优先权分配算法，为重要和紧迫的进程分配较多的物理块。通常采取的方法是把所有可分配的物理块分成两部分，即一部分按比例分配给各个进程，一部分则根据优先权分配。
14.   调入页面时机
      1.   预调页策略（运行前）：预测不久之后可能访问到的页面，将它们预先调入内存。主要用于**进程的首次调入**，由程序员指出应该先调入哪些部分。
      2.   请求调页策略（运行时）：进程在运行期间发现缺页时才将所缺页面调入内存，调入的页面一定会被访问到。但由于每次只能调入一页，而每次调页都要磁盘$I/O$操作，因此$I/O$开销较大。
15.   调入页面位置
      1.   对换区：系统拥有足够的对换区空间。页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前，需将进程相关的数据从文件区复制到对换区。
      2.   文件区：系统缺少足够的对换区空间。凡是不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，故换出时不必写回磁盘。对于可能被修改的部分，换出时需写回磁盘对换区，下次需要时再从对换区调入
      3.   $UNIX$方式：运行之前进程有关的数据全部放在文件区，故**未使用过**的页面，都可从文件区调入。若被使用过的页面**需要换出**，则写回对换区，下次需要时从对换区调入。
16.   抖动（颠簸现象）：刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存。
      1.   根本原因是，系统中同时运行的进程太多，由此分配给每个进程的物理块太少。主要原因是页面置换算法不合理。
      2.   **所有**的页面置换算法都可能存在抖动。
      3.   可以撤销部分进程来减缓抖动。
17.   进程工作集：指在某段时间间隔里，进程实际访问页面的集合。窗口尺寸就是驻留集的大小，约束工作集大小，**工作集大小**小于等于**窗口尺寸/驻留集大小**。驻留集大小不能小于工作集大小，否则会产生抖动现象。

#### 页面置换算法

**页面置换**发生在**内存已满**且欲访问页面不在内存中时，**缺页中断**发生在欲访问页面不在内存时（**包括一开始没有页面**的时候）。缺页时未必发生页面置换。

1.   最佳置换算法$OPT$：每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。
     1.   不可能实际实现：不可能预测本进程所有页面请求。一般用来评价其他算法效果。
2.   先进先出置换算法$FIFO$：每次选择淘汰的页面是最早进入内存的页面，只考虑进入时间而不考虑访问次数。
     1.   有且仅有$FIFO$算法会产生$Belady$异常：当为进程分配的**物理块数**增大时，缺页次数不减反增。
     2.   使用队列实现，是队列类算法。
     3.   性能差：该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。
3.   最近最久未使用置换算法$LRU$：每次淘汰的页面是**最近最久未使用**的页面（是检查过去的，而$OPT$是检查未来的）。需要使用页表中访问字段：记录该页面自上次被访问以来所经历的时间$t$，并淘汰$t$值最大的。
     1.   手动做题：在**逆向扫描过程中最后一个出现的页号就是要淘汰的页面**。
     2.   实现困难开销大，需要专门的硬件支持：要对所有页面进行排序，需要增加额外的$LRU$位。
     3.   算法性能好，最接近$OPT$算法。
4.   简单时钟置换算法$CLOCK$：一种性能和开销较均衡的算法，又称最近未用算法$NRU$，即对$LRU$的简化，只用管最近未使用即可，不用管最久。
     1.   页面初始化：为每个页面设置一个访问位初始化全部为$1$，将内存中的页面都通过链接指针链接成一个循环队列，当某页被访问时，其访问位置设为$1$。
     2.   当内存满需要淘汰一个页面时：依次检查页的访问位，如果是$0$就直接换出，如果是$1$就将它置为$0$继续检查下一个页面。第二轮检查中一定会有访问位为$0$的页面，将其换出即可。
5.   改进型时钟置换算法：在其他条件都相同时，应优先淘汰没有修改过的页面，避免$I/O$操作。为方便讨论，用**(访问位，修改位)**的形式表示各页面状态，如$(1，1)$表示一个页面近期被访问过，且被修改过。
     1.   第一轮（**没访问没修改**）：从当前位置开始扫描到第一个$(0，0)$的帧用于替换，本轮扫描不修改任何标志位。
     2.   第二轮（**没访问有修改**）：查找第一个$(0，1)$的帧用于替换。本轮将所有扫描过的帧访问位设为$0$。
     3.   第三轮（**有访问没修改**）：查找第一个$(0，0)$的帧【原来是$(1,0)$】用于替换。本轮扫描不修改任何标志位。
     4.   第四轮（**有访问有修改**）：查找第一个$(0，1)$的帧【原来是$(1,1)$】用于替换。

## 大题总结

### 进程的内存映像

![image-20231105163416786](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202311051634272.png)

1.   进程虽然拥有很大的一块逻辑地址空间，但是有很大一部分空间可能是空着的，只有需要使用的时候才进行相应的分配。

2.   通过将不同进程的某些页表项映射到同一内存空间（相同页框号）的方式实现页面共享（虚拟页号可以不同，两个进程的虚拟页号是相互独立的）。

3.   低地址部分进程独享，高地址部分（操作系统内核区）所有进程共享，即都是映射到相同的一片物理页框中（通过页表映射的方式实现）。
4.   不同于存放在硬盘上的可执行程序文件，当一个程序调入内存运行时，就构成了进程的内存映像。一个进程的内存映像一般有几个要素
     1.   代码段/程序段：即程序的二进制代码，代码段是只读的，可以被多个进程共享。 即上图中`只读代码/数据段`和`共享库的存储映射区`。
     2.   数据段：即程序运行时加工处理的对象，包括全局变量和静态变量。 其他的用户`栈`$Stack$、`堆`$Stack$和`读/写数据`等
     3.   进程控制块$PCB$：存放在系统区。操作系统通过$PCB$来控制和管理进程。 
     4.   堆$Heap$：用来存放动态分配的变量。通过调用`malloc`函数动态地向高地址分配空间。 
     5.   栈$Stack$：用来实现函数调用。从用户空间的最大地址往低地址方向增长。 
     6.   操作系统内核区：仅操作系统可以访问。
5.   每个进程的虚拟地址空间都是连续的，但某些页面可能没有数据。

### 存储系统

1.   磁盘以块为单位。

2.   内存物理上被分为若干页框（考试中一般认为页框大小和磁盘块大小一致，但是现实中可能不一致）。

3.   进程被分为若干页面，每个进程的页面被离散的放在内存中的页框中。

4.   CPU访问进程某个页面时需要查询TLB/慢表进行地址转换：

     1.   进程的页面和页表项一一对应。
     2.   每个页表项中记录页号和实际物理地址的页框号的映射关系，以及是否有效（是否已经调入内存/是否缺页）。

5.   进程间有共享的页面（每个进程都有一个固定的地址部分映射到内核区的代码和内核数据，用于实现各种系统调用）

     1.   当进程之间利用系统调用进行通信的时，进程A先通过系统调用（存放在内核代码区）将要通信的内容存放在内核数据区。
     2.   进程B再通过系统调用将存放在内核数据区的内容取出，并放入自己的数据区中（进程A和进程B的内核区映射到的是同一片主存地址空间）。

6.   进程的数据区由若干指令组成，执行指令时可能需要访问某个虚拟地址，CPU就会将虚拟地址从指令中拆分出来，并进行虚拟地址到物理地址的转换：

     1.   使用虚拟地址中的虚拟页号查询TLB（TLB存放的是虚拟页号和物理地址页框号的映射关系）
     2.   TLB命中（TLB中有和虚拟页号对应的表项）且有效位为1时，不可能发生缺页：
          1.   将该表项中存放的页框号和页内偏移量进行拼接得到物理地址
          2.   根据物理地址中的页框号找到对应页框
          3.   根据页内偏移量找到对应的具体数据，并取出该数据
     3.   TLB命中但有效位为0，或者TLB未命中：
          1.   根据页表始址寄存器中存放的内容（页表始址）得到存放该进程页表的页表始址（进程未运行，页表始址存放在PCB中；进程上处理机运行时，CPU将页表始址从PCB中取出并放入页表始址寄存器中）
          2.   查询该页的页表项得到物理地址的页框号，并将该映射关系复制到TLB中：该页的页表项（记录放该页号和其实际主存中物理页框的映射关系）的地址 = 页表始址 + 页号 * 单个页表项大小（页表项采用连续存储的方式，占用一片连续的存储空间）
          3.   根据页表项中记录的物理页框号和页内偏移量进行拼接，得到具体数据的物理地址，取出数据
     4.   TLB未命中，且慢表命中但有效位为0，即发生缺页：
          1.   发生缺页异常（页故障），操作系统检测到该异常后，会对该异常进行处理，即调页（读磁盘块），慢表中的页表项中保存着其外存地址，根据此外存地址将外存中的物理块（考试中默认大小与页相等）读入主存
          2.   主存仍有空闲页框：该块调入主存的空闲页框中，并修改相应页表项
          3.   主存没有空闲页框：先根据页面置换算法选择一个页面淘汰，并且根据其脏位判断是否应该写回外存；然后再将该页面放入被淘汰页面之前所占用的页框中（覆盖），并修改相应页表项（慢表和TLB）
          4.   执行完调页后，将会重新执行引发缺页异常的指令（重新执行一遍访存过程）：在408中，某一条指令引发缺页异常，操作系统处理完缺页异常（即完成调页），该指令重新执行时，TLB命中（缺页异常处理也会将TLB中的表项进行更新）

7.   假设物理页框中可以存放数组A的1024个数组元素（即A[0] - A[1023]），TLB表初始为空，执行以下代码：

     ```
     for (int i = 0; i < 1024; i++) a[i] = 0;
     ```

     共需要访问1025次内存：

     1.   第1次访存，TLB未命中，根据内存中的慢表得到A[0]的逻辑地址得到A[0]的物理地址，并将该逻辑地址和物理地址的映射关系存入TLB中
     2.   第2次访存：根据A[0]的物理地址取出A[0]的数据
     3.   第3 $\sim$ 1025次访存：TLB命中，分别根据表中的映射关系得到A[1] - A[1023]的物理地址，取出A[1] - A[1023]的数据（A[1] - A[1023]的物理地址到逻辑地址的转换无需访存，此时TLB中已经有存放A[0] - A[1023]的主存块的逻辑地址和物理地址的映射关系，而查询TLB不用访存；故仅需从内存中取出数据一次访存）
