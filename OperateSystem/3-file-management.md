# 第四章 文件管理

## 导读

### 【考纲内容】

1. 文件
    + 文件的基本概念
    + 文件元数据和索引结点($inode$)
    + 文件的操作
        + 建立
        + 删除
        + 打开
        + 关闭
        + 读
        + 写
    + 文件的保护
    + 文件的逻辑结构
    + 文件的物理结构
2. 目录
    + 目录的基本概念
    + 树形目录
    + 目录的操作
    + 硬链接和软链接
3. 文件系统
    + 文件系统的全局结构($layout$)
    + 文件系统在外存中的结构，文件系统在内存中的结构
    + 外存空闲空间管理办法
    + 虚拟文件系统
    + 文件系统挂载（$mounting$)

### 【知识导图】

### 【复习提示】

+ 本章内容较为具体，要注意对概念的理解.重点掌握文件系统的结构及其实现、文件分配和空闲空间管理等
+ 要掌握文件系统的文件控制块、物理分配方法、索引结构、树形目录结构、文件共享原理、文件系统的布局、虚拟文件系统原理等
+ 这些都是统考真题易考查的内容.

## 文件系统

![1](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309070756602.png)

### 文件系统基础

![image-20230626222700660](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262227751.png)

#### 文件基本概念

+ 文件$File$
    + 文件是以硬盘为载体的存储在计算机上的信息集合，文件可以是文本文档、图片、程序等。

    + 在系统运行时，计算机以进程为基本单位进行资源的调度和分配，而==在用户进行的输入输出中，则以文件为基本单位==。

    + 大多数应用程序的输入都是通过文件来实现的，其输出也都保存在文件中，以便信息的长期存储及将来的访问。

    + 是指由创建者所定义的、具有文件名的一组相关元素的集合，可分为有结构文件和无结构文件两种。
        + 在有结构的文件中，文件由若干个相似的记录组成，如一个班的学生记录

        + 而无结构文件则被视为一个字符流，比如一个二进制文件或字符文件。
    + ==文件系统不仅管理普通文件，对于$UNIX$系统所有设备都被视为特殊文件.==
    
+ 文件系统$File System$
    + 当用户将文件用于程序的输入、输出时，还希望==可以访问、修改和保存文件等，实现对文件的维护管理==
    + 这就需要系统提供一个文件管理系统， 操作系统中的文件系统就是用于实现用户的这些管理要求的。

+ 数据项，是文件系统中最低级的数据组织形式，可分为以下两种类型：
    + 基本数据项，用于描述一个对象的某种属性的一个值，是数据中的最小逻辑单位。 

    + 组合数据项，由多个基本数据项组成。

+ 记录，是一组相关的数据项的集合，用于描述一个对象在某方面的属性
+ ==操作系统以“块”为单位为文件分配存储空间，外存中的数据读入内存同样以块为单位==.

除了文件数据，操作系统还会保存与文件相关的信息，这些附加信息称为文件属性或文件元数据。文件属性在不同系统中差别很大，但通常都包括如下属性：

+ 文件名
    + 由创建文件的用户决定文件名，主要是为了方便用户找到文件
    + 同一目录下不允许有重名文件.
    + 文件名称唯一，以容易读取的形式保存。
+ 标识符
    + 一个系统内的各文件标识符唯一，对用户来说毫无可读性
    + 因此标识符只是操作系统用于区分各个文件的一种内部名称.
+ 类型
    + 指明文件的类型.
    + 被支持不同类型的文件系统所使用。
+ 位置
    + 指向设备和设备上文件的指针
    + 文件存放的路径（让用户使用）
    + 在外存中的地址（操作系统使用，对用户不可见）.
+ 大小
    + 指明文件大小.
    + 文件当前大小（用字节、字或块表示），也可包含文件允许的最大值
+ 创建时间.
    + 用于保护和跟踪文件的使用
+ 上次修改时间.
    + 用于保护和跟踪文件的使用
+ 创建者
    + 文件创建者的ID
+ 文件所有者信息.
    + 文件当前所有者的ID。
+ 保护信息
    + 对文件进行保护的访问控制信息.

操作系统通过文件控制块$FCB$来维护文件元数据

#### 文件组织形式

+ 无结构文件（如文本文件)
    + 由一些二进制或字符流组成，又称“流式文件”
+ 有结构文件（如数据库表）
    + 目录也是一种特殊的有结构文件
    + 由一组相似的记录组成，又称“记录式文件”
    + 记录是一组相关数据项的集合
    + 数据项是文件系统中最基本的数据单位
    + 有结构文件中，各个记录间应该如何组织的问题，顺序存放$OR$索引表
        + 这是后文“文件的逻辑结构”重点要探讨的问题

#### 文件存放在外存的形式

+ 与内存一样，外存也是由一个个存储单元组成的，每个存储单元可以存储一定量的数据（如$1B$).
    + 每个存储单元对应一个物理地址
+ 类似于内存分为一个个“内存块”，外存会分为一个个“块/磁盘块/物理块”
    + 每个磁盘块的大小是相等的，每块一般包含$2$的整数幂个地址
    + 同样类似的是，文件的逻辑地址也可以分为（逻辑块号，块内地址），操作系统同样需要将逻辑地址转换为外存的物理地址（物理块号，块内地址）的形式
    + 块内地址的位数取决于磁盘块的大小
+ 后文“文件的物理结构”重点要探讨的问题
    + 文件数据放在连续的几个磁盘块中
    + 文件数据放在离散的几个磁盘块中

#### 文件控制块$FCB$

![image-20230626231528261](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262315381.png)

+ 文件控制块$FCB$是用来存放控制文件需要的各种信息的数据结构，以实现“按名存取”，==$FCB$的有序集合称为文件目录，一个$FCB$就是一个文件目录项==。

    + $FCB$实现了文件名与文件之间的映射，使得用户（用户程序）可以实现按名存取.

+ 目录本身就是一种有结构文件，由一条条记录组成

    + 每条记录对应一个在该放在该目录下的文件.

        ![image-20230626225353206](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262253274.png)

+ 目录文件中的一条记录就是一个**文件控制块**$FCB$

    + $FCB$的有序集合就是文件目录，一个$FCB$就是一个文件目录项

        ![image-20230626225547911](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262255984.png)

+ $FCB$中包含了

    + 文件的基本信息
        + 文件名、物理地址、逻辑结构、物理结构等

    + 存取控制信息
        + 是否可读/可写、禁止访问的用户名单等
        + 包括文件主的存取权限、核准用户的存取权限以及一般用户的存取权限

    + 使用信息
        + 如文件的建立时间、修改时间等

    + 最重要最基本的就是文件名和文件存放物理地址.

+ 一个文件目录也被视为一个文件，称为目录文件

+ 需要对目录进行的操作

    + 搜索
        + 当用户要使用一个文件时，系统要根据文件名搜索目录，找到该文件对应的目录项

    + 创建文件
        + 创建一个新文件时，需要在其所属的目录中增加一个目录项

    + 删除文件
        + 当删除一个文件时，需要在目录中删除相应的目录项

    + 显示目录
        + 用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性

    + 修改目录
        + 某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项
        + 如：文件重命名


#### 索引结点

+ 其实在查找各级目录的过程中只需要用到“文件名”这个信息，只有文件名匹配时，才需要读出文件的其他信息
    + 因此可以考虑让目录表“瘦身”来提升效率.
    + 将文件名和文件描述信息分开
    + 使文件描述信息单独形成一个称为索引结点的数据结构，简称i结点$inode$
    + 在文件目录中的每个目录项仅由文件名和指向该文件所对应的i结点的指针构成。
    
+ 所以目录只包含文件名与索引结点指针，除了文件名之外的文件描述信息都存放在索引结点之中
    + 索引结点是对$FCB$的改进.
    
    + ==$FCB$必须连续存放==
    
        ![image-20230626231131920](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262311980.png)
    
+ 假设一个$FCB$是$64=2^6B$，磁盘块的大小为$1K=2^{10}B$，则每个盘块中只能存放$2^4=16$个$FCB$
    + 若一个文件目录中共有$640$个目录项，则共需要占用$640\div16=40$个盘块
    + 因此按照某文件名检索该目录，使用折半查找平均需要查询$320$个目录项，平均需要启动磁盘$20$次
        + 每次磁盘$I/O$读入一块

+ 若使用索引结点机制，文件名占$14B$，索引结点指针站$2B$，则每个盘块可存放$64$个目录项，那么按文件名检索目录平均只需要读入$320\div64=5$个磁盘块
    + 显然，这将大大提升文件检索速度.
    + 可使查找文件的平均启动磁盘次数减少到原来的1/4,大大节省了系统开销


+ 当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件.
    + 存放在**外存**中的索引结点称为“磁盘索引结点”
    + 当索引结点放入**内存**后称为“内存索引结点”
    + 相比之下内存索引结点中需要增加一些信息，比如：文件是否被修改、此时有几个进程正在访问该文件等.
+ “磁盘索引结点”：存放在外存中的索引结点，每个文件有一个唯一的磁盘索引结点.
    + 文件主标识符，拥有该文件的个人或小组的标识符
    + 文件类型，包括普通文件、目录文件或特别文件
    + 文件存取权限，各类用户对该文件的存取权限。
    + 文件物理地址，每个索引结点中含有13个地址项，即iaddr(O)〜iaddr(12)，它们以直接或间接方式给出数据文件所在盘块的编号。
    + 文件长度，指以字节为单位的文件长度
    + 文件链接计数，在本文件系统中所有指向该文件的文件名的指针计数
    + 文件存取时间，本文件最近被进程存取的时间、最近被修改的时间及索引结点最近被修改
        的时间
+ “内存索引结点”：存放在内存中的索引结点，当文件被打开时，要将磁盘索引结点复制到内存的索引结点中，便于以后使用。相比之下内存索引结点中需要增加一些信息：
    + 索引结点编号，用于标识内存索引结点
    + 状态，指示i结点是否上锁或被修改
    + 访问计数，每当有一进程要访问此i结点时，计数加1；访问结束减1。
    + 逻辑设备号，文件所属文件系统的逻辑设备号。 
    + 链接指针，设置分别指向空闲链表和散列队列的指针

### 文件操作

文件属于抽象数据类型。为了正确地定义文件，需要考虑可以对文件执行的操作。==操作系统提供系统调用==，它对文件进行创建、写、读、重定位、删除和截断等操作。

![image-20230627214433106](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306272144231.png)

#### 文件基本操作

+ 创建`create`
    + 创建文件有两个必要步骤：
        1.   文件系统为文件找到空间.
        2.   在目录中为新文件创建条目，记录文件名称、位置和其他可能的信息.

+ 写文件`write`：执行一个系统调用，指明文件名和内容
    + 系统通过文件名搜索位置.
    + 系统需要为文件维护一个写位置的指针，当写时就更新写指针.

+ 读文件`read`：执行一个系统调用，指明文件名和位置，系统维护一个读位置的指针，读时就更新读指针，一个进程通常只对一个文件读或写，因此当前操作位置可作为每个进程当前文件位置的指针。
  
    + ==由于读和写操作都使用同一指针，因此节省了空间，也降低了系统复杂度==，需要的参数：
        1.   文件描述符.
        2.   缓冲区首址.
        3.   传输字节数.
    
    >   `read`只需使用`open`返回的文件描述符，并不使用文件名作为参数
    
+ 文件重定位（文件寻址）：按条件搜索目录，将当前文件位置设置为给定值，不读写.

+ 删除`delete`：找到对应目录项，使其为空，并回收该文件所占存储空间.

+ 截断：允许文件所有属性不变，删除文件内容，即设置长度归零并释放空间.

这6个基本操作可以组合起来执行其他文件操作，例如，一个文件的复制，可以创建新文件、 从旧文件读出并写入新文件。

#### 文件打开

+ 开文件操作是将该文件的$FCB$存入内存的活跃文件目录表.
+ 当用户对一个文件实施操作时，每次都要从检索目录开始，为了避免多次重复地检索目录，在很多操作系统中，==在对文件进行操作之前，要求先使用`open`系统调用“打开文件”==，需要提供的几个主要参数：
    1. 文件存放路径.
    2. 文件名.
    3. 要对文件的操作类型（如：$r$只读；$rw$读写等）.
+ 操作系统在处理`open`系统调用：
    1. 将文件名传递给逻辑文件系统.
        +   当所读文件的数据不在内存时，产生中断(缺页中断)，==原进程进入阻塞态==，直到所需数据从外存调入内存后，才将该进程唤醒
    2. 搜索系统打开文件表.
        +   操作系统维护一个包含所有打开文件信息的表（打开文件表）
        +   所谓''打开”，是指调用`open`根据文件名搜索目录，将指明文件的属性（包括该文件在外存上的物理位置），==从外存复制到内存打开文件表的一个表目中， 并将该表目的编号（也称索引）返回给用户==
    3. 如果已打开，则在进程打开文件表种创建新目录指向系统打开文件表对应条目.
        +   当用户再次向系统发出文件操作请求时，可通过索引在打开文件表中查到文件信息，从而节省再次搜索目录的开销
    4. 如果未打开，根据文件名搜索目录结构，并检查该用户是否有指定的操作权限.
        +   部分文件目录会缓存到内存中以加快检索
    5. 找到文件后将目录项$FCB$复制到系统打开文件表（活跃文件目录表）中.
    6. 进程打开文件表中创建一个条目，然后通过指针将系统打开文件表条目和其他域相联.
    7. 返回一个指向进程打开文件表条目的指针，通过指针操作文件.
    8. 打开文件后内核不能通过文件名访问文件，只能通过文件描述符（文件句柄）访问.
+ 打开文件时并不会把文件数据直接读入内存，而是提供索引号
    + “索引号”也称“文件描述符”或“文件句柄”.
+ 在多个不同进程可以同时打开文件的操作系统中，通常采用两级表：整个系统表和每个进程表。
    + 整个==系统==的打开文件表包含==$FCB$的副本及其他信息==。
        + 只有一张，包括编号、文件名、外存地址、打开计数器（多少个进程打开了次文件）等.
    + ==每个进程==的打开文件表==根据它打开的所有文件，包含指向系统表中适当条目的指针==。
        + 包括编号、文件名、读写指针、访问权限、系统表索引号等.
    + ==文件名不必是打开文件表的一部分==，因为一旦完成对$FCB$在磁盘上的定位，系统就不再使用文件名
    + 一旦有进程打开了一个文件，系统表就包含该文件的条目。
    + 当另一个进程执行调用`open`时，只不过是在其文件打开表中增加一个条目，并指向系统表的相应条目。
    + 通常，系统打开文件表为每个文件关联一个**打开计数器**$Open Count$，以记录多少进程打开了该文件。
    + 每个关闭操作`close`使`count`递减，当打开计数器为0时，表示该文件不再被使用，并且可从系统打开文件表中删除相应条目。
    + 图4.3展示了这种结构。

![image-20230907091532363](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309070915440.png)

每个打开文件都有如下关联信息：

+ 文件指针
    + 系统跟踪上次的读写位置作为当前文件位置的指针
    + 这种指针==对打开文件的某个进程来说是唯一的==
    + 因此==必须与磁盘文件属性分开保存==.
+ 文件打开计数
    + 文件关闭时，操作系统必须重用其打开文件表条目
    + 否则表内空间会不够用
    + 因为==多个进程可能打开同一个文件==，所以系统在删除打开文件条目之前必须等待最后一个进程关闭文件
    + 计数器跟踪打开和关闭的数量，计数为$0$时，系统关闭文件，删除该条目.
+ 文件磁盘位置
    + ==绝大多数文件操作都要求系统修改文件数据==
    + 该信息保存在内存中，以免为每个操作都从磁盘中读取.
    + 查找磁盘上的文件所需的信息保存在内存中，以便系统不必为每个操作都从磁盘上读取该信息
+ 访问权限
    + 每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等）
    + 该信息保存在进程的打开文件表中，以便操作系统能够允许或拒绝之后的$I/O$请求.

#### 文件关闭

+ 用户使用`close`系统调用“打开文件”，需要提供的几个主要参数：
    1. 文件存放路径.
    2. 文件名.
+ 操作系统在处理`close`系统调用时，主要做了几件事：
    1. 将进程的打开文件表相应表项删除.
    2. 回收分配给该文件的内存空间等资源.
    3. 系统打开文件表的打开计数器$count$减$1$，若$count=0$，则删除对应表项.

### 文件保护

![image-20230627215911899](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306272159955.png)

口令保护和加密保护是为了防止用户文件被他人存取，而访问控制用于控制用户对文件的访问方式

注意两个问题：

1.   现代操作系统常用的文件保护方法是，将访问控制列表与用户、组和其他成员访问控制方案一起组合使用。
2.   对于多级目录结构而言，不仅需要保护单个文件，而且需要保护子目录内的文件，即需要提供目录保护机制。目录操作与文件操作并不相同，因此需要不同的保护机制。

#### 访问类型

对文件的保护可从限制对文件的访问类型中出发。可加以控制的访问类型主要有以下几种

+   读。从文件中读。

+   写。向文件中写。
+   执行。将文件装入内存并执行。.
+   添加。将新信息添加到文件结尾部分。 
+   删除。删除文件，释放空间。
+   列表清单。列出文件名和文件属性

此外还可以对文件的重命名、复制、编辑等加以控制。这些==高层的功能可以通过系统程序调用低层系统调用来实现==。==保护可以只在低层提供==。例如，复制文件可利用一系列的读请求来完成,这样，具有读访问权限的用户同时也就具有了复制和打印权限。

#### 口令保护

+ 为文件设置一个“口令”，用户请求访问该文件时必须提供“口令”.
+ 口令指用户在建立一个文件时提供一个口令，系统为其建立FCB时附上相应口令，同时告诉允许共享该文件的其他用户，用户请求访问时必须提供相应的口令
+ 口令一般存放在文件对应的$FCB$或索引结点中，用户访问文件前需要先输入“口令”，操作系统会将用户提供的口令与$FCB$中存储的口令进行对比，如果正确，则允许该用户访问文件.
+ 优点：保存口令的空间开销不多，验证口令的时间开销也很小.
+ 缺点：正确的“口令”存放在系统内部，不够安全.

#### 加密保护

+ 使用某个“密码”对文件进行加密，在访问文件时需要提供正确的“密码”才能对文件进行正确的解密.
+ 系统并不保存原始数据，而是加密过的数据.
+ 加密方式有异或加密等.
+ 优点：保密性强，不需要在系统中存储“密码”.
+ 缺点：编码/译码，或者说加密/解密要花费一定时间.

#### 访问控制

+ 在每个文件的$FCB$（或索引结点）中增加一个访问控制列表$ACL$（$AccessControl\;List$），该表中记录了各个用户可以对该文件执行哪些操作.
+ 访问类型包括：
    + 读：从文件中读数据.
    + 写：向文件中写数据.
    + 执行：将文件装入内存并执行.
    + 添加：将新信息添加到文件结尾部.
    + 删除：删除文件，释放空间.
    + 列表清单：列出文件名和文件属性.
+ 优点：可以使用复杂的访问方法.
    + ==访问控制的级别和保护力度较小==， 因此它的==灵活性相对较高==

+ 缺点：长度无法余集且可能导致复杂的空间管理.
+ 有的计算机可能会有很多个用户，因此访问控制列表可能会很大，可以用精简的访问列表解决这个问题.
+ 精简的访问列表
    + 以“组”为单位，标记各“组”用户可以对文件执行哪些操作
    + 当某用户想要访问文件时，系统会检查该用户所属的分组是否有相应的访问权限
    + 所以系统也需要管理分组的信息.

+ 用户类型：
    + 拥有者：创建文件用户.
    + 组：一组需要共享文件且拥有类似访问的用户.
    + 其他：系统内其他所有用户.
+ 若想要让某个用户能够获取某种权限，需要把该用户放入有该权限的分组即可.
+ 如果对某个目录进行了访问权限的控制，那也要对目录下的所有文件进行相同的访问权限控制.

#### Linux文件权限

+   命令格式`chmod 权限 文件名`.

+   一共九位，从左至右分为三组，$1-3$位数字代表文件所有者的权限，$4-6$位数字代表同组用户的权限，$7-9$数字代表其他用户的权限.每一组的第一位表示可读，第二位表示可写，第三位表示可执行.
    +   如$755$，第一组的$7=4+2+1$表示所有者可读可写可执行，$5=4+0+1$表示同组用户和其他用户可读可执行但是不可写.
+   对于任意文件系统，若用户类别有$n$种，访问权限有$m$中，则需要描述文件权限的位数至少为$nm$位

### 文件逻辑结构

![image-20230626225052485](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262250534.png)

+ 所谓的“逻辑结构”，就是指在用户看来，文件内部的数据应该是如何组织起来的
    + 而“物理结构”指的是在操作系统看来，文件的数据是如何存放在外存中的.

+ 类似于数据结构的“逻辑结构”和“物理结构”.
    + 如“线性表”就是一种逻辑结构，在用户角度看来，线性表就是一组有先后关系的元素序列，
    + 而“线性表”这种逻辑结构可以用不同的物理结构实现
        + 如：顺序表/链表.顺序表的各个元素在逻辑上相邻，在物理上也相邻
        + 而链表的各个元素在物理上可以是不相邻的
        + 因此，顺序表可以实现“随机访问”，而“链表”无法实现随机访问.
+ 可见，算法的具体实现与逻辑结构、物理结构都有关
    + 文件也一样，文件操作的具体实现与文件的逻辑结构、物理结构都有关

#### 文件分类及逻辑结构

分为无结构文件与有结构文件.

+ 无结构文件/流式文件：
    + 无结构文件是最简单的文件组织形式，无结构文件将数据按顺序组织成记录并积累、保存， 它是有序相关信息项的集合
    + 以字节$Byte$为单位.
    + 由于无结构文件没有结构，只能通过穷举进行搜索
        + 因此这种文件形式对大多数应用不适用
    + 管理简单，适用于字符流的无结构方式
        + 所以，那些==对基本信息单位操作不多的文件较适于采用字符流的无结构方式==
        + 如源程序文件、目标代码文件等。
    + 例如$Windows$操作系统中的`. txt` 文件
+ 有结构文件/记录式文件
    + 由一组相似的记录组成
        + 每条记录又若干个数据项组成，数据项又包含多个属性，是文件系统中最基本的数据单位
    + 每条记录有一个数据项可作为关键字（如$ID$）.
    + 可以根据各条记录的长度（占用的存储空间）是否相等，可分为**定长记录**和可变长记录两种.
    + ![image-20230626223426807](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262234877.png)


有结构文件的逻辑结构：

+ 顺序文件.
+ 索引文件.
+ 索引顺序文件.
+ 散列文件.

#### 顺序文件

文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的，各个记录在物理上可以顺序存储或链式存储.

根据关键字与顺序之间的关系：

+ 串结构(链式存储)
    + 记录之间的顺序与关键字无关
    
    + 按存入时间的先后进行排列

    + 对串结构文件进行检索必须从头开始顺序依次查找，比较费时
    
        + 无论是定长/可变长记录，都无法实现随机存取，每次只能从第一记录开始依次往后查找
    
        ![image-20230626223518827](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262235869.png)
    
+ 顺序结构(顺序存储)
    + 记录之间的顺序按关键字顺序排列.
    
        ![image-20230626223510675](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262235713.png)
    
    + 可变长记录
    
        + **无法实现随机存取**
    
        + 要查找第$i$条记录，必须顺序地查找前$i-1$条记录，从而获得相应记录的长度$L$，进而按下式计算出第$i$条记录的首址：
            $$
            A_{i}=\sum_{i=0}^{i-1} L_{i}+1
            $$
    
        + 每次只能从第一个记录开始依次往后查找.因为需要显式地给出记录长度
    
            ![image-20230626223751118](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262237163.png)
    
    + 定长记录：
    
        + **可实现随机存取**，记录长度为$L$，则第$i$个记录存放的相对位置是$A_i=i\times L$.
    
        + 若采用串结构，只能从头开始查找，无法快速找到某关键字对应的记录.
    
        + 若采用顺序结构，可以快速找到某关键字对应的记录（如折半查找）
    
            ![image-20230626223851744](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262238793.png)
    
        + **【注意】：**
    
            + ==一般来说，考研题目中所说的“顺序文件”指的是**物理上顺序存储的顺序文件**==

+ 在对记录进行批量操作，即每次要读或写一大批记录时，顺序文件的效率是所有逻辑文件中最高的
    + ==读写效率高==
+ 对于==顺序存储设备（如磁带），也只有顺序文件才能被存储并能有效地工作==
+ 缺点是**增加/删除一个记录比较困难**，如果是串结构则相对简单一点
    + ==增删改较困难==
+ 顺序文件插入删除文件比较麻烦
    + 一般实际实现时会隔一个时间段集中将修改写入到文件中.

#### 索引文件

+ 变长记录文件只能顺序查找，效率较低，可以建立一张索引表存放主文件的每个记录的表项，以加快文件检索速度
    + 每条记录对应一个索引项.
    + 索引表包含索引号，长度，指针三个部分
        + 索引表本身是定长长度的顺序文件，所以可以快速找到索引，通过指针随机访问.
    
    +   索引表其实是索引顺序结构的.
    
    ![image-20230626224218240](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262242286.png)
    
+ ==记录可以离散存放，而索引表必须连续存放.==

+ 可将关键字作为索引号内容，若按关键字顺序排列，则还可以支持按照关键字折半查找.

+ 每当要增加/删除一个记录时，需要对索引表进行修改.

+ ==由于索引文件有很快的检索速度，因此主要用于对信息处理的及时性要求比较高的场合.==

+ 可以使用不同的数据项对一组数据建立多个索引表.

#### 索引顺序文件

类似于字典.

+ 因为每个记录对应一个索引表项，因此索引表可能会很大
    + 同时若数据长度本身远小于索引表项长度，则空间利用率会很低.

+ 索引顺序文件是索引文件和顺序文件思想的结合
    + 索引顺序文件中，同样会为文件建立一张索引表，但不同的是并不是每个记录对应一个索引表项，而是一组记录对应一个索引表项
    + 在索引表中为每组中的第一条记录建立一个索引项，其中含有该记录的关键字值和指向该记录的指针
    + 每个分组就是一个顺序文件（==组间有序==），分组内的记录不需要按关键字排序（==组内无序==）.
    + 查找一条记录时，首先通过索引表找到其所在的组，然后在该组中使用顺序查找，就能很快地找到记录。
    + ![image-20230626224506881](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262245941.png)
    
+ 索引项页不需要按关键字顺序排列，从而能便利插入删除.

+ ==索引顺序文件的索引表其实是**定长记录**的**串结构**的**顺序文件**.==

+ 索引文件和索引顺序文件都提高了存取的速度，但因为配置索引表而增加了存储空间。

+ 对于$N$条记录的顺序文件

    + 折半查找查找关键字记录平均需要$N/2$次
    + 在索引顺序文件中，将其分为$\sqrt{N}$组，每组$\sqrt{N}$条记录
    + 所以索引表查找需要$\dfrac{\sqrt{N}}{2}$次，主文件顺序查找也需要$\dfrac{\sqrt{N}}{2}$次
    + 所以一共需要查找$\sqrt{N}$次.

+ 检索效率分析
  
    ![image-20230626224935856](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262249900.png)
    
+ 为了进一步提高索引效率，可以建立多级索引表.
  
    ![image-20230626225030820](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262250876.png)

#### 散列文件/直接文件

+   给定记录的键值或通过散列函数转换的键值直接决定记录的物理地址。

+   这种映射结构不同于顺序文件或索引文件，==没有顺序的特性==。 

+   ==散列文件有很高的存取速度，但是会引起冲==突，即不同关键字的散列函数值相同。 

    +   >   复习了数据结构的读者读到这里时，会有这样的感觉：有结构文件逻辑上的组织，是为在文件中查找数据服务的（顺序查找、索引查找、索引顺序查找、哈希查找）。 

### 文件物理结构

![image-20230627000929742](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306270009818.png)

![image-20230626231857349](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262318396.png)

+ 文件物理结构即文件分配方式，是对非空间磁盘块的管理.
    + 连续分配
    + 链接分配
        + 隐式链接
        + 显式链接
    + 索引分配
+ 有的系统（如RDOS操作系统）对三种方法都支持，但==更普遍的是一个系统只支持一种方法==
+ 文件物理结构即文件数据应该怎样存放在外存中

#### 文件块与磁盘块

+ 类似于内存分页，磁盘中的存储单元也会被分为一个个“块/磁盘块/物理块”
    + ==很多操作系统中，磁盘块的大小与内存块、内存页面的大小相同==.
        + 便于数据交换

+ 内存与磁盘之间的数据交换（即读/写操作、磁盘$I/O$)都是以“块”为单位进行的
    + 即每次读入一块，或每次写出一块.

+ 在内存管理中，进程的逻辑地址空间被分为一个一个页面
    + 同样的，在外存管理中，为了方便对文件数据的管理，文件的逻辑地址空间也被分为了一个一个的文件“块”
    + 于是文件的逻辑地址也可以表示为（逻辑块号，块内地址）的形式.

+ 用户通过逻辑地址来操作自己的文件，操作系统要负责实现从逻辑地址到物理地址的映射，即文件的物理结构或文件分配方式.
    + 文件分配方式/文件的物理结构的核心问题
        + 怎么把文件逻辑块号映射为物理块号


#### 记录成组分解技术

+ 由于磁盘块的大小是预先划分好的，大小固定
+ 而逻辑记录的大小是用户文件性质决定的，不一定和块大小一致
+ 如果逻辑记录比物理块小得多时，可以==把多个逻辑记录存放在一个块中，这就是记录的成组==，
+ 用户==使用时再把读取的一块信息中分离出所需的记录，这就是记录的分解==.

#### 连续分配

+ 连续分配方式要求每个文件在磁盘上占有一组连续的块.

+ （逻辑块号，块内地址）→（物理块号，块内地址）
    + 只需转换块号就行，块内地址保持不变.

+ 文件目录中记录存放的起始块号和长度（总共占用几个块）.

    ![image-20230626232531792](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262325846.png)

+ 用户给出要访问的逻辑块号，操作系统找到该文件对应的目录项$FCB$
    + 物理块号=起始块号＋逻辑块号.

+ 优点：
    + 可以直接算出逻辑块号对应的物理块号，因此连续分配支持顺序访问和直接访问
        + 直接访问=随机访问
    + 连续分配的文件在顺序读写时速度最快，==作业访问磁盘时需要的寻道数和寻道时间最小==
        + 读取某个磁盘块时，需要移动磁头，访问的两个磁盘块相隔越远，移动磁头所需时间就越长.
        + 连续分配的文件相邻，磁头移动距离最短
    
+ 缺点：
    + 文件长度不宜动态增加，因为一个文件末尾后的盘块可能已分配给其他文件，一旦需要增加，就需要大量移动盘块。
      
        + 不利于拓展
        
        ![image-20230626232837902](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262328956.png)
        
    + 存储空间利用率低，产生难以利用的**磁盘碎片**
        + 可以利用紧凑处理碎片，但是需要耗费巨大的时间代价
    
            ![image-20230626232905051](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262329103.png)
    
    + 为保持文件的有序性，删除和插入记录时，需要对相邻的记录做物理上的移动，还会动态改变文件的长度
    
    + 很难确定一个文件需要的空间大小，因而==只适用于长度固定的文件==

#### 链接分配

+ 采取离散分配的方式，可以为文件分配离散的磁盘块
    + 消除了磁盘的外部碎片，提高了磁盘的利用率
    + 可以动态地为文件分配盘块，因此==无须事先知道文件的大小==
    + 对文件的插入、删除和修改也非常方便
    + 分为隐式链接和显式链接两种.
    + 考试题目中遇到未指明隐式/显式的“链接分配”，默认指的是隐式链接的链接分配
    
+ 隐式链接：
  
    + 类似链表.
    
    + $FCB$目录中记录了文件存放的起始块号和结束块号，当然也可以增加一个字段来表示文件的长度.
    + 除了文件的最后的磁盘块之外，每个磁盘块中都会保存指向下一个盘块的指针，==这些指针对用户是透明的.==
    
    ![image-20230626233036804](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262330872.png)
    
    + 读入$i$号逻辑块，总共需要$i+1$次磁盘$I/O$操作
        + 从目录项中找到起始块号（即$0$号块）
        + 将$0$号逻辑块读入内存，由此知道$1$号逻辑块存放的物理块号
        + 于是读入$1$号逻辑块，再找到$2$号逻辑块的存放位置
        + 以此类推.
        + 即分别读取$i$次物理块加上读取目录项的一次
    + 优点：
        + 方便文件拓展.
            + 若需要拓展文件，则可以随便找一个空闲磁盘块，挂到文件的磁盘块链尾，并修改文件的$FCB$
        + 不会有硬盘碎片.
    + 缺点：
        + 只支持顺序访问，不支持随机访问，查找效率低.
            + 若要访问文件的第$i$个盘块，则只能从第$1$个盘块开始通过盘块指针顺序查找到第$i$块
        + 指向下一个盘块的指针也需要耗费少量的存储空间.
        + 存储稳定性不足，若是中间毁坏后面的数据也会丢失.
            + 系统在运行过程中由于软件或硬件错误导致链表中的指针丢失或损坏，会导致文件数据的丢失
    + 解决方案
        + 将几个盘块组成簇$cluster$，按簇而不按块来分配，可以成倍地减少查找时间。
            + 比如一簇为4块，这样指针所占的磁盘空间比例也要小得多。
            + 这种方法的代价是增加了内部碎片。
            + 簇可以改善许多算法的磁盘访问时间，因此==应用于大多数操作系统==
    
+ 显式链接：

    + 类似静态链表.
    + 把用于链接文件各物理块的指针，从每个物理块的末尾中提取出来，显式地存放在内存的一张链接表中即**文件分配表**$FAT$（$File\;Allocation\;Table$）
        + $FCB$目录中只需记录文件的起始块号，后续的盘块可通过查FAT找到
        + $FAT$包含物理块号和下一块指针两项.
        + ==$FAT$的各个表项在物理上连续存储==，且每一个表项长度相同，==因此“物理块号”字段可以是隐含的==.
    + 一个**磁盘**仅设置一张$FAT$，开机时，将$FAT$读入内存，并==常驻内存==，所以==地址转换不需要读取内存，从而效率更高==，而且==明显减少了访问磁盘的次数==

    ![image-20230626233424662](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262334718.png)

    

    + 地址转换
        + 目录项中找到起始块号，若$i>0$，则查询内存中的文件分配表$FAT$，往后找到$i$号逻辑块对应的物理块号
        + 逻辑块号转换成物理块号的过程不需要**读磁盘**操作.
    + 优点：
        + 很方便文件拓展.
        + ==不会有外部碎片问题==，外存利用率高.
        + ==支持顺序访问也支持随机访问==.
            + 访问$i$号数据块时并不需要访问之前的$0\sim i-1$号数据块
        + 相比于隐式链接来说，==地址转换时不需要访问磁盘==，因此文件的访问效率更高.
    + 缺点：文件分配表的需要占用一定的存储空间.

#### 索引分配

![image-20230627000724673](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306270007740.png)

+ 允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表
  
    ![image-20230626235343848](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262353904.png)
    
    + 索引表中记录了文件的各个逻辑块对应的物理块
        + 索引表的功能类似于内存管理中的页表
            + 建立逻辑页面到物理页之间的映射关系
    
    + 索引表存放的磁盘块称为索引块，文件数据存放的磁盘块称为数据块.
    
+ 索引表包含逻辑块号和物理块号两项
    + 逻辑块号可以是隐含的.

+ 每一个文件都有一个索引表.
+ 地址转换
    + 从目录项中可知索引表存放位置，将索引表从外存读入内存，并查找索引表即可只$i$号逻辑块在外存中的存放位置.

+ 优点：
    + 很方便文件拓展，不会有碎片问题，外存利用率高.
    + 支持随机访问.
+ 缺点
    + 文件索引表的需要占用一定的存储空间.


索引块必须不能太大，但是索引块太小就无法支持大文件，解决方案：

+ 链接方案：
    + 一个索引块通常为一个磁盘块，因此它本身能直接读写。
    + 为了支持大文件，可以将分配多个索引块并链接起来.
    + 文件$FCB$中只需要记录第一个索引块的块号.
    + 缺点：查找效率低.
    
+ 多层索引：
    + 建立类似多级页表的多层索引，使上层索引块指向下一层的索引块.
    + ==$FCB$中只需要记录顶层索引块即可==
    + 若采用多层索引，则各层索引表大小不能超过一个磁盘块.理由同多级页表.
    + 采用$K$层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要$K+1$次读磁盘操作.
    + 缺点：即使是小文件页需要$K+1$次读磁盘操作.
    
+ 混合索引：
    + 多种索引分配方式的结合
        + 一个文件的顶级索引表中
        + 直接地址索引（直接指向数据块）
            + 为了提高对文件的检索速度，在索引结点中可设置若干个直接地址项
            + 直接存放存放直接地址，即文件数据盘块的盘块号。
            + 假如每个盘块的大小为4KB,当文件不大于40KB时，便可直接从索引结点中读出该文件的全部盘块号。
        + 一级间接索引（指向单层索引表）
            + 对于中、大型文件，只采用直接地址并不现实的。
            + 为此，可再利用索引结点中的一个地址项来提供一次间接地址指向单层索引表。
            + 图中的一次间址块也就是索引块，系统将分配给文件的多个盘块号记入其中。
            + 在一次间址块中可存放1024个盘块号，因而允许文件长达4MB。
        + 两级间接索引（指向两层索引表）
            + 当文件长度大于4MB + 40KB (一次间接地址与10个直接地址项)时， 系统还需采用二次间接地址分配方式。
            + 这时，用一个地址项提供二次间接地址指向两层索引表
            + 系统此时在二次间址块中记入所有一次间址块的盘号。 
            + 地址项i.addr(ll)作为二次间址块，允许文件最大长度可达4GB。
            + 同理，地址项iaddr(12)作为三次间址块，其允许的文件最大长度可达4TB。
        
        ![image-20230627000523511](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306270005569.png)
        
    + 优点：对于小文件，只需较少的读磁盘次数就可以访问目标数据块.
        + 一般计算机中小文件更多
    
    +   如一共十三个地址项，前十个为直接地址，后面三个为一级间址、二级间址、三级间址
    
        +   每个盘块的大小为$4KB$，索引块大小为$4B$.
    
        +   所以文件不大于$4\times10=40KB$时可以直接读出
        +   一个一级间址块中能包含$4KB\div4B=1K=2^{10}$个索引，所以能索引出$2^{10}\times4KB=4MB$的空间
        +   同理，若文件长度大于$4MB+40KB$时可以使用二级间址块，索引出$4GB$的空间，三级间址能索引出$4TB$的空间.

---

|  &nbsp;  |   访问第n条记录    |                             优点                             |                             缺点                             |
| :------: | :----------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 连续分配 |   需访问磁盘1次    | ==顺序存取时速度最快==，文件定长时可根据文件起始地址及记录长度==进行随机访问== | 文件存储要求连续的存储空间，==会产生碎片，不利于文件的动态扩充== |
| 链接分配 |   需访问磁盘n次    | ==可解决外存的碎片问题==，提高外存空问的利用率，==动态增长较方便== | 只能按照文件的指针链顺序访问，==查找效率低==，指针信息存放消耗外存空间 |
| 索引分配 | m级需访问磁盘m+1次 |                ==可以随机访问==，文件易于增删                | 索引表增加存储空间的开销，索引表的查找策略对文件系统效率影响较大 |

### 逻辑结构$V.S.$物理结构

![image-20230627190938735](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306271909790.png)

+ 对于一个无结构文件
    + 文件内容为
        + `Hello world!Hello world!Hello world!Hello world!...`
        
    + 逻辑结构：从用户视角看
        + 每个占用字符$1B$，在用户看来，整个文件占用一片连续的逻辑地址空间
        
        + 只需要提供字符在文件中的逻辑地址就可以取到字符
        
            ![image-20230627184535855](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306271845930.png)
        
    + 物理结构：从操作系统视角看
        + 操作系统以每个物理块为$1KB$的大小将文件拆分为若干个物理块
            + 逻辑块号相邻
            
        + 然后采用某种策略决定分配方式
        
            ![image-20230627184951798](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306271849879.png)
    
+ **【例】：$C$语言创建顺序文件**
    + 逻辑地址
      
        ![image-20230627185442548](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306271854602.png)
        
        + 如果想读出第五个学生的信息
        
            <img src="https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309071249333.png" alt="23September07-124915-1694062155-75ab184f-16da-4dc0-9645-b225e29d8755" style="zoom:150%;" />
        
    + 物理结构
        + 说白了就是操作系统的存储方式
    
+ 存储方式对比
    + 逻辑结构:用户自己设计，调用时使用相应的调用方式调用
        + 链式存储:顺序文件
        + 顺序存储:顺序文件
        + 索引表存储:索引文件
            + 索引文件的索引表是用户自己建立的
            + 映射为关键字$\to$记录存放的逻辑地址
        + 索引顺序存储:索引顺序文件
        + 散列存储(哈希存储):散列文件
    + 物理结构
        + 连续分配
        + 链式分配
        + 索引分配
            + 索引分配的索引表是由操作系统建立的
            + 映射为逻辑块号$\to$物理块号

### 文件共享

![image-20230627215359461](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306272153524.png)

+ 操作系统为用户提供文件共享功能，可以让多个用户共享地使用同一个文件
+ **【注意】：**
    + 多个用户共享同一个文件，意味着系统中只有“一份”文件数据
    + 并且只要某个用户修改了该文件的数据，其他用户也可以看到文件数据的变化
    + 如果是多个用户都“复制”了同一个文件，那么系统中会有“好几份”文件数据
    + 其中一个用户修改了自己的那份文件数据，对其他用户的文件数据并没有影响

#### 基于索引结点的共享方式（硬链接）

+ 索引结点，是一种文件目录瘦身策略
    + 由于检索文件时只需用到文件名，因此可以将除了文件名之外的其他信息放到索引结点中。这样目录项就只需要包含文件名、索引结点指针。
+ 索引结点中设置一个链接计数变量`cout`，用于表示链接到本索引结点上的用户目录项数。
    + 若`cout=2`，说明此时有两个用户目录项链接到该索引结点上，或者说是有两个用户在共享此文件。
    + 若某个用户决定“删除”该文件，则只是要把用户目录中与该文件对应的目录项删除，且索引结点的`count`值减$1$
    + 若`cout>0`，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空。
    + 当`cout=0`时系统负责删除文件

#### 基于符号链的共享方式（软链接）

+ 软链接是通过创建一个指向目标文件或目录的`Link`类型的特殊文件来实现的
    + 相当于$Windows$中的快捷方式
+ 这个特殊文件包含了指向目标文件或目录的路径信息
+ 当用户访问软链接时，操作系统会自动跟随链接，并将用户的访问请求重定向到链接指向的目标文件或目录。
+ 软链接的特点如下：
    1. 软链接是一个独立的文件实体，它有自己的文件名和属性，但实际内容是指向目标文件或目录的路径。
    2. 软链接可以跨越不同的文件系统，即可以链接到不同磁盘分区或挂载点上的文件。
    3. 软链接可以指向文件或目录，因此可以用于创建对目录的链接。
    4. 软链接的创建和删除对目标文件或目录没有影响，删除软链接不会删除目标文件或目录。
    5. 软链接可以相互引用，也可以形成循环链接，但需要注意避免链接的循环依赖。

## 目录系统

![image-20230907111247269](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309071112596.png)

### 目录的基本概念

+   $FCB$的有序集合称为文件目录，==一个$FCB$就是一个文件目录项==。
    +   与文件管理系统和文件集合相关联的是文件目录，它包含有关文件的属性、位置和所有权等。 
+   首先来看目录管理的基本要求：
    +   从用户的角度看，目录在用户(应用程序)所需要的文件名和文件之间提供一种映射，所以==目录管理要实现"按名存取”==
        +   实现用户对文件的按名存取，系统先利用用户提供的文件名形成检索路径，对目录进行检索。 
        +   ==在顺序检索中，路径名的一个分量未找到，说明路径名中的某个目录或文件不存在，不需要继续检索==
    +   目录存取的效率直接影响到系统的性能，所以要==提高对目录的检索速度==
    +   在多用户系统中，应允许多个用户共享一个文件，因此==目录还需要提供用于控制访问文件的信息==。
    +   此外，==应允许不同用户对不同文件采用相同的名字==， 以便于用户按自己的习惯给文件命名，==目录管理通过树形结构来解决和实现==。

### 目录结构

#### 单级目录结构

![image-20230907222734786](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309072227919.png)

+ 当访问一个文件时，先按文件名在该目录中查找到相应的$FCB$，经合法性检查后执行相应的操作。
    + 当建立一个新文件时，必须先检索所有目录项，以确保没有“重名”的情况，
    + 然后在该目录中增设一项，把新文件的属性信息填入到该项中。
    + 当删除一个文件时，先从该目录中找到该文件的目录项，回收该文件所占用的存储空间，然后清除该目录项
    
+ 早期操作系统并不支持多级目录，==整个系统中只建立一张目录表==，每个文件占一个目录项.
    + ==实现了“按名存取”==，但是==不允许文件重名==.
        + 在创建一个文件时，需要先检查目录表中有没有重名文件，确定不重名后才能允许建立文件，并将新文件对应的目录项插入目录表中.
    + ==查找速度慢==
    + ==不便于文件共享==
    + 不适用于多用户操作系统.

#### 两级目录结构

![image-20230907222939779](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309072229869.png)

分为主文件目录$MFD$（$Master\;File\;Directory$）和用户文件目录$UFD$（$User\;Flie\;Directory$）：

+ 主文件目录$MFD$中每项记录用户名及相应用户文件目录所在的存储位置.
+ 用户文件目录$UFD$中每项由该用户的文件$FCB$组成.
    + 当某用户欲对其文件进行访问时，只需搜索该用户对应的$UFD$，这既解决了不同用户文件的“重名”问题，又在一定程度上保证了文件的安全

+ ==允许不同用户的文件重名==，文件名虽然相同，但是对应的其实是不同的文件.
+ 两级目录结构允许不同用户的文件重名，也可以在目录上实现实现访问限制
    + 检查此时登录的用户名是否匹配
+ 两级目录结构依然缺乏灵活性，用户不能对自己的文件进行分类.

#### 多级目录结构/树形目录结构

![image-20230907223208764](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309072232842.png)

+ 不同目录下的文件可以重名.
+ ==可以明显地提高对目录的检索速度和文件系统的性能==
+ 用户（或用户进程）要访问某个文件时要用文件路径名标识文件，文件路径名是个字符串，各级目录之间用`/`隔开.
+ 从根目录出发的路径称为**绝对路径**.
+ 每次都从根目录开始查找，是很低效的，因此可以设置一个“当前目录”出发的**相对路径**.
    + 相对路径由从当前目录出发到所找文件通路上所有目录名与数据文件名用分隔符`/`链接而成
    + `.`号表示当前工作目录

+ 树形目录结构可以很方便地对文件进行分类，层次结构清晰，也能够==更有效地进行文件的管理和保护.==
+ 但是，树形结构==不便于实现文件的共享==，且查找文件需要逐级访问影响速度，==磁盘访问次数较多，会影响查询速度==
    + 为此，提出了“无环图目录结构”.

#### 无环图目录结构

+ 在树形目录结构的基础上，增加一些指向同一节点的有向边，使整个目录成为一个有向无环图
    + 可以更方便地实现多个用户间的文件共享.
    +   ![image-20230626230932887](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262309958.png)
+ 可以用不同的文件名指向同一个文件，甚至可以指向同一个目录（共享同一目录下的所有内容）.
+ 需要为每个共享结点设置一个共享计数器，用于记录此时有多少个地方在共享该结点
    + 用户提出删除结点的请求时，只是删除该用户的$FCB$、并使共享计数器减$1$，并不会直接删除共享结点.
    + 当且仅当共享计数器计数为$0$时才真正删除节点

+ 共享文件不同于复制文件，在共享文件中，由于各用户==指向的是同一个文件==，因此==只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化==
    + 对于共享文件，只存在一个真正的文件，任何改变都会为其他用户所见

+ 无环图目录结构方便地实现了文件的共享，但使得系统的管理变得更加复杂

### 目录操作

#### 目录基本操作

+ 搜索。当用户使用一个文件时，需要搜索目录，以找到该文件的对应目录项。 
+ 创建文件。当创建一个新文件时，需要在目录中增加一个目录项。
+ 删除文件。当删除一个文件时，需要在目录中删除相应的目录项。 
+ 创建目录。在树形目录结构中，用户可创建自己的用户文件目录，并可再创建子目录。 
+ 删除目录。有两种方式：
    1.   不删除非空目录，删除时要先删除目录中的所有文件，并递归地删除子目录。
    2.   可删除非空目录，目录中的文件和子目录同时被删除。 
+ 移动目录。将文件或子目录在不同的父目录之间移动，文件的路径名也会随之改变。
+ 显示目录。用户可以请求显示目录的内容，如显示该用户目录中的所有文件及属性。
+ 修改目录。某些文件属性保存在目录中，因而这些属性的变化需要改变相应的目录项

#### 目录实现*

+ 线性列表.
    + 当创建新文件时，必须首先搜索目录以确定没有同名的文件存在，然后在目录中增加一个新的目录项。
    + 当删除文件时，则根据给定的文件名搜索目录，然后释放分配给它的空间。
    + 当要重用目录项时有许多种方法：
        + 可以将目录项标记为不再使用
        + 或将它加到空闲目录项的列表上
        + 还可以将目录的最后一个目录项复制到空闲位置，并减少目录的长度。

    + 采用链表结构可以减少删除文件的时间。 
    + ==线性列表的优点在于实现简单，不过由于线性表的特殊性，查找比较费时==

+ 哈希表.
    + 除了采用线性列表存储文件目录项，还可以采用哈希数据结构。
    + 哈希表根据文件名得到一个值，并返回一个指向线性列表中元素的指针。
    + 这种方法的==优点是查找非常迅速，插入和删除也较简单，不过需要一些措施来避免冲突==（两个文件名称哈希到同一位置）。
    + 目录查询是通过在磁盘上反复搜索完成的，==需要不断地进行I/O操作，开销较大==。
    + 所以如前所述，为==了减少I/O操作，把当前使用的文件目录复制到内存==，以后要使用该文件时只需在内存中操作，因此降低了磁盘操作次数，提高了系统速度。


### 文件目录共享

多个用户共享同一个文件或目录，意味着系统中只有“一份”文件数据，并且只要某个用户修改了该文件的数据，其他用户也可以看到文件数据的变化.

文件共享方式分为：

+ 基于索引结点的共享方式：硬链接.
    + 硬链接就是多个指针指向一个索引结点，保证只要还有一个指针指向索引结点，索引结点就不能删除

+ 基于符号链的共享方式：软链接.
    + 软链接就是把到达共享文件的路径记录下来，当要访问文件时，根据路径寻找文件


索引结点中设置一个链接计数变量`count`，用于表示链接到本索引结点上的用户目录项数.

硬链接和软链接都是静态共享方式，都存在一个共同的问题，每个共享文件都有几个文件名，从而每增加一条文件名，当遍历整个文件系统时会多次遍历到该共享文件.

多个进程同时对同一个文件操作称为**动态共享**.

==硬链接的查找速度要比软链接的快==

硬链接和软链接均可适用于文件和目录

#### 硬链接

+ 在文件目录中提到，索引结点，是一种文件目录瘦身策略，由于检索文件时只需用到文件名，因此可以将除了文件名之外的其他信息放到索引结点中，这样目录项就只需要包含文件名、索引结点指针.
    + 在这种共享方式中，诸如文件的物理地址及其他的文件属性等信息，不再放在目录项中，而放在索引结点中
+ ==硬链接指通过索引结点进行链接==
    + 一个文件在物理存储器上有一个索引结点号
    + 存在多个文件名指向同一个索引结点的情况
+ 不同目录下对于同一个文件的索引结点的命名可以是不同的.
+ 源文件和硬链接的两个进程各自维护自己的文件描述符
    + ==读写指针位置不一定相同==
+ 在文件目录中只设置文件名及指向相应索引结点的指针。
    + 在索引结点中还应有一个链接计数`count`，用于表示链接到本索引结点（即文件）上的用户目录项的数目。
    + 当`count = 2`时，表示有两个用户目录项链接到本文件上，或者说有两个用户共享此文件。

![image-20230907224017238](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309072240321.png)

创建硬链接时：

+ 创建硬链接时$count+1$.

删除文件时：

+ 若`count > 0`，说明还有别的用户要使用该文件，暂时==不能把文件数据删除==，否则会导致指针悬空.
    + 只是要把用户目录中与==该文件对应的目录项删除==，且索引结点的`count`值减$1$.
+ 若`count = 0`，则系统需要删除文件.

#### 软链接

+ 软链接就是共享时建立一个$Link$类型的文件，文件记录了要共享的文件的存放路径或任意一条硬链接路径，类似$Windows$系统的快捷方式.
+ 文件拥有者才拥有指向其索引结点的指针，而共享该文件的其他用户只有该文件的路径名.
+ 当访问共享文件时，先判断这个文件属于$Link$类型文件，然后根据其中记录的路径层层查找路径找到索引结点.
    + 因此，每次访问共享文件时，都==可能要多次地读盘==
    + 使得访问文件的开销甚大，且==增加了启动磁盘的频率==
    + 此外，==符号链的索引结点也要耗费一定的磁盘空间==

+ 利用符号链实现网络文件共享时，只需提供该文件所在机器的网络地址及文件路径名

创建软链接时：

+ $count$直接复制.
+ 计算$count$值时忽略所有软链接.

删除文件时：

+ 由于删除操作对软链接不可见，==所以$count$值不变==.
+ 当以后通过符号链接再次访问时发现文件不存在再直接删除软链接.

优点：

+ 网络共享只用提供文件所在机器的网络地址和文件路径.
+ 若共享文件被删除了，则软链接失效.删除软链接则无影响.

缺点：

+ 当共享文件删除，而其他用户新建一个相同路径的文件则原链接指向的是新文件而不是原文件.
+ 因为软链接访问共享文件时需要查询多层目录，所以有多层$I/O$操作，从而软链接访问速度慢于硬链接.

## 文件系统管理

![image-20230907111154227](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309071111269.png)

### 文件系统的系统层次结构

![image-20230907232907571](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309072329646.png)

1. 设备.
2. $I/O$控制
    + 包括设备驱动程序和中断处理程序，在内存和磁盘系统之间传输信息.
    + **设备驱动程序**将输入的命令翻译成底层硬件的特定指令
    + **硬件控制器**利用这些指令使$I/O$设备与系统交互.
    + **设备驱动程序**告诉$I/O$控制器对设备的什么位置采取什么动作.
3. 相关模块
    + **辅助分配模块**：管理辅存空间，即负责分配和回收存储空间.
    + **设备管理模块**：管理设备，直接与硬件交互，负责和硬件直接相关的一些管理工作
        + 如分配设备、分配设备缓冲区、磁盘调度、启动设备、释放设备等.
4. 物理文件系统/基本文件系统
    + 物理地址转换
    + 这一层需要把上一层提供的文件逻辑地址转换为实际的物理地址.
    + 向对应的设备驱动程序发送通用命令，以读取和写入磁盘的物理块。
    + 每个物理块由磁盘地址标识。
        + 该层也管理内存缓冲区， 并保存各种文件系统、目录和数据块的缓存。
        + 在进行磁盘块传输前，分配合适的缓冲区，并对缓冲区进行管理。
        + 管理它们对于系统性能的优化至关重要
    + 详见<a href='###文件物理结构'>文件物理结构</a>
5. 逻辑文件系统与文件信息缓冲区
    + 逻辑地址转换
    + 用户指明想要访问文件记录号，这一层需要将记录号转换为对应的逻辑地址，文件信息缓冲区用来在调入索引表到内存时暂存索引表的内容.
    + 详见<a href='###文件逻辑结构'>文件逻辑结构</a>
6. 存取控制模块
    + 文件保护.为了保证文件数据的安全，还需要验证用户是否有访问权限.
    + 详见<a href='###文件保护'>文件保护</a>
7. 文件目录系统/逻辑文件系统
    + 管理文件目录，管理元数据信息
        + 元数据包括文件系统的所有结构，而不包括实际数据或文件内容
        + 逻辑文件系统管理目录结构，以便根据给定文件名称为文件组织模块提供所需要的信息。
        + 它通过文件控制块$FCB$来维护文件结构。
        + 逻辑文件系统还负责文件保护。
    + 用户是通过文件路径来访问文件的，因此这一层需要根据用户给出的文件路径找到相应的$FCB$或索引结点
    + 所有和目录、目录项相关的管理工作都在本层完成，如管理活跃的文件目录表、管理打开文件表等.
    + 详见<a href='###目录操作'>目录操作</a>
8. 用户接口
    + 向用户提供文件目录相关功能接口
    + 这层就是用于处理用户发出的系统调用请求（$read$、$write$、$open$、$close$等系统调用）.
    + 详见<a href='###文件操作'>文件操作</a>
9. 用户/应用程序.

![image-20230627224621130](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306272246225.png)

假设某用户请求删除文件“$D:$/工作目录/学生信息.$xlsx$”的最后$100$条记录：

1. 用户需要通过操作系统提供的接口发出上述请求
    + 用户接口.
2. 由于用户提供的是文件的存放路径，因此需要操作系统一层一层地查找目录，找到对应的目录项
    + 文件目录系统
3. 不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限
    + 存取控制模块（存取控制验证层）.
4. 验证了用户的访问权限之后，需要把用户提供的“记录号”转变为对应的逻辑地址
    + 逻辑文件系统与文件信息缓冲区.
5. 知道了目标记录对应的逻辑地址后，还需要转换成实际的物理地址
    + 物理文件系统.
6. 要删除这条记录，必定要对磁盘设备发出请求
    + 设备管理程序模块.
7. 删除这些记录后，会有一些盘块空闲，因此要将这些空闲盘块回收
    + 辅助分配模块.

### 文件系统分布

文件系统存放在磁盘上，多数磁盘划分分区，每个分区都有独立的文件系统.

#### 格式化

+ 物理格式化，即低级格式化
    + 划分扇区，检测坏扇区，并用备用扇区替换坏扇区
+ 逻辑格式化
  
    ![image-20230627225857212](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306272258288.png)
    
    + 划分磁盘分区（分卷$Volume$)，完成各分区的文件系统初始化
    + 注：逻辑格式化后，灰色部分就有实际数据了，白色部分还没有数据

#### 文件系统磁盘结构

+ 主引导记录$MBR$（$Master\;Boot\;Record$）
    + 位于磁盘的$0$号扇区，用来引导计算机
    + $MBR$后面是分区表，该表给出每个分区的起始和结束地址
    + 表中的一个分区被标记为活动分区
    + ==当计算机启动时，$BIOS$读入并执行$MBR$==
    + $MBR$做的第一件事是确定活动分区，读入它的第一块，即引导块.
    
+ 引导块（$boot\;block$）
    + $MBR$执行引导块中的程序后，该程序负责启动该分区中的操作系统
    + 为统一起见，每个分区都从一个引导块开始，即使它不含有一个可启动的操作系统，也不排除以后会在该分区安装一个操作系统
    + $Windows$系统称之为分区引导扇区
    + 除了从引导块开始，磁盘分区的布局是随着文件系统的不同而变化的

+ 超级块（$super\;block$）
    + ==包含文件系统的所有关键信息==
    + ==在计算机启动时，或者在该文件系统首次使用时，超级块会被载入内存==
    + 超级块中的典型信息包括==分区的块的数量、块的大小、空闲块的数量和指针、空闲的$FCB$数量和$FCB$指针==等.
    + 能够迅速找到若干个空闲块

+ i节点区（$inode\; area$)
    + 是指在文件系统中用于存储索引节点（$inode$）的特定区域
    + 索引节点是文件系统中的一种数据结构，用于描述文件或目录的元数据信息。
    + $i$节点区存储了文件或目录的元数据信息，包括但不限于以下内容：
        1. 文件类型：表示该i节点所关联的是文件还是目录。
        2. 文件访问权限：指定了文件的读、写和执行权限。
        3. 文件所有者和所属组：记录了文件的所有者和所属组的标识符。
        4. 文件大小：表示文件的大小，对于目录来说，表示目录所包含的文件数量。
        5. 文件创建时间、修改时间和访问时间：记录了文件的创建、修改和访问时间戳。
        6. 文件数据块的指针：指向存储文件实际数据的数据块。

+ 文件系统中空闲块的信息，可以使用位示图或指针链接的形式给出.
+ 根目录，它存放文件系统目录树的根部
+ 磁盘的其他部分存放了其他所有的目录和文件.

#### 文件系统内存结构

![image-20230627230551067](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306272305130.png)

内存中的信息用于管理文件系统并通过缓存来提高性能.

+ 内存中的安装表（$mount\;table$），包含每个已安装文件系统分区的有关信息.
+ 内存中的目录结构的缓存包含最近访问目录的信息.对安装分区的目录，它可以包括一个指向分区表的指针.
    + 近期访问过的目录文件会缓存在内存中，不用每次都从磁盘读入，这样可以加快目录检索速度

+ 整个系统的打开文件表，包含每个打开文件的$FCB$副本及其他信息.
+ 每个进程的打开文件表，包含一个指向整个系统的打开文件表中的适当条目的指针与其他信息

![image-20230627230845123](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306272308191.png)

+   为了创建新的文件，应用程序调用逻辑文件系统。
    +   逻辑文件系统知道目录结构的格式，它将为文件分配一个新的$FCB$。
    +   然后，系统将相应的目录读入内存，使用新的文件名和$FCB$进行更新，并将它写回磁盘。 

+   一旦文件被创建，它就能用于I/O。
    +   不过，首先应该要打开文件。
    +   系统调用`open`将文件名传递给逻辑文件系统。
    +   调用```open()```首先搜索整个系统的打开文件表，以确定这个文件是否已被其他进程使用。
        +   如果已被使用，则在单个进程的打开文件表中创建一个条目，让其指向现有整个系统的打开文件表的相应条目。
    +   该算法在文件已打开时，能节省大量开销。
    +   如果这个文件尚未打开，则根据给定文件名来搜索目录结构。
        +   部分目录结构通常缓存在内存中，以加快目录操作。找到文件后，它的$FCB$会复制到整个系统的打开文件表中。
    +   该表不但存储$FCB$​，而且跟踪打开该文件的进程的数量。然后， 在单个进程的打开文件表中创建一个条目，并且通过指针将整个系统打开文件表的条目与其他域（如文件当前位置的指针和文件访问模式等）相连
    +   调用`open`返回的是一个指向单个进程的打开文件表中的适当条目的指针。
    +   以后，所有文件操作都通过该指针执行。一旦文件被打开，内核就不再使用文件名来访问文件而使用文件描述符（$Windows$称之为文件句柄）。
    +   当进程关闭一个文件时，就会删除单个进程打开文件表中的相应条目，整个系统的打开文件表的文件打开数量也会递减。
        +   当所有打开某个文件的用户都关闭该文件后，任何更新的元数据将复制到磁盘的目录结构中，并且整个系统的打开文件表的对应条目也会被删除

### 外存空闲空间管理

文件存储空间管理即文件空闲空间管理。==文件管理要解决的重要问题是，如何为创建文件分配存储空间==，即如何找到空闲盘块，并对其管理。

安装$Windows$操作系统的时候，一个必经步骤就是为磁盘分区($C:$盘、$D:$盘、$E:$盘等)

包含文件系统的分区称为卷.

#### 存储空间划分与初始化

![image-20230907234621537](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309072346626.png)

+ 存储空间的划分
    + 将物理磁盘划分为一个个文件卷（逻辑卷、逻辑盘）.
    + 同一个卷中==存放数据的空间（文件区）==和==$FCB$的空间（目录区）==是分离的.
    + 由于存在很多种类的文件表示和存放格式，所以现代操作系统中一般都有很多不同的文件管理模块，通过它们可以访问不同格式的卷中的文件。
    + 卷在提供文件服务前，必须由对应的文件程序进行初始化，划分好目录区和文件区，建立空闲空间管理表格及存放卷信息的超级块
    + 文件存储设备分成许多大小相同的物理块，并==以块为单位交换信息==
    
+ 将各个文件卷初始化为：
    + 目录区
        + 主要存放文件目录信息$FCB$
        + 用于磁盘存储空间管理的信息
    + 文件区
        + 用于存放普通文件数据.
+ 有的系统支持超大型文件，支持由多格物理磁盘组成一个文件卷.
    + ==空闲表法和空闲链表法都不适用于大型文件系统==，因为这会使空闲表或空闲链表太大。


#### 空闲表法

+   ==属于连续分配方式==，与内存的动态分配方式类似，为每个文件分配一块连续的存储空间。
+   外存上的所有空闲区建立一张空闲表， 每个空闲区对应一个空闲表项
    +   其中包括表项序号、该空闲区间的起始位置（第一个空闲盘块号）和空闲空间长度（空闲盘块数）.
    +   ==将空闲区按其起始盘块号递增的次序排列==

![image-20230627192424014](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306271924078.png)

+ 如何分配磁盘块
    + 同样可采用首次适应、最佳适应、最坏适应等算法来决定要为文件分配哪个区间.
        + 首次适应:放进==第一个可以装==的空闲区间，再将该盘区分配给用户，同时修改空闲盘块表。 
        + 最佳适应:放进==满足需求且最小==的空闲区间，再将该盘区分配给用户，同时修改空闲盘块表。 
        + 最坏适应:放进==满足需求且最大==的空闲区间，再将该盘区分配给用户，同时修改空闲盘块表。 
+ 如何回收磁盘块
    + 与内存管理中的动态分区分配很类似，当回收某个存储区时需要有四种情况：
        + 回收区的前后都没有相邻空闲区.
            + 新增空闲盘块表表项

        + 回收区的前后都是空闲区.
            + 前后空闲区和回收区合并
            + 空闲盘块表表项数减一

        + 回收区前面是空闲区.
        + 回收区后面是空闲区.

    + 总之，回收时需要注意表项的合并问题.

#### 空闲链表法

将所有空闲盘区拉成一条空闲链。根据构成链所用基本元素的不同，分为两种形式：

+ 空闲盘块法：将磁盘上的所有空闲空间==以盘块为单位==拉成一条链
  
    + 空闲盘块中存储着下一个空闲盘块的指针.
    + 操作系统保存着链头、链尾指针.
    
    ![image-20230627193230765](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306271932829.png)
    
    + 如何分配磁盘块
        + 若某文件申请$K$个盘块，则==从链头/链首开始==依次摘下$K$个盘块分配，并修改空闲链的链头指针.
    + 如何回收磁盘块
        + 回收的盘块依次挂到链尾，并修改空闲链的链尾指针.
    + 适用于**离散分配**的物理结构，为文件分配多个盘块时可能要重复多次操作.
    + 优点：是分配和回收一个盘块的过程非常简单
    + 缺点：
        + 为一个文件分配盘块时可能要重复操作多次，==效率较低==。
        + 又因它是以盘块为单位的，==空闲盘块链会很长==
+ 空闲盘区法：将磁盘上的所有空闲盘区（每个盘区可包含若干个盘块）拉成一条链

    + 由连续的几个盘块组成一个盘区，每一个盘区内的第一个盘块内记录了盘区的长度和下一个盘区的指针.
    + 操作系统保存着链头、链尾指针.

    ![image-20230627193256587](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306271932670.png)

    + 如何分配
        + 若某文件申请$K$个盘块，则可以采用首次适应、最佳适应等算法，从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区，分配给文件
        + ==通常采用首次适应算法==
        + 若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件
            + 注意分配后可能要修改相应的链指针、盘区大小等数据.
    + 如何回收
        + 若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中
        + 若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾.
    + 离散分配、连续分配都适用.为一个文件**分配多个盘块**时**效率更高**.
    + 这种方法的优缺点刚好与第一种方法的相反
        + ==分配与回收的过程比较复杂==
        + 但==效率通常较高==，且==空闲盘区链较短==

#### 位示图法

+   **位示图**是利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应
    +   如“$0$”代表盘块空闲，“$1$”代表盘块已分配.
    +   ==位示图一般用连续的“字”来表示==，如一个字的字长是$16$位，则一共有$16$列，字中的每一位对应一个盘块
        + 位号表示一个字中的第几位，即列数
        + 字号表示第几个字，即行数
        + 因此可以用（字号，位号）对应一个盘块号.当然有的题目中也描述为（行号，列号）.

![image-20230627193540159](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306271935304.png)

+ 若盘块号、字号、位号从$0OR1$开始，若$n$表示字长，则

    + ==注意题目条件：盘块号、字号、位号到底是从$0$开始还是从$1$开始==

    + 字位号$\to$盘块号
        + (字号，位号)=$(i，j)$​的二进制位对应的盘块号$b$
            $$
            \begin{align}
            b_0 & = n\times i+j\\
            b_1 & = n\times(i-1)+j
            \end{align}
            $$

    + 盘块号$\to$字位号
        + $b$号盘块对应的字号$i$，位号$j$​.
            $$
            \begin{align}
            i_0 & = b\div n\\
            i_1 & = (b-1)\div n\\
            j_0 & = b\%n\\
            j_1 & = (b-1)\%n
            \end{align}
            $$
            

+ 如何分配：若文件需要$K$个块，
    1. 顺序扫描位示图，找到$K$个相邻或不相邻的“$0$”.
        + “$0$”代表盘块空闲
    2. 根据字号、位号算出对应的盘块号，将相应盘块分配给文件.
    3. 修改位示图，令将相应位设置为“$1$”.

+ 如何回收：
    1. 根据回收的盘块号计算出对应的字号、位号.
    2. 修改位示图，将相应二进制位设为“$0$”.

+ 离散分配、连续分配都适用.

#### 成组链接法

>   ~~这部分不要看王道的视频，讲的什么依托构思~~
>
>   ~~强化阶段写到这感觉还是全部直接看书好，看不懂的才看视频~~
>
>   本部分是旧版，部分内容彼此有冲突我都不知道该信谁，主要是不同的教材对**指针盘块号**的解释还不一样，王道的教材直接没写
>
>   新版直接按照王道教材不写**指针盘块号**相关内容，旧版仅用于拓展阅读用
>
>   ~~将来有哪位同学搞懂了欢迎提个PR~~

##### 新版

+   空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或空闲链表可能过大

    + $UNIX$系统中采用了成组链接法对磁盘空闲块进行管理.

    + 这是将了空闲表和空闲链表两种方法相结合而形成的一种空闲盘块管理方法，它兼备了上述两种方法的优点而克服了两种方法均有的表太长的缺点。

+   用来存放一组空闲盘块号（空闲盘块的块号）的盘块称为**成组链块**。

    +   把顺序的n个空闲盘块号保存在第一个成组链块中，其==最后一个空闲盘块（作为成组链块）则用于保存另一组空闲盘块号==，如此继续，直至所有空闲盘块均予以链接。

    +   ==系统只需保存指向第一个成组链块的指针==。

    +   假设磁盘最初全为空闲盘块，其成组链接如图4.21所示

        ![image-20230908111141381](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309081111492.png)

+   盘块的分配： 

    +   根据第一个成组链块的指针，将其对应的盘块分配给用户，然后将指针下移一格。
    +   若该指针指向的是最后一个盘块（即成组链块），由于该盘块记录的是下一组空闲盘块号，
    +   因此要将该盘块读入内存，并将指针指向新的成组链块的第一条记录，然后执行上述分配操作。 

+   盘块的回收： 

    +   成组链块的指针上移一格，再记入回收盘块号。
    +   当成组链块的链接数达到n时，表示已满， 便将现有已记录n个空闲盘块号的成组链块号记入新回收的盘块（作为新的成组链块）。

+   超级块

    +   UNIX系统中，存放在磁盘中的卷头位置包含表示**空闲空间的位向量表或第一个成组链块**，以及**卷中的目录区**、**文件区划分信息**的物理块，称为**超级块**。
    +   在对卷中的文件进行操作前，超级块需要预先读入系统空闲的主存，并且==经常保持主存超级块与磁盘卷中超级块的一致性==

##### 旧版

+ 成组链接法的结构
    + 将空闲块分成若干组，如每$100$个空闲块为一组
        + 每组的空闲块总数有一个上限
        + 最末一组只有$99 $个盘块，其盘块号分别记入其前一组的`S.free[1] `～`S.free[99]`中
        + 而在`S.free[0]`中则存放$-1$，作为空闲盘块链的结束标志。
            + 结束标志也有可能是$0$
        
        ![image-20230627211259667](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306272112727.png)
        
    + 对于以上形式的空闲块组，编号`1`的组会保存一个空闲盘块号栈`S.free[]`和==本组内部栈中尚有的空闲盘块（号）数==`N`
        + **该组为超级块，会调入内存**
        
        + `N`还兼作栈顶指针用
          
            + 例如，当`N=100`时，栈指针指向`S.free[99]`
            
        + 空闲盘块号栈`S.free[]`
          
            + 通常`S.free[0]`指向下一个指针盘块号
            
                + 当本盘块为最后一个即没有下一个指针盘块号时`S.free[0]=-1`
            
            + `S.free[1]`及以后的栈项保存空闲盘块的指针
            
                ![image-20230627212408295](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306272124499.png)

+ 如何分配：
    1. 首先检查空闲盘块号栈是否上锁
    2. 如未上锁，便从栈顶取出一空闲盘块号，将与之对应的盘块分配给用户，然后将栈顶指针下移一格
    3. 若该盘块号已是栈底，即`S.free[0]`，这是当前栈中最后一个可分配的盘块号
        + 由于在该盘块号所对应的盘块中记有下一组可用的盘块号
        + 因此，须调用磁盘读过程，将栈底盘块号所对应盘块的内容读入栈中，作为新的盘块号栈的内容
        + **并把原栈底对应的盘块分配出去**
            + 其中的有用数据已读入栈中
        + 然后，再分配一相应的缓冲区(作为该盘块的缓冲区)。
        + 最后，把栈中的空闲盘块数减1 并返回。

+ 如何回收：
    1. 将回收盘块的盘块号记入空闲盘块号栈的顶部，并执行空闲盘块数加$1 $操作
    2. 当栈中空闲盘块号数目已达$100 $时，表示栈已满，便将现有栈中的$100$个盘块号记入新回收的盘块中，再将其盘块号作为新栈底。

### 虚拟文件系统

#### 虚拟文件系统$VFS$

![image-20230627231043088](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306272310148.png)

+ 虚拟文件系统$VFS$为用户程序提供了文件系统操作的统一接口，屏蔽了不同文件系统的差异和操作细节
  
    + 即统一调用函数
    
+ 使应用程序可以透明地访问不同类型的文件系统，而不需要关心底层文件系统的具体实现.
    + 屏蔽了不同文件系统的差异
    
+ 虚拟文件系统==采用了面向对象的思想==，它抽象出一个通用的文件系统模型，定义了通用文件系统都支持的接口。
  
    + 新的文件系统只要支持并实现这些接口，即可安装和使用。
    
    + 以$Linux$中调用`write`操作为例，它在$VFS$中通过`sys_write()`函数处理，`sys_write()`找到具体文件系统，将控制权
        交给该文件系统，最后由具体文件系统与物理介质交互并写入数据，如图4.23所示。
    
        ![image-20230908111941147](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309081119254.png)
    
+ 特点

    1. 向上层用户进程提供统一标准的系统调用接口，屏蔽底层具体文件系统的实现差异
    2. $VFS$要求下层的文件系统必须实现某些规定的函数功能，一个新的文件系统想要在某操作系统上被使用，就必须满足该操作系统$VFS$的要求
        + 如：`open/read/write`
    3. 每打开一个文件，$VFS$就在主存中新建一个$vnode$($v$结点)，用统一的数据结构表示文件，无论该文件存储在哪个文件系统。
    4. 创建$vnode$，并将文件信息复制到$vnode$中，$vnode$的功能指针指向具体文件系统的函数功能。

+   $VFS$可以提高系统性能
    +   最近最常使用的目录项对象被放在目录项高速缓存的磁盘缓存中，以加速从文件路径名到最后一个路径分量的索引结点的转换过程
+   严格来说，$VFS$并不是一种实际的文件系统，它==只存在于内存中，不存在于任何外存空间中==。
+   ==VFS在系统启动时建立，在系统关闭时消亡==

$Linux$实现$VFS$提供四个对象：

+ 超级块对象：表示已安装或挂载的特定文件系统.
    + 超级块对象对应于磁盘上特定扇区的文件系统超级块，用于存储己安装文件系统的元信息
    + 元信息中包含文件系统的基本属性信息
        + 如文件系统类型、文件系统基本块的大小、文件系统所挂载的设备、操作方法（函数）指针等。
        + 其中操作方法（函数）指针指向该超级块的操作方法表，包含一系列可在超级块对象上调用的操作函数，
            + 主要有对inode的分配、销毁、读、写、文件同步等。

+ 索引结点对象：表示一个特定的文件.
    + 文件系统处理文件所需要的所有信息，都放在一个称为索引结点的数据结构中，索引结点对文件是唯一的。
    + 只有当文件被访问时，才在内存中创建索引结点对象，每个索引结点对象都会复制磁盘索引结点包含的一些数据。
    + ==该对象中有一个状态字段表示是否被修改，其值为“脏”时，说明对应的磁盘索引结点必须被更新==。
    + 索引结点对象还提供许多操作接口，如创建新索引结点、创建硬链接、创建新目录等

+ 目录项对象：表示特定的目录项.
    + 由于VFS经常执行切换到某个目录这种操作，==为了提高效率，便引入了目录项的概念==
    + 目录项对象是一个路径的组成部分，它要么是目录名，要么是文件名。
        + 例如，在查找路径名`/test`时，内核为根目录`/`创建一个目录项对象，为根目录下的`test`创建一个第二级目录项对象。

    + 目录项对象包含指向关联索引结点的指针，还包含指向父目录和指向子目录的指针。
    + 不同于前面两个对象，==目录项对象在磁盘上没有对应的数据结构==，而是==VFS在遍历路径的过程中，将它们逐个解析成目录项对象==的

+ 文件对象：表示一个与进程相关的已打开文件.
    + 可以通过`open()`调用打开一个文件， 通过`close()`调用关闭一个文件。
    + ==文件对象和物理文件的关系类似于进程和程序的关系==。
    + 由于多个进程可以打和操作同一文件，所以同一文件在内存中可能存在多个对应的文件对象，但对应的索引结点和目录项是唯一的。
    + 文件对象仅在进程观点上代表己经打开的文件，它反过来指向其索引结点。
    + 文件对象包含与该文件相关联的目录项对象，包含该文件的文件系统、文件指针等，还包含在该文件对象上调用的一系列操作函数。

进程与文件进行交互：

+   如图，三个不同的进程已打开了同一个文件，其中两个进程使用同一个硬链接。
+   在这种情况下，每个进程都使用自己的文件对象，但只需要两个目录项对象，每个硬链接对应一个目录项对象。
+   这两个目录项对象指向同一个索引结点对象,这个索引结点对象标识的是超级块对象及随后的普通磁盘文件

![image-20230908113216515](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309081132631.png)

#### 文件系统挂载

文件系统挂载($mounting$)，即文件系统安装/装载

+   一个磁盘可以划分为多个分区，==每个分区都可以用于创建单独的文件系统，每个分区还可以包含不同的操作系统==。

    +   分区可以是原始的，没有文件系统，当没有合适的文件系统时，可以使用原始磁盘。
        +   例如，UNIX交换空间可以使用原始磁盘格式，而不使用文件系统

+   操作系统的引导：Linux启动后，首先载入MBR，随后MBR识别活动分区，并且加载活动分区中的引导程序。

    +   图4.25中显示了一个典型的Linux分区

        ![image-20230908124156538](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309081241623.png)

    +   分区的第一部分是引导块，里面存储着**引导信息**，它有自身的格式，因为在引导时系统并未加载文件系统代码，因此不能解释文件系统的格式。

    +   引导信息是一系列可以加载到内存中的连续块，加载到内存后从其第一条代码开始执行，引导程序便启动一个具体的操作系统。

    +   引导块之后是超级块，它存储文件系统的有关信息，包括文件系统的类型、`i结点`的数目、数据块的数目。

    +   随后是多个索引结点`i结点`，它们是实现文件存储的关键，每个文件对应一个索引结点，索引结点中包含多个指针，指向属于该文件的各个数据块。

    +   最后是文件数据块

+   如文件在使用前必须打开一样，文件系统在进程使用前必须先安装，也称**挂载**。 

    +   文件系统挂载要做的事：

        1. 在$VFS$中注册新挂载的文件系统内存中的挂载表($mount\;table$)包含每个文件系统的相关信息，包括文件系统类型、容量大小等。
        2. 新挂载的文件系统，要向$VFS$提供一个函数地址列表
        3. 将新文件系统加到挂载点($mount\; point$)，也就是将新文件系统挂载在某个父目录下
    +   Windows系统维护一个扩展的两级目录结构，用驱动器字母表示设备和卷。
        +   卷具有常规树结构的目录，与驱动器号相关联，还含有指向己安装文件系统的指针
        +   操作系统找到相应文件系统的指针，并且遍历该设备的目录结构，以查找指定的文件。
        +   新版本的Windows允许文件系统安装在目录树下的任意位置，就像UNIX一样。
        +   ==在启动时，Windows操作系统自动发现所有设备，并且安装所有找到的文件系统==
    +   UNIX使用系统的根文件系统，由内核在引导阶段直接安装，其他文件系统要么由初始化脚本安装，要么由用户安装在已安装文件系统的目录下。
        +   作为一个目录树，每个文件系统都拥有自己的根目录。安装文件系统的这个目录称为**安装点**，安装就是将磁盘分区挂载到该安装点下，进入该目录就可以读取该分区的数据。
        +   己安装文件系统属于安装点目录的一个子文件系统。
        +   安装的实现是在目录inode的内存副本上加上一个标志，表示该目录是安装点。
        +   还有一个域指向安装表的条目，表示哪个设备安装在哪里，这个条目还包括该设备的文件系统超级块的一个指针。
        +   可以这么理解：==UNIX本身是一个固定的目录树，只要安装就有，但是如果不给它分配存储空间，就不能对它进行操作==，所以首先要给根目录分配空间，这样才能操作这个目录树

>   操作系统引导
>
>   ![image-20230610221923113](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306102219174.png)
>
>   1. 激活$CPU$，充电，`CS:IP`指向`FFFF0H`
>   2. 执行$JMP$指令跳转到$BIOS$（基本输入输出系统）.
>       + $BIOS$是一组固化到计算机内主板上一个$ROM$芯片上的程序，
>           + 它保存着计算机最重要的基本输入输出的程序、开机后自检程序和系统自启动程序
>           + 可从$CMOS$中读写系统设置的具体信息.
>       + ==$BIOS$主要功能是为计算机提供最底层的、最直接的硬件设置和控制==.
>       + 此外，==$BIOS$还向作业系统提供一些系统参数==.
>       + 系统硬件的变化是由$BIOS$隐藏，程序使用$BIOS$功能而不是直接控制硬件.
>       + 现代作业系统会忽略$BIOS$提供的抽象层并直接控制硬件组件.
>   3. 登记$BIOS$中断例程入口地址.
>       + 读取$ROM$中的$Boot$程序，将指令寄存器置为$BIOS$的第一条指令
>       + 即==开始执行$BIOS$的指令==.
>   4. 硬件自检，并识别已连接的外设.检
>       +   查硬件是否出现故障
>       +   如有故障，主板会发出不同含义的蜂鸣，启动中止
>       +   如无故障，屏幕会显示$CPU$、内存、硬盘等信息.
>   5. 加载带有操作系统的硬盘
>       +   硬件自检后，$BIOS$开始读取$Boot\;Sequence$（通过$CMOS$里保存的启动顺序，或者通过与用户交互的方式）
>       +   把控制权交给启动顺序排在第一位的存储设备
>       +   然后$CPU$将该存储设备引导扇区的内容加载到内存中.
>   6. 在$ROM$中加载主引导记录$MBR$
>       +   硬盘以特定的标识符区分引导硬盘和非引导硬盘
>       +   如果发现一个存储设备不是可引导盘，就检查下一个存储设备
>       +   如无其他启动设备，就会死机
>       +   主引导记录$MBR$的作用是告诉$CPU$去硬盘的哪个主分区去找操作系统.
>   7. $MBR$扫描硬盘分区表，加载硬盘活动分区
>       +   $MBR$包含硬盘分区表，硬盘分区表以特定的标识符区分活动分区和非活动分区
>       +   主引导记录扫描硬盘分区表，进而识别含有操作系统的硬盘分区（活动分区）
>       +   找到硬盘活动分区后，开始加载硬盘活动分区，将控制权交给活动分区.
>   8. $MBR$加载分区引导记录$PBR$，即该分区的启动程序（操作系统引导扇区），
>       +   读取活动分区的第一个扇区，这个扇区称为分区引导记录（$PBR$）
>       +   其作用是寻找并激活分区根目录下用于引导操作系统的程序（启动管理器）.
>   9. 加载启动管理器
>       +   **硬盘**的分区引导记录搜索活动分区中的启动管理器（活动分区的引导扇区的**引导程序**）
>       +   加载启动管理器.
>   10. 加载操作系统
>       +   常驻内存的只有操作系统的**内核**，其他需要时再调入.

## 本章小结

### 常见计算

![image-20230907111321077](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309071113225.png)
