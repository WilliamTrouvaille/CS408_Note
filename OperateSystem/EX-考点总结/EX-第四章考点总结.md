# EX-第四章 文件管理考点总结

## 导读

### 【考纲内容】

1. 文件
    + 文件的基本概念
    + 文件元数据和索引结点($inode$)
    + 文件的操作：建立、删除、打开、关闭、读、写
    + 文件的保护
    + 文件的逻辑结构
    + 文件的物理结构
2. 目录
    + 目录的基本概念
    + 树形目录
    + 目录的操作
    + 硬链接和软链接
3. 文件系统
    + 文件系统的全局结构$layout$
    + 文件系统在外存中的结构，文件系统在内存中的结构
    + 外存空闲空间管理办法
    + 虚拟文件系统
    + 文件系统挂载$mounting$

### 【复习提示】

+ 本章内容较为具体，要注意对概念的理解.重点掌握文件系统的结构及其实现、文件分配和空闲空间管理等
+ 要掌握文件系统的文件控制块、物理分配方法、索引结构、树形目录结构、文件共享原理、文件系统的布局、虚拟文件系统原理等
+ 这些都是统考真题易考查的内容.

选择题：文件系统的文件控制块、物理分配方法、索引结构、树形目录结构、文件共享原理、文件系统的布局、虚拟文件系统原理、文件系统的结构及其实现、文件分配和空闲空间管理。

综合题：文件系统的结构及其实现、文件分配和空闲空间管理。

## 选择题考点总结

### 文件系统概述

1.   文件$File$：以硬盘为载体的存储在计算机上的信息集合，文件可以是文本文档、图片、程序等。在用户进行的输入输出中，则以文件为基本单位。可分为有结构文件和无结构文件两种。文件系统不仅管理普通文件，对于$UNIX$系统所有设备都被视为特殊文件。
2.   文件组织形式
     1.   无结构文件（如文本文件)：由一些二进制或字符流组成，又称“流式文件”。
     2.   有结构文件（如数据库表）：由一组相似的记录组成，又称“记录式文件”。目录也是一种特殊的有结构文件。
3.   文件系统$File System$：访问、修改和保存文件等，实现对文件的维护管理。
4.   数据项：是文件系统中最低级的数据组织形式。
     1.   基本数据项：用于描述一个对象的某种属性的一个值，是数据中的最小逻辑单位。 
     2.   组合数据项：由多个基本数据项组成。
5.   记录：一组相关的数据项的集合，用于描述一个对象在某方面的属性。
6.   文件属性：文件名、标识符、类型、位置、大小、创建时间、上次修改时间、创建者、文件所有者信息、保护信息。操作系统通过文件控制块$FCB$来维护文件元数据。其中文件名在同一目录下唯一，以容易读取的形式保存。**同一目录下不允许有重名文件**。
7.   文件控制块$FCB$：用来存放控制文件需要的各种信息的数据结构，以实现**按名存取**。$FCB$的有序集合称为**文件目录**，一个$FCB$就是一个文件目录项。$FCB$中包含了文件名和文件存放物理地址等信息。$FCB$必须连续存放。
8.   索引结点：在查找各级目录的过程中只需要用到“文件名”这个信息，故将文件名和文件描述信息分开，使文件描述信息单独形成一个称为`索引结点`的数据结构，简称$inode$（$i$结点）。索引结点极大提升了文件检索速度，节省了系统开销。
     1.   **磁盘索引结点**：存放在**外存**中的索引结点。
     2.   **内存索引结点**：存放在**内存**中的索引结点。内存索引结点中需要增加一些信息，例如文件是否被修改、此时有几个进程正在访问该文件等。

### 文件操作

1.   文件操作：由**操作系统提供系统调用**，对文件进行操作。

     1.   创建`create`：文件系统为文件找到空间。在目录中为新文件创建条目，记录文件名称、位置和其他可能的信息。

     2. 写文件`write`：执行一个系统调用，指明文件名和内容。系统通过文件名搜索位置。系统需要为文件维护一个写位置的指针，当写时就更新写指针。

     3. 读文件`read`：执行一个系统调用，指明文件名和位置，系统维护一个读位置的指针，读时就更新读指针，一个进程通常只对一个文件读或写，因此当前操作位置可作为每个进程当前文件位置的指针。

         读和写操作都使用同一指针，需要的参数：文件描述符、缓冲区首址、传输字节数。

     4. 文件重定位（文件寻址）：按条件搜索目录，将当前文件位置设置为给定值，不读写。

     5. 删除`delete`：找到对应目录项，使其为空，并回收该文件所占存储空间。

     6. 截断：允许文件所有属性不变，删除文件内容，即设置长度归零并释放空间。

2.   文件打开：将该文件的**文件控制块**$FCB$存入内存的**系统打开文件表/活跃文件目录表**。在对文件进行操作之前，要求先使用`open`系统调用“打开文件”。

     +   需要提供的参数：文件存放路径、文件名、要对文件的操作类型（如：$r$只读；$rw$读写等）。

3.   处理`open`系统调用

     1.   将文件名传递给逻辑文件系统：数据不在内存时，产生缺页中断，进程进入阻塞态，处理后唤醒。
     2.   搜索**系统打开文件表**，如果已打开，则在**进程打开文件表**中创建新目录指向**系统打开文件表**对应条目。当用户再次向系统发出文件操作请求时，可通过索引在打开文件表中查到文件信息，从而节省再次搜索目录的开销。
     3.   如果未打开，根据文件名搜索目录结构，并检查该用户是否有指定的操作权限，部分文件目录会缓存到内存中以加快检索。找到文件后将目录项$FCB$复制到**系统打开文件表**中。在**进程打开文件表**中创建一个条目，然后通过指针将系统打开文件表条目和其他域相联.。返回一个指向进程打开文件表条目的指针，通过指针操作文件。
     4.   打开文件后内核不能通过文件名访问文件，只能通过**文件描述符/文件句柄**访问。

4.   打开文件表：**文件名不必是打开文件表的一部分**。

     1.   系统打开文件表：只有一张。包含$FCB$的副本及**打开计数器**$Open Count$（多少个进程打开了次文件）等信息。每个关闭操作`close`使**打开计数器**$Open Count$递减，当**打开计数器**$Open Count=0$时，表示该文件不再被使用，并且可从系统打开文件表中删除相应条目。
     2.   进程打开文件表：根据进程打开的所有文件，包含指向系统表中适当条目的指针。文件指针为上次的读写位置，对打开文件的某个进程来说是唯一的，必须与磁盘文件属性分开保存。

5.   文件关闭：使用`close`系统调用“关闭文件”，需要提供的几个主要参数：文件存放路径、文件名。

### 文件保护

口令保护和加密保护是为了防止用户文件被他人存取，而访问控制用于控制用户对文件的访问方式。

1.    口令保护：为文件设置一个“口令”，用户请求访问该文件时必须提供“口令”。口令一般存放在文件对应的$FCB$或索引结点中。

2.   加密保护：使用某个“密码”对文件进行加密，在访问文件时需要提供正确的“密码”才能对文件进行正确的解密。系统并不保存原始数据，而是加密过的数据。

3.   访问类型：读写、执行（将文件装入内存并执行）、添加。删除、列表清单（列出文件名和文件属性）。高层的功能可以通过系统程序调用低层系统调用来实现，保护可以只在低层提供。

4.   访问控制：在每个文件的**文件控制块**$FCB$（或索引结点）中增加一个访问控制列表$ACL$（$AccessControl\;List$），该表中记录了各个用户可以对该文件执行哪些操作（访问类型）。访问控制的级别和保护力度较小， 因此它的灵活性相对较高。

5.   $Linux$文件权限：一共九位，从左至右分为三组，$1-3$位数字代表文件所有者的权限，$4-6$位数字代表同组用户的权限，$7-9$数字代表其他用户的权限。每一组的第一位表示可读，第二位表示可写，第三位表示可执行。

     +   对于任意文件系统，若用户类别有$n$种，访问权限有$m$中，则需要描述文件权限的位数至少为$nm$位。

### 文件结构

#### 文件逻辑结构

1.   逻辑结构：指在用户看来，文件内部的数据应该是如何组织起来的。
2.   无结构文件/流式文件：是最简单的文件组织形式，无结构文件将数据按顺序组织成记录并积累、保存， 是有序相关信息项的集合。以字节$Byte$为单位。
     1.   由于无结构文件没有结构，只能通过穷举进行搜索。因此这种文件形式对大多数应用不适用。
     2.   管理简单，适用于字符流的无结构方式，如源程序文件、目标代码文件等。对基本信息单位**操作不多**的文件较适于采用字符流的无结构方式。
3.   有结构文件/记录式文件：由一组相似的记录组成，每条记录又若干个数据项组成，数据项又包含多个属性，是文件系统中最基本的数据单位。可以根据各条记录的长度（占用的存储空间）是否相等，可分为**定长记录**和可变长记录两种，增加/删除一个记录比较困难。
     1.   顺序文件：文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的，各个记录在物理上可以顺序存储或链式存储。每次要读或写一大批记录时，顺序文件的效率是所有逻辑文件中最高的。但是
          1.   串结构（链式存储）：记录之间的顺序与关键字无关、按存入时间的先后进行排列。无论是定长/可变长记录，都无法实现随机存取，对串结构文件进行检索必须从头开始顺序依次查找，比较费时。
          2.   顺序结构（顺序存储）：记录之间的顺序按关键字顺序排列。
               1.   对于可变长记录：**无法实现随机存取**。$A_{i}=\sum_{i=0}^{i-1} L_{i}+1$，要查找第$i$条记录，必须顺序地查找前$i-1$条记录，并获取每条记录的长度$L$，进而计算出第$i$条记录的首址。
               2.   对于定长记录：**可实现随机存取**，记录长度为$L$，则第$i$个记录存放的相对位置是$A_i=i\times L$。
     2.   索引文件：建立一张索引表存放主文件的每个记录的表项，以加快文件检索速度。
          +   索引表：每条记录对应一个索引项，索引表包含索引号，长度，指针三个部分。索引表本身是定长长度的顺序文件，所以**可以随机访问**。**索引表本身是索引顺序结构的**。**记录可以离散存放，而索引表必须连续存放**。由于索引文件有很快的检索速度，因此主要用于对信息处理的及时性要求比较高的场合。
     3.   索引顺序文件：同样会为文件建立一张索引表，但不同的是并不是每个记录对应一个索引表项，而是一组记录对应一个索引表项。每个分组就是一个顺序文件（**组间有序**），分组内的记录不需要按关键字排序（**组内无序**）。，首先通过索引表找到其所在的组，然后在该组中使用顺序查找，就能很快地找到记录。索引顺序文件的索引表本身是**定长记录**的**串结构**的**顺序文件**。
     4.   散列文件/直接文件：给定记录的键值或通过散列函数转换的键值直接决定记录的物理地址。散列文件有很高的存取速度，但是会引起冲突。

#### 文件物理结构

1.   文件块：磁盘中的存储单元被分为一个个“块/磁盘块/物理块”。为便于数据交换，很多操作系统中，磁盘块的大小与内存块、内存页面的大小相同。内存与磁盘之间的数据交换（即读/写操作、磁盘$I/O$）都是以**块**为单位进行的。

2.   记录成组分解技术：由于磁盘块的大小是预先划分好的，大小固定，而逻辑记录的大小是用户文件性质决定的，不一定和块大小一致。如果逻辑记录比物理块小得多时，可以把多个逻辑记录存放在一个块中，这就是记录的成组。用户使用时再把读取的一块信息中分离出所需的记录，这就是记录的分解。

3.   连续分配：要求每个文件在磁盘上占有一组连续的块。（逻辑块号，块内地址）$\to$（物理块号，块内地址），只需转换块号即可，块内地址保持不变。

     1.   物理块号$=$起始块号$+$逻辑块号。用户给出要访问的逻辑块号，操作系统找到该文件对应的目录项$FCB$。
     2.   连续分配支持顺序访问和随机访问。在顺序读写时速度最快，作业访问磁盘时需要的寻道数和寻道时间最小。
     3.   不利于拓展：因为一个文件末尾后的盘块可能已分配给其他文件，一旦需要增加，就需要大量移动盘块。（解题中可能要求计算移动盘块数，这时可以把前面的往前移动也可以把后面的往后移，哪边少移哪边）。
     4.   存储空间利用率低，产生难以利用的**外部碎片**。
     5.   很难确定一个文件需要的空间大小，因而只适用于长度固定的文件。

4.   链接分配：采取离散分配的方式，可以为文件分配离散的磁盘块。消除了磁盘的外部碎片，提高了磁盘的利用率。以动态地为文件分配盘块，因此**无须事先知道文件的大小**。对文件的插入、删除和修改也非常方便。

     1.   隐式链接：$FCB$目录中记录了文件存放的起始块号和结束块号，增加一个字段来表示文件的长度。除了文件的最后的磁盘块之外，每个磁盘块中都会保存指向下一个盘块的指针，**这些指针对用户是透明的**。
          1.   地址转换：读入$i$号逻辑块，总共需要$i+1$次磁盘$I/O$操作。
          2.   优点：方便文件拓展，不会有硬盘碎片。
          3.   缺点：不支持随机访问，查找效率低。指针需要开销。存储稳定性不足，若是中间毁坏后面的数据也会丢失。
     2.   簇$cluster$：隐式链接的解决方法，大多数操作系统均有应用。将几个盘块组成簇，按簇而不按块来分配，可以成倍地减少查找时间，改善许多算法的磁盘访问时间，指针所占的磁盘空间比例也要小得多，代价是增加了内部碎片。
     3.   显式链接：类似静态链表。把用于链接文件各物理块的指针，从每个物理块的末尾中提取出来，显式地存放在内存的一张链接表中即**文件分配表**$FAT$。显式链接的**文件控制块**$FCB$中只需记录文件的起始块号，后续的盘块可通过$FAT$找到。
          1.   地址转换：目录项中找到起始块号，若$i>0$，则查询内存中的**文件分配表**$FAT$，往后找到$i$号逻辑块对应的物理块号。显式链接的地址转换的过程不需要**读磁盘**操作。
          2.   优点：很方便文件拓展。不会有外部碎片问题。支持顺序访问也支持随机访问。址转换时不需要访问磁盘。
          3.   缺点：文件分配表的需要占用一定的存储空间。
     4.   **文件分配表**$FAT$（$File\;Allocation\;Table$）：$FAT$包含物理块号和下一块指针两项，其各表项在物理上连续存储，且每一个表项长度相同，因此“物理块号”字段可以是隐含的。一个**磁盘**仅设置一张$FAT$，开机时，将$FAT$读入内存，并**常驻内存**，所以**地址转换不需要读取内存**，从而效率更高，明显减少了访问磁盘的次数。

5.   ※※※索引分配：允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表。支持随机访问、不会有碎片问题、方便文件拓展。**单个文件长度与索引节点个数无关**。

     1.   索引分配的索引表：记录了文件的各个逻辑块对应的物理块，功能类似于内存管理中的页表（建立逻辑页面到物理页之间的映射关系）。索引表包含逻辑块号（连续存储、隐含）和物理块号两项。每一个文件都有一个索引表。

     2.   地址转换：从目录项中可知索引表存放位置，将索引表从外存读入内存并查找索引表即可知道$i$号逻辑块在外存中的存放位置。

     3.   链接方案：一个索引块通常为一个磁盘块，因此它本身能直接读写。为了支持大文件，可以将分配多个索引块并链接起来。文件$FCB$中只需要记录第一个索引块的块号。缺点是查找效率低。

     4.   多层索引：建立类似多级页表的多层索引，使上层索引块指向下一层的索引块，$FCB$中只需要记录顶层索引块即可。若采用多层索引，则各层索引表大小不能超过一个磁盘块，理由同多级页表。采用$K$层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要$K+1$次读磁盘操作。缺点是即使是小文件页需要$K+1$次读磁盘操作。

     5.   混合索引：在一个文件的顶级索引表中采用，是多种索引分配方式的结合。对于小文件，只需较少的读磁盘次数就可以访问目标数据块。

          1.   直接地址索引（直接指向数据块）：直接存放存放直接地址，即文件数据盘块的盘块号。
          2.   一级间接索引（指向单层索引表）：可再利用索引结点中的一个地址项来提供一次间接地址指向单层索引表，图中的一次间址块也就是索引块，系统将分配给文件的多个盘块号记入其中。
          3.   两级间接索引（指向两层索引表）：用一个地址项提供二次间接地址指向两层索引表，系统此时在二次间址块中记入所有一次间址块的盘号。 

          >   例题：每个盘块的大小为$4KB$，索引块大小为$4B$。
          >
          >   文件不大于$4\times10=40KB$时可以直接读出，一个一级间址块中能包含$4KB\div4B=1K=2^{10}$个索引，所以能索引出$2^{10}\times4KB=4MB$的空间。
          >
          >   若文件长度大于$4MB+40KB$时可以使用二级间址块，索引出$4GB$的空间，三级间址能索引出$4TB$的空间

### 文件共享

1.   文件共享：让多个用户共享地使用同一个文件。系统中只有“一份”文件数据，只要某个用户修改了该文件的数据，其他用户也可以看到文件数据的变化 。如果是多个用户都“复制”了同一个文件，那么系统中会有“好几份”文件数据，此时其中一个用户修改了自己的那份文件数据，对其他用户的文件数据并没有影响。
2.   硬链接（基于索引结点的共享方式）：索引结点中设置一个**引用计数值**$count$，用于表示链接到本索引结点上的用户目录项数。当新文件建立时，一般默认引用计数值为$1$。硬链接的查找速度要比软链接的快。源文件和硬链接的两个进程各自维护自己的文件描述符，读写指针位置不一定相同。
     1.   创建硬链接：与被链接文件指向同一个索引结点，**引用计数值**$count+1$。由于指向同一个索引结点，此时硬链接和源文件可以视为一个文件，或者说**新创建的硬链接和原来的被链接文件互为硬链接和被链接文件**。
     2.   删除硬链接/被链接文件：先把用户目录中与该文件对应的目录项删除，且**引用计数值**$count-1$。若$count>0$，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空。当$count=0$时系统负责删除文件。
3.   软链接（基于符号链的共享方式）：通过创建一个指向目标文件或目录的$Link$类型的特殊文件来实现的，相当于$Windows$中的快捷方式。软链接是一个独立的文件实体，它有自己独立的文件名和属性，软链接和被链接文件指向不同的索引结点。软链接可以跨越不同的文件系统。软链接可以指向文件或目录，因此可以用于创建对目录的链接。
     1.   创建软链接/删除软链接/删除被链接文件：$count$直接复制，文件的**引用计数值**$count$均不会改变。
     2.   软链接的**引用计数值**$count$：记录的是链接到**被链接文件的索引结点**的用户目录项数，即只要文件没有被完全删除，软链接的**引用计数值**$count$就等于被链接文件和硬链接的总数（忽略所有软链接）。

### 目录系统

#### 目录概述

1.   目录：$FCB$的有序集合称为文件目录，一个$FCB$就是一个文件目录项。与文件管理系统和文件集合相关联的是文件目录，它包含有关文件的属性、位置和所有权等。 
2.   目录管理的基本要求
     1.   实现"按名存取”：从用户的角度看，目录在用户(应用程序)所需要的文件名和文件之间提供一种映射。实现用户对文件的按名存取，系统先利用用户提供的文件名形成检索路径，对目录进行检索。 在顺序检索中，路径名的一个分量未找到，说明路径名中的某个目录或文件不存在，不需要继续检索。
     2.   提高对目录的检索速度：目录存取的效率直接影响到系统的性能。
     3.   提供用于控制访问文件的信息：在多用户系统中，应允许多个用户共享一个文件。
     4.   允许不同用户对不同文件采用相同的名字：以便于用户按自己的习惯给文件命名。目录管理通过树形结构来解决和实现。

#### 目录结构

1.   单级目录结构：整个系统中只建立一张目录表。当访问一个文件时，先按文件名在该目录中查找到相应的$FCB$，经合法性检查后执行相应的操作。不允许文件重名，查找速度慢，不便于文件共享。
2.   两级目录结构：允许不同用户的文件重名，文件名虽然相同，但是对应的其实是不同的文件。用户不能对自己的文件进行分类，缺乏灵活性。
     1.   主文件目录$MFD$（$Master\;File\;Directory$）：每项记录用户名及相应用户文件目录所在的存储位置。
     2.   用户文件目录$UFD$（$User\;Flie\;Directory$）：由该用户的文件$FCB$组成，当某用户欲对其文件进行访问时，只需搜索该用户对应的$UFD$，这既解决了不同用户文件的“重名”问题，又在一定程度上保证了文件的安全。
3.   多级目录结构/树形目录结构：不同目录下的文件可以重名，可以明显地提高对目录的检索速度和文件系统的性能。不便于实现文件的共享，且查找文件需要逐级访问影响速度，磁盘访问次数较多，会影响查询速度。
     1.   绝对路径：从根目录出发的路径。每次都从根目录开始查找，比较低效。
     2.   相对路径：从当前目录出发的路径。相对路径由从当前目录出发到所找文件通路上所有目录名与数据文件名用分隔符链接而成。
4.   无环图目录结构：在树形目录结构的基础上，增加一些指向同一节点的有向边，使整个目录成为一个有向无环图。可以更方便地实现多个用户间的文件共享。
     1.   共享计数器：用于记录此时有多少个地方在共享该结点。用户提出删除结点的请求时，只是删除该用户的$FCB$并使共享计数器减$1$，并不会直接删除共享结点，当且仅当共享计数器计数为$0$时才真正删除节点。
     2.   共享文件不同于复制文件，在共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化。

### 文件系统管理

1.   文件系统的系统层次结构
     1.   设备：最底层结构。
     2.   $I/O$控制：包括设备驱动程序和中断处理程序，在内存和磁盘系统之间传输信息。
     3.   基本文件系统/物理文件系统：需要把上一层提供的文件逻辑地址转换为实际的物理地址，并向对应的设备驱动程序发送通用命令，以读取和写入磁盘的物理块。
     4.   文件组织模块：将记录号转换为对应的逻辑地址。
     5.   逻辑文件系统/文件目录系统：管理文件目录，管理元数据信息。需要根据用户给出的文件路径找到相应的$FCB$或索引结点。所有和目录、目录项相关的管理工作都在本层完成，如管理活跃的文件目录表、管理打开文件表等。
     6.   应用程序：与用户交互，最顶层结构。
2.   物理格式化：即低级格式化。划分扇区，检测坏扇区，并用备用扇区替换坏扇区。
3.   逻辑格式化：划分磁盘分区（分卷$Volume$)，完成各分区的文件系统初始化。
4.   **系统打开文件表**：包含每个打开文件的$FCB$副本及其他信息。
5.   **进程打开文件表**：包含一个指向整个系统的打开文件表中的适当条目的指针与其他信息。

#### 文件系统磁盘结构

1.   主引导记录$MBR$（$Master\;Boot\;Record$）：位于磁盘的$0$号扇区，用于引导计算机。$MBR$后面是分区表，该表给出每个分区的起始和结束地址，表中的一个分区被标记为活动分区。当计算机启动时，$BIOS$读入并执行$MBR$。$MBR$做的第一件事是确定活动分区，读入它的第一块，即引导块。
2.   引导块（$boot\;block$）：$MBR$执行引导块中的程序后，该程序负责启动该分区中的操作系统。
3.   超级块（$super\;block$）：包含文件系统的所有关键信息。在计算机启动时，或者在该文件系统首次使用时，超级块会被载入内存。超级块中的典型信息包括分区的块的数量、块的大小、空闲块的数量和指针、空闲的$FCB$数量和$FCB$指针等。能够迅速找到若干个空闲块。在对卷中的文件进行操作前，超级块需要预先读入系统空闲的主存，并且经常保持主存超级块与磁盘卷中超级块的一致性。
4.   $INODE$区（$inode\; area$)：是指在文件系统中用于存储**索引节点$inode$**的特定区域。

#### 外存空闲空间管理

1.   存储空间管理：即如何找到空闲盘块，并对其管理。

2.   空闲表法：属于连续分配方式，与内存的动态分配方式类似，为每个文件分配一块连续的存储空间。外存上的所有空闲区建立一张空闲表， 每个空闲区对应一个空闲表项。

     1.   分配磁盘块：首次适应、最佳适应、最坏适应等算法。

          首次适应：放进**第一个可以装**的空闲区间，再将该盘区分配给用户，同时修改空闲盘块表。 

          最佳适应：放进**满足需求且最小**的空闲区间，再将该盘区分配给用户，同时修改空闲盘块表。 

          最坏适应：放进**满足需求且最大**的空闲区间，再将该盘区分配给用户，同时修改空闲盘块表。 

     2.   回收磁盘块：与内存管理中的动态分区分配很类似。

          新增空闲盘块表表项：回收区的前后都没有相邻空闲区。

          空闲盘块表表项数减一：回收区的前后都是空闲区。

          空闲盘块表表项数不变：回收区前面是空闲区或回收区后面是空闲区。

3.   空闲链表法：将所有空闲盘区拉成一条空闲链。

     1.   空闲盘块法：将磁盘上的所有空闲空间以盘块为单位拉成一条链。适用于**离散分配**的物理结构，为文件分配多个盘块时可能要重复多次操作。
          1.   分配磁盘块：若某文件申请$K$个盘块，则从链头/链首开始依次摘下$K$个盘块分配，并修改空闲链的链头指针。
          2.   回收磁盘块：回收的盘块依次挂到链尾，并修改空闲链的链尾指针。
     2.   空闲盘区法：将磁盘上的所有空闲盘区（每个盘区可包含若干个盘块）拉成一条链。离散分配、连续分配都适用。为一个文件**分配多个盘块**时**效率更高**。与空闲盘块法相反，分配与回收的过程比较复杂，但效率通常较高，且空闲盘区链较短。
          1.   分配磁盘块：若某文件申请$K$个盘块，则可以采用首次适应、最佳适应等算法，从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区，分配给文件。通常采用首次适应算法。若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件。
          2.   回收磁盘块：若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾。

4.   位示图法：利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。位示图一般用连续的“字”来表示，位号表示一个字中的第几位（**列数**），字号表示第几个字（**行数**）。离散分配、连续分配都适用。

     1.   若盘块号、字号、位号从$0$开始，若$n$表示字长，$b$表示盘块号，(字号，位号)=$(i，j)$则
          1.   字位号$\to$盘块号：$b_0  = n\times i+j$
          2.   盘块号$\to$字位号：$i_0  = b\div n,j_0  = b\%n$
     2.   若盘块号、字号、位号从$0$开始，若$n$表示字长，$b$表示盘块号，(字号，位号)=$(i，j)$则
          1.   字位号$\to$盘块号：$b_1  = n\times(i-1)+j$
          2.   盘块号$\to$字位号：$i_1  = (b-1)\div n,j_1 = (b-1)\%n$
     3.   分配磁盘块：若文件需要$K$个块，顺序扫描位示图，找到$K$个相邻或不相邻的“$0$”，根据字号、位号算出对应的盘块号，将相应盘块分配给文件，修改位示图，令将相应位设置为“$1$”。
     4.   回收磁盘块：根据回收的盘块号计算出对应的字号、位号，修改位示图，将相应二进制位设为“$0$”。

5.   成组链接法：把顺序的$n$个空闲盘块号保存在第一个成组链块中，其最后一个空闲盘块（作为成组链块）则用于保存另一组空闲盘块号，如此继续，直至所有空闲盘块均予以链接。系统只需保存指向第一个成组链块的指针。

     1.   盘块的分配：根据第一个成组链块的指针，将其对应的盘块分配给用户，然后将指针下移一格。若该指针指向的是最后一个盘块（即成组链块），由于该盘块记录的是下一组空闲盘块号，因此要将该盘块读入内存，并将指针指向新的成组链块的第一条记录，然后执行上述分配操作。
     2.   盘块的回收： 成组链块的指针上移一格，再记入回收盘块号。当成组链块的链接数达到n时，表示已满， 便将现有已记录n个空闲盘块号的成组链块号记入新回收的盘块（作为新的成组链块）。


#### 虚拟文件系统$VFS$

1.   虚拟文件系统$VFS$：统一调用函数，为用户程序提供了文件系统操作的统一接口，屏蔽不同文件系统的差异和操作细节，而不需要关心底层文件系统的具体实现。
     1.   虚拟文件系统采用了**面向对象**的思想，它抽象出一个通用的文件系统模型，定义了通用文件系统都支持的接口。新的文件系统只要支持并实现这些接口，即可安装和使用。
     2.   严格来说，$VFS$并不是一种实际的文件系统，它只存在于内存中，不存在于任何外存空间中。
     3.   $VFS$可以提高系统性能：最近最常使用的目录项对象被放在目录项高速缓存的磁盘缓存中，以加速从文件路径名到最后一个路径分量的索引结点的转换过程。
2.   $VFS$的四个对象
     1.   超级块对象：表示已安装或挂载的特定文件系统。
     2.   索引结点对象：表示一个特定的文件。
     3.   目录项对象：表示特定的目录项。
     4.   文件对象：表示一个与进程相关的已打开文件。

3.   操作系统的引导：$Linux$启动后，首先载入$MBR$，随后$MBR$识别活动分区，并且加载活动分区中的引导程序。
     1.   分区的第一部分是引导块，里面存储着**引导信息**，它有自身的格式，因为在引导时系统并未加载文件系统代码，因此不能解释文件系统的格式。
     2.   引导信息是一系列可以加载到内存中的连续块，加载到内存后从其第一条代码开始执行，引导程序便启动一个具体的操作系统。

     3.   引导块之后是超级块，它存储文件系统的有关信息，包括文件系统的类型、`i结点`的数目、数据块的数目。

     4.   随后是多个索引结点`i结点`，它们是实现文件存储的关键，每个文件对应一个索引结点，索引结点中包含多个指针，指向属于该文件的各个数据块。

     5.   最后是文件数据块。
4.   文件系统挂载($mounting$：一个磁盘可以划分为多个分区，每个分区都可以用于创建单独的文件系统，每个分区还可以包含不同的操作系统。文件系统在进程使用前必须先安装，也称**挂载**。
     1.   在$VFS$中注册新挂载的文件系统内存中的挂载表($mount\;table$)包含每个文件系统的相关信息，包括文件系统类型、容量大小等。
     2.   新挂载的文件系统，要向$VFS$提供一个函数地址列表
     3.   将新文件系统加到挂载点($mount\; point$)，也就是将新文件系统挂载在某个父目录下

