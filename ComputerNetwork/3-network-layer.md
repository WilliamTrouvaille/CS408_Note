# 第四章 网络层

## 导读

### 【考纲内容】

1.   网络层的功能
     +   异构网络互连
     +   路由与转发
     +   $SDN$基本概念；
     +   拥塞控制
2.   路由算法
     +   静态路由与动态路由
     +   距离-向量路由算法
     +   链路状态路由算法
     +   层次路由
3.   $IPv4$
     +   $IPv4$分组
     +   $IPv4$地址与$NAT$
     +   子网划分与子网掩码、$CIDR$、路由聚合、$ARP$、$DHCP$与$ ICMP$
4.   $IPv6$
     +   $IPv6$的主要特点
     +   $IPv6$地址
5.   路由协议
     +   自治系统
     +   域内路由与域间路由
     +   $RIP$路由协议
     +   $OSPF$路由协议
     +   $BGP$路由协议
6.   $IP$组播
     +   组播的概念
     +   $IP$组播地址
7.   移动$IP$
     +   移动$IP$的概念
     +   移动$IP$通信过程
8.   网络层设备
     +   路由器的组成和功能
     +   路由表与路由转发

### 【知识导图】

![f2460bcd775b41009e3329934a4e761e~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307271126256.webp)

### 【复习提示】

+   本章是历年考查的重中之重，尤其是结合第$3$章、第$5$章、第$6$章出综合题的概率很大
+   其中$IPv4$以及路由的相关知识点是核心，历年真题都有涉及，因此必须牢固掌握其原理，也要多做题，以便灵活应用
+   本章的其他知识点，如$IP$组播、移动$IP$、$IPv6$也要有所了解。

## 基本概念

网络层只向上提供简单灵活的、无连接的、尽最大努力交付的数据报服务

主要任务是将**分组**从源端发送到目的端，为分组交换网上的不同主机提供通信服务。在任意结点间进行数据报传输，但不可靠。

### 传输单位

1. 应用层的传输单位是报文。
2. 传输层的传输单位是报文或报文段。
3. 网络层的传输单位是IP数据报或分组。
4. 数据链路层的传输单位是帧。
5. 物理层的传输单位是比特流

### 网络层功能

#### 异构网络互联

+ 网络的异构性是指传输介质、数据编码方式、链路控制协议及不同的数据单元格式和转发机制，即==物理层与数据链路层均不同。==
+ 路由器要求物理层、数据链路层、网络层协议可以不同，但==网络层以上的高层协议必须相同==。
    + 由于路由器无法处理上层数据所以要求上层的协议必须相同。

+ 网络互连是指将两个以上的计算机网络，通过一定的方法，用一些中间设备（又称中继系统）相互连接起来，以构成更大的网络系统。根据所在的层次，中继系统分为以下4种：
    1.   物理层中继系统：转发器，集线器。
    2.   数据链路层中继系统：网桥或交换机
    3.   网络层中继系统：路由器。
    4.   网络层以上的中继系统：网关
+ ==网络互连通常是指用路由器进行网络互连和路由选择==
    + 使用物理层或数据链路层的中继系统时，只是把一个网络扩大了，而从网络层的角度看，它仍然是同一个网络，一般并不称为网络互连。

+ $IP$网络
    + 使用IP协议的虚拟互连网络可简称为IP网络
    + 虚拟互连网络也就是逻辑互连网络，其意思是互连起来的各种物理网络的异构性本来是客观存在的，但是通过IP协议就可以使这些性能各异的网络在网络层上看起来好像是一个统一的网络。
    + 使用IP网络的好处是
        + 当IP网上的主机进行通信时，就好像在一个单个网络上通信一样， 而看不见互连的各网络的具体异构细节
        + 如具体的编址方案、路由选择协议等


#### 路由选择与分组转发

网络层的主要任务是转发和路由选择

+   路由选择即**选择最佳路径**。
    +   “最佳”只能是相对于某一种特定要求下得出的较为合理的选择而已。
        +   一般情况下，最佳默认最短
    +   一般指按照复杂的分布式算法，根据从各相邻路由器所得到的关于整个网络拓扑的变化情况，动态地改变所选择的路由。

+   分组转发即当一个分组到达时所采取的动作
    +   指路由器根据转发表将用户的$IP$数据报从合适的端口转发出去。

+ 路由器的路由表中包含目的网络和到达该目的网络路径上的下一个路由器的$IP$地址。
+ 分组传输时，源主机和中间路由器都不知道$IP$分组到达目的主机需要经过的完整路径。

#### SDN

+   可以将网络层抽象地划分为数据层面（也称转发层面）和控制层面

    +   **转发**是**数据平面**实现的功能
        +   数据平面执行的主要功能是==根据转发表进行转发==，这是路由器的本地动作。

    +   而**控制平面**用于控制和管理网络协议的运行，即**路由选择**
        +   比如$OSPF$协议、$RIP$协议、$BGP$协议。
            +   传统方法/每路由器法
                +   路由选择算法运行在每台路由器中，并且在每台路由器中都包含转发和路由选择两种功能。
                +   在一台路由器中的路由选择算法与其他路由器中的路由选择算法通信（通过交换路由选择报文），计算出路由表和转发表。
                +   ==路由选择处理器执行控制平面功能。==
            +   $SDN$方法
                +   控制平面从路由器物理上分离
                    +   路由器仅实现转发，远程控制器计算和分发转发表以供每台路由器所使用。
                +   路由器通过交换包含转发表和其他路由选择信息的报文与远程控制器通信
                    +   因为计算转发并与路由器交互的控制器是用软件实现的，所以网络是**软件定义的**。
                +   在$SDN$路由器中，路由选择处理器负责于远程控制器通信，目的是接收远程控制器计算的转发表项。
                +   ==远程控制器执行控制平面功能==

+   软件定义网络$SDN$是近年流行的一种创新网络架构，它采用集中式的控制层面和分布式的数据层面，两个层面相互分离，控制层面利用控制-数据接口对数据层面上的路由器进行集中式控制，方便软件来控制网络。

![23July31-125848-1690779528-71cf5022-d314-4c84-b8c3-2580832d1e79](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307311259619.png)

+   $SDN$控制器的三个层次
    1.   对于网络控制应用程序的接口：
         +   $SDW$控制器通过**北向按口/北向$API$**与网络控制应用序交互
             +   $Northbound API$层是$SDN$控制器向上提供的接口，用于与上层应用程序或网络服务进行交互
             +   这些应用程序可以是网络管理应用、安全应用、负载均衡应用、流量监测应用等
             +   $Northbound API$层为上层应用程序提供了一系列的编程接口，使得应用程序能够与$SDN$控制器交互，控制和管理网络资源。
         +   该$API$允许网络控韩制应用圉序在状态管理层之间读写网络状态。
    2.   网络范围状态管理层：
         +   由$SDN$**控制平面**作出的最终控制决定，将要求$SDN$控制器具有有关网络的主机链路等最新状态信息。
             +   **控制平面**负责执行$SDN$控制器的逻辑功能，包括网络拓扑发现、路径计算、流表下发等
             +   网络状态数据库用于存储网络拓扑、设备配置信息和流表信息等，以便控制平面进行网络资源管理和控制。
    3.   通信层：
         +   $SDN$控制器与受控网络设备之间的通信($OpenFlow$协议)，包含**南向接口/南向$API$**
             +   $Southbound API$层是$SDN$控制器向下提供的接口，用于与网络设备（例如交换机、路由器）进行通信和控制
             +   这些设备支持$OpenFlow$协议或其他$SDN$兼容的协议，通过$Southbound API$与$SDN$控制器进行交互
             +   $SDN$控制器使用$Southbound API$来下发控制指令、获取网络状态信息，并对网络设备进行配置和管理。
+   在传统互联网中，每个路由器既有转发表又有路由选择软件，也就是说，既有数据层面又有控制层面。

+   在$SDN$中不需要路由选择软件，所以不需要路由器之间交换路由信息
    +   而是由网络的控制层面的一个逻辑上的远程控制器进行控制
    +   其掌握主机和网络状态，分析最佳路由，通过$Openflow$协议等将转发表（流表）下发给路由器
    +   路由器只需要收到分组、查找转发表、转发分组。


特点：

+ 控制和转发功能分离。
+ 控制层面集中化。
+ 接口开放可编程。

优点：

+ 全局集中式控制和分布式高速转发，既利于控制层面的全局优化，又利于高性能的网络转发。
+ 灵活可编程与性能的平衡，控制和转发功能分离后，使得网络可以由专有的自动化工具以编程方式配置。
+ 降低成本，控制和数据层面分离后，尤其是在使用开放的接口协议后，就实现了网络设备的制造与功能软件的开发相分离，从而有效降低了成本。

缺点：

+ 安全风险，集中管理容易受攻击，如果崩溃，整个网络会受到影响。
+ 瓶颈问题，原本分布式的控制层面集中化后，随着网络规模扩大，控制器可能成为网络性能的瓶颈。

#### 拥塞控制

+ 拥塞定义：
    + 在通信子网中，因出现过量的分组而引起网络性能下降的现象称为拥塞

+ 拥塞分类
    + 如果网络负载增加，网络吞吐量**明显小于正常吞吐量**，则进入**轻度拥塞**。
    + 如果网络负载增加，网络吞吐量**反而下降**，则进入**拥塞**。
    + 如果网络负载增加，网络吞吐量**变为零**，则进入**死锁**。
+ 拥塞避免
    + 为避免拥塞现象的出现，要采用能防止拥塞的一系列方法对子网进行拥塞控制
    + 拥塞控制主要解决的问题是如何获取网络中发生拥塞的信息，从而利用这些信息进行控制，以避免由于拥塞而出现分组的丢失，以及严重拥塞而产生网络死锁的现象

+ 拥塞控制
    + 拥塞控制的作用是确保子网能够承载所达到的流量
        + 这是一个全局性的过程，涉及各方面的行为：主机、路由器及路由器内部的转发处理过程等
        + 单一地增加资源并不能解决拥塞

    + 流量控制和拥塞控制的区别：
        + 流量控制往往是指在发送端和接收端之间的点对点通信量的控制
            + 流量控制所要做的是抑制发送端发送数据的速率，以便使接收端来得及接收

        + 而拥塞控制必须确保通信子网能够传送待传送的数据，是一个全局性的问题，涉及网络中所有的主机、路由器及导致网络传输能力下降的所有因素。 

    + 拥塞控制的方法有两种
        1.   开环控制：在拥塞之前就提前设计解决。
             +   这是一种静态的预防方法。一旦整个萦统启动并运行，中途就不再需要修改。
             +   开环控制手段包括确定何时可接收新流量、何时可丢弃分组及丢弃哪些分组，确定何种调度策略等
             +   所有这些手段的共性是，在做决定时不考虑当前网络的状态。
        2.   闭环控制：在拥塞时自动调整解决问题。
             +   事先不考虑有关发生拥塞的各种因素，采用监测网络系统去监视，及时检测哪里发生了拥塞，然后将拥塞信息传到合适的地方,以便调整网络系统的运行，并解决出现的问题
             +   闭环控制是基于反馈环路的概念，是一种动态的方法。


## 路由算法与协议

路由算法就是让路由知道收到报文之后下一步怎么走。

路由器分组是通过路由表来转发，而路由表由路由算法给出。

+ 路由选择分为直接交付和间接交付。
+ 当发送站与目的站在同一网段（子网号相同）内时，就使用直接交付。直接交付不涉及到路由器。
+ 反之使用间接交付，间接交付最后一个路由器肯定是直接交付。

### 路由算法与协议概述

+ 静态路由算法（非自适应路由算法）：
    + 管理员手工配置路由信息。
    + 简便、可靠，==在负荷稳定，拓扑变化不大的网络中较好==。
    + 适用于高度安全的军事网络与较小的商业网络。
    + ==路由更新慢，不适合用于大型网络==。
+ 动态路由算法（自适应路由算法）：
    + 路由器之间交换信息，按照路由算法优化出路由表。
    + ==路由更新快，适用大型网络==，及时响应链路反应与网络拓扑变化。
    + ==算法复杂，加重网络负担==。

对于动态路由算法，又可以分为

+   全局性：链路状态路由算法$\sim OSPF$
    +   所有路由器掌握完整的网络拓扑和链路费用信息。
+   分散性：距离-向量路由算法$\sim RIP$
    +   路由器只掌握物理相连的邻居及链路费用

### RIP协议

+ 路由信息协议$RIP$（$Routing\; Information\; Protocol$）是一种内部网关协议$IGP$，是一种分布式的基于**距离-向量路由算法**的路由选择协议，最大的优点是简单。
+ 在距离-向量路由算法中，所有结点都定期地将它们的整个路由选择表传送给所有与之直接相邻的结点。
    + 要求网络中的每一个路由器都维护从它到其他每一个目的网络的唯一最佳路径（即一组距离）。
    + 这种路由选择表包含：
        + 每条路径的目的地（另一结点）。
        + 路径的代价（也称距离）
            + 距离通常指跳数，即从源端口到目的端口所经过的路由器个数，经过一个路由器跳数$+1$，与路由器直接连接的网络距离为$1$。$RIP$允许一条路最多只能包含$15$个路由器，所以$16$表示网络不可达。

+ $RIP$协议只适用于小型互联网。
+ 路由表由目的网络、距离、下一跳路由器三个项目构成。
+ ==$RIP$协议是应用层协议，使用$UDP$传送数据。==
+ 一个$RIP$报文最多只包含$25$个路由，如果超过必须再用多的$RIP$报文传送。

#### RIP协议交换信息

1. 仅和相邻路由器交换信息。
2. 路由器交换的信息是自己的路由表，其中包括每条路径的目的地与路径代价两条信息。
3. 每$30s$就交换一次，如果$180s$没收到相邻路由器的通告就默认这个路由器出现错误，并更新路由表。
4. 最开始路由器只知道直接相连的网络，若干次更新后所有路由器都会知道到达本自治系统中任何网络的信息，即收敛。

#### 距离向量算法

1. 修改相邻路由器发来的$RIP$报文中的所有表项
    +   对地址为$X$的相邻路由器发来的$RIP$报文，修改此报文的所有项目：把下一跳字段中的地址改为$X$，并把所有的距离$+1$。
2. 对修改后的$RIP$报文中的每一个项目都进行以下步骤：
    1. 本路由器路由表中没有该网络，则把这个项目直接填入路由表中。
    2. 本路由器路由表中已经有该网络，则查看下一跳路由器地址。
        +   如果下一跳的路由器名相同，则表明距离更新了，用收到的项目替换原有项目。
        +   如果下一跳的路由器名不同，原来距离更远则更新。
    3. 否则不处理。
3. 若$180s$超时，则把该路由器设为不可达，距离设为$16$。
4. 返回。

#### RIP协议问题

$RIP$协议存在问题：

+ 限制了网络规模。
+ 路由器交换完整的路由表，所以网络规模越大，开销越大。
+ 当网络出现故障时，要经过较长的时间才能将此信息传送到所有的路由器，即出现路由回路问题，称为**慢收敛**
    + ==也叫做好消息传得快，坏消息传得慢。==
    + ==慢收敛是导致发生路由回路的根本原因==


当一个网络故障时，由于坏消息传输的可能较慢，导致故障信息晚于其相邻信息传输的原来正确信息，故障信息被其原来信息覆盖，从而让双方路由器都不断认为通过对方就能达到已经坏掉的网络，直到重复了$16$次才会发现该网络不可达。

解决慢收敛方法：

+ 限制路径最大距离：超过$16$次就认为不可达不再传输。
+ 分割水平线：路由器从某个接口接收到的更新信息不允许再从这个接口发回去。
+ 抑制计时器法：等待足够多的时间（一般$60$秒），已确保所有的机器都收到坏消息，而不会错误的连接过时的报文
    + 需要指出的是，参与$RIP$的机器都要遵循抑制策略，否则任依旧会发生环路
    + 缺点是：如果发生环路，在抑制期内这些路由环路任然会维持下去。

+ 毒性逆转：路由中毒是指在路由信息在路由表中失效时，先将度量值变为无穷大的数，而不是马上从路由表中删掉这条路由信息，然后再将其中毒的路由信息发布出去，这样相邻的路由器收到该中毒路由就可以通过其度量值就得知这条路由的度量值是$16$，说明该路由是无效的
    + 然后收到中毒路由信息的相邻的路由器会发送一个毒性逆转的信息，表示已经收到中毒路由信息。

+ 触发刷新：正常情况下，路由器会基于计时器每$30s$将路由表发送给邻居路由器，而触发更新就是立刻发送路由更新信息
    + 也就是说检测到网络故障的路由器会直接发送一个更新信息给邻居路由器，并依次产生触发更新通知它们的邻居路由器，此过程就叫触发更新
    + 触发更新这种方式使整个网络上的路由器在最短的时间内收到更新信息。


### OSPF协议

+ 开放最短路径优先协议$OSPF$（$Open \;Shortest \;Path\; First$）是一种内部网关协议$IGP$，是基于**链路状态路由算法**的路由选择协议。
+ 开放最短路径优先协议的开放指$OSPF$协议是开放的，$SPF$是指最短路径算法。
+ $OSPF$协议是网络层（或传输层）协议，使用$IP$数据报传输。
+ $OSPF$对不同的链路可根据$IP$分组的不同服务类型（$TOS$）而设置成不同的代价
    + 因此，$OSPF$对于不同类型的业务可计算出不同的路由，十分灵活。

+ 如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。这称为**多路径间的负载平衡**。
+ 所有在$OSPF$路由器之间交换的分组都具有鉴别功能，因而保证了仅在可信赖的路由器之间交换链路状态信息。
+ 支持可变长度的子网划分和无分类编址$CIDR$。
+ 每个链路状态都带上一个$32$位的序号，序号越大，状态就越新。
+ 主要优点
    + 每个路由结点都使用同样的原始状态数据独立地计算路径，而不依赖中间结点的计算
    + 链路状态报文不加改变地传播，因此采用该算法易于查找故障。
    + 当一个结点从所有其他结点接收到报文时，它可以在本地立即计算正确的通路，保证一步汇聚。
    + 由于链路状态报文仅运载来自单个结点关于直接链路的信息，其大小与网络中的路由结点数目无关
        + 因此==链路状态算法比距离-向量算法有更好的规模可伸展性==。 


#### 与RIP协议的区别

+ $OSPF$向本自治系统中的所有路由器发送信息，这里使用的方法是洪泛法
    + 而$RIP$仅向自己相邻的几个路由器发送信息。
        + $RIP\sim$距离-向量路由算法有可能遇到路由环路

+ $OSPF$发送的信息是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。
    + 而在$RIP$中，发送的信息是本路由器所知道的全部信息，即整个路由表。

+ $OSPF$只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息，并且更新过程收敛得快，不会出现$RIP$“坏消息传得慢”的问题
    + 而在$RIP$中，不管网络拓扑是否发生变化，路由器之间都会定期交换路由表的信息。

+ $OSPF$是网络层协议，它不使用$UDP$或$TCP$，而直接用$IP$数据报传送（其$IP$数据报首部的协议字段为$89$）
    + 而$RIP$是应用层协议，它在传输层使用$UDP$。

+ $OSPF$中每个路由结点都使用同样的原始状态数据独立地计算路径，而不依赖中间结点的计算
    + 而$RIP$依赖中间结点的计算


#### OSPF协议交换信息

1. 使用洪泛法向自治系统内所有路由器发送信息
    +   即路由器通过输出端口向所有相邻的路由器发送信息，而每一个相邻路由器又再次将此信息发往其所有的相邻路由器
        +   但不再发送给刚刚发来信息的那个路由器
    +   最终整个区域内所有路由器都得到了这个信息的一个副本。
2. 发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息
    +   本路由器和哪些路由器相邻，以及该链路的度量/代价——费用、距离、时延、带宽等
3. 路由器根据全网拓扑结构图使用$Dijkstra$最短路径算法计算自己到各目的网络的最优路径，构建新的路由表。（只存储下一跳）
4. 只有当链路状态发生变化时，路由器才向所有路由器洪泛发送此信息。
5. 最后，所有路由器都能建立一个链路状态数据库，即全网拓扑图。

#### 链路状态路由算法

涉及到$OSPF$的五种分组类型：

1. 每个路由器发现它的邻居结点**HELLO问候分组**（用于发现和维持邻站的可达性），并了解邻居节点的网络地址。
2. 设置到它的每个邻居的成本度量$metric$。
3. 构造**DD数据库描述分组**，向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息。
4. 如果$DD$分组中的摘要自己都有，则邻站不做处理；如果有没有的或者是更新的，则发送**LSR链路状态请求分组**请求自己没有的和比自己更新的信息。
5. 收到邻站的$LSR$分组后，发送**LSU链路状态更新分组**，使用洪泛法对全网链路进行更新。
6. 更新完毕后，邻站返回一个**LSAck链路状态确认分组**进行确认。
7. 根据$Dijkstra$算法与自己的链路状态数据库构造到其他结点之间的最短路径。
8. 用**HELLO问候分组**分组保持与邻居的连接。

当一个路由器的链路状态发生变化时，就会重复$5$及其之后的步骤。

通常隔$10$秒相邻两个路由器就要交换一次问候分组。且还要每隔一段时间如$30$分粥就要刷新依次数据库中的链路状态。

#### OSPF协议的区域

为了使$OSPF$能够用于规模很大的网络，$OSPF$将一个自治系统再划分为若干个更小的范围，叫做**区域**。每一个区域都有一个$32$位的区域标识符（用点分十进制表示）。

区域也不能太大，在一个区域内的路由器最好不超过$200$个。

一个区域内的路由器只知道本区域内的完整网络拓扑。

处在上层的区域位主干区域，负责连通其他下层的区域和其他自治域。

路由器分为：

+ 主干路由器（可以兼任）。
+ 区域内部路由器。
+ 区域边界路由器。
+ 自治系统边界路由器。

### 层次路由

+   当网络规模扩大时，路由器的路由表成比例地增大。这不仅会消耗越来越多的路由器缓冲区空间，而且需要用更多$CPU$时间来扫描路由表，用更多的带宽来交换路由状态信息。因此路由选择必须按照层次的方式进行。

+   且由于因特网规模大，而许多单位不想让外界知道自己的路由选择协议但是仍想接入因特网，所以就出现了自治系统$AS$。

    +   自治系统$AS$:在单一的技术管理下的一组路由器，而这些路由器使用一种$AS$内部的路由选择协议和共同的度量以确定分组在该$AS$内的路由，同时还使用一种$AS$之间的路由协议以确定在$AS$之间的路由。
        +   自治系统$AS$就是多个使用同一种内部选择路由的协议的路由器之间构成的单独的小圈子，圈子内使用自己的协议，圈子和圈子之间也需要另一种$AS$协议。

    +   一个$AS$内的所有网络都属于一个行政单位来管辖，一个自治系统的所有路由器在本自治系统内都必须连通。


+   每个自治系统$AS$​都有权自主地决定本系统内应采用何种路由选择协议，如果两个自治系统需要通信，那么就需要一种在两个自治系统之间的协议来屏蔽这些差异。据此，因特网把路由选择协议划分为两大类
    +   内部网关协议$IGP$：一个自治系统内部所使用的路由选择协议
        +   $RIP$
        +   $OSPF$
    +   外部网关协议$EGP$​：自治系统之间所使用的路由选择协议，用于不同自治系统的路由器之间交换路由信息，并负责为分组在不同自治系统之间选择最优的路径
        +   $BGP$
+   使用层次路由时，$OSPF$将一个自治系统再划分为若干区域$Area$，每个路由器都知道在本区域内如何把分组路由到目的地的细节，但不用知道其他区域的内部结构。
+   采用分层次划分区域的方法虽然会使交换信息的种类增多，会使$OSPF$协议更加复杂。但这样做却能使每个区域内部交换路由信息的通信量大大减小，因而使$OSPF$协议能够用于规模很大的自治系统中。

## IP协议

![PdfImage](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307311105740.png)

网际协议是$TCP/IP$协议栈中两个最主要的协议。与之配套的还有地址解析协议$ARP$，网际控制报文协议$ICMP$、网际组管理协议$IGMP$，还有一个逆地址解析协议$RARP$已不被使用。

![TCPIP协议栈](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307311056423.jpg)

$IP$协议使用$ARP$协议，而$ICMP$与$IGMP$使用$IP$协议。

### IP数据报

#### IP数据报格式

![IP数据报格式](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307311056823.png)

当单个$IP$数据报太长，就会被划分不同的数据部分加上$IP$首部，就是分组。

固定部分$20B=160bit$，按照五行来展示而不是真的这样排列，一行$32$比特。

![IP数据报具体格式](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307311056592.png)

|              名称               |                             注释                             |            大小             |
| :-----------------------------: | :----------------------------------------------------------: | :-------------------------: |
|          版本 Version           |                         ipv4或者ipv6                         |             4位             |
|          首部长度 IHL           | ==单位为4字节==(即首部总长=首部长度字段值$\times4B$,下同)，同时因为IP数据报固定长度（最小值）为20字节，所以此处最小值为5，即二进制的0101 |             4位             |
|       区分服务 DSCP + ECN       |                 希望获得哪种服务，用的比较少                 |             8位             |
|       总长度 Total Length       | 首部和数据之和的长度，==单位为1字节==，最大为$2^{16}-1=65535B$，但是实际上永远不会达到该长度，因为有$MTU$的限制 |            16位             |
|       标识 Identification       | 就是一个计数器，用来表示是哪一个数据报的分片，==同一个数据报的分片标识相同== |             8位             |
|           标志 Flags            | 3bit，用来表示是否分片和分片是否结束；中间位DF（Don't Fragment）为1表示禁止分片，如果是0代表允许分片；最低位MF（More Fragment）为1表示后面还有分片，如果为0表示最后一片分片 | 3位，但实际有用的只有后两位 |
|     片偏移 Fragment Offset      | 用来标记分片之后，该分片在原来的数据报的位置，==以8字节为单位== |            13位             |
|      生存时间 Time To Live      | 即TTL，每经过一个路由器TTL-1，等于0时自动放弃，根据系统不同默认的TTL不同，为了防止无法传输的数据报在链路中无限传输 |             8位             |
|          协议 Protocol          | 用来标记数据部分协议名的字段值，如ICMP：1；IGMP：2；==TCP：6==；EGP：8；IGP：9；==UDP：17==；IPv6：41；ESP：50；OSPF：89 |             8位             |
|   首部检验和 Header Checksum    |  检验首部的字段是否出错，不包括数据部分，出错就丢弃此数据报  |            16位             |
|    源地址 Source IP Address     |                         发送方ip地址                         |            32位             |
| 目的地址 Destination IP Address |                         接收方ip地址                         |            32位             |
|        可选字段 Options         |                      用来排错等安全检测                      |      可在0-40字节之间       |
|              填充               |           将数据报对齐成4字节的整数倍，数值全部为0           |   未知，根据可选字段来定    |

由于$IP$具有标识，所以重传的数据不能与之前的数据进行重组。

数据部分永远在 4 字节的整数倍开始，这样在实现 IP 协议时较为方便。

<span style="color:orange">注意：</span>由于片偏移为$8$的整数倍，所以分片后的数据报的数据部分长度必须在小于$MTU-20B$的前提下为$8$的整数倍。

>   在IP数据报首部中有三个关于长度的标记，==首部长度、总长度、片偏移，基本单位分别为4B、1B、8B== （需要记住）。题目中经常会出现这几个长度之间的加减运算。另外，读者要熟悉IP数据报首部的各个字段的意义和功能，但不需要记忆IP数据报的首部，正常情况下如果需要参考首部，题目都会直接给出。第5章学到的TCP、UDP的首部也是一样的

#### IP数据报分片

+ 由于为$IP$数据报被封装在链路层数据报中，故数据链路层的最大传送单元$MTU$严格地限制着$IP$数据报的长度
    + 以太网的$MTU$是$1500$字节。
        + 由于首部长$20B$，则数据部分长$1420B$
    
    + 许多广域网的$MTU$不超过$576B$
    + 在$IP$数据报的源与目的地路径上的各段链路可能使用不同的链路层协议，有不同的$MTU$
    
+ 当$IP$分组超过$MTU$时为了传输就必须要分片，而如果$IP$分组不允许分片则无法传输，会返回上层一个差错报告。
+ $IP$首部中的标志位$ Flags$后两位$DF$和$MF$。
    + 当`DF = 0`时，该$IP$数据报才可以被分片
    + $MF$则用来告知目的主机该$IP$数据报是否为原始数据报的最后一个片
        + 当`MF = 1`时，表示相应的原始数据报还有后续的片
        + 当`MF = 0`时，表示该数据报是相应原始数据报的最后一个片

    + 目的主机在对片进行重组时，使用片偏移字段$Fragment Offset$来确定片应放在原始$IP$数据报的哪个位置

+ 除了最后一个分片，其他所有片中的有效数据载荷都是8的倍数

<span style="color:orange">注意：</span>$MF=0$不能确定是独立的数据报，还是分片得来的，只有当$MF=0$且片段偏移字段$=0$时，才能确定是独立的$IP$数据包。

>   路由器在接收到分组后，剥离该分组的数据链路层协议头，然后在分组被转发之前， 给分组加上一个新的链路层协议头

### IP地址

默认指$IPv4$地址，全世界唯一的$32$位/$4$字节标识符，标识路由器主机的接口。$IP$地址={网络号,主机号}。

#### IP地址类别

$IP$地址一共分为五类。

![IP地址类别](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307311057153.png)

其中一些$IP$地址被予以保留做特殊用途：

![特殊IP地址](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307311057001.jpg)

+   全$1$的广播地址也称为受限广播地址。
    +   原本表示整个$TCP/IP$网络的广播地址
    +   实际使用时，由于路由器对广播域的隔离，`255.255.255.255`等效为本网络的广播地址

+   `127.x.x.x`保留为环回自检（Loopback Test）地址，此地址表示任意主机本身，目的地址为环回地址的IP数据报永远不会出现在任何网络上。

由于网络号不能全$0$或全$1$，所以基本上可用的都要减二。

![23July31-215755-1690811875-c3b497c5-e0d0-4798-8cd3-ffffaeed7b20](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307312157977.png)

为什么$A$类最大是$126.x.x.x$？

因为网络号最开始第一位是$0$，一共八位，所以二进制表示位$0xxxxxxx$，最大就是$2^7-1=127$，但是因为$127.x.x.x$是特殊$IP$地址，所以将其去掉。

为什么$B$类最大是$191.255.x.x$？

因为网络号最开始第一位是$10$，一共八位，所以二进制表示位$10xxxxxx$，最大就是$10111111=191$，最小就是$10000000=128$，无特殊$IP$地址。

为什么$C$类最大是$223.255.x.x$？

因为网络号最开始第一位是$110$，一共八位，所以二进制表示位$110xxxxx$，最大就是$11011111=223$，最小就是$10000000=192$，无特殊IP地址。

#### IP地址特点

+ 每个$IP$地址都由网络号和主机号两部分组成，因此$IP$地址是一种分等级的地址结构。分等级的好处是：
    + $IP$地址管理机构在分配$IP$地址时只分配网络号（第一级)，而主机号（第二级）则由得到该网络的单位自行分配，方便了$IP$地址的管理。
    + 路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目标主机号），从而减小了路由表所占的存储空间。
+ $IP$地址是标志一台主机（或路由器）和一条链路的接口
    + 当一台主机同时连接到两个网络时，该主机就必须同时具有两个相应的$IP$地址，每个$IP$地址的网络号必须与所在网络的网络号相同，且这两个$IP$地址的网络号是互相**不同**的
    + 因此==$IP$网络上的一个路由器必然至少应具有两个$IP$地址==（路由器每个端口必须至少分配一个$IP$地址）
        + 不然会冲突。
    
+ 用转发器或桥接器（网桥等）连接的若干$LAN$仍然是同一个网络（同一个广播域）
    + 因此该$LAN$中所有主机的$IP$地址的网络号必须相同，但主机号必须不同。

+ 在$IP$地址中，所有分配到网络号的网络（无论是$LAN$还是$WAN$）都是平等的。
+ 路由器对目的地址是私有$IP$地址的数据报一律不进行转发。
+ 在同一个局域网上的主机或路由器的$IP$地址中的网络号必须是一样的
    + 路由器总是具有两个或两个以上的$IP$地址，路由器的每个端口都有一个不同网络号的$IP$地址。


### 专用网络通信

#### NAT

+   网络地址转换$NAT$是指通过将专用网络地址（如内部网络$Intranet$）转换为公用地址（如因特网$Internet$），从而对外隐藏内部管理的$IP$地址。它使得整个专用网只需要一个全球$IP$地址就可以与因特网连通，由于==专用网本地$IP$地址是可重用的==，所以$NAT$大大节省了$IP$地址的消耗。同时，它隐藏了内部网络结构，从而降低了内部网络受到攻击的风险。

+   在进行$NAT$转发的时候必须保证内网地址与网络端口都一致，否则不转发。

+   此外，为了网络安全，划出了部分$IP$地址为私有$IP$地址

    +   私有$IP$地址只用于局域网$LAN$，不用于广域网$WAN$连接

        +   因此私有$IP$地址不能直接用于因特网$Internet$
        +   必须通过网关利用$NAT$把私有$IP$地址转换为因特网$Internet$中合法的全球$IP$地址后才能用于因特网$Internet$

        >   广域网$WAM$，局域网$LAN$

    +   并且允许私有$IP$地址被局域网$LAN$重复使用。

私有$IP$地址（可重用$IP$地址）如下：

![私有IP地址](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307311057722.png)

+   在**因特网$Internet$**中的所有路由器，对目的地址是私有地址的数据报一律不进行转发
    +   这种采用私有$IP$地址的互联网络称为专用互联网或本地互联网
    +   私有$IP$地址也称可重用地址。
    +   如果局域网$LAN$没有接入因特网，那么在局域网内部的路由器或交换机通常会对目的地址是私有地址的数据报进行转发
        +   因为在局域网$LAN$内部使用私有地址是合理的，并且这些私有地址在局域网范围内是有效的，可以用于内部通信。
+   私有$IP$地址也叫做可重用地址，不同于一般的全球$IP$地址，这些地址可以在机构内部自行分配使用，这张网络就是专用互联网或是本地互联网，当然也无法直接用于与因特网的通信。
    +   不同的两个局域网$LAN$中可能存在两个相同的$IP$地址

+ 如果专用网的内部某些主机已经分配到了本地专用$IP$地址，又想无加密的跟互联网上的主机通信，就需要网络地址转换$NAT$。
+ 只用在专用网与因特网的路由器上按照$NAT$软件，安装了$NAT$软件的路由器就是$NAT$路由器，其至少有一个有效的外部全球$IP$地址。
+ $NAT$路由器就是该本地专用网的代表，负责与外部因特网联通，分发外部的数据信息，发送时一定会按$NAT$转换表改变源$IP$地址或目的$IP$地址。
+ $NAT$路由器维护$NAT$转换表，包含$WAN$端与$LAN$端的散列值对。每个值都包含网络号与端口号。$NAT$路由器在发送和接收时都需要根据转换表更改$IP$地址。
+ 普通路由器工作在网络层，而$NAT$路由器工作在网络层和传输层。
    + 普通路由器在转发$IP$数据报时，不改变其源$IP$地址和目的$IP$地址
    + 而$NAT$路由器在转发$IP$数据报时，一定要更换其$IP$地址
        + 转换源$IP$地址或目的$IP$地址
            + 硬件地址只具有本地意义，因此每当路由器将IP数据报转发到一个具体的网络中时，都需要重新封装源硬件地址和目的硬件地址
        + 转发数据报时需要查看和转换传输层的端口号


#### VPN

当目的地址是私有（专用）$IP$地址时路由器一律不转发，而如果在内网的私有$IP$地址要转发或接收本地网络其他主机的数据怎么办呢？

可以利用公用的互联网作为本地各专用网之间的通信载体，这种网络就是虚拟专用网$VPN$（$Virtual\;Private\; Network$）。这种网络不同于互联网是因为它只用于本地网络的通信，但是又依靠互联网传输，所以就需要对数据进行加密。

当$VPN$需要外部机构加入就是外联网$VPN$；如果成员分布分散，通过某种软件建立$VPN$通道，这种$VPN$就是远程接入$VPN$。

### 子网与超网

分级$IP$地址的缺点：

1. $IP$地址空间利用率较低。
2. 两级$IP$地址不够灵活。

#### 子网划分

+ 由两级$IP$地址（网络号+主机号）变为三级$IP$地址（网络号+子网号+主机号），将原来的主机号分割出来一部分作为子网号
    + 子网的划分由单位内部完成，但是对外仍表现一个网络，外部无法看到本单位内子网的划分。
+ 子网划分的子网号可以全$0$或全$1$
    + 网络地址和主网络的网络地址是重叠的。（与$CIDR$区别）

+ 子网的标识依靠子网掩码，其中网络号和子网号的部分全部位数为$1$，而主机号部分全部为$0$。
+ 凡是从其他网络发送给本单位某台主机的$IP$数据报，仍然是根据$IP$数据报的目的网络号， 先找到连接到本单位网络上的路由器
    + 然后该路由器在收到$IP$数据报后，按目的网络号和子网号找到目的子网。最后把$IP$数据报直接交付给目的主机。

+ 划分子网只是才巴IP地址的主机号这部分进行再划分，而不改变IP地址原来的网络号
    + 因此，从一个IP地址本身或IP数据报的首部，无法判断源主机或目的主机所连接的网络是否进行了子网划分

+ $ RFC 950$规定，对分类的$IPv4$地址进行子网划分时，子网号不能为全$1$或全$0$
    + ==但随着$CIDR$的广泛使用，现在全1和全0的子网号也可使用==
    + 但一定要谨慎使用，要弄清你的路由器所用的路由选择软件是否支持全$0$或全$1$的子网号
+ 划分子网可以增加子网的数量，子网之间的数据传输需要通过路由器进行，因此减少了广播域的大小
+ 由于子网号占据了主机号位，所以会减少主机的数量
+ 划分子网仅提高IP地址的利用率，并不增加网络的数量


#### 子网掩码

将子网掩码与$IP$地址逐位进行与操作，就可以得到子网网络地址。

在使用子网掩码的条件下，路由表不仅要给出目的网络地址和下一跳地址外，还需要给出目的网络的子网掩码。

+ $A$类地址的默认子网掩码是$255.0.0.0$。
+ $B$类地址的默认子网掩码是$255.255.0.0$。
+ $C$类地址的默认子网掩码是$255.255.255.0$。

|  二进制   | 十进制 |
| :-------: | :----: |
| 1000 0000 |  128   |
| 1100 0000 |  192   |
| 1110 0000 |  224   |
| 1111 0000 |  240   |
| 1111 1000 |  248   |
| 1111 1100 |  252   |
| 1111 1110 |  254   |
| 1111 1111 |  255   |

在使用子网掩码的情况下：

1.   一台主机在设置IP地址信息的同时，必须设置子网掩码。
2.   同属于一个子网的所有主机及路由器的相应端口，必须设置相同的子网掩码。
3.   路由器的路由表中，所包含信息的主要内容有目的网络地址、子网掩码、下一跳地址。

<span style="color:orange">注意：</span>由于子网可以全$0$和全$1$，所以可用子网数量不用减二。

#### IP广播

如之前的保留地址所展示，如果需要进行广播，则包含两种广播方式。

受限（有限）广播地址是$32$位全$1$的$IP$地址``255.255.255.255``。该地址用于主机配置过程中$IP$数据报的目的地址，此时，主机可能还不知道它所在网络的网络掩码，甚至连它的$IP$地址也不知道。在任何情况下，路由器都不转发目的地址为受限的广播地址的数据报，这样的数据报仅出现在本地网络中。

直接广播地址包含一个有效的网络号和一个全$1$的主机号，如果我们要求一个$IP$地址的直接广播地址，那么需要根据$IP$地址与子网掩码，将网络号部分与出来，然后将所有的主机号位全部置$1$，从而得到的地址就是该网络地址的直接广播地址。

#### 无分类编址CIDR

无分类域间路由选择。

+ 一般子网划分在同一个单位下的子网掩码都是相同长度的，而无分类编址$CIDR$就是变长的子网掩码。
+ $CIDR$的子网号可以全$0$全$1$。因为掩码与$IP$地址同时传送，所以可以。但是严格情况下不行。
+ $CIDR$构建的超网可以在单位内部根据不同部门的主机个数分配不同数量的子网$IP$地址。
+ 通过$CIDR$就将子网划分的三级$IP$地址又回归为两级$IP$地址（网络前缀+主机号）。
+ $CIDR$记法：$IP$地址后加上/，然后写上网络前缀的位数。
+ 也可用使用：二进制网络前缀*。
+ $CIDR$把网络前缀都相同的连续的$IP$地址组成一个$CIDR$地址块。

如根据$128.14.35.7/20$，可以得到其二进制是$1000\,0000\quad0000\,1110\quad0010|0011\quad0000\,0111$，所以其最小地址就是将竖线后面的位全部变为$0$，最大地址就是将竖线后的位全部变为$1$，即为$128.14.32.0$与$128.14.47.255$，可用地址就是$2^{12}-2$个，地址块就是$128.14.32.0/20$。

+   $CIDR$查找路由表的方法
    +   为了更加有效地查找最长前缀匹配，通常将无分类编址的路由表存放在一种层次式数据结构中，然后自上而下地按层次进行查找
    +   这里最常用的数据结构就是**二叉线索**
+   最长前缀匹配（最佳匹配）：
    +   使用$CIDR$时，路由表中的每个项目由“网络前缀”和“下一跳地址”组成
    +   在查找路由表时可能会得到不止一个匹配结果
    +   此时，应当从匹配结果中选择具有最长网络前缀的路由，因为网络前缀越长，其地址块就越小，因而路由就越具体。

<span style="color:orange">注意：</span>

+ 默认路由：如果是直连一个互联网，就直接是$0.0.0.0/0$，没有指定主机，需要特别记忆。
+ 主机路由：对特定目的主机$IP$地址专门制定路由，指定子网掩码为$32$，表示子网掩码没有意义。

#### 构成超网

将多个子网构成一个较大的子网就是构成超网，即将网络前缀都相同的连续$IP$地址组成“$CIDR$地址块”。一个$CIDR$地址块可以表示很多地址，这也就是路由聚合，或称构成超网。

方法就是将网络前缀缩短。

如有两个路由表项$206.1.0.0/17$和$206.1.128.0/17$，路由器会发现这两个表项到的网络地址都是同一个，所以可以合并为一个更大的地址块$206.1.0.0/16$。

最长前缀匹配：使用$CIDR$时，查找路由表时可能得到多个匹配结果，应该选择具有最长网络前缀的路由，前缀越长，地址块越小，路由也越具体。

#### 网络层转发分组流程

路由表包括：

1. 目的网络地址。
2. 目的网络子网掩码。
3. 下一跳地址。

路由器转发分组的算法：

1. 从收到的$IP$分组的首部提取目的$IP$地址。
2. 若查找到特定主机路由（目的地址为$D $），就按照这条路由的下一跳转发分组；否则从转发表中的下一条（即按前缀长度的顺序）开始检查，执行步骤`3.`
    +   查找到有特定主机路由（特殊地址，为了测试或安全），就直接按此路由传输。
3. 将这一行的子网掩码与目的地址$D $进行按位与运算
    +   若运算结果与本行的前缀匹配，则查找结束，按照“下一跳”指出的进行处理
        1.   直接交付本网络上的目的主机
        2.   通过指定接口发送到下一跳路由器
    +   否则，若转发表还有下一行，则对下一行进行检查， 重新执行步骤`3.`
    +    其他情况，执行步骤`4.`
4. 若转发表中有一个默认路由`0.0.0.0`，则把分组传送给默认路由`0.0.0.0`，让其他路由器查看是否有该地址
    +   否则，报告转发分组出错

>得到下一跳路由器的IP地址后，并不是直接将该地址填入待发送的数据报，而是将该IP地址转换成MAC地址（通过ARP ）,将此MAC地址放到MAC帧首部中，然后根据这个MAC地址找到下一跳路由器。在不同网络中传送时，MAC帧中的源地址和目的地址要发生变化， 但是网桥在转发帧时，不改变帧的源地址，请注意区分。

### IP地址及其相关协议

#### IP地址与硬件地址

+   IP地址是网络层使用的地址，它是分层次等级的
    +   硬件地址是数据链路层使用的地址（MAC地址），它是平面式的
    +   在网络层及网络层之上使用IP地址，IP地址放在IP数据报的首部，而MAC地址放在MAC帧的首部
    +   通过数据封装，把IP数据报分组封装为MAC帧后，数据链路层看不见数据报分组中的IP地址
+   由于路由器的隔离，IP网络中无法通过广播MAC地址来完成跨网络的寻址，因此在网络层只使用IP地址来完成寻址
    1.   在IP层抽象的互联网上只能看到IP数据报。
    2.   虽然在IP数据报首部中有源IP地址，但路由器只根据目的IP地址进行转发。
    3.   在局域网的链路层，只能看见MAC帧
         +   IP数据报被封装在MAC帧中
         +   通过路由器转发IP分组时，IP分组在每个网络中都被路由器解封装和重新封装，其MAC帧首部中的源地址和目的地址会不断改变
         +   这也决定了无法使用MAC地址跨网络通信。
    4.   尽管互连在一起的网络的硬件地址体系各不相同，但IP层抽象的互联网却屏蔽了下层这些复杂的细节。只要我们在网络层上讨论问题，就能够使用统一的、抽象的IP地址研究主机与主机或路由器之间的通信

>   路由器由于互连多个网络，因此它不仅有多个IP地址，也有多个硬件地址

#### 地址解析协议ARP

无论网络层使用什么协议，在实际网络的链路上传送数据帧时，最终必须使用硬件地址

所以需要一种方法来==完成主机或路由器$IP$地址到$MAC$地址的映射==，即地址解析协议$ARP(Address\; Resolution\;Protocol)$。

每台主机都设有一个$ARP$高速缓存，用来存放本局域网上各主机和路由器的$IP$地址到$MAC$地址的映射表，称$ARP$表。使用$ARP$来动态维护此$ARP$表

由于局域网的数据链路层只能看见$MAC$帧，所以路由器转发时会不断被解封和重新封装。数据帧的$IP$地址不变，但是源与目的$MAC$地址会在不同的路由器中发生变化。（对于网桥则不改变帧的源地址）这决定了无法用$MAC$地址来跨网络通信。

$ARP$由于“看到了” $IP$地址，所以它工作在网络层，而$NAT$路由器由于“看到了”端口，所以它工作在传输层

>   对于某个协议工作在哪个层次，读者应该能通过协议的工作原理进行猜测。

##### ARP协议使用流程

1. 检查在主机或路由器上的$ARP$高速缓存，如果有对应项就写入$MAC$帧。
2. 没有对应项，就用`FF-FF-FF-FF-FF-FF`作为目的$MAC$地址，并广播$ARP$请求分组，同一个局域网内的所有主机都能收到该请求。
    +   广播发送
3. 目的主机收到请求后会向源主机单播一个$ARP$响应分组，源主机收到后将该映射写入$ARP$缓存中。（$10-20min$更新）
    +   单播发送
4. 如果源主机将源$MAC$地址与目的$MAC$地址与操作，发现目的主机不在同一个局域网，就查询本局域网的默认网关地址并填入目的$MAC$地址，传送到其他局域网。

>ARP用于解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题。如果所要找的主机和源主机不在同一个局域网上，那么就要通过ARP找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做，尽管ARP请求分组是广播发送的，但ARP响应分组是普通的单播，即从一个源地址发送到一个目的地址。

##### ARP协议的典型情况

1. 主机$A$发送给本网络的主机$B$：用$ARP$找到主机$B$的硬件地址。
2. 主机$A$发送给另一网络的主机$B$：用$ARP$找到本网络上一个路由器（网关）的硬件地址。
3. 路由器发送给本网络的主机$A$：用$ARP$找到主机$A$的硬件地址。
4. 路由器发送给另一网络的主机$B$：用$ARP$找到本网络上一个路由器（网关）的硬件地址。

#### 动态主机配置协议$DHCP$

动态主机配置协议$DHCP$($Dynamic Host Configuration Protocol$)常用于给主机动态地分配IP地址，它提供了即插即用的联网机制，这种机制允许一台计算机加入新的网络和获取IP地址，而不用手工参与

==$DHCP$是应用层协议==，它是基于$UDP$的。

##### $DHCP$工作原理

+   使用客户/服务器模式
+   需要IP地址的主机在启动时就向DHCP服务器广播发送发现报文，这时该主机就成为DHCP客户
+   本地网络上所有主机都能收到此广播报文，但只有DHCP服务器才回答此播报文
+   DHCP服务器先在其数据库中查找该计算机的配置信息
    +   若找到，则返回找到的信息
    +   若找不到，则从服务器的IP地址池中取一个地址分配给该计算机
    +   DHCP服务器的回答报文称为提供报文

##### $DHCP$工作流程

1. 主机广播“$DHCP$发现报文”，寻找网络中的$DHCP$服务器，从其中获得一个$IP$地址。
    +   源地址为`0.0.0.0`,目的地址为`255.255.255.255`
2. $DHCP$服务器收到“$DHCP$发现报文”后，广播“$DHCP$提供报文”，其中包括提供$DHCP$客户机的$IP$地址与配置信息。
    +   源地址为$DHCP$服务器地址，目的地址为`255.255.255.255`
3. $DHCP$客户机收到“$DHCP$提供报文”，接收$DHCP$服务器所提供的相关参数，客户机广播“$DHCP$请求报文”，向$DHCP$服务器请求提供$IP$地址。
    +   源地址为`0.0.0.0`,目的地址为`255.255.255.255`
4. $DHCP$服务器广播“$DHCP$确认报文”，将$IP$地址分配给$DHCP$客户机。
    +   源地址为$DHCP$服务器地址，目的地址为`255.255.255.255`

##### $DHCP$注意事项

+   DHCP允许网络上配置多台DHCP服务器
    +   当DHCP客户机发出“DHCP发现”消息时，有可能收到多个应答消息
    +   这时，DHCP客户机只会挑选其中的一个，通常挑选最先到达的。
+   DHCP服务器分配给DHCP客户的IP地址是临时的
    +   因此DHCP客户只能在一段有限的时间内使用这个分配到的IP地址
    +   DHCP称这段时间为**租用期**
    +   租用期的数值应由DHCP服务器自己决定，DHCP客户也可在自己发送的报文中提出对租用期的要求。
+   DHCP的客户端和服务器端需要通过广播方式来进行交互
    +   原因是在DHCP执行初期，客户端不知道服务器端的IP地址，而在执行中间，客户端并未被分配IP地址，从而导致两者之间的通信必须采用广播的方式
    +   采用UDP而不采用TCP的原因也很明显：TCP需要建立连接，如果连对方的IP地址都不知道，那么更不可能通过双方的套接字建立连接。
+   DHCP是应用层协议，因为它是通过客户/服务器模式工作的
    +   DHCP客户端向DHCP服务器请求服务，而其他层次的协议是没有这两种工作方式的

####  网际控制报文协议$ICMP$

为了提高IP数据报交付成功的机会，在网络层使用了**网际控制报文协议$ICMP$** $(Internet \;Control\;Message \;Protocol)$

网际控制报文协议支持差错报告与网络探寻。主要通过发送特定$ICMP$报文来实现。

$ICMP$协议是网络层的协议，$ICMP$报文是作为$IP$报文的一部分而传输的。

![ICMP帧格式](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307311058979.png)

##### ICMP报文类型

报文类型的值占四个字节。

##### ICMP差错报文

|       类型       |  值  |                             说明                             |
| :--------------: | :--: | :----------------------------------------------------------: |
|    终点不可达    |  3   |   当路由器或主机不能交付数据报时就向源点发送终点不可达报文   |
|     源点抑制     |  4   | 当路由器或主机由于==拥塞==而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢 |
| 改变路由(重定向) |  5   | 路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器(==可通过更好的路由==) |
|     时间超过     |  11  | 当路由器收到生存时间==TTL=0==的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文 |
|     参数问题     |  12  | 当路由器或目的主机收到的数据报的首部中有的==字段的值不正确==时，就丢弃该数据报，并向源点发送参数问题报文 |

![ICMP差错报文数据字段](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307311058638.png)

不应发送$ICMP$差错报文的情况：

1. 对$ICMP$差错报告报文（即使差错报文本身出错也不会管）。
2. 对第一个分片的数据报片之后的所有后续数据报片。
3. 对具有组播地址的数据报。
4. 对具有特殊地址（如`127.0.0.1`或`0.0.0.0`）的数据报。

>   最新 ICMP标准［RFC6633］已不再使用 “源点抑制报文”。

##### ICMP询问报文

|          类型          |   值   |                             说明                             |
| :--------------------: | :----: | :----------------------------------------------------------: |
|   回送请求和回答报文   |  8或0  | 主机或路由器向特定目的主机发出的询问，收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。测试目的站是否可达以及了解其相关状态 |
|  时间戳请求和回答报文  | 13或14 | 请某个主机或路由器回答当前的日期和时间。用来进行时钟同步和测量时间 |
| 地址掩码请求和回答报文 |        |                                                              |
|  路由器询问和通告报文  |        |                                                              |

##### ICMP应用

1. $PING$：测试两个主机之间的连通性，使用了$ICMP$回送请求和回答报文
    +   工作在应用层，直接使用网络层$ICMP$，而未使用$TCP$或$UDP$。
2. $Traceroute/Tracert$：跟踪一个分组从源点到终点，使用了$ICMP$时间超过差错报告报文
    +   工作在网络层。
    +   UNIX中叫$Traceroute$，在$Windows$中是$Tracert$

### IPv6

无论是$NAT$技术还是$CIDR$技术都无法完全解决$IPv4$地址耗尽的问题，所以就出现了$IPv6$从根本上解决地址耗尽的问题。

解决的问题有：

1. $IP$地址不足，增加到了$128$位。
2. 改进首部格式，简化$IP$地址类型，且首部长度固定。
3. 快速处理/转发数据报，去掉了差错检验，不允许分片。
4. 支持$QoS$（服务质量指一个网络能够利用各种基础技术，为指定的网络通信提供更好的服务能力，是网络的一种安全机制，用来解决网络延迟和阻塞等问题的一种技术）。

#### IPv6帧格式

$IPv6$帧包括$40$字节即$320$位的基本首部，再加上不超过$65535$字节的有效载荷，有效载荷中包含着多个拓展首部与数据部分。

其中报头格式如下：

![IPv6报头格式](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307311058965.png)

|              名称              |                             作用                             | 位数  |
| :----------------------------: | :----------------------------------------------------------: | :---: |
|          版本 Version          |            指明协议版本，此处因为是ipv6所以总是6             |  4位  |
|      优先级 Traffic Class      |                   区分数据报的类型和优先级                   |  8位  |
|       流标签 Flow Label        |  和ipv4标识某个数据报分片不同，这是对于一整个数据报流的标记  | 19位  |
|  有效载荷长度 Payload Length   | 指的是扩展首部+数据部分的大小，和ipv4的总长度和首部长度都不同，ipv6的首部长度是固定的40字节 | 16位  |
| 下一个首部（报头） Next Header | 基本首部的下一个首部指的是有效载荷里标记的的扩展首部，有效载荷里的扩展首部再指向有效载荷里标记的的扩展首部，直至最后指向数据 |  8位  |
|       跳数限制 Hop Limit       |    基本相当于ipv4当中的TTL，每到一个路由器-1.减到0时丢弃     |  7位  |
|     源地址 Source Address      |                        发送方ipv6地址                        | 128位 |
|  目标地址 Destination Address  |                        接收方ipv6地址                        | 128位 |

#### IPv6的主要特点

1.   更大的地址空间。IPv6将地址从IPv4的32位增大到了 128位
     +   IPv6的字节数（16B）是IPv4字节数（4B）的平方。
2.   扩展的地址层次结构。
3.   灵活的首部格式。
4.   改进的选项。
5.   允许协议继续扩充。
6.   支持即插即用（即自动配置）。
7.   支持资源的预分配。
8.   IPv6只有在包的源结点才能分片，是端到端的，传输路径中的路由器不能分片，所以从一般意义上说，IPv6不允许分片（不允许类似IPv4的路由分片）。
9.   IPv6首部长度必须是8B的整数倍，而IPv4首部是4B的整数倍。
10.   增大了安全性。身份验证和保密功能是IPv6的关键特征。 

#### IPv6与IPv4的区别

1. 地址空间扩大，由$32$位变为$128$位。
2. 将==校验和字段彻底移除==，减少每跳处理时间。
3. 将可选字段移出首部，首部长度固定，变成**扩展首部**（丢弃了首部长度字段），更加灵活。
    +   路由器通常不对扩展首部进行检查，大大提高了路由器的处理效率。
4. 支持即插即用（即自动配置），不需要$DHCP$协议。
5. 首部是$8$字节的整数倍，而$IPv4$首部是$4$字节的整数倍。
6. $IPv6$只能在主机处即包的源结点分片，而$IPv4$能在主机和路由器处分片，所以$IPv6$不允许分片。
    +   如过大在路由器会无法分片而无法传输的话，会丢弃该数据报，并向发送方发送一个指示分组太大的ICMP报文
7. 支持资源预分配，支持实时视像等要求，保证一定的带宽和时延的应用。
8. 取消了协议字段，改成下一个首部字段。
9. 取消了总长度字段，改成有效载荷字段。
10. 取消服务类型字段。

#### IPv6地址表示

一般形式：冒号十六进制记法。（分为八个十六进制端）

压缩形式：一段中有连续的$0$，可用一个$0$代替；把在前面的$0$全部删去；使用零压缩的方式，一串连续的$0$可用用一对冒号代替，但是只能在一个地址中使用一次。

#### IPv6基本地址类型

| 名称 |                             作用                             |         要求         |
| :--: | :----------------------------------------------------------: | :------------------: |
| 单播 |                          一对一通信                          | 可做源地址，目的地址 |
| 多播 |       一对多通信，以前的广播地址当做覆盖所有主机的多播       |     可做目的地址     |
| 任播 | 一对多当中的一个通信，看似一对多，实则一对一，一般是最近的主机 |     可做目的地址     |

#### IPv4和IPv6之间的过渡

+ 双栈协议：在一台设备上同时启用$IPv4$协议栈和$IPv6$协议栈
    + 这样的话，这台设备既能和$IPv4$网络通信，又能和$IPv6$网络通信
    + 如果这台设备是一个路由器，那么这台路由器的不同接口上，分别配置了$IPv4$地址和$IPv6$地址，并很可能分别连接了$IPv4$网络和$IPv6$网络
    + 如果这台设备是一个计算机，那么它将同时拥有$IPv4$地址和$IPv6$地址，并具备同时处理这两个协议地址的功能。

+ 隧道技术：通过使用互联网络的基础设施在网络之间传递数据的方式
    + 使用隧道传递的数据（或负载）可以是不同协议的数据帧或包
    + 隧道协议将其它协议的数据帧或包重新封装然后通过隧道发送。

## 路由协议

### 自治系统

自治系统$AS(Autonomous System)$是单一技术管理下的一组路由器，这些路由器使用一种$AS$内部的路由选择协议和共同的度量来确定分组在该$AS$内的路由，同时还使用一种AS之间的路由选择协议来确定分组在$AS$之间的路由。 

一个自治系统内的所有网络都由一个行政单位管辖，一个自治系统的所有路由器在本自治系统内都必须是连通的。

### 域内路由与域间路由

每个自治系统$AS$​都有权自主地决定本系统内应采用何种路由选择协议，如果两个自治系统需要通信，那么就需要一种在两个自治系统之间的协议来屏蔽这些差异。据此，因特网把路由选择协议划分为两大类

+   内部网关协议$IGP$：一个自治系统内部所使用的路由选择协议，与互联网中其他自治系统选用什么路由选择协议无关
    +   $RIP$
    +   $OSPF$
+   外部网关协议$EGP$​：自治系统之间所使用的路由选择协议，用于不同自治系统的路由器之间交换路由信息，并负责为分组在不同自治系统之间选择最优的路径
    +   $BGP$

### 路由信息协议$RIP$

+ 路由信息协议$RIP$（$Routing\; Information\; Protocol$）是一种内部网关协议$IGP$，是一种分布式的基于**距离-向量路由算法**的路由选择协议，最大的优点是简单。
+ 在距离-向量路由算法中，所有结点都定期地将它们的整个路由选择表传送给所有与之直接相邻的结点。
    + 要求网络中的每一个路由器都维护从它到其他每一个目的网络的唯一最佳路径（即一组距离）。
    + 这种路由选择表包含：
        + 每条路径的目的地（另一结点）。
        + 路径的代价（也称距离）
            + 距离通常指跳数，即从源端口到目的端口所经过的路由器个数，经过一个路由器跳数$+1$，与路由器直接连接的网络距离为$1$。$RIP$允许一条路最多只能包含$15$个路由器，所以$16$表示网络不可达。

+ $RIP$协议只适用于小型互联网。
+ $RIP$默认在任意两个使用$RIP$的路由器之间每$30$秒广播一次$RIP$路由更新信息，以便自动建立并维护路由表（动态维护）
+ 路由表由目的网络、距离、下一跳路由器三个项目构成。
+ ==$RIP$协议是应用层协议，使用$UDP$(端口 `520`)传送数据。==
+ 一个$RIP$报文最多只包含$25$个路由，如果超过必须再用多的$RIP$报文传送。
+ 在$RIP$中不支持子网掩码的$RIP$广播，所以$RIP$中每个网络的子网掩码必须相同
    + 但在新的$RIP2$中，支持变长子网掩码和$CIDR$

+ $RIP$选择的路径不一定是时间最短的，但一定==是具有最少路由器的路径==
    + 因为它是根据最少跳数进行路径选择的


#### RIP协议特点

1. 仅和相邻路由器交换信息。
2. 路由器交换的信息是自己的路由表，其中包括每条路径的目的地与路径代价两条信息。
3. 按固定的时间间隔交换路由信息，如每$30s$就交换一次，如果$180s$没收到相邻路由器的通告就默认这个路由器出现错误，并更新路由表。
4. 最开始路由器只知道直接相连的网络，若干次更新后所有路由器都会知道到达本自治系统中任何网络的信息，即收敛。

$RIP$最大的优点是实现简单、开销小、收敛过程较快

#### 距离向量算法

每个路由表项目都有三个关键数据：

1.   目的网络$N$
2.   距离$d$
3.   下一跳路由器地址$X$

对于每个相邻路由器发送过来的$RIP$报文，执行如下步骤：

1. 修改相邻路由器发来的$RIP$报文中的所有表项
    +   对地址为$X$的相邻路由器发来的$RIP$报文，修改此报文的所有项目：把下一跳字段中的地址改为$X$，并把所有的距离加$1$。
2. 对修改后的$RIP$报文中的每一个项目都进行以下步骤：
    1. 本路由器路由表中没有该网络$N$，则把这个项目直接填入路由表中。
    2. 本路由器路由表中已经有该网络$N$，则查看下一跳路由器地址
        +   如果下一跳的路由器名是$X$，则表明距离更新了，用收到的项目替换原有项目。
        +   如果下一跳的路由器名不是$X$，且收到的项目中的距离$d$小于路由表中的距离，那么就用收到的项目替换原路由表中的项目
    3. 否则不处理。
3. 若$180s$超时，则把该路由器设为不可达，那么把此相邻路由器记为不可达路由器，即距离设为$16$。
    +   $RIP$默认超时时间为$180$秒
4. 返回。

#### RIP协议问题

$RIP$协议存在问题：

+ 限制了网络规模。
    + ==能使用的最大距离为15 （16表示不可达）==

+ 路由器交换完整的路由表，所以网络规模越大，开销越大。
+ 当网络出现故障时，要经过较长的时间才能将此信息传送到所有的路由器，即出现路由回路问题，称为**慢收敛**
    + ==也叫做好消息传得快，坏消息传得慢。==
    + ==慢收敛是导致发生路由回路的根本原因==


当一个网络故障时，由于坏消息传输的可能较慢，导致故障信息晚于其相邻信息传输的原来正确信息，故障信息被其原来信息覆盖，从而让双方路由器都不断认为通过对方就能达到已经坏掉的网络，直到重复了$16$次才会发现该网络不可达。

解决慢收敛方法：

+ 限制路径最大距离：超过$16$次就认为不可达不再传输。
+ 分割水平线：路由器从某个接口接收到的更新信息不允许再从这个接口发回去。
+ 抑制计时器法：等待足够多的时间（一般$60$秒），已确保所有的机器都收到坏消息，而不会错误的连接过时的报文
    + 需要指出的是，参与$RIP$的机器都要遵循抑制策略，否则任依旧会发生环路
    + 缺点是：如果发生环路，在抑制期内这些路由环路任然会维持下去。

+ 毒性逆转：路由中毒是指在路由信息在路由表中失效时，先将度量值变为无穷大的数，而不是马上从路由表中删掉这条路由信息，然后再将其中毒的路由信息发布出去，这样相邻的路由器收到该中毒路由就可以通过其度量值就得知这条路由的度量值是$16$，说明该路由是无效的
    + 然后收到中毒路由信息的相邻的路由器会发送一个毒性逆转的信息，表示已经收到中毒路由信息。

+ 触发刷新：正常情况下，路由器会基于计时器每$30s$将路由表发送给邻居路由器，而触发更新就是立刻发送路由更新信息
    + 也就是说检测到网络故障的路由器会直接发送一个更新信息给邻居路由器，并依次产生触发更新通知它们的邻居路由器，此过程就叫触发更新
    + 触发更新这种方式使整个网络上的路由器在最短的时间内收到更新信息。

### 开放最短路径协议$OSPF$

+ 开放最短路径优先协议$OSPF$（$Open \;Shortest \;Path\; First$）是一种内部网关协议$IGP$，是基于**链路状态路由算法**的路由选择协议。
+ 开放最短路径优先协议的开放指$OSPF$协议是开放的，$SPF$是指最短路径算法。
+ $OSPF$协议是网络层（或传输层）协议，使用$IP$数据报传输。
+ $OSPF$对不同的链路可根据$IP$分组的不同服务类型$TOS$而设置成不同的代价
    + 因此，$OSPF$对于不同类型的业务可计算出不同的路由，十分灵活。

+ ==如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。这称为**多路径间的负载平衡**。==
+ ==所有在$OSPF$路由器之间交换的分组都具有鉴别功能==，因而保证了仅在可信赖的路由器之间交换链路状态信息。
+ 支持可变长度的子网划分和无分类编址$CIDR$。
+ ==每个链路状态都带上一个$32$位的序号，序号越大，状态就越新。==
+ 主要优点
    + 每个路由结点都使用同样的原始状态数据独立地计算路径，而不依赖中间结点的计算
    + 链路状态报文不加改变地传播，因此采用该算法易于查找故障。
    + 当一个结点从所有其他结点接收到报文时，它可以在本地立即计算正确的通路，保证一步汇聚。
    + 由于链路状态报文仅运载来自单个结点关于直接链路的信息，其大小与网络中的路由结点数目无关
        + 因此==链路状态算法比距离-向量算法有更好的规模可伸展性==。 


#### 与RIP协议的区别

+ $OSPF$向本自治系统中的所有路由器发送信息，这里使用的方法是洪泛法
    + 而$RIP$仅向自己相邻的几个路由器发送信息。
        + $RIP\sim$距离-向量路由算法有可能遇到路由环路

+ $OSPF$发送的信息是与本路由器相邻的所有路由器的**链路状态**，但这只是路由器所知道的部分信息。
    + 而在$RIP$中，发送的信息是本路由器所知道的全部信息，即整个路由表。
    + “链路状态”说明本路由器和哪些路由器相邻及该链路的“度量”（或代价）。

+ $OSPF$只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息，并且更新过程收敛得快，不会出现$RIP$“坏消息传得慢”的问题
    + 而在$RIP$中，不管网络拓扑是否发生变化，路由器之间都会定期交换路由表的信息。

+ $OSPF$是网络层协议，它不使用$UDP$或$TCP$，而直接用$IP$数据报传送（其$IP$数据报首部的协议字段为$89$）
    + 而$RIP$是应用层协议，它在传输层使用$UDP$。

+ $OSPF$中每个路由结点都使用同样的原始状态数据独立地计算路径，而不依赖中间结点的计算
    + 而$RIP$依赖中间结点的计算
+ 当互联网规模很大时，$OSPF$要比$RIP$好得多， 而且$OSPF$协议没有“坏消息传播得慢”的问题


#### OSPF协议交换信息

1. 使用洪泛法向自治系统内所有路由器发送信息
    +   即路由器通过输出端口向所有相邻的路由器发送信息，而每一个相邻路由器又再次将此信息发往其所有的相邻路由器
        +   但不再发送给刚刚发来信息的那个路由器
    +   最终整个区域内所有路由器都得到了这个信息的一个副本。
2. 发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息
    +   本路由器和哪些路由器相邻，以及该链路的度量/代价——费用、距离、时延、带宽等
3. 路由器根据全网拓扑结构图使用$Dijkstra$最短路径算法计算自己到各目的网络的最优路径，构建新的路由表。（只存储下一跳）
4. 只有当链路状态发生变化时，路由器才向所有路由器洪泛发送此信息。
5. 最后，所有路由器都能建立一个链路状态数据库，即全网拓扑图。

>   虽然使用Dijkstra算法能计算出完整的最优路径，但路由表中不会存储完整路径，而只存储“下一跳”（只有到了下一跳路由器，才能知道再下一跳应当怎样走）。

#### 链路状态路由算法

涉及到$OSPF$的五种分组类型：

1. 每个路由器发现它的邻居结点**HELLO问候分组**，并了解邻居节点的网络地址。
    +   用于发现和维持邻站的可达性
2. 设置到它的每个邻居的成本度量$metric$。
3. 构造**DD数据库描述分组**
    +   向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息
4. 如果$DD$分组中的摘要自己都有，则邻站不做处理；如果有没有的或者是更新的，则发送**LSR链路状态请求分组**请求自己没有的和比自己更新的信息。
    +   向对方请求发送某些链路状态项目的详细信息
5. 收到邻站的$LSR$分组后，发送**LSU链路状态更新分组**，使用洪泛法对全网链路进行更新。
    +   用洪泛法对全网更新链路状态
6. 更新完毕后，邻站返回一个**LSAck链路状态确认分组**进行确认。
    +   对链路更新分组的确认
7. 根据$Dijkstra$算法与自己的链路状态数据库构造到其他结点之间的最短路径。
8. 用**HELLO问候分组**分组保持与邻居的连接。

当一个路由器的链路状态发生变化时，就会重复$5$及其之后的步骤。

通常隔$10$秒相邻两个路由器就要交换一次问候分组。且还要每隔一段时间如$30$分粥就要刷新依次数据库中的链路状态。

#### OSPF协议的区域

为了使$OSPF$能够用于规模很大的网络，$OSPF$将一个自治系统再划分为若干个更小的范围，叫做**区域**。每一个区域都有一个$32$位的区域标识符（用点分十进制表示）。

区域也不能太大，在一个区域内的路由器最好不超过$200$个。

一个区域内的路由器只知道本区域内的完整网络拓扑。

处在上层的区域位主干区域，负责连通其他下层的区域和其他自治域。

路由器分为：

+ 主干路由器（可以兼任）。
+ 区域内部路由器。
+ 区域边界路由器。
+ 自治系统边界路由器。

### 边界网关协议$BGP$

边界网关协议$BGP(Border\; Gateway\; Protocol)$是外部网关协议$EGP$，最新的版本是$BGP-4$。

而BGP使用的环境与内部网关协议$IGP$不同，主要原因如下：

1.   因特网的规模太大，使得自治系统之间路由选择非常困难。
2.   对于自治系统之间的路由选择，要寻找最佳路由是很不现实的。
3.   自治系统之间的路由选择必须考虑有关策略。 

边界网关协议$BGP$只能力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子）， 而并非寻找一条最佳路由

BGP采用的是**路径向量路由选择协议**，它与距离向量协议和链路状态协议有很大的区别

==$BGP$是应用层协议，它是基于$TCP$的。==

#### BGP协议工作原理

$BGP$发言人是$AS$与$AS$之间交流信息的路由器，往往是$BGP$边界路由器。

1. 每个自治系统的管理员至少选择一个路由器作为该自治系统的“$BGP$发言人”。

2. 一个$BGP$发言人与其他自治系统中的$BGP$发言人要交换路由信息，就要先建立$TCP$连接

    +   即==通过$TCP$传送，==

    +   可见$BGP$报文是通过$TCP$传送的，也就是说$BGP$报文是$TCP$报文的数据部分

3. 然后在此连接上交换$BGP$报文以建立$BGP$会话$session$，利用$BGP$会话交换路由信息。

4. $BGP$发言人之间互相交换了网络可达性的信息后，各$BGP$发言人就根据所采用的策略从收到的路由信息中找出到达各$AS$的较好路由。

5. 网络可达性信息是指到达某个网络所经过的路径（一整条），且这个路径不一定是最佳的，而是选择能到达且网络较好的。

![image-20230801224134283](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308012241499.png)

#### BGP协议特点

+ ==每个$BGP$发言人除必须运行$BGP$外，还必须运行该$AS$所用的内部网关协议，如$OSPF$或$RIP$。==
+ $BGP$所交换的网络可达性信息就是要到达某个网络（用网络前缀表示）所要经过的一系列$AS$路径。
+ $BGP$协议书寻找一条较好的**路由**，而非找一条最优路由。因为因特网规模太大，选择困难，且$AS$之间选择最优路由不现实，还必须考虑其他相关策略。
+ $BGP$交换路由信息的结点数量级是自治系统的数量级，要比这些自治系统$AS$中的网络数少很多。
+ 每个自治系统中$BGP$发言人（或边界路由器）的数目是很少的
    +   这样就使得自治系统之间的路由选择不致过分复杂。
+ $BGP$支持$CIDR$
    + 因此$BGP$的路由表也就应当包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的各个自治系统序列。

+ 在$BGP$刚刚运行时，$BGP$的邻站是交换整个的$BGP$路由表
    + 但以后只需要在发生变化时更新有变化的部分。这样做对节省网络带宽和减少路由器的处理开销都有好处。


#### BGP-4报文类型

1. $OPEN$（打开）报文：用来与相邻的另一个$BGP$发言人建立关系，并认证发送方。
2. $UPDATE$（更新）报文：通告新路径或撤销原路径。
3. $KEEPALIVE$（保活）报文：在无$UPDATE$时，周期性证实邻站的连通性；也作为$OPEN$的确认。
4. $NOTIFICATION$（通知）报文：报告先前报文的差错；关闭连接。

### 三种协议的比较

|   协议   |                    RIP                     |                 OSPF                 |                  BGP                   |
| :------: | :----------------------------------------: | :----------------------------------: | :------------------------------------: |
|   类型   |                    内部                    |                 内部                 |                  外部                  |
| 路由算法 |                 距离-向量                  |               链路状态               |               路径-向量                |
| 传递协议 |                    UDP                     |                  IP                  |                  TCP                   |
|   层次   |                   应用层                   |                网络层                |                 应用层                 |
| 路径选择 |                  跳数最少                  |               代价最低               |              较好，非最佳              |
| 交换结点 |            和本结点相邻的路由器            |          网络中的所有路由器          |          和本结点相邻的路由器          |
| 交换内容 | 当前本路由器知道的全部信息，即自己的路由表 | 与本路由器相邻的所有路由器的链路状态 | 首次是整个路由表，非首次是有变化的部分 |

+ $RIP$是一种分布式的基于距离向量的路由选择协议，它通过广播$UDP$报文来交换路由信息。
+ $OSPF$是一个内部网关协议，要交换的信息量较大，应使报文的长度尽量短，所以不使用传输层协议（如$UDP$或$TCP$），而直接采用$IP$。
+ $BGP$是一个外部网关协议，在不同的自治系统之间交换路由信息，由于网络环境复杂，需要保证可靠传输，所以采用$TCP$。

## IP多播

+   $IP$多播也称为组播。所以肯定仅用于$UDP$，它对将报文同时送往多个接收者的应用来说非常重要
    +   而$TCP$是面向连接的协议，它意味着分别运行于两台主机（由IP地址来确定）内的两个进程（由端口号来确定）之间存在一条连接，因此会一对一地发送

+   当网络中某些用户需要特定数据时，组播数据发送者仅发送一次数据，避免路由环路，借助组播路由协议为组播数据包建立**组播转发树**，被传输的数据到达距离用户端尽可能近的结点后才开始复制和分发。
+   组播提高了数据传输效率，降低拥塞的可能性，组播组中的主机可以时同一个物理网络，如果有组播路由器也可以来自不同物理网络。
+   能运行组播协议的路由器就是组播路由器。
+   使用组播的缘由是
    +   有的应用程序要把一个分组发送给多个目的地主机
        +   不是让源主机给每个目的地主机都发送一个单独的分组，而是让源主机把单个分组发送给一个组播地址，该组播地址标识一组地址
    +   网络（如因特网）把这个分组的副本投递给该组中的每台主机
    +   主机可以选择加入或离开一个组，因此一台主机可以同时属于多个组
+   因特网中的$IP$组播也使用组播组的概念，每个组都有一个特别分配的地址，要给该组发送的计算机将使用这个地址作为分组的目标地址
    +   在$IPv4$中，这些地址在$D$类地址空间中分配
    +    而$IPv6$也有一部分地址空间保留给组播组
+   主机使用一个称为因特网组管理协议$IGMP $的协议加入组播组
    +   它们使用该协议通知本地网络上的路由器关于要接收发送给某个组播组的分组的愿望
    +   通过扩展路由器的路由选择和转发功能，可以在许多路由器互连的支持硬件组播的网络上面实现因特网组播
+   需要注意的是，主机组播时仅发送一份数据，只有数据在传送路径出现分岔时才将分组复制后继续转发
    +   因此，对发送者而言，数据只需发送一次就可发送到所有接收者，大大减轻了网络的负载和发送者的负担。
+   由于组播$IP$地址与以太网硬件地址的映射关系不是唯一的，因此收到组播数据报的主机，还要在$IP$层利用软件进行过滤， 把不是本主机要接收的数据报丢弃
+   在组播路由选择中，路由器可以从它的多个接口转发收到的分组
+   用多个单播仿真一个组播时需要更多的带宽
+   .在设计组播路由时，为了避免路由环路，构造一个组播转发树
    +   通过该转发树既能将组播分组传送到组内的每台主机，又能避免环路


### 组播实现

因特网的组播是靠路由器来实现的，这些路由器必须增加一些能够识别组播的软件。能够运行组播协议的路由器可以是一个单独的路由器，也可以是运行组播软件的普通路由器。因特网上的组播比以太网上的组播复杂得多，因为以太网本身支持广播和组播，而因特网上当前的路由器和许多物理网络都不支持广播和组播。

多个单播可以仿真组播，此时仿真的实验基本上是相同的，但是一个组播所需要的带宽小于多个单播带宽之和，此时路由器的时延变大，而处理一个组播分组的时延是比较小的。

IP组播可以分为两种

1.   一种只在本局域网上进行硬件组播
2.   另一种则在因特网的范围内进行组播

在因特网上进行组播的最后阶段，还是要把组播数据报在局域网上用硬件组播交付给组播组的所有成员

![image-20230801230318985](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308012303138.png)

### IP组播地址

$IP$组播地址能让源设备能将分组发送给一组设备，属于多播组的设备将被分配一个组播组$IP$地址。

$IP$组播使用$D$类地址格式，范围是`244.0.0.0`到`239.255.255.255`，==一个$D$类地址表示一个组播组，只能用作目的地址，源地址必然是单播地址。==

组播数据报和一般的$IP$数据报的区别是，前者使用$D$类$IP$地址作为目的地址，并且首部中的协议字段值是$2$，表明使用$IGMP$需要注意的是：

1. 组播数据报也是“尽最大努力交付”，不提供可靠交付
2. 组播地址只能用于目的地址，而不能用于源地址。
3. 组播数据报由于是组播所以不是一对一，所以无法建立连接，仅能应用于$UDP$，只能尽最大努力交付，不提供,可靠交付，。
4. 对组播数据报不产生$ICMP$差错报文。
    +   因此，若在`PING`命令后面键入组播地址，将永远不会收到响应
5. 并非所有$D$类地址都可以作为组播地址。
    +   部分地址已经被指派作为永久组地址

### 硬件组播

同单播地址一样，组播$IP$地址也需要对应的组播$MAC$地址在本地网络中实际传输帧。组播$MAC$地址以十六进制值$01-00-5E$开头，即范围为`01-00-5E-00-00-00` $\to$`01-00-53-7F-FF-FF`，余下的六个十六进制位根据$IP$组播组地址的最后$23$位转换而成，第$9$位为$0$。

![硬件组播](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307311058938.png)

有时候可能会$IP$地址映射成同样的$MAC$地址，从而数据组播时可能会出错，所以在收到多播数据报的主机，还要在$IP$层利用软件进行过滤，将不是本主机要接受的数据丢弃。

### 因特网组管理协议$IGMP$

网际组管理协议$IGMP(Internet\; Group\;Management\; Protocol)$让==连接在本地局域网上的多播路由器==知道本局域网上是否还有主机的某个进程参加或退出了某个多播组，以便把组播数据报用最小代价传送给所有组成员。

$IGMP$并不是在因特网范围内对所有组播组成员进行管理的协议

$IGMP$不知道$IP$组播组包含的成员数，也不知道这些成员分布在哪些网络上

首部中协议字段值为$2$表示使用$IGMP$协议。

#### 工作阶段

1. 某主机要加入组播组时，该主机向组播组的组播地址发送一个$IGMP$报文，声明自己要称为该组的成员

    +   本地组播路由器收到$IGMP$报文后，要利用组播路由选择协议把这组成员关系发给因特网上的其他组播路由器。

2. 因为组成员关系是动态的，本地组播路由器周期性探询本地局域网上的主机，以便知道这些主机是否还是组播组的成员。

    +   只要有一个主机对某个组响应，那么组播路由器就认为这个组是活跃的。

    +   如果经过几次探询后没有一个主机响应，组播路由器就认为本网络上的没有此组播组的主机
        +   因此就不再把这组的成员关系发给其他的组播路由器
    +   组播路由器知道的成员关系只是所连接的局域网中有无组播组的成员。

### 组播路由选择协议

组播路由协议目的是找出以源主机为根节点的组播转发树。

对不同的多播组对应不同的多播转发树；同一个多播组，对不同的源点也会也不同的多播转发树。

#### 组播数据报方法

1. 洪泛与剪除。
2. 隧道技术。
3. 基于核心的发现技术。

#### 建议组播路由选择协议

1. 距离向量多播路由选择协议$DVMRP$。
2. 基于核心的转发树$CBT$。
3. 开发最短通路优先的多播扩展$MOSPF$。
4. 协议无关多播-稀疏方式$PIM-SM$。
5. 协议无关多播-密集方式$PIM-DM$。

## MPLS

多协议标记交换利用面向连接的技术，使每个分组都携带一个叫做标记的小整数，当分组到达交换机时，交换机读取分组的标记，并用标记值来检索分组转发表。

$MPLS$具有以下特点：

1. 支持面向连接的服务质量。
2. 支持流量工程，平衡网络负载。
3. 有效地支持虚拟专用网$VPN$。

## 移动IP

移动$IP$技术是移动结点（计算机/服务器等）以固定的网络$IP$地址，实现跨越不同网段的漫游功能，并保证了基于网络$IP$的网络权限在漫游过程中不发生任何改变。

移动结点具有永久$IP$地址的移动设备。

移动$IP$的目标是把分组自动地投递给移动站

一个移动站是把其连接点从一个网络或子网改变到另一个网络或子网的主机。 

### 相关术语

移动$IP$定义了三种功能实体：移动节点、本地代理（也称归属代理）和外地代理：

+   移动节点：具有永久$IP$地址的移动站。

+ 归属代理/本地代理：一个移动结点拥有的永久“居所”称为归属网络，在归属网络中代表移动节点执行，移动管理功能的实体叫做归属代理，通常就是连接在归属网络（原始连接到的网络）上的路由器。。
+ 外部代理/外地代理：在外部网络中帮助移动节点完成移动管理功能的实体称为外部代理，通常就是连接在被访网络（移动到另一地点所接入的网络）上的路由器。。

对应的地址如下

+ 永久地址（归属地址/主地址）：移动站点在归属网络中的原始地址。
    + 永久地址和归属网络的关联是不变的
+ 转交地址（辅地址）：移动站点在外部网络使用的临时地址。
    + 归属代理通常是连接到归属网络上的路由器，然而它实现的代理功能是在应用层完成的
+ 被访网络：当移动站移动到另一地点，所接入的外地网络
+ 外地代理：被访网络中使用的代理，通常是连接在被访网络上的路由器。
    + 外地代理有两个重要功能
        1.   要为移动站创建一个临时地址，称为转交地址。转交地址的网络号显然和被访网络一致
        2.   及时把移动站的转交地址告诉其归属代理。 

### 通信过程

移动$IP$的基本工作过程可以分为代理发现、注册、分组路由与注销四个阶段

移动站$A$在归属网络时：

1.   按传统的$TCP/IP$方式进行通信

$A$刚进入外部网络：

1. 在外部代理登记获得一个临时的转交地址，离开时注销。
    +   外部代理广播报文
2. 移动节点通过外部代理发送注册报文给归属代理
    +   包含永久地址&转交地址
3. 归属代理接收请求，并将移动节点的永久地址和转交地址绑定，并返回一注册响应报文。
    +   以后到达该归属代理的数据报且要发往移动节点的数据报将被封装并以隧道方式发给转交地址
4. 外部代理接收注册响应，并转发给移动节点。

$B$给$A$发送数据报：

1. 本地代理截获数据报。
2. 本地代理再封装数据报，新的数据报目的地址是转交地址，发给外部代理（隧道）。
3. 外部代理拆封数据报并发给$A$。

$A$给$B$发送数据报：

1.   $A$用自己的主地址作为数据报源地址，用$B$的$IP$地址作为数据报的目的地址。

$A$移动到了下一个网络：

1. 在新外部代理登记注册一个转交地址。
2. 新外部代理给本地代理发送新的转交地址（覆盖旧的）。
3. 通信。

$A$回到了归属网络:

1. $A$向本地代理注销转交地址。
2. 按原始方式通信。

移动$IP$为移动主机设置了两个$IP$地址，即主地址和辅地址（转交地址）。移动主机在本地网时，使用的是主地址。当移动到另一个网络时，需要获得一个临时的辅地址，但此时主地址仍然不变。从外网移回本地网时，辅地址改变或撤销，而主地址仍然保持不变。

## 互联网连接问题

计算机网络中主机不仅需要跟其他主机相联，还需要跟互联网相联。

+ 当询问该网段的主机是否可以访问互联网时，要查看对应网段的默认网关地址，此时默认网关的地址必须跟连接的路由器的接口地址一致，那么可以访问互联网。
+ 当主机处于不同的网段（子网号不同）则需要路由器进行连接（就是互联网连接问题，因为不同网段主机访问即使再近都要访问互联网再找到该地址）。此时默认网关的地址必须跟连接的路由器的接口地址一致，否则不能通过路由器转发，从而无法连接。
+ 当一个路由表中要填写访问互联网的路径时，那么这个路径就是固定的$0.0.0.0$，掩码也是$0.0.0.0$。这样的话只要这个地址不与路由表中的其他所有地址匹配，那么他们都可以选择这个最终的方案通过互联网查找$IP$地址。
+ 如果是要到固定的设备，如域名服务器，则必须$IP$地址全部匹配，此时子网掩码就是$255.255.255.255$。

## 网络层设备

一般为路由器，是一种具有多个输入端口和多个输出端口的专用计算机，其任务是根据转发表分组转发。

若收到$RIP/OSPF$分组等，则把分组送往路由选择处理机；若收到数据分组，则查找转发表并输出。

### 冲突域和广播域.

这里的“域”表示冲突或广播在其中发生并传播的区域

#### 冲突域

冲突域是指连接到同一物理介质上的所有结点的集合，这些结点之间存在介质争用的现象

在$OSI$参考模型中，冲突域被视为第1层概念，像集线器、中继器等简单无脑复制转发信号的第1层设备所连接的结点都属于同一个冲突域，也就是说它们不能划分冲突域。==而第2层（网桥、 交换机）、第3层（路由器）设备都可以划分冲突域。==

#### 广播域

广播域是指接收同样广播消息的结点集合。也就是说，在该集合中的任何一个结点发送一个广播帧，其他能收到这个帧的结点都被认为是该广播域的一部分。在$OSI$参考模型中，广播域被视为第2层概念，像第1层（集线器等）、第2层（交换机等）设备所连接的结点都属于同一个广播域。而==路由器，作为第3层设备，则可以划分广播域，即可以连接不同的广播域。==

 通常所说的==局域网$LAN$特指使用路由器分割的网络，也就是广播域。==

### 路由器

#### 路由器的组成和功能

+   路由器是一种具有多个输入/输出端口的专用计算机，其任务是连接不同的网络（连接异构网络）并完成路由转发。在多个逻辑网络（即多个广播域）互连时必须使用路由器。 
+   ==功能主要为分组转发和路由计算，不进行差错检测。==
+   路由器作用于物理层、数据链路层、网络层。
+   可以通过用路由器将网络分段控制制网络上的广播风暴

+   当源主机要向目标主机发送数据报时，路由器先检查源主机与目标主机是否连接在同一个网络上。

    +   如果源主机和目标主机在同一个网络上，那么直接交付而无须通过路由器。
    +   如果源主机和目标主机不在同一个网络上，那么路由器按照转发表（路由表）指出的路由将数据报转发给下一个路由器，这称为**间接交付**。

+   可见，在同一个网络中传递数据无须路由器的参与，而跨网络通信必须通过路由器进行转发。

    +   例如，路由器可以连接不同的$LAN$,连接不同的$VLAN$,连接不同的$WAN$,或者把$LAN$和$WAN$互连起来。
    +   路由器隔离了广播域。 

+   从结构上看，路由器由路由选择和分组转发两部分构成

    ![image-20230801234812750](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308012348886.png)

    而从模型的角度看,路由器是网络层设备，它实现了网络模型的下三层，即物理层、数据链路层和网络层

    +   **路由选择部分**也称**控制部分**，其核心构件是**路由选择处理机**

        +   路由选择处理机的任务是根据所选定的路由选择协议构造出路由表
        +   同时经常或定期地和相邻路由器交换路由信息而不断更新和维护路由表。 

    +   **分组转发部分**由三部分组成：

        1.   交换结构

        2.   一组输入端口

        3.   一组输出端口

             +   输入端口在从物理层接收到的比特流中提取出数据链路层帧，进而从帧中提取出网络层数据报，输出端口则执行恰好相反的操作

             +   交换结构是路由器的关键部件，它根据转发表对分组进行处理，将某个输入端口进入的分组从一个合适的输出端口转发出去

                 +   有三种常用的交换方法：
                     1.   通过存储器进行交换
                     2.   通过总线进行交换
                     3.   通过互联网络进行交换

                 +   交换结构本身就是一个网络。 

+   路由器主要完成两个功能：一是分组转发，二是路由计算

    +   前者处理通过路由器的数据流， 关键操作是转发表查询、转发及相关的队列管理和任务调度等
    +   后者通过和其他路由器进行基于路由协议的交互，完成路由表的计算。

+   路由器和网桥的重要区别是：

    +   网桥与高层协议无关
    +   而路由器是面向协议的
        +   它依据网络地址进行操作，并进行路径选择、分段、帧格式转换、对数据报的生存时间和流量进行控制等
        +   现今的路由器一般都提供多种协议的支持，包括$OSI、TCP/IP、IPX$等。

>   ==如果一个=存储转发设备=实现了某个层次的功能，那么它就可以互连两个在该层次上使不同协议的网段/网络 。==
>
>   如网桥实现了物理层和数据链路层，那么网桥可以互连两个物理层和数据链路层不同的网段，但中继器实现了物理层后，却不能互连两个物理层不同的网段，这是因为中继器不是存储转发设备它属于直通式设备。

#### 路由表与路由转发

路由表由路由选择算法得到，主要用于路由选择，总由软件实现。包括四个部分：目的网络$IP$地址、子网掩码、下一跳$IP$地址、接口。

其中路由表都有一个默认路由：$0.0.0.0$，其子网掩码为$0.0.0.0$，当不知道发送给谁时就发送这个默认路由，让别的路由器帮忙处理。

转发表是从路由表得出的，其表项和路由表项有直接的对应关系，可以使用软件实现也可以使用特殊的硬件实现。转发表必须包含完成转发功能所必须的信息，在每一行都包含要达到的目的网络到输出端口和某些$MAC$地址信息的映射。

一般默认网关地址就是路由器的$LAN$端口地址。

注意转发和路由选择的区别：

+   “转发”是路由器根据转发表把收到的IP数据报从合适豹端口转发出去，它仅涉及一个路由器
+   而“路由选择”则涉及很多路由器，路由表是许多路由器协同工作的结果
    +   这些路由器按照复杂的路由算法，根据从各相邻路由器得到的关于网络拓扑的变化情况，动态地改变所选择的路由，并由此构造出整个路由表。 

![image-20230801235638958](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308012356108.png)

>   注意，在讨论路由选择的原理时，往往不去区分转发表和路由表的区别，但要注意路由表不等于转发表。分组的实际转发是靠直接查找转发表，而不是直接查找路由表

#### 输入端口处理

1. 从线路接受分组。
2. 物理层进行处理。
3. 数据链路层进行处理。
4. 网络层进行处理，首先对数据进行分组与排队，再进行查表与转发。
5. 输出到交换结构中。

输入端口的查找和转发功能在路由器的交换功能中最重要。

#### 输出端口处理

1. 交换结构中收到分组。
2. 网络层进行处理，首先对数据进行分组与排队，速度太快需要放在缓存中并进行缓存处理。
3. 数据链路层进行处理。
4. 物理层进行处理。
5. 向线路发送分组。

若路由器处理分组的速率赶不上分组进入队列的速率，则队列的存储空间必然最终降为$0$，使后面再进入队列的分组由于没有存储而被丢弃。

路由器中的输入或输出队列产生溢出是造成分组丢失的主要原因。

#### 三层设备的对比

+ 路由器可以互联两个不同网络层协议的网段。面向协议，根据不同协议进行不同操作。
+ 网桥可以互联两个物理层和链路层不同的网段。与高层协议无关
+ 集线器不能互联两个物理层不同的网段。

