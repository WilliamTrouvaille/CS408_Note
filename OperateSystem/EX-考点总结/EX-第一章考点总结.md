# EX-第一章 计算机系统概述考点总结

## 导读

### 【考纲内容】

1. 操作系统的基本概念

2. 操作系统的发展历程

3. 程序运行环境：

    +   $CPU$运行模式。

    + 内核模式与用户模式。
    + 中断和异常的处理系统调用。
    + 程序的链接与装入。
    + 程序运行时内存映像与地址空间。

4. 操作系统结构：分层、模块化、宏内核、微内核、外核。

5. 操作系统引导

6. 虚拟机

### 【复习提示】

选择题：操作系统的功能、运行环境和提供的服务。

## 选择题考点总结

### 操作系统概述

1.   操作系统$OS(Operating\;System)$：指控制和管理整个计算机系统的硬件与软件资源，合理地组织、调度计算机的工作与资源的分配，进而为用户和其他软件提供方便接口与环境的程序集合。操作系统是计算机系统中最基本的**系统软件**。

2.   操作系统的功能

     1.   计算机系统资源的管理者：管理软硬件资源、合理的组织、调度计算机的工作与资源的分配。
          1.   中央处理器$CPU$管理：可理解为对进程的管理。进程管理的主要功能包括进程控制、进程同步、进程通信、死锁处理、处理机调度等。
          2.   存储器管理：主要包括内存分配与回收、地址映射、内存保护与共享和内存扩充等功能。
          3.   文件管理：包括文件存储空间的管理、目录管理及文件读写管理和保护等。
          4.   设备管理：包括缓存管理、设备分配、设备处理和虚拟设备等功能。
     2.   用户与计算机硬件系统之间的接口：向上层提供方便易用的服务。
          1.   命令接口：用户可以直接使用的。
               1.   联机命令接口：又称交互式命令接口，适用于分时或实时系统的接口。用户说一句，系统跟着做一句。
               2.   脱机命令接口：又称批处理接口，使用于批处理系统。用户说一堆，系统跟着做一堆。
          2.   程序接口：用于请求操作系统服务。由一组**系统调用**组成。只能通过用户程序间接调用，如使用各种外部设备、申请分配和回收内存及其它各种要求。
          3.   图形用户接口：即图形用户界面$GUI$，指采用图形方式显示的计算机操作用户界面。图形接口不算操作系统的一部分，但是其调用的系统调用是操作系统的一部分。
     3.   作为扩充机器（虚拟机）：没有任何软件支持的计算机称为裸机，覆盖了软件的机器称为**扩充机器**或**虚拟机**。

3.   操作系统的特征：**并发、共享、虚拟、异步**。其中**并发和共享**是两个最基本的特征，两者互为存在条件。

     1.   并发：两个或多个事件在同一时间间隔内发生。操作系统的并发性指系统中**同时存在着多个运行的程序**。
          1.   一个单核$CPU$同一时刻只能执行一个程序，但操作系统会协调多个程序使他们交替进行。
          2.   操作系统是伴随着“多道程序技术”出现的，因此**操作系统和并发是一同诞生的**。
          3.   单核$CPU$只有并发没有并行，多核$CPU$同时有并发和并行。
     2.   共享：指系统中的资源可供内存中多个并发执行的进程共同使用。
          1.   互斥共享：系统中的某些资源，虽然可以提供给多个进程使用，但**一个时间段内只允许一个进程访问该资源**。
               +   **临界资源（独占资源）**：在一段时间内只允许一个进程访问的资源，计算机中大多数物理设备及某些软件中的栈、变量和表格都属于临界资源，它们被要求互斥共享。
          2.   同时共享：计算机中的某个资源在在一段时间内可以同时允许多个进程访问。同时共享通常要求一个请求分为几个时间片段间隔的完成，即交替进行，微观上“分时共享”。
     3.   虚拟：把一个物理上的实体变为若干逻辑上的对应物。**没有并发性，就没有虚拟性**。
     4.   异步：**进程的执行以不可预知的速度向前推进**。**只有系统拥有并发性，才有可能导致异步性**。

4.   操作系统的发展

     1.   手动操作阶段：无操作系统。
     2.   单道批处理系统：引入**脱机输入/输出技术**。
     3.   多道批处理系统：操作系统正式诞生，引入中断技术，能并发执行程序。

5.   操作系统的分类

     1.   分时操作系统：以时间片为单位轮流为各个用户/作业服务。对于每个用户都是公平的，不能处理紧急任务。
     2.   实时操作系统：能优先响应紧急任务。
          1.   硬实时系统：对某个动作必须绝对在指定时间内完成，如导弹系统、股票系统、自动驾驶系统等。
          2.   软实时系统：对某个动作可以接受偶尔违反规定且伤害较小，如订票系统，旅店管理系统。

6.   操作系统的体系结构：按功能关系分类可以分为分层式架构和模块化架构；按照内核架构分类可以分为宏内核和微内核。

     1.   宏内核（大内核）：除了基本功能外还包含进程管理等其他功能。主流的系统，如$Windows$、$MacOS$、$Linux$等都是宏内核。
          1.   优点：高性能，速度快。
          2.   缺点：内核代码庞大，结构混乱，难以维护。可靠性低，单个服务崩溃全系统崩溃。占用空间大。可移植性差。
     2.   微内核：只包含低级进程（线程）管理、低级存储器管理、中断和陷入处理、低级输入输出。**通过信息传递机制传输数据**。
          1.   特点：内核小。基于$C/S$结构。机制与策略分离。面向对象技术。
          2.   优点：扩展性和灵活性。可靠性和安全性。可移植性。分布式计算。
          3.   缺点：因为很多功能不在内核中，需要频繁在核心态和用户态之间切换，效率较低。
     3.   分层法（分层结构）：层$0$为硬件，层$N$为用户接口，每层只能调用紧邻其低层的功能和服务，为单向依赖。
          1.   优点：便于系统调试和验证。易扩充和维护，不会影响其他层次。
          2.   缺点：分层困难。依赖复杂，不够灵活。使用一个功能要穿越多层调用，效率较低。
     4.   模块化：将系统功能划分为多个独立模块，**通过接口进行通信**。重点是划分模块的方式。
          1.   优点：无需采用消息传递进行通信，效率高。支持动态加载新的内核模块，增强了操作系统的可适应性。模块间逻辑清晰易于维护，可多模块同时开发，加速了操作系统的开发过程。
          2.   缺点：模块间的接口规定很难满足对接口的实际需求。模块间相互依赖，更难调试和验证。

7.   ※操作系统引导：**操作系统最终加载到$RAM$中**。

     1.   激活$CPU$：$CPU$读取$ROM$中的$Boot$程序，跳转并开始执行**基本输入输出系统**$BIOS$的指令。
          + **基本输入输出系统**$BIOS$：一组固化到计算机内主板上一个$ROM$芯片上的程序，保存着计算机最重要的基本输入输出的程序、开机后自检程序和系统自启动程序。主要功能是为计算机提供最底层的、最直接的硬件设置和控制。
     2.   硬件自检：检查并识别已连接的外设，检查硬件是否出现故障。有故障主板会发出不同含义的蜂鸣，启动中止。没有故障就继续。
     3.   加载带有操作系统的硬盘：$BIOS$读取$Boot\;Sequence$（通过$CMOS$里保存的启动顺序，或者通过与用户交互的方式），把控制权交给启动顺序排在第一位的存储设备，然后$CPU$将该存储设备引导扇区的内容加载到内存中。
     4.   在$ROM$中加载**主引导记录**$MBR$：先找引导硬盘，找不到就死机。**主引导记录**$MBR$的作用是指示操作系统在硬盘的哪个主分区。
     5.   **主引导记录**$MBR$扫描硬盘分区表，加载硬盘活动分区，找到硬盘活动分区后，开始加载硬盘活动分区，将控制权交给活动分区。
     6.   $MBR$加载分区引导记录$PBR$，即该分区的启动程序（操作系统引导扇区），读取活动分区的第一个扇区，即**分区引导记录**$PBR$。
          +   **分区引导记录**$PBR$作用是寻找并激活分区根目录下用于引导操作系统的程序（启动管理器）。
     7.   加载启动管理器：硬盘的分区引导记录搜索活动分区中的启动管理器（活动分区的引导扇区的**引导程序**）。
     8.   加载操作系统：常驻内存的只有操作系统的**内核**，其他需要时再调入。

8.    虚拟机：使用虚拟化技术，将一台物理机器虚拟化为多台**虚拟机器**$VM(Virtual \;Machine)$。每个**虚拟机器**都可以独立运行一个操作系统。分为裸金属架构（第一类$VMM$，直接运行在硬件上），寄居架构（第二类$VMM$，运行在宿主操作系统上）。

### 操作系统运行环境

1.   $CPU$状态：程序状态字寄存器$PSW$中的某标志位来标识当前处理器处于什么状态，如$0$为用户态，$1$为核心态。

     1.   内核态：又称**核心态**或**管态**。可以执行特权指令。
     2.   用户态：又称**目态**。只能执行非特权指令。

2.   两种指令：特别注意$I/O$指令都是特权指令（涉及中断）。

     1.   特权指令：只能操作系统使用，普通用户不能直接使用。

          如**有关对$I/O$设备使用的指令**、有关**访问程序状态**的指令、**存取特殊寄存器**指令。

          具体而言如清内存、**置时钟**、输入输出、分配系统资源、**修改虚存的段表和页表**，修改用户的访问权限等。

          修改$PSW$中$CPU$状态标志位的指令也属于特权指令。

     2.   非特权指令：可以被用户自由使用的指令。

          如读取时钟、**从内存中取数、将运算结果装入内存**、算术运算、寄存器清零等。

3.   $CPU$状态的转换

     1.   内核态$\to$用户态：执行特权指令修改$PSW$的标志位为“用户态”，操作系统主动让出$CPU$使用权。
     2.   用户态$\to$内核态：由“**中断**”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回$CPU$的使用权。**但凡需要操作系统介入的地方，都会触发中断信号**。
          + 执行**自陷指令**也将引发陷阱**中断**，从而进入内核态。

4.   内核功能

     1.   时钟管理：进程等的计时功能、**时钟中断实现进程切换**。
     2.   中断处理：实现中断机制的中断服务程序部分。
     3.   原语：定义原语的直接方法是**关中断**，让所有操作一致完成再开中断。如设备驱动、$CPU$切换、进程通信等。
     4.   系统资源管理功能

5.   中断：见$CO$第七章。三个部分的中断全总结在那里。

6.   系统调用：也称为**广义指令**。系统调用的相关处理只能在**核心态**下执行，系统调用需要触发**访管指令**。

     1.   需要用到系统调用的功能：**凡是与共享资源有关的操作**（如存储分配、$I/O$操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核代为完成。
     2.   ※系统调用的过程：传递系统调用参数、执行陷入指令、执行系统调用相应服务程序、返回用户程序。
          +   发出系统调用请求的是在用户态，而对系统调用的相应处理在核心态下进行。

7.   陷入指令：也称为$trap$指令，访管指令，在**用户态**执行（因此**不是特权指令**），执行陷入指令后立刻引发一个**内中断**，从而$CPU$进入**核心态**。陷入指令是**唯一一个**只能在用户态执行，而不能在核心态执行的指令。

8.   系统调用与库函数的联系与区别

     1.   系统调用是操作系统的⼀部分，是内核为⽤户提供的程序接⼝，运⾏在内核空间；库函数是语⾔或应⽤程序的⼀部分，运⾏在⽤户空间中。
     2.   许多库函数都会使⽤系统调⽤来实现功能，也存在没有使⽤系统调⽤的库函数。
     3.   未使⽤系统调⽤的库函数，执⾏效率通常⽐系统调⽤的⾼（**系统调⽤要完成上下⽂的切换和状态的转换**）。