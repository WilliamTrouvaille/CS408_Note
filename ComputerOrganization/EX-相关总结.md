# CO相关总结

## 易错

### 字

**字、字长、机器字长、指令宇长、存储字长和字节**

+   **字节**是固定单位，一个字节始终等于8位，$1B=8bit$，与以下其他没有联系
+   **字**用来表示被处理信息的单位，用来度量数据类型的宽度，如x86机器中将一个字定义为16位。
+   **字长/机器字长**：在通常所说的“某16位或32位机器”中，16、32指的是字长，也称机器字长。
    +   所谓字长，通常是指CPU内部用于整数运算的数据通路的宽度，
    +   因此字长等于CPU内部用于整数运算的运算器位数和通用寄存器宽度，它反映了计算机处理信息的能力。
+   **存储字长**：一个存储单元存储的二进制代码的长度。
    +   早期的存储字长一般与指令字长、字长相等，因此访问一次主存便可取出一条指令或一个数据。
    +   随着计算机的发展，指令字长、字长都可变，但==必须都是字节的整数倍==。
+   **指令字长**：一个指令字中包含的二进制代码的位数。
    +   指令字长一般是存储字长的整数倍，这是为了硬件设计方便，而不是必然的关系。
        +   若指令字长等于存储字长的$n$倍，则需要$n$个访存周期来取出一条指令
        +   若指令字长等于存储字长，则取指周期等于机器周期。
    +   ==实际上指令字长取决于操作码长度、地址码长度和地址码个数==。
        +   与机器字长没有必然的联系
        +   但为了硬件设计方便，指令字长一般取字节或存储字长的整数倍

#### 各种硬件的位数

| 硬件       | 位数             |
| ---------- | ---------------- |
| ALU        | 机器字长         |
| 通用寄存器 | 机器字长         |
| IR         | 指令字长         |
| PC         | 对应存储单元个数 |
| MAR        | 对应存储单元个数 |
| MDR        | 存储字长         |

+   $ALU$
    +   基本ALU具有三个并行数据总线，包括两个输入操作数A、B和一个结果输出Y，且A、B、Y总线宽度相同。
    +   ALU的宽度即ALU运算对象的宽度，通常与字长/机器字长相同
    +   ALU是CPU的核心部分，能直接处理的二进制数据位数（输入的操作数的位数）等于==机器字长==。
+   通用寄存器
    +   ALU操作数的来源通常是通用寄存器
    +   因此通用寄存器位数=输入ALU的操作数的位数===机器字长==。
+   指令寄存器$IR$
    +   IR用于保存当前正在执行或解码的指令，在简单的处理器中，每条要执行的指令都被加载到IR中
    +   其位数取决于==指令字长==。
+   程序计数器$PC$
    +   用于存放下一条要执行的指令在主存中的地址。
    +   位数取决于==可寻址内存==，例如，PC宽度为$32$位 能够寻址$2^{32}$个存储单元。
    +   所以PC的位数n反映了主存的容量。
+   地址寄存器$MAR$
    +   MAR里保存着需要访问的数据的内存位置。
    +   ==位数同PC，由存储单元的个数决定==。

+   数据寄存器$MDR$
    +   $MDR$充当处理器和内存单元之间的缓冲区，存放指令或地址（间接寻址）。
    +   一个要存储的字必须传送到$MDR $，从那里转到特定的内存位置。
    +   $MDR$的位数由==存储字长==决定。
+   按字节/字/`X bit`编址
    +   按字节/字/Xbit编址分别表示存储空间的最小编址单位是字节/字/Xbit，
    +   用白话说，每个存储单元里的二进制代码位数为1字节/1个字长/Xbit
    +   这个长度就是存储单元长度，也即==存储字长==。
+   地址总线
    +   地址总线位数决定了CPU可以直接访问的RAM的最大数量，因为每根线对应一个地址位。
    +   例如：
        +   具有32位地址总线的计算机可以直接寻址4GB（$2^{32}$B ）的物理内存
        +   而36位的计算机可以寻址64GB($2^{36}$B)。
    +   如果I/O端口和主存地址空间统一编址，也要把I/O端口的数量考虑进去。
+   数据总线
    +   数据总线==可以双向传输，其位数和机器字长、存储字长有关==
    +   ==如果等于机器字长，那么传输一次刚好可以处理一次==
    +   ==如果等于存储字长，那么传输一次刚好可以读写一次==。
    +   数据总线的位数与处理器的位数相同，它表示CPU 一次能处理的数据的数，即CPU的位数
+   总线宽度
    +   总线宽度又称总线位宽，是该总线可同时传输数据的位数，通常指==数据总线的根数==。
+   ALU
    +   ALU的位数取决于能执行的操作($2^n$)


### ※K的换算

+   ==在描述**存储容量、文件大小**等时，$K、M、G、T$通常用$2$的幂次表示，如$1Kb=2^{10}b$;==
    +   计算机内部的$K$基本都表示$1024$

+   ==在描达**速率、频率**等时，$k、M、G、T$通常用$10$的幂次表示，如$1kb/s=10^{3}b/s$。通常前者用大写的$K$，后者用小写的$k$，但其他前缀均为大写，表示的含义取决于所用的场景。==
    +   $CN$中在计算信号的传输速率时表示$1000$

### 对用户是否透明

取决于该部件的功能是否有必要被用户操作

+   不透明的
    +   CPU
        +   通用寄存器组$X$
        +   程序状态字寄存器$PSW$
        +   程序计数器$PC$
+   透明的，对程序员不可见
    +   CPU
        +   指令寄存器$IR$
        +   暂存寄存器$R$
        +   $MAR$
        +   $MDR$
        +   微程序的结构和功能

## 标志位

### 带标志位加法器的四个标志位

#### 零标志位

即$ZF$（$Zero\;Flag$）。判断当前数字是否为全0值。

+ $ZF=1$表示结果为$0$。
+ **无论是有符号数还是无符号数，$ZF$都有意义。**
+ 通过加法电路和最后的取反操作实现。

#### 溢出标志位

即$OF$（$Overflow\;Flag$）。表示带符号整数运算时结果发生溢出。

+ $OF=1$表示溢出。
+ 对于无符号整数运算，$OF$没有意义。

对于有符号数的溢出判断方式有：

1. 采用一位符号位：思想为：正正得负或负负得正则为溢出，其他情况无溢出。
    + 设$A$符号为$A_S$、$B$符号为$B_S$、运算结果符号为$S_S$。
    + 溢出逻辑表达式为
        $$
        V=A_SB_S\overline{S_S}+\overline{A_SB_S}S_S
        $$
    
2. 采用双符号位：$s1$、$s2$表示运算结果的两个符号位：
    + $s1s2=00$：表示正数，无溢出。
    + $s1s2=01$：表示结果正溢出 ，即正正得负，且$s2$表示当前运算符号为负，$s1$表示原本正确的符号应该为正。
    + $s1s2=10$：表示结果负溢出 ，即负负得正，且$s2$表示当前运算符号为正，$s1$表示原本正确的符号应该为负。
    + $s1s2=11$：表示结果为负数，无溢出
3. 采用一位符号位，根据数据位和符号位的进位情况判断溢出：
    + $C_0$：表示运算时符号位(最高位)是否产生进位，若符号位产生进位则为$1$，否则为$0$。
    + $C_1$：表示运算时最高数值位(次高位)是否产生进位，若最高数值位产生进位则为$1$，否则为$0$。
    + $$
        V=C_0\oplus C_1
        $$
    
        若$V=0$表示无溢出；$V=1$表示有溢出。

#### 符号标志位

即$SF$（$Symbol\;Flag$）。判断当前结果符号。

+ $SF=1$表示结果为负值。
+ 当产生溢出时，符号标志位置出错。
+ $$
    SF=F_{i=max}
    $$

    +   $F_{i=max}$即为运算结果的最高位
+ 对于无符号整数运算，$SF$没有意义。

#### 进/借位标志位

即$CF$（$Carry\;Flag$）。表示无符号整数数加/减运算时的进位/借位（溢出）。

+ $CF=1$表示无符号数加法溢出/减法借位。
+ $$
    CF=C_{out}\oplus Sub
    $$

    +   $Sub$即为加减法控制信号，加法0减法1
    +   $C_{out}$即为最高位产生的进位
+ ==对于有符号数的整数运算，$CF$没有意义。==

## 调度算法

### 作业与进程的调度算法

+ 适用于批处理系统算法：
    + $FCFS$.
    + $SJF/SPF/SRTN$.
    + $HRRN$.
+ 适用于交互式系统算法：
    + $RR$.
    + $PS$.
    + $MFQ$.

![image-20230618222928003](http://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306182229165.png)

|    &nbsp;    |  先来先服务  |           短作业优先           |    高响应比优先    |              时间片轮转              |               多级反馈队列               |
| :----------: | :----------: | :----------------------------: | :----------------: | :----------------------------------: | :--------------------------------------: |
| 能否是可抢占 |      否      |               是               |         是         |                  是                  |             队列内算法不一定             |
|     优点     | 公平实现简单 |   平均等待时间最少，效率最高   |    兼顾长短作业    |             兼顾长短作业             | 兼颐长短作业，有较好的响应时间，可行性强 |
|     缺点     | 不利于短作业 | 长作业会饥饿，估计时间不易确定 | 计算响应比的开销大 | 平均等待时间较长，上下文切换浪费时间 |                    无                    |
|    适用于    |      无      |      作业调度，批处理系统      |         无         |               分时系统               |                   通用                   |
| 默认决策模式 |    非抢占    |             非抢占             |       非抢占       |                 抢占                 |                   抢占                   |

$CPU$繁忙型更接近于长作业，少$I/O$所以少中断.而$I/O$繁忙型需要大量$I/O$，等待输入输出数据时会阻塞从而重新排队，所以更接近短作业.

#### 算法评价指标

+ $CPU$利用率：$CPU$忙碌时间占总时间的比例.

    + $CPU$利用率=$CPU$忙碌（运行）时间÷进程运行总时间.
    + $CPU$是计算机系统中最重要和昂贵的资源之一，所以应尽可能使$CPU$保持“忙”状态，使这一资源利用率最高

+ 系统吞吐量：单位时间内完成**作业**的数量.

    + 系统吞吐量$=\dfrac{\text{总共完成多少道作业}}{\text{总时间}}$.

+ 周转时间：从作业**被提交到系统**开始到**作业完成**为止的时间间隔.

    + 它包括四个部分：

        1. 作业在外存后备队列上等待作业调度（高级调度）的时间
        2. 进程在就绪队列上等待进程调度（低级调度）的时间
        3. 进程在$CPU$上执行的时间
        4. 进程等待$I/O$操作完成的时间.

        后三项在一个作业的整个处理过程中，可能发生多次.

    + （作业）周转时间=作业完成时间-作业提交时间.

    + 平均周转时间$=\dfrac{\text{各作业周转时间之和}}{\text{作业数}}$.

    + 带权周转时间$=\dfrac{\text{作业周转时间}}{\text{作业实际运行的时间}}=\dfrac{\text{作业完成时间}-\text{作业提交时间}}{\text{作业实际运行的时间}}\geqslant1$.是一个比值，越靠近$1$越合理.

    + 平均带权周转时间$=\dfrac{\text{各作业带权周转时间之和}}{\text{作业数}}$.

+ 等待时间：指进程或作业处于等待处理机状态时间之和.

    + 对于进程来说，等待时间就是指进程建立后等待被服务的时间之和
    + 在等待$I/O$完成的期间其实进程也是在被服务的，所以不计入等待时间.
    + 对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间.
    + 一个作业总共需要被$CPU$服务多久，被$I/O$设备服务多久一般是确定不变的，因此==调度算法其实只会影响作业或进程的等待时间==
        + 当然，与前面指标类似，也有“平均等待时间”来评价整体性能.
    + 如果一个进程到达后要么等待要么运行，则等待时间=周转时间-运行时间.
    + 如果一个进程又有计算又有$I/O$操作，则等待时间=周转时间-运行时间-$I/O$操作时间.

+ 响应时间：从用户提交请求到首次产生响应所用的时间

    + 主要用于交互式系统.

#### 先来先服务调度算法$FCFS$

即$FCFS(First-Come， First-Served)$算法.

+ 算法思想：主要从“公平”的角度考虑.
+ 算法规则：按照作业/进程到达的先后顺序进行服务.
+ 用于作业/进程调度：既可用于作业调度，又可用于进程调度
    + 用于作业调度时，考虑的是哪个作业先到达后备队列
    + 用于进程调度时，考虑的是哪个进程先到达就绪队列.
+ 是否可抢占：非抢占式的算法.
+ 特点：
    + 优点：公平、算法实现简单.
    + 缺点：排在长作业/进程后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好.
        + 即$FCFS$算法**对长作业有利，对短作业不利**.
        + ==不能作为分时系统和实时系统的主要调度策略.==
    + 但它常被结合在其他调度策略中使用。
        + 例如，在使用优先级作为调度策略的系统中，往往对多个具有相同优先级的进程按$FCFS$原则处理。
    + 利于$CPU$繁忙型作业，不利于$I/O$繁忙型作业（即适用于长作业类型）.
+ 是否会导致饥饿：不会.

![image-20230823144304672](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308231443782.png)

#### 短作业优先调度算法$SJF$

即$SJF(Shortest \;Job\; First)$算法.

+ 算法思想：追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间.
+ 算法规则：最短的作业/进程优先得到服务（==所谓“最短”，是指**要求服务时间**最短==）.
+ 用于作业/进程调度：==即可用于作业调度，也可用于进程调度.==
    + 用于进程调度时称为**短进程优先$SPF(Shortest\;Process\;First)$算法**

+ 特点：
    + 优点：“最短的”平均等待时间、平均周转时间.
    + 缺点：
        + 不公平.==对短作业有利，对长作业不利==.
        + 可能产生饥饿现象.
        + 未考虑作业紧迫性.
        + 另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先.
+ 是否可抢占：$SJF$和$SPF$都是非抢占式的算法.但是也有抢占式的版本：最短剩余时间优先算法$SRTN（Shortest\;Remaining\;Time\;Next）$
    + 最短剩余时间优先算法$SRTN$：**每当有进程加入就绪队列改变时就需要调度**，如果新到达的进程**剩余时间**比当前运行的进程剩余时间更短，则由新进程**抢占处理机**，当前运行进程**重新回到就绪队列**.另外，当一个进程完成时也需要使用$SRTN$进行调度

+ 是否会导致饥饿：会.
    + 如果源源不断地有**短**作业/进程到来，可能使**长**作业/进程长时间得不到服务，产生“饥饿”现象.如果一直得不到服务，则称为“饿死”.

>   1. 如果题目中未特别说明，所提到的“短作业/进程优先算法”**默认是非抢占式的**.
>   2. 很多书上都会说“$SJF$调度算法的平均等待时间、平均周转时间最少”，严格来说，这个表述是**错误的，不严谨的**.
>       + **最短剩余时间优先算法$SRTN$得到的平均等待时间、平均周转时间还要更少.**
>       + 应该加上一个条件“在所有进程同时可运行时，采用$SJF$调度算法的平均等待时间、平均周转时间最少”，或者说“在所有进程都**几乎**同时到达时，采用$SJF$调度算法的平均等待时间、平均周转时间最少”.
>       + 如果不加上述前提条件，则应该说“抢占式的短作业/进程优先调度算法（最短剩余时间优先，$SRNT$算法）的平均等待时间、平均周转时间最少”.
>   3. 虽然严格来说，$SJF$的平均等待时间、平均周转时间并不一定最少，但相比于其他算法（如$FCFS$），$SJF$依然可以获得较少的平均等待时间、平均周转时间.
>   4. 如果选择题中遇到“$SJF$算法的平均等待时间、平均周转时间最少”的选项，那最好判断其他选项是不是有很明显的错误，如果没有更合适的选项，那也应该选择该选项.

![image-20230823144544372](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308231445490.png)

#### 高响应比优先调度算法$HRRN$

即$HRRN$算法，高响应比优先调度$HRRN$算法主要用于作业调度

+ 算法思想：要综合考虑作业/进程的等待时间和要求服务的时间，是$FCFS$和$SJF$的综合.
+ 算法规则：在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务.
    + 响应比$R_P=\dfrac{\text{等待时间}+\text{要求服务时间}}{\text{要求服务时间}}\geqslant1$.

+ 用于作业/进程调度：==即可用于作业调度，也可用于进程调度，但是主要用于作业调度.==
+ 是否可抢占：非抢占式的算法.
    + 因此只有当前运行的作业/进程主动放弃处理机(正常/异常完成，或主动阻塞)时，才需要调度，才需要计算响应比.
        + 只有存在$I/O$操作的进程队列才会存在主动阻塞的情况

+ 特点：
    + 综合考虑了等待时间和运行时间（要求服务时间）.
    + 等待时间相同时，要求服务时间短的优先，有利于短作业
        + $SJF$的优点
    + 要求服务时间相同时，等待时间长的优先
        + $FCFS$的优点
    + 对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而**避免了长作业饥饿**的问题.
+ 是否会导致饥饿：不会.

#### 优先级调度算法$PS$

也称为优先权调度算法，即$PS（Priority Scheduling Algorithm）$算法.

==优先级调度算法既可用于作业调度，又可用于进程调度==

+ 算法思想：随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序.
+ 算法规则：==调度时选择优先级最高的作业/进程.==
    + $I/O$繁忙型作业要优于计算繁忙型作业
        + 因为$I/O$操作需要及时完成，其无法长时间保存输入输出数据
    + 系统进程的优先权应高于用户进程优先权.
+ 用于作业/进程调度：==既可用于作业调度，也可用于进程调度.甚至，还会用于在之后会学习的$I/O$调度中.==
+ 是否可抢占：抢占式、非抢占式都有，做题时的区别在于：
    + 非抢占式只需在进程主动放弃处理机时进行调度即可.
    + 抢占式还需在就绪队列变化时，检查是否会发生抢占，若优先级更高的进程进入就绪队列，则立刻暂停正在运行的进行.
+ 特点：
    + 优点：用优先级区分紧急程度、重要程度，适用于实时操作系统
        + 可灵活地调整对各种作业/进程的偏好程度.
    + 缺点：若源源不断地有高优先级进程到来，则可能导致饥饿.
+ 是否会导致饥饿：会.
    + 见上，若源源不断地有高优先级进程到来，则可能导致饥饿.

+ 优先数与优先级的关系要看具体情况，如$Windows$优先级与优先数成正比，$UNIX$中成反比.
+ 优先级调度算法中就绪队列未必只有一个，可以按照不同优先级来组织.
+ 可以把优先级更高的进程排在队头位置.
+ 根据优先级是否可以动态改变，分为：
    + 静态优先级：创建进程时确定，一直保持不变.
        + 依据
            1. 进程类型
            2. 进程对资源的要求
            3. 用户要求.
    + 动态优先级：创建进程时有初始值，之后根据情况动态调整优先级.
        + 依据
            1. 进程占用$CPU$时间的长短
            2. 就绪进程等待$CPU$时间的长短.
+ 设置进程优先级：
    + 系统进程高于用户进程.
    + 前台进程高于后台进程
        + 即交互性进程高于非交互性进程.
    + 操作系统更偏好$I/O$型进程（$I/O$繁忙型进程）而不是计算型进程（$CPU$繁忙型进程）
        + $I/O$设备和$CPU$可以并行工作
        + 如果优先让$I/O$繁忙型进程优先运行的话，则越有可能让$I/O$设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升.
+ 调整动态优先级：
    + 若进程在就绪队列中等待了很长时间，则提升其优先级.
    + 若进程占用处理机很长时间，则降低其优先级.
    + 若进程频繁进行$I/O$操作，则提升其优先级.

#### 时间片轮转调度算法

即$RR(Round -Robin -Scheduling- Algorithm)$算法.

+ 算法思想：公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应.
+ 算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如$100ms$）.若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队.
+ 用于作业/进程调度：用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）.
+ 是否可抢占：若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法.由时钟装置发出时钟中断来通知$CPU$时间片已到.
+ 特点：
    + 优点：
        + 公平.
        + ==响应快，适用于分时操作系统.==
    + 缺点：
        + 由于高频率的进程切换，因此有一定开销.
        + 不区分任务的紧急程度.
+ 是否会导致饥饿：不会.

+ 常用于分时操作系统，更注重响应时间，所以不怎么关系周转时间.
+ 在时间片轮转调度算法中，时间片的大小对系统性能的影响很大
    + 如果时间片太大，每个进程在一个时间片内就可以完完成，则时间片轮转算法会退化为**先来先服务$FCFS$算法**，增大进程响应时间，所以时间片不能太大.
    + 如果时间片太小，进程切换会频繁发生，需要保存现场恢复环境，增加时间开销.
    + 时间片分片因素：系统响应时间、就绪队列中的进程数目、系统处理能力.
    + 一般设计时间片段时要让切换进程的开销不超过$1\%$.

#### 多级反馈队列调度算法

即$MFQ$算法.

+ 算法思想：对时间片轮转调度算法和优先级调度算法的折中权衡，动态调整进程优先级和时间片大小.
+ 算法规则：
    1. 设置多级就绪队列，各级队列优先级从$1$到$k$依次递减，时间片从小到大依次变大一倍.
    2. 新进程到达时先进入第$1$级队列队尾，按$FCFS$原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾.如果此时已经是在最下级的队列，则重新放回该队列队尾.若是被剥夺，则回退到该队列队尾.
    3. 只有第$k$级队列为空时，才会为$k+1$级队头的进程分配时间片，当又有新进程进入优先级较高的队列则立刻抢占给更够优先级的进程.
+ 用于作业/进程调度：用于进程调度.
+ 是否可抢占：一般认为是抢占式的
    + 抢占式的算法.在$k$级队列的进程运行过程中，若更上级的队列（$1\sim k-1$级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回$k$级队列队尾.

+ 优缺点：
    + 对各类型进程相对公平（$FCFS$的优点）.
    + 每个新到达的进程都可以很快就得到响应（$RR$的优点）.
    + 短进程只用较少的时间就可完成($SPF$的优点）.
    + 不必实现估计进程的运行时间（避免用户作假）.
    + 可灵活地调整对各类进程的偏好程度
        + 比如$CPU$密集型进程、$I/O$密集型进程
        + 拓展：可以将因$I/O$而阻塞的进程重新放回原队列，这样$I/O$型进程就可以保持较高优先级
    + 一般不说认为$MFQ$算法有缺点，不过可能导致饥饿
+ 是否会导致饥饿：会.

各就绪队列的调度算法也可能不是时间片调度算法而是别的，但是基本上都是差不多的计算方式.

#### 多级队列调度算法

+ 系统中按进程类型设置多个队列，进程创建成功后插入某个队列
+ 队列之间可采取固定优先级，或时间片划分
    + 固定优先级：高优先级空时低优先级进程才能被调度
    + 时间片划分：如三个队列分配时间$50%、40%、10%$
+ 各队列可采用不同的调度策略
    + 系统进程队列采用优先级调度
    + 交互式队列采用$RR$
    + 批处理队列采用$FCFS$