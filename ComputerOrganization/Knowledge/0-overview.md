# 第一章 计算机系统概述

## 【考纲内容】

### 【考纲内容】

1. **计箅机系统层次结构**
    
    - 计算机系统的基本组成
    - 计算机硬件的基本组成
    - 计算机软件和硬件的关系
    - 计算机系统的工作原理：“存储程序”方式、高级语言程序与机器语言程序的转换程序和指令的执行过程
2. **计算机性能指标**

    - 吞吐量、响应时间、CPU时钟周期、主频、$CPI$、$CPU$执行时间


    - $MIPS$、$MFLOPS$、$GFLOPS$、$TFLOPS$、$PFLOPS$、$EFLOPS$、$ZFLOPS$


### 【知识导图】

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/DFB631B62B5746AE93BDE69E9C818ACE.png)

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/0BDB891F8C034AED8807FDEDAFB6FEA2.png)

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/1000BF9CB68B4FCEAAD5CE99DB22B6B4.png)

### 【复习提示】

本章是组成原理的概述，考查时易针对有关概念或性能指标出选择题，也可能综合后续章节的内容出有关性能分析的综合题。掌握本章的基本概念，是学好后续章节的基础。部分知识点在初学时理解不深刻也无须担忧， 相信随着后续章节的学习，一定会有更为深入的理解

学习本章时，请读者思考以下问题;         .

1) 计算机由哪几部分组成? 以哪部分为中心? .

2) 主频高的 $CPU $一定比主频低的$CPU $快吗? 为什么?

3) 翻译程序、汇编程序、编译程序、解释程序有什么差别? 各自的特性是什么?

4) 不同级别的语言编写的程序有什么区别? 哪种语言编写的程序能被硬件直接执行?



## *计算机发展历程

| 发展阶段 |   时间    |         逻辑元件         | 速度（次/秒） |      内存      |              外存              |
| :------: | :-------: | :----------------------: | :-----------: | :------------: | :----------------------------: |
|  第一代  | 1946-1957 |          电子管          |   几千-几方   | 汞延迟线、磁鼓 |         穿孔卡片、纸带         |
|  第二代  | 1958-1964 |          晶体管          |  几万-几干万  |   磁芯存储器   |              磁带              |
|  第三代  | 1964-1971 |     中小规模集成电路     | 几十万-几百万 |  半导体存储器  |           磁带、磁盘           |
|  第四代  | 1972-现在 | 大规模、超大规模集成电路 |  上千万-万亿  |  半导体存储器  | 磁盘、磁带、光盘、半导体存储器 |

+ 第一代使用纸带磁带编程。
+ 第二代出现了面向过程的程序设计语言$FORTRAN$，有了操作系统雏形。
+ 第三代主要用于科学计算等专业用途，高级语言快速发展，开始有了分时系统。
+ 第四代开始出现$CPU$、$PC$，如$Windows$、$MacOS$等。



## 计算机系统层次结构

### 计算机系统的组成

计算机系统 = 硬件系统 + 软件系统

软件= 程序+数据+文档

计算机软件=应用软件+系统软件

**计算机系统性能的好坏，很大程度上是由软件的效率和作用来表征的**，而软件性能的发挥又离不开硬件的支持。

#### 冯诺依曼结构

1. 计算机由五大部件组成：
    + 输入设备：将信息转换成机器能识别的形式。
    + 存储器：存放数据和程序。
    + 运算器：算术运算和逻辑运算。
    + 控制器：协调其他部件与解析存储器中的程序或指令。
    + 输出设备：将结果转换为人类熟悉的形式。
2. 指令和数据以同等地位存于存储器，可按地址寻访。
3. 指令和数据用二进制表示。
4. 指令由操作码（指令序列号，用来表示处理的指令）和地址码（操作数据存储的地址）组成。
5. 存储程序：指将指令以二进制代码的形式事先输入计算机的主存储器，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。
6. **以运算器为中心**：输入/输出设备与存储器之间的数据传送通过运算器完成。

现代计算机:以存储器为中心

$CPU(Central\,Processing\,Unit)$=运算器+控制器

![image-20230525162924076](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230525162924076.png)

#### 计算机的功能部件

##### 主存储器$(Main\,Memory,MM)$

![image-20230525163152049](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230525163152049.png)

$MAR$对应$Address $地址寄存器

$MDR$对应$Data $数据寄存器

![image-20230531150315847](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230531150315847.png)

$MAR$位数反映存储单元的个数

$MDR$位数$=$存储字长

例：

$MAR=4$位→总共有$24$个存储单元

$MDR=16$位→每个存储单元可存放$16bit$,

$1$个字($word$)$=16bit$



##### 运算器$(Arithmetic\,Logic\,Unit,ALU)$

![image-20230525163515957](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230525163515957.png)

**运算器：**用于实现算术运算（加减乘除）、**逻辑运算**（与或非）

$ACC(Accumulator)$:累加器，用于存放操作数，或运算结果。

$MQ(Multiplier-Quotient\,Register)$:乘商寄存器，在乘、除运算时，用于存放操作数或运算结果。

$X$(此字母没有专指的缩写含义，可以用作任一部件名):通用的操作数寄存器，用于存放操作数

$ALU(Arithmetic\,Logic\,Unit)$:算术逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算



以下内容详见第二章2.5.3 原码乘法

进行乘法操作$(a*b)$时,$MQ$存放乘数,$X$存放被乘数,$ALU$计算后把乘积放入$ACC$中

如果数据较大会将部分积存储在$MQ$中,在乘法的每个时钟周期中，$ALU$会将当前乘法结果累加到$MQ$中。

$ALU$还可以使用$ACC$来保存中间积的高位，以便在乘法的不同阶段进行溢出处理。

##### 控制器$(Controller,CU)$

![image-20230525163828848](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230525163828848.png)

控制单元$CU(Control\,Unit)$：分析指令，给出控制信号

指令寄存器$IR(Instruction\,Register)$：存放当前执行的指令

程序计数器$PC(Program\,Counter)$：存放下一条指令地址，有自动加1功能



$PC$(取指令)$\to$$IR$(分析指令)$\to$$CU$(执行指令)



##### 计算机执行指令的工作过程

对于C语言代码

```C
int a=2,b=3,c=1,y=0;
void main(){
    y=a*b+c;
}
```

主存中编译出来的机器语言如下:

![image-20230527210627384](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230527210627384.png)

**(MAR),(PC)指该寄存器中的内容 PC是一种特殊的寄存器**

**M指Memory存储器,这里是主存储器,M(MAR)指主存MAR指向地址所对应的内容**

**(PC)→MAR指PC里面的内容放到MAR里面**

**OP是操作码,AD是地址码**

以第一步操作为例:

初始状态：(PC)=0,指向第一条指令的存储地址

#1:(PC)→MAR,导致(MAR)=0

#3:M(MAR)→MDR,导致(MDR)=**000001** 0000000101

#4:(MDR)→1R,导致(IR)=**000001** 0000000101

#5:OP(IR)→CU,指令的操作码送到CU,CU分析后得知，这是“取数”指令

#6:AdIR)→MAR,指令的地址码送到MAR,导致(MAR)=5

#8:M(MAR)→MDR,导致(MDR)=0000000000000010=2

#9:(MDR)→ACC,导致(ACC)=0000000000000010=2

**取指令(#1~#4)**

**分析指令(#5)**

**执行取数指令(#6~#9)**



![image-20230527211541526](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230527211541526.png)

上一条指令取指后PC自动+1，(PC)=1:执行后，(ACC)=2

#1:(PC)→MAR,导致(MAR)=1

#3:M(MAR)-→MDR,导致(MDR)=**000100** 0000000110

#4:(MDR)→1R,导致(IR)=**000100** 0000000110

#5:OP(IR)→CU,指令的操作码送到CU,CU分析后得知，

#6:Ad(IR)→MAR,指令的地址码送到MAR,导致(MAR)=6

#8:M(MAR)→MDR,导致(MDR)=0000000000000011=3

#9:(MDR)→MQ,导致(MQ)=0000000000000011=3

#10:(ACC)→X,导致(X)=2

#11:(MQ)*(X)→ACC,由ALU实现乘法运算，导致(ACC)=6,



**取指令(#1~#4)**

**分析指令(#5)**

**执行取数指令(#6~#11)**



### 计算机软件

#### **程序设计语言**

+ 机器语言：唯一可以被计算机识别和执行的语言。
+ 汇编语言：必须经过汇编程序的翻译。
+ 高级语言：转换为汇编程序或直接翻译为机器语言。
    + 解释型语言：采用边解释边执行的方法。不生成目标程序，如$Python$。（每次执行都要翻译）
    + 编译型语言：必须先将源程序翻译成目标程序才能运行，如$C$语言等。（只需翻译一次）
    + $Java$既不属于传统的编译型语言，也不属于解释型语言。Java事先编译成“.class”字节码文件，然后再利用$JVM$虚拟机进行解释执行的，所以$Java$即可以说成编译型，也可以说成解释型。




#### **翻译程序**

汇编程序(汇编器):将汇编语言程序翻译成机器语言程序。

解释程序(解释器):将源程序中的语句按执行顺序逐条翻译成机器指令并执行。

编译程序(编译器):将高级语言翻译成汇编语言或机器语言程序。（只需翻译一次）

#### 软硬件逻辑等价性

硬件实现的往往是最基本的算术和逻辑运算功能，而其他功能大多通过软件的扩充得以实现。对某一功能来说，既可以由硬件实现，又可以由软件实现，从用户的角度来看，它们在功能上是等价的。这一等价性被称为软、硬件逻辑功能的等价性。例如，浮点数运算既可以用专门的浮点运算器硬件实现，又可以通过一段子程序实现，这两种方法在功能上完全等效，不同的只是执行时间的长短而已，显然**硬件实现的性能要优于软件实现的性能**。

### 计算机系统层次结构



![image-20230521155703897](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230521155703897.png)

- 高级语言层：面向用户，必须用编译程序（编译器或解释器）翻译成汇编语言程序。

- 汇编语言层：不能直接运行汇编语言，必须用汇编程序（汇编器）翻译成机器语言程序，所以是虚拟的。汇编语言与机器语言一一对应。

- 操作系统机器层：由操作系统程序实现，向上提供“广义指令”即系统调用。也称为混合层。

    ---

- 传统机器层（指令集架构层，$ISA$）：执行二进制机器指令，微程序解释机器执行微指令。

- 微指令层：由硬件直接执行微指令。只有微程序设计的计算机系统才有这一层。

- 逻辑门层：最底层的硬件系统。



## 计算机性能指标和评价

### 基本性能指标

#### 字长

字长是指计算机进行一次整数运算（即定点整数运算）所能处理的二进制数据的位数。

字长一般与计算机内部**寄存器**、**运算器**，**数据总线**的位宽相等。

**注**：

**字、字长、机器字长、指令宇长、存储字长的区别和联系是什么？**

在通常所说的“某16位或32位机器”中，16、32指的是字长，也称机器字长。所谓字长，通常是指CPU内部用于整数运算的数据通路的宽度，因此字长等于CPU内部用于整数运算的运算器位数和通用寄存器宽度，它反映了计算机处理信息的能力。字和字长的概念不同。字用来表示被处理信息的单位，用来度量数据类型的宽度，如x86机器中将一个字定义为16位。

指令字长：一个指令字中包含的二进制代码的位数。

存储字长：一个存储单元存储的二进制代码的长度。

它们都必须是字节的整数倍。

指令字长一般取存储字长的整数倍，若指令字长等于存储字长的2倍，则需要2个访存周期来取出一条指令：若指令字长等于存储字长，则取指周期等于机器周期。

早期的存储字长一般与指令字长、字长相等，因此访问一次主存便可取出一条指令或一个数据。随着计算机的发展，指令字长、字长都可变，但必须都是字节的整数倍。



#### 数据通路带宽

数据通路带宽是指数据总线一次所能并行传送信息的位数。这里所说的数据通路宽度是指外部数据总线的宽度，它与$CPU$内部的数据总线宽度·（内部寄存器的大小）有可能不同。

**注：各个子系统通过数据总线连接形成的数据传送路径称为数据通路。**



#### 主存客量

主存容量是指主存储器所能存储信息的最大容量，通常以字节来衡量，也可用字数×字长（如$512K×16位$)来表示存储容量。其中，$MAR$的位数反映了存储单元的个数，$MDR$的位数反映了存储单元的字长。例如，$MAR$为16位，表示$2^{16}$=$65536$，即此存储体内有$65536$个存储单元（可称为$64K$内存，$1K=1024$),若$MDR$为32位，表示存储容量为$64K×32$位。

增加主存容量可以减少程序运行期间访问辅存的次数，有利于提高程序的运行速度，也有利于计算机性能的提高。

**注：$MAR$是地址寄存器（用来储存地址），$MDR$是数据寄存器（用来储存数据）。**

### 与时间有关的性能指标

**程序执行时间(响应时间)=硬盘访问时间+内存访问时间+$I/O$操作时间+操作系统开销时间+$CPU$执行时间**



#### 时钟周期$T$与主频$f$

$CPU$主频$f$ :$CPU$内数字脉冲信号振荡的频率。单位为赫兹。

$CPU$主频（时钟主频）=$\frac{1}{\text{CPU时钟周期}}$。

即
$$
f=\frac{1}{T}
$$
$CPU$时钟周期$T$ ：单位为纳秒或微秒。在一个时钟周期内，$CPU$仅完成**一个最基本的动作**。



**最基本的动作$\ne $一条指令**

**最基本的动作$\ne $一条指令**

**最基本的动作$\ne $一条指令**

下文全是针对**指令**而言



#### 执行指令均所需时钟周期数$CPI$

$CPI$（$Clock\,cycle\,Per\,Instruction$）：执行一条指令所需的时钟周期数。

也称节拍周期或$T$周期

$CPI$即可表示每条指令执行所需要的时钟周期数，也可指一类指令或一段程序中所有指令所需时钟周期数的平均值。

计算公式：
$$
CPI=\frac{m}{IC}
$$
其中，程序中**包含的总指令条数用$IC$表示**，程序执行所需**时钟周期数为$m$，机器周期为$T$，频率为$f$**。

若能知道某程序中每类指令的使用频率（用$P_i$表示），每类指令的$CPI$(用$CPI_i$表示)，每类指令的条数（用$IC_i$表示)，则程序的$CPI$可表示为：
$$
\mathrm{CPI}=\sum_{i=1}^{n}\left(\mathrm{CPI}_{i} \times P_{i}\right)=\sum_{i=1}^{n}\left(\mathrm{CPI}_{i} \times \frac{\mathrm{IC}_{i}}{\mathrm{IC}}\right)
$$



#### $CPU$时间$T_{\text {cpu}}$

即执行程序一共需要多少时间
$$
T_{\text {cpu}}=m \times T
$$
考虑$CPI$后，
$$
T_{\text {cpu}}=\mathrm{CPI} \times \mathrm{IC} \times T=\frac{\mathrm{CPI} \times \mathrm{IC}}{f}
$$

#### 每时钟周期执行指令条数$IPC$

$IPC(Instructions\, Per\, Cycle)$是指每个时钟周期$CPU$能执行的指令条数，是$CPI$的倒数，
于指令流水线技术以及多核技术的发展，目前$IPC$的值已经可以大于$1$，反过来$CPI$的值也可
小于$1$。

即
$$
IPC=\frac{1}{CPI}
$$


#### 每秒执行(百万)指令条数$(M)IPS$



$IPS(Instructions\,Per\,Second)$,即每秒执行多少条指令。
$$
IPS=\frac{IC}{T_{\text {cpu}}}
$$
$MIPS(Million\,Instructions\,Per\,Second)$,即每秒执行多少百万条指令。
$$
MIPS=\frac{IC}{T_{\text {cpu}}\times 10^{6}}
$$
$MIPS$对不同机器进行性能比较是有缺陷的，因为不同机器的指令集不同，指令的功能也就
不同，比如在机器$M1$上某条指令的功能也许在机器$M2$上要用多条指令来完成：不同机器的$CPI$
和时钟周期也不同，因而同一条指令在不同机器上所用的时间也不同。



**注：**在描述存储容量、文件大小等时，$K、M、G、T$通常用$2$的幂次表示，如$1Kb=2^{10}b$;在
描达速率、频率等时，$k、M、G、T$通常用$10$的幂次表示，如$1kb/s=10^{3}b/s$。通常前者用大写的
$K$,后者用小写的$k$,但其他前缀均为大写，表示的含义取决于所用的场景。





#### 系统整体的性能指标

##### 数据通路带宽

数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）

##### 吞吐量

指系统在单位时间内处理请求的数量。

它取决于信息能多快地输入内存，CPU能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备。这些步骤中的每一步都关系到主存，因此，系统吞吐量主要取决于主存的存取周期。

##### 响应时间

指从用户向计算机发送一个请求，到系统对该请求做出响应并获得它所需
要的结果的等待时间。



### QA常见问题

问：主频高的CPU一定比主频低的CPU快吗？
	不一定，如两个CPU,A的主频为2GHz,平均CPI=10;B的主频1GHz,平均CPI=1



问：若A、B两个CPU的平均CPI相同，那么A一定更快吗？

也不一定，还要看指令系统，如A不支持乘法指令，只能用多次加法实现乘法；而B支持乘法指令。



问：基准程序执行得越快说明机器性能越好吗？

基准程序中的语可存在频度差异，运行结果也不能宪全说明问题