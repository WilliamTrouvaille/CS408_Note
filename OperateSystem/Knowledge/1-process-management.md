# 第二章 进程管理

## 导读

### 【考纲内容】

1. 进程与线程
    + 进程与线程的基本概念
    + 进程/线程的状态与转换
    + 线程的实现
        + 内核支持的线程
        + 线程库支持的线程
    + 进程与线程的组织与控制
    + 进程间通信
        + 共享内存
        + 消息传递
        + 管道

2. $ CPU $调度与上下文切换

    + 调度的基本概念
    + 调度的目标

    + 调度的实现
        + 调度器/调度程序
        + 调度的时机与调度方式(抢占式/非抢占式)
        + 闲逛进程
        + 内核级线程与用户级线程调度
    + 典型调度算法
        + 先来先服务调度算法
        + 短作业(短进程、短线程)优先调度算法
        + 时间片轮转调度算法
        + 优先级调度算法
        + 高响应比优先调度算法
        + 多级队列调度算法
        + 多级反馈队列调度算法
    + 上下文及其切换机制

3. 同步与互斥
    + 同步与互斥的基本概念
    + 基本的实现方法
        + 软件方法
        + 硬件方法
    + 锁
    + 信号量
    + 条件变量
    + 经典同步问题
        + 生产者-消费者问题
        + 读者-写者问题
        + 哲学家进餐问题

4. 死锁
    + 死锁的基本概念
    + 死锁预防
    + 死锁避免
    + 死锁检测和解除

### 【知识导图】

### 【复习提示】

进程管理是操作系统的核心,也是每年必考的重点.

其中,进程的概念、进程调度、信号量机制实现同步和互斥、进程死锁等更是重中之重,必须深入掌握.需要注意的是,除选择题外,本章还容易出综合题,其中信号量机制实现同步和互斥、进程调度算法和死锁等都可能命制综合题,如利用信号量进行进程同步就在往年的统考中频繁出现.

## 进程与线程

![image-20230611110201119](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306111102169.png)

### 进程概念

+ 程序指一个指令序列.
+ 进程为了满足操作系统的并发性和共享性.
+ 进程和程序的根本区别在于其动态性.（<span style="color:orange">注意：</span>所以进程不能与程序相等）
+ 系统为每个运行的程序配置一个数据结构,称为**进程控制块PCB**,用来描述进程的各种信息,如程序代码存放位置.
+ $PCB$、程序段、数据段三个部分构成了进程实体（进程映像）
+ 创建进程就是创建$PCB$,销毁进程就是销毁$PCB$,$PCB$是进程存在的唯一标志.
+ 进程映像是静态的,而进程是动态的.
+ 进程是进程实体的运行过程,是系统进行资源分配和调度的一个独立单位.
+ 进程和进程实体（进程映像）的区别(一般可以认为是同一个东西,不过区别还是要记得)
    + **进程是系统进行资源分配和调度的基本单位**
    + 进程实体由$PCB$、程序段、数据段组成,进程是进程实体的运行过程

+ 系统资源这里指处理机、存储器和其他设备服务于某个进程的时间单位.

#### 进程结构

![image-20230611103859745](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306111038787.png)

![image-20230611103717845](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306111037906.png)

+ 程序段（代码段）：包括程序代码,程序运行时使用、产生的运算数据,往往是只读的.
+ 数据段：存放程序运行过程中处理的各种数据.如全局变量、静态变量、宏定义的常量.
+ 进程控制块$(Process\; Control\; Block,PCB)$：操作系统用$PCB$来管理进程,所以$PCB$包含所有管理进程所需的信息.
    + 进程描述信息：
        + 进程标识符$PID$：标识进程.
        + 用户标识符$UID$：标识进程归属的用户,用于共享和保护服务.
    + 进程控制和管理信息：
        + 进程当前状态：进程状态信息,作为处理机发分配调度的依据.
        + 进程优先级：进程抢占处理机的优先级.
        + 代码运行入口地址.
        + 程序外存地址.
        + 进入内存时间.
        + 处理机占用时间.
        + 信号量使用.
    + 资源分配清单：说明有关内存地址空间或虚拟地址空间的状况,打开文件的列标与使用的输入输出设备信息.
        + 代码段指针.
        + 数据段指针.
        + 堆栈段指针.
        + 文件描述符.
        + 键盘.
        + 鼠标.
    + 处理机相关信息：主要处理机中各种寄存器值.
        + 通用寄存器值.
        + 地址寄存器值.
        + 控制寄存器值.
        + 标志寄存器值.
        + 状态字.
+ 堆：用来存放动态分配的变量,如调用`malloc`函数动态地向高地址分配空间.
+ 栈：用来实现函数调用,保存局部变量、函数传递参数,从用户空间的高地址向低地址增长.

#### 进程特征

+ 动态性：是进程最基本的特征,进程是程序的一次执行过程,是动态地产生、变化和消亡的.
+ 并发性：内存中有多个进程实体,各进程可并发执行.
+ 独立性：进程是资源分配、接受调度、能独立运行、独立获得资源、独立接受调度的基本单位.
+ 异步性：各进程按各自独立的、不可预知的速度向前推进.
    + 异步性会导致并发程序执行结果的不确定性, 操作系统要提供“进程同步机制”来解决异步问题

+ 结构性：每个进程都会配置一个$PCB$.结构上看,进程由程序段、数据段、$PCB$组成.

#### 进程组织

当一个系统中存在多个$PCB$时,需要以适当的方式组织$PCB$.

+ 链接方式：
    + 按照进程状态将$PCB$分为多个队列.如执行指针（指针数为最大执行并行数）、就绪队列指针（一般会把优先级高的进程放在队头）、阻塞队列指针（许多操作系统会根据阻塞原因的不同将其分为多个阻塞队列）.
    + 操作系统持有指向各个队列的指针.
    + ![image-20230611112722015](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306111127068.png)
+ 索引方式：
    + 根据进程状态的不同建立索引表.如执行指针、就绪表指针、阻塞表指针.
    + 操作系统持有指向各个索引表的指针.
    + ![image-20230611112756465](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306111127510.png)

#### 进程与程序

执行一条命令或运行一个应用程序时,进程和程序之间形成一对一的关系.进程在执行过程中可以加载执行不同的应用程序,从而形成一对多的关系；以不同的参数或数据多次执行同一个应用程序时,形成多对一的关系；并发地执行不同的应用程序时,形成多对多的关系.

### 进程状态

![image-20230611112836892](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306111128940.png)

#### 基本进程状态

进程$PCB$中,会有一个变量$state$来表示进程的当前状态.

具有三种基本状态和其他两种状态：

+ 运行态：占有$CPU$并已经在$CPU$上运行.
    + 单核$CPU$的情况下,同一时刻只会有一个进程处于运行态,多核$CPU$情况下,可能有多个进程处于运行态

+ 就绪态：已经具备运行条件（除处理机外的一切所需资源）,但是由于没有空闲$CPU$,导致暂时不能运行.
+ 阻塞态（等待态）：因等待某一事件而暂时不能运行,只有分配其他资源到位才能考虑分配$CPU$.
    + 进程映像还在**内存**

+ 创建态（新建态）：为进程分配所需的内存空间等系统资源,将转为就绪态.
    + 申请一个空白$PCB$.
    + 向$PCB$填写一些控制和管理进程的信息.
    + 系统为进程分配运行所需资源.
    + 进程转为就绪态.
+ 终止态（结束态）：进程运行结束或出现错误导致进程被撤销,操作系统需要回收进程资源,撤销$PCB$等工作,以防止内存泄漏.
    + 一个进程可以执行$exit$系统调用,请求操作系统终止该进程.

+ 挂起态：暂时不能获得服务,进程映像调到**外存**等待（对应进程的$PCB$还在内存中等待并允许被修改）.分为：
    + 就绪挂起态：准备好后在外存中,只要允许可以随时进入内存.
    + 阻塞挂起态：等待事件在外存中,必须等待一定时间发生.

#### 进程状态转换

五状态模型:

![image-20230611112454100](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306111124163.png)

+ 创建态到就绪态：系统完成创建进程等工作并准备好处理机等资源.
+ 就绪态到运行态：占有$CPU$资源,进程被调用.
+ 运行态到就绪态：时间片到或处理机（包含$CPU$和内存的一系列硬件）被抢占.
+ 运行态到阻塞态：进程主动用系统调用的方式申请某种系统资源（由用户态程序调用操作系统内核）,或请求等待某个事件发生.
+ 阻塞态到就绪态：申请的资源被分配或等待的事件发生,是被动发生.
+ 运行态到终止态：进程运行结束或运行过程中遇到不可修复的错误.

七状态模型:

![image-20230612112344417](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306121123469.png)

+ 创建态到就绪态：系统完成创建进程等工作并准备好处理机等资源.
+ 就绪态到运行态：占有$CPU$资源,进程被调用.
+ 运行态到就绪态：时间片到或处理机（包含$CPU$和内存的一系列硬件）被抢占.
+ 运行态到阻塞态：进程主动用系统调用的方式申请某种系统资源（由用户态程序调用操作系统内核）,或请求等待某个事件发生.
+ 阻塞态到就绪态：申请的资源被分配或等待的事件发生,是被动发生.
+ 运行态到终止态：进程运行结束或运行过程中遇到不可修复的错误.
+ 就绪挂起态到就绪态：激活.
+ 就绪态到就绪挂起态：挂起.
+ 阻塞挂起态到阻塞态：激活.
+ 阻塞态到阻塞挂起态：挂起.
+ 阻塞挂起态到就绪挂起态：阻塞事件发生.
+ 运行态到就绪挂起态：运行中内存空间不足,或优先级更高的进程进入队列.
+ 创建态到就绪挂起态：创建后发现内存空间不足.



**【注意】：**

+ “挂起”和“阻塞”的区别
    + 两种状态都是暂时不能获得$CPU$的服务,但挂起态是将进程映像调到外存去了,而阻塞态下进程映像还在内存中.

### 进程控制

#### 进程控制概念

+ 进程控制主要功能是对系统中的所有进程实施有效的管理,具有创建新进程、撤销已有进程、实现进程状态转换功能.
+ 如进程组织所说,通过将$PCB$指针放入各种状态的进程队列中转换进程状态来实现控制.
+ 进程控制由**原语**实现.
    + 特点是执行期间不能中断.
    + 这种不能中断的操作就是原子操作.
    + 原语采取“关中断指令”（屏蔽外部中断信息）和“开中断指令”（开始监听外部中断信息）实现.
    + 关/开中断指令的权限很大,所以必然是核心态下执行的特权指令.从而原语必然运行在核心态.

#### 父子进程

允许一个进程创建另一个进程.此时创建者称为父进程,被创建的进程称为子进程.子进程可以继承父进程所拥有的资源.当子进程被撤销时,应将其从父进程那里获得的资源归还给父进程.此外,在撤销父进程时,必须同时撤销其所有的子进程.

父进程创建子进程后,父进程与子进程同时执行（并发）.主程序调用子程序后,主程序暂停在调用点,子程序开始执行,直到子程序返回,主程序才开始执行.

父进程和子进程可以共享一部分资源,但是不能共享虚拟地址空间,因为这是逻辑地址.且其有不同的$PCB$用于区分进程.

#### 进程控制原语

前四种是必要的.

+ 过程创建：
    + 创建原语：
        + 分配一个唯一的进程标识号$PID$,**申请空白$PCB$**,若申请失败,则创建失败.
        + 为新进程**分配所需资源**,若资源不足,则进入阻塞态.
        + **初始化$PCB$**,主要包括标志信息、处理机状态信息、处理机控制信息、进程优先级.
        + 将$PCB$**插入就绪队列**.
            + 创建态$\to$就绪态
    + 引起进程创建的事件：
        + 用户登录：分时系统中,用户登录成功,系统会为其建立一个新进程.
        + 作业调度：多道批处理系统中,有新的作业进入内存时,会为其创建一个新进程.
        + 提供服务：用户向系统提出请求时,会创建一个新进程来处理请求.
        + 应用请求：由用户进程主动请求创建一个子进程.
+ 进程终止：
    + 撤销原语(就绪态/阻塞态/运行态$\to$终止态)：
        + 根据被终止进程的标识符,从$PCB$集合中找到终止进程的$PCB$,读取进程的状态.
        + 若进程正在运行,则立刻剥夺其$CPU$交给其他进程.
        + 若是普通的终止,父进程终止时会将其子进程交给$init$进程收养.
        + 若是整个进程组的进程,则终止其所有子进程.
        + 将进程所有的资源交给父进程或操作系统.
        + 从所在队列或链表中删除$PCB$.
    + 引起进程终止的事件：
        + 正常结束：任务完成.
            + 进程自己请求终止($exit$系统调用)
        + 异常结束：内部异常,如存储区越界、保护错、运行超时等.
            + 例如整数除以$0$、非法使用特权指令,
        + 外界干预：外部请求而终止运行,如操作员或操作系统干预、父进程请求、父进程终止.
+ 进程阻塞：
    + 阻塞原语(运行态$\to$阻塞态)：
        + 找到要阻塞的进程对应的$PCB$.
        + 保护进程运行现场,将$PCB$状态信息设置为阻塞态,暂停进程.
        + 将$PCB$插入事件等待队列,将处理机资源调度给其他就绪态进程.
    + 引起进程阻塞的事件：
        + 需要等待系统分配资源.
        + 需要等待相互合作的其他进程完成工作.
+ 进程唤醒：
    + 唤醒原语(阻塞态$\to$运行态)：
        + 在事件等待队列中找到$PCB$.
        + 将$PCB$从等待队列中移除,设置进程为就绪态.
        + 将$PCB$插入就绪队列,等待被调度.
    + 引起进程唤醒的事件：
        + 等待的事件的发生（因什么事件被阻塞就应该被什么事件唤醒）.
        + 所以进程阻塞和进程唤醒应该是成对出现的
+ 进程切换：
    + 切换原语：
        + 将处理机上下文信息,包括程序计数器$PC$和其他寄存器信息存入$PCB$.
        + $PCB$移入相应队列.
        + 选择另一个进程执行,并更新其$PCB$.
        + 更新内存管理的数据结构.
        + 根据$PCB$恢复新进程所需的运行环境.
    + 引起进程切换的事件：
        + 当前时间片到.
        + 有更高优先级进程到达.
        + 当前进程主动阻塞.
        + 当前进程终止.

### 进程通信

进程通信是两个进程之间的数据交互.

为了保证安全,一个进程不能直接访问另一个进程的地址空间,但是又必须有进程通信.$PV$操作是低级通信方式,高级通信方式有：

+ 共享存储：分配一个可以共同使用的共享空间,进程对其的使用必须是互斥的（使用同步互斥工具如$PV$操作）.
    + 基于数据结构：共享空闲只能放固定的数据结构如数组等.速度慢,限制多,是低级通信方式.
    + 基于存储：内存中划出一块共享存储区,数据的形式、存放位置都由进程控制而非操作系统.速度更快,限制少,是高级通信方式.
    + ![image-20230611123227178](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306111232224.png)
+ 信息传递：进程间的数据交换以格式化的消息为单位.进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换.
    + 消息包括消息头和消息体,消息头包括：发送进程$ID$、接受进程$ID$、消息类型、消息长度等格式化的信息.
    + 消息传递包括：
        + 直接通信方式：消息直接挂到接受进程的信息缓冲队列上.
        + 间接通信方式：消息先发送到中间实体（信箱）中,因此也称为信箱通信方式,如计算机网络中的电子邮件系统.
    + ![image-20230611123849695](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306111238747.png)
+ 管道通信：是消息传递的特殊方式,指用于链接各自一个的读写进程的一个共享文件,又名$pipe$文件,其实就是内存中开辟一个大小**固定**的缓冲区.  
    + 只能使用半双工的通信,**同一时间段**内只能**单向**传输(但传输结束释放空间后可以进行方向相反的传输),若要**双向同时**通信则必须设置两个管道.
    + 两个进程使用生产者-消费者的方式进行通信
    + 进程需要互斥访问管道,需要满足互斥、同步、确定对方存在.
    + 数据以字符流的形式写入管道,当满时,写进程的$write()$系统调用将被阻塞,等待读进程将数据取走.当读进程将数据全部取走后,管道变空,此时读进程的$read()$系统调用将被阻塞.
    + 如果没有**写满**则不允许读,如果没有**读空**则不允许写.所以读写都可能被堵塞.
    + 管道中的数据一旦被读出,就彻底消失.因此,当多个进程读同一个管道时,可能会错乱.对此,通常有两种解决方案
        1. 一个管道允许多个写进程一个读进程($2014$年$408$真题高教社官方答案)
            + 以这个说法为主
        2. 允许有多个写进程,多个读进程,但系统会让各个读进程轮流从管道中读数据($Linux$的方案).
            + 但这个说法也没错
+ 共享文件（文件系统）：利用操作系统提供的文件共享功能实现进程之间的通信.
+ 信号量：也需要信号量来解决文件共享操作中的同步和互斥问题.

由于不同进程拥有不同代码段和数据段,全局变量是针对同一个进程而言,所以全局变量不能用来交换数据.

### 线程

#### 线程概念

传统而看,进程是程序的一次执行,但是程序的多个功能不能由一个程序顺序处理就能完成,所以一个进程需要同时进行多个任务,所以就引入了线程来增加并发度.

由线程$ID$、程序计数器$PC$、寄存器集合和堆栈组成.

线程是$CPU$**执行**的基本单元,是程序执行流的最小单位,是处理机的分配单元.进程只作为除$CPU$之外的系统资源的分配单元,即打印机等都是分配给线程而不是进程.

#### 线程与进程

+ 系统分配调度：
    + 传统进程机制中,进程是资源分配、调度的基本单位.
    + 引入线程后,进程是**资源分配**的基本单位,线程是**调度**的基本单位.
    + 同一进程中,线程切换不会导致进程切换,在不同进程进行线程切换才会引起进程切换.
+ 拥有资源：
    + 进程都是拥有资源的基本单位,线程除了必备的资源不拥有系统资源.
    + 线程可以拥有同进程的所有资源.
    + 同进程的所有线程共享进程地址空间.
+ 并发性：
    + 传统进程机制中,只能进程间并发.
    + 引入线程后,各线程间也能并发,提升了并发度.
+ 系统开销：
    + 传统的进程间并发,需要切换进程的运行环境,系统开销很大.
    + 线程间并发,如果是同一进程内的线程切换,则不需要切换进程环境,系统开销小.
    + 引入线程后,并发所带来的系统开销减小.
    + 同一进程多个线程共享进程地址空间,所以线程同步通信非常容易.
+ 地址空间和其他资源：
    + 进程间不可见,同一进程的线程间可见.
+ 通信：
    + 进程间通信$IPC$需要进程同步和互斥来保证一致性.
    + 线程间可以直接读写进程数据段如全局变量完成.

#### 线程属性

+ 线程是处理机调度的单位.
+ 多$CPU$计算机中,各个线程可占用不同的$CPU$.
+ 每个线程都有一个线程$ID$、线程控制块$TCB$（记录线程执行的寄存器和栈等现场状态）.
+ 线程也有就绪、阻塞、运行三种基本状态.
+ 线程几乎不拥有系统资源.
+ 同一进程的不同线程间共享进程的资源.
+ 由于共享内存地址空间,同一进程中的线程间通信甚至无需系统干预.
+ 没有独立地址空间.
+ 同一进程中的线程切换,不会引起进程切换.
+ 不同进程中的线程切换,会引起进程切换.
+ 切换同进程内的线程,系统开销很小.
+ 切换进程,系统开销较大.
+ 只有执行、就绪、阻塞三种状态.

#### 线程实现

![image-20230612105036603](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306121050661.png)

线程库（$thread\,library$）是为程序员提供创建和管理线程的$API$.线程库中的线程都是单例模式,所以不同的进程使用线程库中的同名线程都是同一个线程.实现线程库主要的方法有如下两种：

1. 在用户空间中提供一个没有内核支持的库.这种库的所有代码和数据结构都位于用户空间中.这意味着,调用库内的一个函数只导致用户空间中的一个本地函数的调用.
2. 实现由操作系统直接支持的内核级的一个库.对于这种情况,库内的代码和数据结构位于内核空间.调用库中的一个$API$函数通常会导致对内核的系统调用.

用户级线程$(User-Level\;Thread,ULT)$：

![image-20230612104426282](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306121044334.png)

+ 用户级线程由应用程序通过线程库实现.所有的线程管理工作都由应用程序负责（包括线程切换）.
+ 用户级线程中,线程切 换可以在用户态下即可完成,无需操作系统干预.
+ 在用户看来,是有多个线程.但是在操作系统内核看来,并意识不到线程的存在.用户级线程对用户不透明,对操作系统透明.
+ 所以操作系统无法操作用户级线程,就不会给用户级线程分配$TLB$.
    <!-- + 操作系统无法进行线程调度,只能进行进程调度. -->

优点：

+ 线程切换不需要转换到内核空间,节省了模式切换的开销.
+ 调度算法可以是进程专用的,不同的进程可根据自身的需要,对自己的线程选择不同的调度算法.
+ 用户级线程的实现与操作系统平台无关,对线程管理的代码是属于用户程序的一部分.

缺点：

+ 系统调用的阻塞问题,当线程执行一个系统调用时,不仅该线程被阻塞,而且进程内的所有线程都被阻塞.
+ 不能发挥多处理机的优势,内核每次分配给一个进程的仅有一个$CPU$,因此进程中仅有一个线程能执行.

内核级线程（内核支持的线程）$KLT$：

![image-20230612104409533](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306121044601.png)

+ 内核级线程的管理工作由操作系统内核完成.
+ 线程调度、切换等工作都由内核负责,因此内核级线程的切换必然需要在核心态下才能完成.
+ 内核级线程就是从操作系统内核视角看能看到的线程.
    <!-- + 由于操作系统只能看见内核级线程,所以只有内核级线程才是处理机分配的单位,此时操作系统才能进行线程调度. -->

优点：

+ 能发挥多处理机的优势,内核能同时调度同一进程中的多个线程并行执行.
+ 如果进程中的一个线程被阻塞,内核可以调度该进程中的其他线程占用处理机,也可运行其他进程中的线程.
+ 内核支持线程具有很小的数据结构和堆栈,线程切换比较快、开销小.
+ 内核本身也可采用多线程技术,可以提高系统的执行速度和效率.

缺点：

+ 同一进程中的线程切换,需要从用户态转到核心态进行,系统开销较大.这是因为用户进程的线程在用户态运行,而线程调度和管理是在内核实现的.

组合方式：

+ 有些系统使用组合方式的多线程实现.
+ 在组合实现方式中,内核支持多个内核级线程的建立、调度和管理,同时允许用户程序建立、调度和管理用户级线程.
+ 一些内核级线程对应多个用户级线程,这是用户级线程通过时分多路复用内核级线程实现的.
+ 同一进程中的多个线程可以同时在多处理机上并行执行,且在阻塞一个线程时不需要将整个进程阻塞.

#### 多线程模型

组合方式同时支持用户线程和内核线程,对于用户级线程如何映射到内核级线程的问题出现了“多线程模型”问题.

+ 多对一模型：
    + 多个用户级线程映射到一个内核级线程.每个用户进程只对应一个内核级线程.多个用户级线程共用一个线程控制块.
    + 优点：用户级线程的切换在用户空间即可完成,不需要切换到核心态,线程管理的系统开销小,效率高.
    + 缺点：当一个用户级线程被阻塞后,整个进程都会被阻塞,并发度不高.多个线程不可在多核处理机上并行运行.
    + ![image-20230612104659344](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306121046397.png)
+ 一对一模型：
    + 一个用户级线程映射到一个内核级线程.每个用户进程有与用户级线程同数量的内核级线程.操作系统给每个用户线程建立一个线程控制块.
    + 优点：当一个线程被阻塞后,别的线程还可以继续执行,并发能力强.多线程可在多核处理机上并行执行.
    + 缺点：一个用户进程会占用多个内核级线程,线程切换由操作系统内核完成,需要切换到核心态,因此线程管理的成本高,开销大.
    + ![image-20230612104727535](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306121047591.png)
+ 多对多模型：
    + 在同时支持用户级线程和内核级线程的系统中,可以使用二者结合的方式,将$n$个用户级线程映射到$m$个内核级线程上（$n\geqslant m$）.
    + 克服了多对一模型并发度不高的缺点,又克服了一对一模型中一个用户进程占用太多内核级线程,开销太大的缺点.
    + ![image-20230612104849035](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306121048088.png)

### 线程的状态与转换

与进程的状态与转换类似

![image-20230612105147478](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306121051531.png)

#### TCB

线程控制块$TCB(Thread \;Control\; Block)$是与进程的控制块$PCB$相似的子控制块,只是$TCB$中所保存的线程状态比$PCB$中保存少而已：

+ 线程标识符.
+ 寄存器.
+ 运行状态.
+ 优先级.
+ 专有存储区.
+ 堆栈指针.

![image-20230612105438770](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306121054816.png)

实际上只有内核级线程才有$TCB$.

#### 线程表

通过线程表,操作系统可以集中管理和跟踪所有线程的状态、上下文和其他重要信息.它提供了一种有效的方式来实现线程的创建、销毁、调度和同步.线程表的结构和内容可能因操作系统的不同而有所差异,但它们的基本功能和作用是相似的.

![image-20230612110559956](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306121105999.png)

## 处理机调度

![image-20230618210522721](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306182105842.png)

### 处理机调度的概念

+ 处理机：包括中央处理器,主存储器,输入输出接口,加接外围设备就构成完整的计算机系统.处理机是处理计算机系统中存储程序和数据,并按照程序规定的步骤执行指令的部件.
+ 处理机调度：在多道程序设计系统中,内存中有多道程序运行,他们相互争夺处理机这一重要的资源.处理机调度就是从就绪队列中,按照一定的算法选择一个进程并将处理机分配给它运行,以实现进程并发地执行.

### 处理机调度的层次

|       &nbsp;       |                           工作内容                           |       发生位置        |            发生频率            |         对进程状态的影响         |
| :----------------: | :----------------------------------------------------------: | :-------------------: | :----------------------------: | :------------------------------: |
| 作业调度(高级调度) | 按照某种规则,从后备队列中选择合适的作业将其调入内存,并为其创建进程 | 外存→内存（面向作业） | 一个作业一个调入一次调出(最低) |         无→创建态→就绪态         |
| 内存调度(中级调度) |   按照某种规则,从挂起队列中选择合适的进程将其数据调回内存    | 外存→内存（面向进程） |              中等              | 挂起态→就绪态（阻塞挂起→阻塞态） |
| 进程调度(低级调度) |     按照某种规则,从就绪队列中选择一个进程为其分配处理机      |      内存→$CPU$       |              最高              |          就绪态→运行态           |

#### 作业调度(高级调度)

+ 由于内存空间有限,有时无法将用户提交的作业全部放入内存,因此就需要确定某种规则来决定将作业从外存调入内存的顺序.一般一个作业包含多个进程
+ 高级调度按一定的原则从外存上处于后备队列的作业中挑选一个(或多个）作业,给他们分配内存等必要资源,并建立相应的进程（建立$PCB$）,以使它（们）获得竞争处理机的权利
+ 高级调度是辅存（外存）与内存之间的调度
+ 每个作业只调入一次,调出一次
+ 作业调入时会建立相应的$PCB$,作业调出时才撤销$PCB$
+ 多道批处理系统多具备,其他系统一般不需要
+ 高级调度主要是指调入的问题,因为只有调入的时机需要操作系统来确定,但调出的时机必然是作业运行结束才调出
+ 调动执行频率低.

#### 内存调度(中级调度)

+ 引入了虚拟存储技术之后,可将暂时不能运行的进程调至外存等待.等它重新具备了运行条件且内存又稍有空闲时,再重新调入内存.
+ 目的是为了提高内存利用率和系统吞吐量.
+ 暂时调到外存等待的进程状态为挂起状态.值得注意的是,$PCB$并不会一起调到外存,而是会常驻内存.$PCB$中会记录进程数据在外存中的存放位置,进程状态等信息,操作系统通过内存中的$PCB$来保持对各个进程的监控、管理.被挂起的进程$PCB$会被放到内存里的挂起队列中,当条件具备转为就绪态.
+ 中级调度就是要决定将哪个处于挂起状态的进程重新调入内存.
+ 一个进程可能会被多次调出、调入内存,因此中级调度发生的频率要比高级调度更高.

#### 进程调度(低级调度)

+ 其主要任务是按照某种方法和策略从就绪队列中选取一个进程,将处理机分配给它.
+ 进程调度是操作系统中最基本的一种调度,在一般的操作系统中都必须配置进程调度.
+ 进程调度的频率很高,一般几十毫秒一次.

### 进程调度的目标(评价指标)

![image-20230618211538030](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306182115114.png)

#### 算法评价指标

+ $CPU$利用率：$CPU$忙碌时间占总时间的比例.

    + $CPU$利用率=$CPU$忙碌（运行）时间÷进程运行总时间.

+ 系统吞吐量：单位时间内完成作业的数量.

    + 系统吞吐量$=\dfrac{\text{总共完成多少道作业}}{\text{总时间}}$.

+ 周转时间：从作业**被提交到系统**开始到**作业完成**为止的时间间隔.
    + 它包括四个部分：

        1. 作业在外存后备队列上等待作业调度（高级调度）的时间
        2. 进程在就绪队列上等待进程调度（低级调度）的时间
        3. 进程在$CPU$上执行的时间
        4. 进程等待$I/O$操作完成的时间.

        后三项在一个作业的整个处理过程中,可能发生多次.
    + （作业）周转时间=作业完成时间-作业提交时间.
    + 平均周转时间$=\dfrac{\text{各作业周转时间之和}}{\text{作业数}}$.
    + 带权周转时间$=\dfrac{\text{作业周转时间}}{\text{作业实际运行的时间}}=\dfrac{\text{作业完成时间}-\text{作业提交时间}}{\text{作业实际运行的时间}}\geqslant1$.是一个比值,越靠近$1$越合理.
    + 平均带权周转时间$=\dfrac{\text{各作业带权周转时间之和}}{\text{作业数}}$.
+ 等待时间：指进程或作业处于等待处理机状态时间之和.
    + 对于进程来说,等待时间就是指进程建立后等待被服务的时间之和
    + 在等待$I/O$完成的期间其实进程也是在被服务的,所以不计入等待时间.
    + 对于作业来说,不仅要考虑建立进程后的等待时间,还要加上作业在外存后备队列中等待的时间.
    + 一个作业总共需要被$CPU$服务多久,被$I/O$设备服务多久一般是确定不变的,因此**调度算法其实只会影响作业或进程的等待时间**.当然,与前面指标类似,也有“平均等待时间”来评价整体性能.
    + 如果一个进程到达后要么等待要么运行,则等待时间=周转时间-运行时间.
    + 如果一个进程又有计算又有$I/O$操作,则等待时间=周转时间-运行时间-$I/O$操作时间.
+ 响应时间：从用户提交请求到首次产生响应所用的时间

    + 主要用于交互式系统.


### 进程调度

![image-20230618213528616](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306182135726.png)

进程调度是最低级的调度也是其他调度的基础,是内核程序.

进程调度（低级调度）,就是按照某种算法从就绪队列中选择一个进程为其分配处理机

#### 进程调度的时机

![image-20230618211853970](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306182118023.png)

需要进行进程调度和切换：

+ 当前运行程序**主动**放弃处理机（非剥夺调度）：
    + 进程正常终止.
    + 出现异常终止.
    + 进程主动请求阻塞（如等待$I/O$）.
+ 当前运行程序**被动**放弃处理机（剥夺式调度）：
    + 分配时间片用完.
    + 有更紧急的事件需要处理（如$I/O$中断）.
    + 优先级更高进程进入就绪队列.
    + 中断处理结束.
    + 自陷处理结束.

不能进行进程调度和切换：

1. 在**处理中断**的过程中.中断处理过程复杂,很难做到在中断处理过程中进行进程切换；与硬件密切相关,不属于某一进程.

2. 进程在操作系统**内核程序临界区**中.

    + 临界资源：一个时间段内只允许一个进程使用的资源.各进程需要**互斥**地访问临界资源.

    + 临界区：一段在多个进程或线程中访问临界资源的代码区域.

    + 内核程序临界区一般是用来访问某种内核数据结构的,比如进程的就绪队列（由各就绪进程的$PCB$组成）.

    + 进程访问时会上锁,如果还没退出临界区（还没解锁）就进行进程调度,此时进程调度相关的程序也需要访问该临界资源,但是该临界资源还没解锁,因此无法顺利进行进程调度.

    + 内核程序临界区访问的临界资源如果不尽快释放的话,极有可能影响到操作系统内核的其他管理工作.因此在**访问内核程序临界区期间不能进行调度与切换**.

    + 而如果是普通程序临界区时,例如在打印机打印完成之前,进程一直处于临界区内,临界资源不会解锁.但打印机又是慢速设备,此时如果一直不允许进程调度的话就会导致$CPU$一直空闲,所以为了保证效率进程**在操作系统普通程序临界区时运行进程调度**.

3. 在**原子操作**过程中（**原语**）.原子操作不可中断,更不能切换进程,要一气呵成（如修改$PCB$中进程状态标志,并把$PCB$放到相应队列）.

进程切换往往在调度完成后立刻发生,它要求保存原进程当前切换点的现场信息,恢复被调度进程的现场信息.

现场切换时,操作系统内核将原进程的现场信息推入当前进程的内核堆栈来保存它们,并更新堆栈指针.

内核完成从新进程的内核栈中装入新进程的现场信息、更新当前运行进程空间指针、重设$PC$寄存器等相关工作之后,开始运行新的进程.

#### 进程调度的方式

针对操作系统是否可以剥夺进程处理机,进程调度方式分为：

+ 非剥夺调度方式,又称非抢占方式：
    + 只允许进程主动放弃处理机.在运行过程中即便有更紧迫的任务到达,当前进程依然会继续使用处理机,直到该进程终止或主动要求进入阻塞态.
    + 实现简单,系统开销小但是无法及时处理紧急任务.
    + 适合于早期的批处理系统.
+ 剥夺调度方式,又称抢占方式：
    + 当一个进程正在处理机上执行时,如果有一个更重要或更紧迫的进程需要使用处理机,则立即暂停正在执行的进程,将处理机分配给更重要紧迫的那个进程.
    + 可以优先处理更紧急的进程,也可实现让各进程按时间片轮流执行的功能（通过时钟中断）.
    + 适合于分时操作系统、实时操作系统.

#### 进程切换与过程

+ “狭义的进程调度”与“进程切换”的区别：
    + **狭义的进程调度**指的是从就绪队列中**选中一个要运行的进程**.
        + 这个进程可以是刚刚被暂停执行的进程,也可能是另一个进程,后一种情况就需要进程切换
        + 进程切换是指一个进程让出处理机,由另一个进程占用处理机的过程.
    + **广义的进程调度**包含了两个步骤
        1. 选择一个进程
        2. 进程切换

+ 进程切换的过程
    1. 对原来运行进程各种数据的保存
    2. 对新的进程各种数据的恢复
+ **【注意】：**
    + **进程切换是有代价的**,因此如果**过于频繁**的进行进程调度和切换,会使整个系统的效率降低,使系统大部分时间都花在了进程切换上,而真正用于执行进程的时间减少.

#### 调度程序

![image-20230612105147478](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306121051531.png)

如上图,其中②③由调度程序引起



+ 组成
    1. 排队器.
        + 将系统中的所有就绪进程按照一定的策略排成一个或多个队列,以便于调度程序选择.
        + 每当有一个进程转变为**就绪态**时,排队器便将它插入到相应的**就绪队列**中.
    2. 分派器.
        + 依据调度程序所选的进程,将其从就绪队列中取出,将$ CPU$ 分配给新进程.
    3. 上下文切换器.
        + 在对处理机进行切换时,会发生两对上下文的切换操作: 
            + 第一对,将当前进程的上下文保存到其$ PCB$ 中,再装入分派程序的上下文,以便分派程序运行
            + 第二对,移出分派程序的上下文,将新选进程的$ CPU $现场信息装入处理机的各个相应寄存器.
        + 在上下文切换时,需要执行大量$ load $和$ store $指令以保存寄存器的内容,因此会花费较多时间.
        + 现在已有硬件实现的方法来减少上下文切换时间,通常采用两组寄存器,其中一组供内核使用,一组供用户使用.这样,上下文切换时,只需改变指针,让其指向当前寄存器组即可.

+ 调度程序决定
    1. 调度算法
    2. 分配时间片大小
+ 触发调度程序的时机
    + 创建新进程
    + 进程退出
    + 运行进程阻塞
    + $I/O$中断发生（可能唤醒某些阻塞进程）
+ 调度策略
    + 非抢占式调度策略
        + 只有运行进程阻塞或退出才会触发调度程序工作
    + 抢占式调度策略
        + 每个**时钟中断**或每$k$个时钟中断都会触发调度程序工作
+ 调度程序的处理对象
    + 不支持内核级线程的操作系统,调度程序的处理对象是进程
    + 支持内核级线程的操作系统,调度程序的处理对象是内核线程



#### 闲逛进程

+ 在进程切换时,如果系统中没有就绪进程,就会调度闲逛进程（$idle$）运行
+ 如果没有其他进程就绪,该进程就一直运行,并在执行过程中测试中断
+ 闲逛进程的优先级最低,没有就绪进程时才会运行闲逛进程,只要有进程就绪,就会立即让出处理机.
+ 闲逛进程不需要$CPU$之外的资源,它不会被阻塞.

+ 特点
    + 优先级最低
    + 可以是$0$地址指令,占一个完整的指令周期（指令周期末尾例行检查中断）
    + 能耗低

#### 线程调度

+ 用户级线程调度：
    + 由于内核并不知道线程的存在,所以内核还是和以前一样,选择一个进程,并给予时间控制.
    + 由进程中的调度程序决定哪个线程运行.
    + 用户级线程的线程切换在同一进程中进行,仅需少量的机器指令.
+ 内核级线程调度：
    + 内核选择一个特定线程运行,通常不用考虑该线程属于哪个进程.
    + 对被选择的线程赋予一个时间片,如果超过了时间片,就会强制挂起该线程.
    + 内核级线程的线程切换需要完整的上下文切换、修改内存映像、使高速缓存失效,这就导致了若干数量级的延迟.

### 调度算法

指作业与进程的调度算法.

+ 适用于批处理系统算法：
    + $FCFS$.
    + $SJF/SPF/SRTN$.
    + $HRRN$.
+ 适用于交互式系统算法：
    + $RR$.
    + $PS$.
    + $MFQ$.



![image-20230618222928003](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306182229165.png)

![image-20230618222938351](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306182229419.png)

|    &nbsp;    |  先来先服务  |          短作业优先           |    高响应比优先    |             时间片轮转              |              多级反馈队列              |
| :----------: | :----------: | :---------------------------: | :----------------: | :---------------------------------: | :------------------------------------: |
| 能否是可抢占 |      否      |              是               |         是         |                 是                  |            队列内算法不一定            |
|     优点     | 公平实现简单 |   平均等待时间最少,效率最高   |    兼顾长短作业    |            兼顾长短作业             | 兼颐长短作业,有较好的响应时间,可行性强 |
|     缺点     | 不利于短作业 | 长作业会饥饿,估计时间不易确定 | 计算响应比的开销大 | 平均等待时间较长,上下文切换浪费时间 |                   无                   |
|    适用于    |      无      |      作业调度,批处理系统      |         无         |              分时系统               |                  通用                  |
| 默认决策模式 |    非抢占    |            非抢占             |       非抢占       |                抢占                 |                  抢占                  |

$CPU$繁忙型更接近于长作业,少$I/O$所以少中断.而$I/O$繁忙型需要大量$I/O$,等待输入输出数据时会阻塞从而重新排队,所以更接近短作业.

#### 算法评价指标

+ $CPU$利用率：$CPU$忙碌时间占总时间的比例.

    + $CPU$利用率$=\dfrac{\text{CPU忙碌（运行）时间}}{\text{进程运行总时间}}$.

+ 系统吞吐量：单位时间内完成作业的数量.

    + 系统吞吐量$=\dfrac{\text{总共完成多少道作业}}{\text{总时间}}$.

+ 周转时间：从作业**被提交到系统**开始到**作业完成**为止的时间间隔.

    + 它包括四个部分：

        1. 作业在外存后备队列上等待作业调度（高级调度）的时间
        2. 进程在就绪队列上等待进程调度（低级调度）的时间
        3. 进程在$CPU$上执行的时间
        4. 进程等待$I/O$操作完成的时间.

        后三项在一个作业的整个处理过程中,可能发生多次.

    + （作业）周转时间=作业完成时间-作业提交时间.

    + 平均周转时间$=\dfrac{\text{各作业周转时间之和}}{\text{作业数}}$.

    + 带权周转时间$=\dfrac{\text{作业周转时间}}{\text{作业实际运行的时间}}=\dfrac{\text{作业完成时间}-\text{作业提交时间}}{\text{作业实际运行的时间}}\geqslant1$.是一个比值,越靠近$1$越合理.

    + 平均带权周转时间$=\dfrac{\text{各作业带权周转时间之和}}{\text{作业数}}$.

+ 等待时间：指进程或作业处于等待处理机状态时间之和.

    + 对于进程来说,等待时间就是指进程建立后等待被服务的时间之和
    + 在等待$I/O$完成的期间其实进程也是在被服务的,所以不计入等待时间.
    + 对于作业来说,不仅要考虑建立进程后的等待时间,还要加上作业在外存后备队列中等待的时间.
    + 一个作业总共需要被$CPU$服务多久,被$I/O$设备服务多久一般是确定不变的,因此**调度算法其实只会影响作业或进程的等待时间**.当然,与前面指标类似,也有“平均等待时间”来评价整体性能.
    + 如果一个进程到达后要么等待要么运行,则等待时间=周转时间-运行时间.
    + 如果一个进程又有计算又有$I/O$操作,则等待时间=周转时间-运行时间-$I/O$操作时间.

+ 响应时间：从用户提交请求到首次产生响应所用的时间

    + 主要用于交互式系统.

#### 先来先服务调度算法

即$FCFS(First-Come, First-Served)$算法.

+ 算法思想：主要从“公平”的角度考虑.
+ 算法规则：按照作业/进程到达的先后顺序进行服务.
+ 用于作业/进程调度：用于作业调度时,考虑的是哪个作业先到达后备队列；用于进程调度时,考虑的是哪个进程先到达就绪队列.
+ 是否可抢占：非抢占式的算法.
+ 特点：
    + 优点：公平、算法实现简单.
    + 缺点：排在长作业(进程）后面的短作业需要等待很长时间,带权周转时间很大,对短作业来说用户体验不好.
    + 即$FCFS$算法**对长作业有利,对短作业不利**.
    + 不能作为分时系统和实时系统的主要调度策略.
    + 利于$CPU$繁忙型作业,不利于$I/O$繁忙型作业（即适用于长作业类型）.
+ 是否会导致饥饿：不会.

#### 短作业优先调度算法

即$SJF(Shortest \;Job\; First)$算法.

+ 算法思想：追求最少的平均等待时间,最少的平均周转时间、最少的平均平均带权周转时间.
+ 算法规则：最短的作业/进程优先得到服务（所谓“最短”,是指要求服务时间最短）.
+ 用于作业/进程调度：即可用于作业调度,也可用于进程调度.
    + 用于进程调度时称为“短进程优先($SPF$,$Shortest\,Process\,First$）算法”.

+ 特点：
    + 优点：“最短的”平均等待时间、平均周转时间.
    + 缺点：
        + 不公平.对短作业有利,对长作业不利.
        + 可能产生饥饿现象.
        + 未考虑作业紧迫性.
        + 另外,作业/进程的运行时间是由用户提供的,并不一定真实,不一定能做到真正的短作业优先.
+ 是否可抢占：$SJF$和$SPF$都是非抢占式的算法.但是也有抢占式的版本$―——$最短剩余时间优先算法（$SRTN$, $Shortest\,Remaining\,Time\,Next$）.
    + 最短剩余时间优先算法$SRTN$：**每当有进程加入就绪队列改变时就需要调度**，如果新到达的进程**剩余时间**比当前运行的进程剩余时间更短，则由新进程**抢占处理机**，当前运行进程**重新回到就绪队列**。另外，当一个进程完成时也需要使用$SRTN$进行调度

+ 是否会导致饥饿：会.
    + 如果源源不断地有**短**作业/进程到来,可能使**长**作业/进程长时间得不到服务,产生“饥饿”现象.如果一直得不到服务,则称为“饿死”.


1. 如果题目中未特别说明,所提到的“短作业/进程优先算法”**默认是非抢占式的**.
2. 很多书上都会说“$SJF$调度算法的平均等待时间、平均周转时间最少”,严格来说,这个表述是**错误的,不严谨的**.
    + **最短剩余时间优先算法$SRTN$得到的平均等待时间、平均周转时间还要更少.**
    + 应该加上一个条件“在所有进程同时可运行时,采用$SJF$调度算法的平均等待时间、平均周转时间最少”,或者说“在所有进程都**几乎**同时到达时,采用$SJF$调度算法的平均等待时间、平均周转时间最少”.
    + 如果不加上述前提条件,则应该说“抢占式的短作业/进程优先调度算法（最短剩余时间优先,$SRNT$算法）的平均等待时间、平均周转时间最少”.
3. 虽然严格来说,$SJF$的平均等待时间、平均周转时间并不一定最少,但相比于其他算法（如$FCFS$）,$SJF$依然可以获得较少的平均等待时间、平均周转时间.
4. 如果选择题中遇到“$SJF$算法的平均等待时间、平均周转时间最少”的选项,那最好判断其他选项是不是有很明显的错误,如果没有更合适的选项,那也应该选择该选项.

#### 高响应比优先调度算法

即$HRRN$算法.

+ 算法思想：要综合考虑作业/进程的等待时间和要求服务的时间,是$FCFS$和$SJF$的综合.
+ 算法规则：在每次调度时先计算各个作业/进程的响应比,选择响应比最高的作业/进程为其服务.
    + 响应比$=\dfrac{\text{等待时间}+\text{要求服务时间}}{\text{要求服务时间}}\geqslant1$.

+ 用于作业/进程调度：即可用于作业调度,也可用于进程调度,但是主要用于作业调度.
+ 是否可抢占：非抢占式的算法.
    + 因此只有当前运行的作业/进程主动放弃处理机(正常/异常完成，或主动阻塞)时,才需要调度,才需要计算响应比.
        + 只有存在$I/O$操作的进程队列才会存在主动阻塞的情况

+ 特点：
    + 综合考虑了等待时间和运行时间（要求服务时间）.
    + 等待时间相同时,要求服务时间短的优先($SJF$的优点）.
    + 要求服务时间相同时,等待时间长的优先（$FCFS$的优点）.
    + 对于长作业来说,随着等待时间越来越久,其响应比也会越来越大,从而**避免了长作业饥饿**的问题.
+ 是否会导致饥饿：不会.

#### 时间片轮转调度算法

即$RR$算法.

+ 算法思想：公平地、轮流地为各个进程服务,让每个进程在一定时间间隔内都可以得到响应.
+ 算法规则：按照各进程到达就绪队列的顺序,轮流让各个进程执行一个时间片（如$100ms$）.若进程未在一个时间片内执行完,则剥夺处理机,将进程重新放到就绪队列队尾重新排队.
+ 用于作业/进程调度：用于进程调度（只有作业放入内存建立了相应的进程后,才能被分配处理机时间片）.
+ 是否可抢占：若进程未能在时间片内运行完,将被强行剥夺处理机使用权,因此时间片轮转调度算法属于抢占式的算法.由时钟装置发出时钟中断来通知$CPU$时间片已到.
+ 特点：
    + 优点：
        + 公平.
        + 响应快,适用于分时操作系统.
    + 缺点：
        + 由于高频率的进程切换,因此有一定开销.
        + 不区分任务的紧急程度.
+ 是否会导致饥饿：不会.

+ 常用于分时操作系统,更注重响应时间,所以不怎么关系周转时间.
+ 如果时间片太大,每个进程在一个时间片内就可以完完成,则时间片轮转算法会退化为**先来先服务算法**,增大进程响应时间,所以时间片不能太大.
+ 如果时间片太小,进程切换会频繁发生,需要保存现场恢复环境,增加时间开销.
+ 时间片分片因素：系统响应时间、就绪队列中的进程数目、系统处理能力.
+ 一般设计时间片段时要让切换进程的开销不超过$1\%$.

#### 优先级调度算法

也称为优先权调度算法,即$PS$算法.

+ 算法思想：随着计算机的发展,特别是实时操作系统的出现,越来越多的应用场景需要根据任务的紧急程度来决定处理顺序.
+ 算法规则：调度时选择优先级最高的作业/进程.$I/O$繁忙型作业要优于计算繁忙型作业（因为$I/O$操作需要及时完成,其无法长时间保存输入输出数据）,系统进程的优先权应高于用户进程优先权.
+ 用于作业/进程调度：既可用于作业调度,也可用于进程调度.甚至,还会用于在之后会学习的$I/O$调度中.
+ 是否可抢占：抢占式、非抢占式都有.做题时的区别在于：
    + 非抢占式只需在进程主动放弃处理机时进行调度即可.
    + 抢占式还需在就绪队列变化时,检查是否会发生抢占,若优先级更高的进程进入就绪队列,则立刻暂停正在运行的进行.
+ 特点：
    + 优点：用优先级区分紧急程度、重要程度,适用于实时操作系统.可灵活地调整对各种作业/进程的偏好程度.
    + 缺点：若源源不断地有高优先级进程到来,则可能导致饥饿.
+ 是否会导致饥饿：会.
    + 见上,若源源不断地有高优先级进程到来,则可能导致饥饿.

+ 优先数与优先级的关系要看具体情况,如$Windows$优先级与优先数成正比,$UNIX$中成反比.
+ 优先级调度算法中就绪队列未必只有一个,可以按照不同优先级来组织.
+ 可以把优先级更高的进程排在队头位置.
+ 根据优先级是否可以动态改变,分为：
    + 静态优先级：创建进程时确定,一直保持不变.
        + 依据
            1. 进程类型
            2. 进程对资源的要求
            3. 用户要求.
    + 动态优先级：创建进程时有初始值,之后根据情况动态调整优先级.
        + 依据
            1. 进程占用$CPU$时间的长短
            2. 就绪进程等待$CPU$时间的长短.
+ 设置进程优先级：
    + 系统进程高于用户进程.
    + 前台进程高于后台进程
        + 即交互性进程高于非交互性进程.
    + 操作系统更偏好$I/O$型进程（$I/O$繁忙型进程）而不是计算型进程（$CPU$繁忙型进程）
        + $I/O$设备和$CPU$可以并行工作
        + 如果优先让$I/O$繁忙型进程优先运行的话,则越有可能让$I/O$设备尽早地投入工作,则资源利用率、系统吞吐量都会得到提升.
+ 调整动态优先级：
    + 若进程在就绪队列中等待了很长时间,则提升其优先级.
    + 若进程占用处理机很长时间,则降低其优先级.
    + 若进程频繁进行$I/O$操作,则提升其优先级.

#### 多级反馈队列调度算法

即$MFQ$算法.

+ 算法思想：对时间片轮转调度算法和优先级调度算法的折中权衡,动态调整进程优先级和时间片大小.
+ 算法规则：
    1. 设置多级就绪队列,各级队列优先级从$1$到$k$依次递减,时间片从小到大依次变大一倍.
    2. 新进程到达时先进入第$1$级队列队尾,按$FCFS$原则排队等待被分配时间片,若用完时间片进程还未结束,则进程进入下一级队列队尾.如果此时已经是在最下级的队列,则重新放回该队列队尾.若是被剥夺,则回退到该队列队尾.
    3. 只有第$k$级队列为空时,才会为$k+1$级队头的进程分配时间片,当又有新进程进入优先级较高的队列则立刻抢占给更够优先级的进程.
+ 用于作业/进程调度：用于进程调度.
+ 是否可抢占：一般认为是抢占式的
    + 抢占式的算法.在$k$级队列的进程运行过程中,若更上级的队列（$1\sim k-1$级）中进入了一个新进程,则由于新进程处于优先级更高的队列中,因此新进程会抢占处理机,原来运行的进程放回$k$级队列队尾.

+ 优缺点：
    + 对各类型进程相对公平（$FCFS$的优点）.
    + 每个新到达的进程都可以很快就得到响应（$RR$的优点）.
    + 短进程只用较少的时间就可完成($SPF$的优点）.
    + 不必实现估计进程的运行时间（避免用户作假）.
    + 可灵活地调整对各类进程的偏好程度
        + 比如$CPU$密集型进程、$I/O$密集型进程
        + 拓展：可以将因$I/O$而阻塞的进程重新放回原队列,这样$I/O$型进程就可以保持较高优先级
    + 一般不说认为$MFQ$算法有缺点，不过可能导致饥饿
+ 是否会导致饥饿：会.

各就绪队列的调度算法也可能不是时间片调度算法而是别的,但是基本上都是差不多的计算方式.



#### 多级队列调度算法

+ 系统中按进程类型设置多个队列，进程创建成功后插入某个队列
+ 队列之间可采取固定优先级，或时间片划分
    + 固定优先级：高优先级空时低优先级进程才能被调度
    + 时间片划分：如三个队列分配时间$50%、40%、10%$
+ 各队列可采用不同的调度策略
    + 系统进程队列采用优先级调度
    + 交互式队列采用$RR$
    + 批处理队列采用$FCFS$

