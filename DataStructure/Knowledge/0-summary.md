# 第一章 数据结构概述

## 导读

### 【考纲内容】

1. 算法时间复杂度和空间复杂度的分析与计算

### 【知识导图】

![1689255678t-20230713-2118-644.250](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/1689255678t-20230713-2118-644.250.png)

### 【复习提示】

+ 本章内容是数据结构概述，并不在考研大纲中。
+ 读者可通过对本章的学习，初步了解数据结构的基本内容和基本方法。
+ 分析算法的时间复杂度和空间复杂度是本章的重点，一定要熟练掌握，算法设计题通常都会要求分析**时间复杂度、空间复杂度**，同时会出现考查时间复杂度的选择题。

## 基本概念

+ 数据项
    + 一个数据元素由若干个数据项组成。

+ 数据元素
    + 组成数据对象的基本单元。

+ 数据对象
    + 性质相同的数据元素的集合。


存储数据时要存储数据元素的值，也要存储数据元素之间的关系。

### 数据类型与抽象数据类型

数据类型是一个值的集合和定义在此集合上的一组操作的总称。

+ 原子类型：其值不可再分的数据类型。
+ 结构类型：其值可以再分解为若干成分（分量）的数据类型。
+ 抽象数据类型$ADT$：用数学化的语言定义数据的逻辑结构、定义运算。与具体的实现无关。
    + 可以定义一个完整的数据结构


## 数据结构三要素

+ 逻辑结构
    + 元素之间的逻辑关系：线性结构、非线性结构（集合）、树结构、网状结构。

+ 存储结构
    + 数据在计算机中的表示（映像），也称物理结构：
        + 顺序存储结构（顺序表）
        + 链式存储结构（链表）
        + 索引存储（索引表）
        + 散列存储（散列表、哈希表）

+ 数据运算
    + 运算的定义是针对逻辑结构的，指出运算的功能
    + 运算的实现是针对存储结构的，指出运算的具体操作步骤

**逻辑结构独立于存储结构，存储结构依托于逻辑结构**。

## 算法

程序$=$数据结构$+$算法。算法为了处理信息。

是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。

### 算法的特性

+ 有穷性。
+ 确定性。
+ 可行性。
+ 输入。零个或多个输入。
    + 可以没有输入

+ 输出。一个或多个输出。
    + 但是一定有输出


### 好算法的特点

+ 正确性。
+ 可读性。
+ 健壮性。
+ 高效率与低储量需求。

## 复杂度分析

### 时间复杂度

#### 统计时间增长趋势

+ 「时间复杂度分析」采取了一种方法，其统计的不是算法运行时间，而是**算法运行时间随着数据量变大时的增长趋势**。

+ “时间增长趋势”这个概念较为抽象，我们通过一个例子来加以理解

+ 假设输入数据大小为$n$，给定三个算法$A , B , C$ 。

    + ```cpp
        // 算法 A 时间复杂度：常数阶
        void algorithm_A(int n) {
            cout << 0 << endl;
        }
        
        // 算法 B 时间复杂度：线性阶
        void algorithm_B(int n) {
            for (int i = 0; i < n; i++) {
                cout << 0 << endl;
            }
        }
        
        // 算法 C 时间复杂度：常数阶
        void algorithm_C(int n) {
            for (int i = 0; i < 1000000; i++) {
                cout << 0 << endl;
            }
        }
        ```

    + 算法$ A $只有$ 1$ 个打印操作，算法运行时间不随着$n$增大而增长

        + 我们称此算法的时间复杂度为「**常数阶**」。

    + 算法 $B$ 中的打印操作需要循环$ n $次，算法运行时间随着$ n $增大呈线性增长

        + 此算法的时间复杂度被称为「**线性阶**」。

    + 算法 $C $中的打印操作需要循环$ 1000000$ 次，但运行时间仍**与输入数据大小$n$无关**

        + 因此$ C $的时间复杂度和$ A $相同，仍为「**常数阶**」。

    + ![image-20230629094451922](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306290944980.png)

+ 相较于直接统计算法运行时间，时间复杂度分析有哪些优势和局限性呢？

    + **时间复杂度能够有效评估算法效率**。例如，算法$ B$ 的运行时间呈线性增长，在$n > 1$ 时比算法$ A$ 慢，在$n > 1000000 $时比算法 $C $慢。事实上，**只要输入数据大小$n $足够大，复杂度为「常数阶」的算法一定优于「线性阶」的算法**，这正是时间增长趋势所表达的含义。
    + **时间复杂度的推算方法更简便**。显然，**运行平台和计算操作类型都与算法运行时间的增长趋势无关**。因此在时间复杂度分析中，我们可以简单地将所有计算操作的执行时间视为相同的“单位时间”，从而将“计算操作的运行时间的统计”简化为“计算操作的数量的统计”，这样的简化方法大大降低了估算难度。
    + **时间复杂度也存在一定的局限性**。例如，尽管算法$ A $和$ C $的时间复杂度相同，但实际运行时间差别很大。同样，尽管算法$ B $的时间复杂度比$ C $高，但在输入数据大小$n $较小时，算法$ B $明显优于算法$ C $。在这些情况下，我们很难仅凭时间复杂度判断算法效率高低。当然，尽管存在上述问题，复杂度分析仍然是评判算法效率最有效且常用的方法。

#### 函数渐近上界

+ 函数渐近上界

    + 设算法的计算操作数量是一个关于输入数据大小$n$的函数，记为$T(n)$

    + 例如以下算法的操作数量为$T(n)=3+2n$

        ```cpp
        void algorithm(int n) {
            int a = 1; // +1
            a = a + 1; // +1
            a = a * 2; // +1
            // 循环 n 次
            for (int i = 0; i < n; i++) { // +1（每轮都执行 i ++）
                cout << 0 << endl; // +1
            }
        }
        
        ```

    + $T(n)$是一次函数，说明时间增长趋势是线性的，因此可以得出时间复杂度是线性阶。

    + 我们将==线性阶==的时间复杂度记为$O(n)$，这个数学符号称为「大 $O$记号$ Big‑O \;Notation$」，表示函数$T(n)$的「渐近上界$ Asymptotic\; Upper\; Bound$」。

    + 推算时间复杂度本质上是计算“操作数量函数$T(n)$”的==渐近上界==

+ 函数渐近上界的数学定义

    + 若存在正实数$ c $和实数 $n_0$，使得对于所有的$n>n_0$​ ，均有
        $$
        T(n)\le c \cdot f(n)
        $$
        则可认为$ f(n) $给出了$T(n)$​的一个渐近上界，记为
        $$
        T(n)=O(f(n))
        $$

    + ![image-20230629095816188](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306290958240.png)

+ 从本质上讲，计算渐近上界就是寻找一个函数$f(n)$，使得当$n$趋向于无穷大时，$T(n)$和$f(n)$处于相同的增长级别，仅相差一个常数项$c $的倍数。

#### 时间复杂度推算方法

##### 统计操作数量

+ 针对代码，逐行从上到下计算即可。然而，由于上述$ 𝑐 ⋅ 𝑓(𝑛) $中的常数项$ 𝑐 $可以取任意大小，因此操作数量$T(n)$中的各种系数、常数项都可以被忽略。根据此原则，可以总结出以下计数简化技巧：
    1. **忽略与$ 𝑛 $无关的操作**。因为它们都是$ 𝑇 (𝑛) $中的常数项，对时间复杂度不产生影响。
    2. **省略所有系数**。例如，循环$ 2𝑛$ 次、$5𝑛 + 1 $次等，都可以简化记为$ 𝑛$ 次，因为$ 𝑛 $前面的系数对时间复杂度没有影响。
    3. **循环嵌套时使用乘法**。总操作数量等于外层循环和内层循环操作数量之积，每一层循环依然可以分别套用上述 1. 和 2. 技巧。

##### 判断渐近上界

+ 时间复杂度由多项式$ 𝑇 (𝑛)$ 中最高阶的项来决定。这是因为在$ 𝑛 $趋于无穷大时，最高阶的项将发挥主导作用，其他项的影响都可以被忽略。

    ![image-20230629101043037](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306291010080.png)

#### 常见类型

+ 设输入数据大小为$ 𝑛 $，常见的时间复杂度类型包括（按照从低到高的顺序排列）：

    $$
    O(1)<O(log_\cdot n)<O(n)<O(nlog_\cdot n)<O(n^2)<O(2^n)<O(n!)
    $$
    ​          														 常数阶$ < $对数阶       $ < $ 线性阶$ < $线性对数阶  $ < $平方阶  $ < $指数阶  $ < $阶乘阶
    

![image-20230629101829062](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306291018112.png)

##### 常数阶 𝑂(1)

+ 常数阶的操作数量与输入数据大小$ 𝑛 $无关，即不随着$ 𝑛 $的变化而变化。
+ 对于以下算法，尽管操作数量` size `可能很大，但由于其与数据大小$ 𝑛 $无关，因此时间复杂度仍为$ 𝑂(1)$。

```cpp
/* 常数阶 */
int constant(int n) {
    int count = 0;
    int size = 100000;
    for (int i = 0; i < size; i++)
        count++;
    return count;
}
```

##### 线性阶 𝑂(𝑛)

+ 线性阶的操作数量相对于输入数据大小以线性级别增长
+ 线性阶通常出现在==单层循环==中

```cpp
/* 线性阶 */
int linear(int n) {
    int count = 0;
    for (int i = 0; i < n; i++)
        count++;
    return count;
}
```

+ 遍历数组和遍历链表等操作的时间复杂度均为$ 𝑂(𝑛) $，其中$ 𝑛 $为数组或链表的长度。
+ 如何确定输入数据大小 $𝑛 $？
    + 数据大小 $n$ 需根据输入数据的类型来具体确定。例如，在上述示例中，我们直接将$n$视为输入数据大小
    + 在下面遍历数组的示例中，数据大小$n$为数组的长度。

```cpp
/* 线性阶（遍历数组） */
int arrayTraversal(vector<int> &nums) {
    int count = 0;
    // 循环次数与数组长度成正比
    for (int num : nums) {
        count++;
    }
    return count;
}
```

##### 平方阶 $O(n^2)$

+ 平方阶的操作数量相对于输入数据大小以平方级别增长
+ 平方阶通常出现在嵌套循环中，外层循环和内层循环都为$O(n)$，因此总体为 $O(n^2)$ 。

```cpp
/* 平方阶 */
int quadratic(int n) {
    int count = 0;
    // 循环次数与数组长度成平方关系
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            count++;
        }
    }
    return count;
}
```

+ ![image-20230629102509273](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306291025324.png)

+ 以「冒泡排序」为例，外层循环执行$ 𝑛 − 1 $次，内层循环执行$ 𝑛 − 1, 𝑛 − 2, ⋯ , 2, 1 $次，平均为 $𝑛^2$ 次，因此时间复杂度为$O(n^2)$ 

    $$
    O((n-1)\cdot \dfrac{n}{2})=O(n^2)
    $$

```cpp
/* 平方阶（冒泡排序） */
int bubbleSort(vector<int> &nums) {
    int count = 0; // 计数器
    // 外循环：未排序区间为 [0, i]
    for (int i = nums.size() - 1; i > 0; i--) {
        // 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端 
        for (int j = 0; j < i; j++) {
            if (nums[j] > nums[j + 1]) {
                // 交换 nums[j] 与 nums[j + 1]
                int tmp = nums[j];
                nums[j] = nums[j + 1];
                nums[j + 1] = tmp;
                count += 3; // 元素交换包含 3 个单元操作
            }
        }
    }
    return count;
}
```

##### 指数阶 $𝑂(2^𝑛)$

+ 指数阶增长非常迅速，在实际应用中通常是**不可接受**的
+ 若一个问题使用「暴力枚举」求解的时间复杂度为$𝑂(2𝑛) $，那么通常需要使用「动态规划」或「贪心算法」等方法来解决。

```cpp
/* 指数阶（循环实现） */
int exponential(int n) {
    int count = 0, base = 1;
    // cell 每轮一分为二，形成数列 1, 2, 4, 8, ..., 2^(n-1)
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < base; j++) {
            count++;
        }
        base *= 2;
    }
    // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1
    return count;
}
```

![image-20230629104114764](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306291041841.png)

+ 在实际算法中，指数阶常出现于**递归函数**
+ 例如以下代码，不断地一分为二，经过 $𝑛$ 次分裂后停止。

```cpp
/* 指数阶（递归实现） */
int expRecur(int n) {
    if (n == 1)
        return 1;
    return expRecur(n - 1) + expRecur(n - 1) + 1;
}
```

##### 对数阶 $𝑂(log_\cdot 𝑛)$

+ 与指数阶相反，对数阶反映了“==每轮缩减到一半的情况==”
+ 对数阶仅次于常数阶，时间增长缓慢，**是理想的时间复杂度**。
+ 对数阶常出现于「二分查找」和「分治算法」中，体现了“一分为多”和“化繁为简”的算法思想。
+ 设输入数据大小为$ 𝑛 $，由于每轮缩减到一半，因此循环次数是$ log_2𝑛$ ，即$ 2^𝑛 $的反函数。

```cpp
/* 对数阶（循环实现） */
int logarithmic(float n) {
    int count = 0;
    while (n > 1) {
        n = n / 2;
        count++;
    }
    return count;
}
```

+ 与指数阶类似，对数阶也常出现于递归函数。以下代码形成了一个高度为$ log_2𝑛$ 的递归树。

```cpp
/* 对数阶（递归实现） */
int logRecur(float n) {
    if (n <= 1)
        return 0;
    return logRecur(n / 2) + 1;
}
```

##### 线性对数阶 $𝑂(𝑛 \cdot log_\cdot 𝑛)$

+ 线性对数阶常出现于嵌套循环中，两层循环的时间复杂度分别为$ 𝑂(log_\cdot 𝑛) $和$ 𝑂(𝑛) $。
+ 主流排序算法的时间复杂度通常为 $𝑂(𝑛 \cdot log_\cdot 𝑛)$，例如快速排序、归并排序、堆排序等。

```cpp
/* 线性对数阶 */
int linearLogRecur(float n) {
    if (n <= 1)
        return 1;
    int count = linearLogRecur(n / 2) + linearLogRecur(n / 2);
    for (int i = 0; i < n; i++) {
        count++;
    }
    return count;
}
```

![image-20230629104548909](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306291045973.png)

##### 阶乘阶$ 𝑂(𝑛!)$

+ 阶乘阶对应数学上的「全排列」问题。给定$ 𝑛 $个互不重复的元素，求其所有可能的排列方案，方案数量为：
    $$
    𝑛! = 𝑛 × (𝑛 − 1) × (𝑛 − 2) × ⋯ × 2 × 1
    $$

+ 阶乘通常使用递归实现。例如以下代码，第一层分裂出$ 𝑛 $个，第二层分裂出$ 𝑛 − 1$ 个，以此类推，直至第 $𝑛$层时终止分裂。

```cpp
/* 阶乘阶（递归实现） */
int factorialRecur(int n) {
    if (n == 0)
        return 1;
    int count = 0;
    // 从 1 个分裂出 n 个
    for (int i = 0; i < n; i++) {
        count += factorialRecur(n - 1);
    }
    return count;
}
```

+ ![image-20230629104807869](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306291048940.png)

#### 最差、最佳、平均时间复杂度

##### 最差、最佳复杂度

+ 某些算法的时间复杂度不是固定的，而是与输入数据的分布有关。例如，假设输入一个长度为 $𝑛 $的数组 `nums `，其中 `nums` 由从$ 1 $至$ 𝑛$ 的数字组成，但元素顺序是随机打乱的；算法的任务是返回元素$ 1 $的索引。
+ 我们可以得出以下结论：
    + 当` nums = [?, ?, ..., 1] `，即当末尾元素是$ 1 $时，需要完整遍历数组，此时达到 **最差时间复杂度**$ 𝑂(𝑛)$；
    + 当` nums = [1, ?, ?, ...] `，即当首个数字为$ 1 $时，无论数组多长都不需要继续遍历，此时达到 **最佳时间复杂度**$ Ω(1)$；
+ “函数渐近上界”使用大$ 𝑂$ 记号表示，代表「最差时间复杂度」
+ 相应地，“函数渐近下界”用$ Ω $记号来表示，代表「最佳时间复杂度」。

**【注意】：**

+ 实际应用中我们很少使用「最佳时间复杂度」，因为通常只有在很小概率下才能达到，可能会带来一定的误导性
+ 相反，「最差时间复杂度」更为实用，因为它给出了一个“效率安全值”，让我们可以放心地使用算法。

##### 平均时间复杂度

+ 从上述示例可以看出，最差或最佳时间复杂度只出现在“特殊分布的数据”中，这些情况的出现概率可能很小，因此并不能最真实地反映算法运行效率。
+ 相较之下，**「平均时间复杂度」可以体现算法在随机输入数据下的运行效率**，用$ \Theta  $记号来表示。
+ 对于部分算法，我们可以简单地推算出随机数据分布下的平均情况。比如上述示例，由于输入数组是被打乱的，因此元素$ 1 $出现在任意索引的概率都是相等的，那么算法的平均循环次数则是数组长度的一半$ \dfrac{n}{2} $，平均时间复杂度为$ \Theta ( \dfrac{n}{2} ) = \Theta (n) $。
+ 但在实际应用中，尤其是较为复杂的算法，计算平均时间复杂度比较困难，因为很难简便地分析出在数据分布下的整体数学期望。**在这种情况下，我们通常使用最差时间复杂度作为算法效率的评判标准。**

为什么很少看到$\Theta $符号?

+ 可能由于$O$符号过于朗朗上口，我们常常使用它来表示「平均复杂度」，但从严格意义上看，这种做法并不规范
+ 若遇到类似“平均时间复杂度$O(n)$”的表述，请将其直接理解为$\Theta (n)$。

### 空间复杂度

「空间复杂度 $Space \;Complexity$」用于衡量算法使用内存空间随着数据量变大时的增长趋势。这个概念与时间复杂度非常类似。

####  算法相关空间

+ 算法运行过程中使用的内存空间主要包括以下几种：
    1. 「输入空间」用于存储算法的输入数据；
    2. 「暂存空间」用于存储算法运行过程中的变量、对象、函数上下文等数据；
    3. 「输出空间」用于存储算法的输出数据；

+ 通常情况下，空间复杂度统计范围是「暂存空间」+「输出空间」
+ 暂存空间可以进一步划分为三个部分：
    1. 「暂存数据」用于保存算法运行过程中的各种常量、变量、对象等。
    2. 「栈帧空间」用于保存调用函数的上下文数据。系统在每次调用函数时都会在栈顶部创建一个栈帧，函数返回后，栈帧空间会被释放。
    3. 「指令空间」用于保存编译后的程序指令，**在实际统计中通常忽略不计**
+ 因此，在分析一段程序的空间复杂度时，我们一般统计**暂存数据、输出数据、栈帧空间**三部分。

![image-20230629110254502](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306291102571.png)

```cpp
/* Definition for a singly-linked list node */
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {
    }
};

/* 函数 */
int func() {
    // do something
    return 0;
}

int algorithm(int n) { 						// 输入数据
    const int a = 0; 						// 暂存数据（常量）
    int b = 0; 								// 暂存数据（变量）
    ListNode *node = new ListNode(0); 		// 暂存数据（对象）
    int c = func(); 						// 栈帧空间（调用函数）
    return a + b + c; 						// 输出数据
}
```

#### 推算方法

+ 空间复杂度的推算方法与时间复杂度大致相同，只是将统计对象从“计算操作数量”转为“使用空间大小”。
+ **与时间复杂度不同的是，我们通常只关注「最差空间复杂度」**，这是因为内存空间是一项硬性要求，我们必须确保在所有输入数据下都有足够的内存空间预留。
+ **最差空间复杂度中的“最差”有两层含义**，分别是输入数据的最差分布和算法运行过程中的最差时间点。
    + 以**最差输入数据**为准
        + 例如,当$ 𝑛 < 10$ 时，空间复杂度为$ 𝑂(1) $；但当$ 𝑛 > 10 $时，初始化的数组` nums `占用$𝑂(𝑛)$ 空间；因此最差空间复杂度为$ 𝑂(𝑛) $；
    + 以算法运行过程中的**峰值内存**为准
        + 例如，程序在执行最后一行之前，占用 $𝑂(1)$ 空间；当初始化数组`nums `时，程序占用$ 𝑂(𝑛) $空间；因此最差空间复杂度为$ 𝑂(𝑛)$ ；

```cpp
void algorithm(int n) {
    int a = 0;	 				// O(1)
    vector<int> b(10000); 		// O(1)
    if (n > 10)
        vector<int> nums(n); 	// O(n)
}
```

+ 在递归函数中，需要注意统计栈帧空间
    + 例如，函数` loop() `在循环中调用了 $𝑛 $次` function() `，每轮中的`function() `都返回并释放了栈帧空间，因此空间复杂度仍为$ 𝑂(1) $
    + 而递归函数` recur() `在运行过程中会同时存在$ 𝑛 $个未返回的` recur() `，从而占用$ 𝑂(𝑛) $的栈帧空间。

```cpp
/* 函数 */
int func() {
    // do something
    return 0;
}

/* 循环 O(1) */
void loop(int n) {
    for (int i = 0; i < n; i++) {
        func();
    }
}

/* 递归 O(n) */
void recur(int n) {
    if (n == 1) return;
    return recur(n - 1);
}
```

#### 常见类型

+ 设输入数据大小为$ 𝑛 $，常见的空间复杂度类型有（从低到高排列）
    + $𝑂(1) < 𝑂(log_\cdot 𝑛) < 𝑂(𝑛) < 𝑂(𝑛^2) < 𝑂(2^𝑛)$
    + 常数阶$ < $对数阶 $ < $线性阶$ < $平方阶$ < $指数阶

+ ![image-20230629111915158](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306291119243.png)

##### 常数阶$ 𝑂(1)$

+ 常数阶常见于数量与输入数据大小$ 𝑛 $无关的常量、变量、对象。
+ 需要注意的是，在循环中初始化变量或调用函数而占用的内存，在进入下一循环后就会被释放，即不会累积占用空间，空间复杂度仍为$ 𝑂(1) $。

```cpp
/* 常数阶 */
void constant(int n) {
    // 常量、变量、对象占用 O(1) 空间
    const int a = 0;
    int b = 0;
    vector<int> nums(10000);
    ListNode node(0);
    // 循环中的变量占用 O(1) 空间
    for (int i = 0; i < n; i++) {
        int c = 0;
    }
    // 循环中的函数占用 O(1) 空间
    for (int i = 0; i < n; i++) {
        func();
    }
}
```

##### 线性阶$ 𝑂(𝑛)$

+ 线性阶常见于元素数量与$ 𝑛 $成正比的数组、链表、栈、队列等。

```cpp
/* 线性阶 */
void linear(int n) {
    // 长度为 n 的数组占用 O(n) 空间
    vector<int> nums(n);
    // 长度为 n 的列表占用 O(n) 空间
    vector<ListNode> nodes;
    for (int i = 0; i < n; i++) {
        nodes.push_back(ListNode(i));
    }
    // 长度为 n 的哈希表占用 O(n) 空间
    unordered_map<int, string> map;
    for (int i = 0; i < n; i++) {
        map[i] = to_string(i);
    }
}
```

+ 以下递归函数会同时存在$ 𝑛 $个未返回的` linearRecur() `函数，使用$ 𝑂(n^2) $大小的栈帧空间。

```cpp
/* 线性阶（递归实现） */
void linearRecur(int n) {
    cout << "递归 n = " << n << endl;
    if (n == 1)
        return;
    linearRecur(n - 1);
}
```

+ ![image-20230629112123648](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306291121743.png)

##### 平方阶 $𝑂(𝑛^2)$

+ 平方阶常见于矩阵和图，元素数量与$ 𝑛 $成平方关系。

```cpp
/* 平方阶 */
void quadratic(int n) {
    // 二维列表占用 O(n^2) 空间
    vector<vector<int>> numMatrix;
    for (int i = 0; i < n; i++) {
        vector<int> tmp;
        for (int j = 0; j < n; j++) {
            tmp.push_back(0);
        }
        numMatrix.push_back(tmp);
    }
}
```

+ 在以下递归函数中，同时存在 𝑛 个未返回的 algorithm() ，并且每个函数中都初始化了一个数组，长度分别为$𝑛, 𝑛 − 1, 𝑛 − 2, ..., 2, 1 $，平均长度为$ 𝑛^2$ ，因此总体占用$ 𝑂(𝑛^2) $空间。

```cpp
/* 平方阶（递归实现） */
int quadraticRecur(int n) {
    if (n <= 0)
        return 0;
    vector<int> nums(n);
    cout << "递归 n = " << n << " 中的 nums 长度 = " << nums.size() << endl;
    return quadraticRecur(n - 1);
}
```

![image-20230629112535376](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306291125474.png)

##### 指数阶 𝑂(2𝑛)

+ 指数阶常见于二叉树。
+ 高度为$ 𝑛 $的「满二叉树」的节点数量为$ 2^𝑛 − 1$ ，占用$ 𝑂(2^𝑛) $空间。

```cpp
/* 指数阶（建立满二叉树） */
TreeNode *buildTree(int n) {
    if (n == 0)
        return nullptr;
    TreeNode *root = new TreeNode(0);
    root->left = buildTree(n - 1);
    root->right = buildTree(n - 1);
    return root;
}
```

![image-20230629112635602](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306291126713.png)

##### 对数阶 𝑂(log 𝑛)

+ 对数阶常见于分治算法和数据类型转换等。
+ 例如“归并排序”算法，输入长度为$ 𝑛 $的数组，每轮递归将数组从中点划分为两半，形成高度为$ log_\cdot 𝑛 $的递归树，使用$ O(log_\cdot 𝑛) $栈帧空间。
+ 再例如“数字转化为字符串”，输入任意正整数$ 𝑛$ ，它的位数为$𝑂(log_{10} 𝑛) $，即对应字符串长度为 $ log_{10}𝑛 $，因此空间复杂度为 $𝑂(log_{10} 𝑛) = 𝑂(log_\cdot 𝑛)$ 。

### 权衡时间与空间

+ 理想情况下，我们希望算法的时间复杂度和空间复杂度都能达到最优。然而在实际情况中，同时优化时间复杂度和空间复杂度通常是非常困难的。
+ **降低时间复杂度通常需要以提升空间复杂度为代价，反之亦**然。我们将牺牲内存空间来提升算法运行速度的思路称为“以空间换时间”；反之，则称为“以时间换空间”。
+ 选择哪种思路取决于我们更看重哪个方面。在大多数情况下，时间比空间更宝贵，因此以空间换时间通常是更常用的策略。当然，在数据量很大的情况下，控制空间复杂度也是非常重要的。



## 小结

### 算法效率评估

+ 时间效率和空间效率是评价算法性能的两个关键维度。
+ 我们可以通过实际测试来评估算法效率，但难以消除测试环境的影响，且会耗费大量计算资源。
+ 复杂度分析可以克服实际测试的弊端，分析结果适用于所有运行平台，并且能够揭示算法在不同数据规模下的效率。

### 时间复杂度

+ 时间复杂度用于衡量算法运行时间随数据量增长的趋势，可以有效评估算法效率，但在某些情况下可能失效，如在输入数据量较小或时间复杂度相同时，无法精确对比算法效率的优劣。
+ 最差时间复杂度使用大$ 𝑂 $符号表示，即函数渐近上界，反映当$ 𝑛$ 趋向正无穷时，$𝑇 (𝑛) $的增长级别。
+ 推算时间复杂度分为两步，首先统计计算操作数量，然后判断渐近上界。
+ 常见时间复杂度从小到大排列有$ 𝑂(1) , 𝑂(log 𝑛) , 𝑂(𝑛) , 𝑂(𝑛 log 𝑛) , 𝑂(𝑛2) , 𝑂(2𝑛) , 𝑂(𝑛!) $等。
+ 某些算法的时间复杂度非固定，而是与输入数据的分布有关。时间复杂度分为最差、最佳、平均时间复杂度，最佳时间复杂度几乎不用，因为输入数据一般需要满足严格条件才能达到最佳情况。
+ 平均时间复杂度反映算法在随机数据输入下的运行效率，最接近实际应用中的算法性能。计算平均时间复杂度需要统计输入数据分布以及综合后的数学期望。

### 空间复杂度

+ 类似于时间复杂度，空间复杂度用于衡量算法占用空间随数据量增长的趋势。
+ 算法运行过程中的相关内存空间可分为输入空间、暂存空间、输出空间。通常情况下，输入空间不计入空间复杂度计算。暂存空间可分为指令空间、数据空间、栈帧空间，其中栈帧空间通常仅在递归函数中影响空间复杂度。
+ 我们通常只关注最差空间复杂度，即统计算法在最差输入数据和最差运行时间点下的空间复杂度。
+ 常见空间复杂度从小到大排列有$ 𝑂(1) , 𝑂(log 𝑛) , 𝑂(𝑛) , 𝑂(𝑛2) , 𝑂(2𝑛)$ 等。
