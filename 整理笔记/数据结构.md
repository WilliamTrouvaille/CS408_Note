# 数据结构

+ 【第一道选择题-时间复杂度】：①嵌套循环应全部标注出每个嵌套循环的总循环次数；②取$n=2^{100}$算出循环次数。
  + 关于树的遍历一般都会访问所有结点，时间复杂度为$O(n)$。
  
+ 【算法的特性】：有穷性、确定性、可行性、零个或多个输入、一个或多个输出。

+ 可以用一个队列模拟栈，但**不能用一个栈模拟队列**。

+ 【两个队列模拟栈】：插入时将元素插入到空队列中，然后将另一个队列的所有元素依次出队并入队到该空队列。

  + 入栈：①新元素入队到空队列 `q2`；②将 `q1` 中的所有元素依次出队并入队到 `q2`；③交换 `q1` 和 `q2` ；
  + 出栈：直接从 `q1` 出队。

+ 【两个栈模拟队列】：栈 `s1` 用于插入元素，栈 `s2` 用于删除元素。

  + 入队：直接将新元素压入栈 `s1`；
  + 出队：①若栈 `s2` 不为空，则直接从 `s2` 弹出元素；②若栈 `s2` 为空，则将 `s1` 中的所有元素弹出并压入到 `s2`，然后从 `s2` 弹出元素。

+ 【前序遍历和中序遍历的前驱后继】：前驱为**左子树中最右的结点**或祖先结点中离它最近的**左上方祖先**；后继为**右子树中最左的结点**或祖先结点中离它最近的**右上方祖先**。

+ 【后序遍历的前驱后继】：前驱是**父节点的左子树的最右结点**，后继是**父节点的右子树的最左结点**。

+ 【前序序列和后序序列确定**祖先关系**】：$XY$分别为任意长度结点组合，若在前序遍历中为$...XY...$，后序遍历中为$...YX...$时，$X$为$Y$的祖先。
  + 【前序序列和后序序列相同】：仅空树或者只有根节点的二叉树，**非空时唯一**；
  + 【前序序列和后序序列相反】：二叉树的高度和其节点个数相同，共$2^{n-1}$种形态，$n$为节点个数。

+ 【二叉哈夫曼树】：①总结点数始终为$2n-1$，其中$n$为叶节点数，没有度为一的结点；②哈夫曼树不唯一，但是$WPL$必然最优。
  + 看清楚是不是二叉哈夫曼树，若为【度为$m$的哈夫曼树】就是$m$叉哈夫曼树。

+ 【最小生成树】：**边数比顶点数少一**、减去一条则不连通、 增加一条则会出现回路。

+ 只要出现了折半查找的相关字眼，就要联想到折半查找判定树

+ 【红黑树】：①**红黑树是能自平衡的二叉排序树不是平衡二叉树**；②根结点是黑色、不存在两个相邻的红结点、从**任一结点**到任一叶结点的简单路径上的黑高相等、查找插入删除的时间复杂度都是$O(\log_2n)$；③从根到叶结点的最长路径不大于最短路径的两倍；④内部结点数最少时为**全黑满树形态**，结点数至少为$2^h-1$。

+ 【红黑树插入】：其中若没有叔叔结点则默认为黑色。

  1. 若插入结点为根结点则染为黑色、否则染为红色，若**其父结点是红色的则需要调整**；
  2. 叔叔结点为红色，则**直接染色**：**叔叔结点、父亲结点和祖父结点三个结点**染色，**祖父结点视为新结点**；
  3. 叔叔结点为黑色，则**旋转后染色**：$LL$型右单旋、$RR$型左单旋、$LR$型左右双旋、$RL$型右左双旋，旋转后将**父亲结点和祖父结点两个结点**染色。
     + 因为此时可能没有叔叔结点所以不用染色。

+ 【折半查找判定树】：①**折半查找相关的题都应该转化到折半查找判定树上**；②折半查找的平均查找长度即为折半查找判定树的$ASL$=($\sum\limits_{i=1}^n$第$i$层的成功结点数$\times i$)$\div$成功结点总数；③查找成功的最大路径长度为$\lceil \log_2(n) \rceil$，查找失败最大路径长度为$\lceil \log_2(n+1) \rceil$；④折半查找判定树是二叉查找树（中序序列是有序序列）、不一定是完全二叉树但一定是一个**平衡二叉树**；⑤**任意一结点右子树结点数最多比左子树结点数多一个**（|右$-$左|$=0$或$1$）。

+ 【二叉树的顺序存储】：**存储一棵高度为$h$且有$m$个结点至少需要$2^h-1$个存储单元**。

+ 【二叉树的链式存储】：在含有$n$个结点的二叉链表中，含有$n+1$个空链域。

+ 排序算法总结

  + 每趟排序结束都**至少能够确定一个元素最终位置**：简单选择排序、快速排序、堆排序。
  + **最后一趟排序开始时所有元素可能都不在最终位置上**：直接插入排序。
  + **排序趟数**与关键字的初始排列初始状态无关：插入排序$n-1$趟、选择排序$n-1$趟、基数排序$d$趟。
  + **比较次数**与关键字的初始序列初始状态无关：基数排序（不需要进行关键字的比较）、选择排序（简单选择排序、堆排序，比较次数始终为$\dfrac{n(n-1)}{2}$）。
  + **移动次数**与关键字的初始排列初始状态无关：**基数排序**。（**反正看到无关选基数排序一定没错**）
  + **时间复杂度**与关键字的初始排列初始状态无关：直接选择排序$O(n^2)$、堆排序$O(n\log_2n)$、归并排序$O(n\log_2n)$、**基数排序**$O(d(n+r))$。
  + 直接插入排序和冒泡排序在最好情况（有序）下的时间开销为线性时间$O(n)$，为所有排序算法中最快的。
  + 不稳定：堆排序、快速排序、希尔排序、直接选择排序。

+ 【归并排序】：①两长度为$a$、$b$的有序表进行归并，**比较次数**最大值为$a+b-1$；②归并排序是稳定的；

+ 【简单选择排序】：①从待排序序列中选择最小元素并与未排序部分的第一个元素交换；②**不稳定**，可用于链表；③比较次数始终为$\dfrac{n(n-1)}{2}$，与序列状态无关。

+ 【快速排序】：①不稳定、会退化、有$O(n\cdot\log_2n)$空间复杂度、不适用于小数据和有序数据；②任意一个枢纽划分后的两边**块间有序，块内不一定有序**；③快排的空间复杂度来源于其递归调用的深度；④可使用三数取中法、随机选择法或恒取首位将空间复杂度优化为$O(\log_2n)$；⑤不产生有序子序列；⑥递归次数与**初始序列**和**选择的枢轴元素**有关，与分区处理顺序无关；

  + 若划分的范围内只有一个元素，则不用继续比较

+ 【堆排序】：①比较总次数不超过$4n$；②适合大量**数据**进行排序（但不能用于外存），不适合大**文件**排序，文件排序只能使用归并排序；

+ 【堆的应用-优先队列】

  + 数据结构定义

    ```cpp
    struct MaxHeap {
        int* data;         // 存储堆的数组
        int size;          // 当前堆中元素的个数
    };
    ```

  + 插入结点

    ```cpp
    void insert(MaxHeap* heap, int value) {
        if (heap->size >= MAX_SIZE) {return ;}	// 堆已满
        heap->data[heap->size] = value;heap->size++;  // 将新元素插入到堆的末尾
        heapifyUp(heap, heap->size - 1);  		// 向上调整堆结构
    }
    ```

  + 移除结点

    ```cpp
    int removeMax(MaxHeap* heap) {
        if (heap->size == 0) return -1;  	// 堆为空,返回错误值
        int max = heap->data[0];  			// 获取最大元素即优先度最高的元素
        heap->data[0] = heap->data[heap->size - 1];  // 将堆底元素移动到堆顶
        heap->size--;heapifyDown(heap, 0);  // 向下调整堆结构
        return max;
    }
    ```

+ 【平衡二叉树的删除】

  + 【删除结点】：①删除叶子结点，直接删除；②删除的结点只有左/右子树：用删除结点的子树顶替位置；③删除的结点既有左子树又有右子树：用删除结点的前驱/后继结点顶替，并转换为前驱/后继结点的删除；
  + 删除后从删除的结点开始向上寻找最小不平衡子树并调整。

+ 【平衡二叉树删除后又加入】：①若其为叶节点，则前后相同；②若其并非叶节点，则前后不同。

+ 【※※※描述$\mathrm{Dijkstra}$​算法】

  + 从源点开始分别初始化三个数组，即完成标记$\mathrm{final}$，最短路径长度$\mathrm{dist}$，最短路径上的前驱$\mathrm{path}$，然后将与源点直连点对应的$\mathrm{dist}$初始化为其长度、$\mathrm{path}$初始化为零；
  + $while$（遍历所有结点）：
    + 所有未完成且最短路径长度值最小的结点并将其完成$\mathrm{final=true}$；
    + 更新该点相连的最短路径$\mathrm{dist}$和前驱$\mathrm{path}$；

+ 【※※※$\mathrm{Dijkstra}$算法】：①$\mathrm{Dijkstra}$要会写，$\mathrm{D\,ijk\,str\,a}$，又有$\mathrm{ijk}$又有$\mathrm{str}$；②使用邻接矩阵和邻接表表示时时间复杂度均为$O(\vert V\vert^2)$；③不适用于含有负权值的带权图。

+ 【单源最短路径】：$BFS$算法（仅限于无权图）、$\mathrm{Dijkstra}$算法（适用于无负权的带权图和无权图）。

+ 【一般情况下，邻接表的时间复杂度小于邻接矩阵】：广度优先遍历$BFS$，深度优先遍历$DFS$，$\mathrm{Prim}$算法。

+ 【普里姆算法$Prim$】：①需要遍历所有**顶点**，**适用于边稠密图**；②时间复杂度为$O(\vert V\vert^2)$，边权不能为负。

+ 【克鲁斯卡尔算法$Kruskal$】：①每次选择最小边只需要$O(\log\vert E\vert)$的时间，时间复杂度为$O(\vert E\vert\log_2\vert E\vert)$，故**适用于边稀疏顶点多的图**，边权不能为负；②将带权边从小到大排列然后**使用并查集**检查是否会成环，重复操作$n-1$次。

+ 【弗洛伊德算法$Floyd$】：①可以用于任意两点间最短路径，边权可为负但不能有负环；②$A^{k}$中第$k$行和第$k$列的路径长度均不变且对角线元素始终为零，其表示其他结点若采用结点$k$作为中转是否会缩短路径。

+ 【广度优先遍历$BFS$】：①需要**辅助队列**记录顶点信息，空间复杂度为$O(\vert V\vert)$；②可用于非带权图的单源最短路径问题，可用于获取连通分量数（等于调用次数）；③类似于二叉树的层序遍历；④**广度优先生成树的高度小于等于深度优先生成树的高度**；

+ 【深度优先遍历$DFS$】：①需要一个**栈**用于递归，空间复杂度为$O(\vert V\vert)$；②可用于判断有向图中是否存在回路、可用于获取逆拓扑有序序列、可用于获取连通分量（等于调用次数）；③类似二叉树的先序遍历；④深度优先序列在邻接表实现时唯一，邻接矩阵实现时不唯一；⑤当且仅当某结点的所有后续结点全部出栈后该结点才会出栈。

+ 【邻接表】：①无向图空间复杂度为$O(\vert V\vert+2\vert E\vert)$、有向图空间复杂度为$O(\vert V\vert+\vert E\vert)$；②适用于**稀疏图**；③邻接表的表示方式不唯一。

  + > ```cpp
    > typedef struct EdgeNode {		// 边表结点
    >     int adjvex;  				// 邻接顶点的编号
    >     EdgeNode* next;  			// 指向下一个相邻顶点
    > }EdgeNode;
    > 
    > typedef struct VertexNode   {	// 边表结点
    >     int data;  					// 权值
    >     VertexNode * next;  		// 指向下一个相邻顶点
    > }VertexNode;
    > 
    > typedef struct Graph {
    >     VertexNode* adjList;  // 存储所有顶点的数组
    >     int numVertices;      // 图中的顶点数量
    >     int numEdges;         // 图中的边数量
    > }Graph;
    > ```

+ 【十字链表】：①在稀疏矩阵和图的存储中均可使用，看清楚是哪里；②只能用于存储有向图（**只存储边**）、表示不唯一、空间复杂度为$O(\vert V\vert+\vert E\vert)$。

+ 【邻接多重表】：只能用于存储无向图、表示不唯一、空间复杂度为$O(\vert V\vert+\vert E\vert)$。

+ 【并查集】

  + 存储值为负表示这个点有子结点，为非负（包括0）表示其父结点的索引值。
  + 合并：将一个集合的根节点的父节点指向另一个集合的根节点。时间复杂度为$O(1)$。
  + 查找优化-路径压缩：当递归地查找到根节点时，依次将路径上的每个节点的父节点更新为根节点。**只压缩一条路径**。通过路径压缩优化，可以将**查找**操作的时间复杂度接近于常数级别，特别适用于大规模的并查集操作。
  + 合并优化-按秩合并：经过路径压缩后，根节点存储值的绝对值表示这个集合的大小（包括根节点本身），可通过其考虑两个集合的大小，将节点数少的根节点合并到节点数多的根节点上，并更新节点数。

+ 【并查集应用】

  1. 判断图的连通分量数：遍历各边，有边相连的两个顶点确认连通，“并”为同一个集合。只要是相互连通的顶点都会被合并到同一个子集合中，相互不连通的顶点一定在不同的子集合中。
  2. $Kruskal$算法的最小生成树$-$各边按权值递增排序，依次处理：判断是否加入一条边之前，先查找这条边关联的两个顶点是否属于同一个集合（即判断加入这条边之后是否形成回郡），若形成回路，则继续判断下一条边；若不形成回路，则将该边和边对应的顶点加入最小生成树$T$，并继续判断下一条边，直到所有顶点都已加入最小生成树$T$。

+ **阶为3和4的B树单个非根结点最少有一个关键字，阶为5的B树单个非根结点最少有两个关键字**。

+ B树查找

  - 在$B$树中找结点：在磁盘上进行。在找到目标结点后，先将结点信息读入内存。

  - 在结点内找关键字：在内存中进行。在结点内采用顺序查找法或**折半查找法**。

+ B树插入：若导致原结点关键字数量超过上限溢出（$m-1$个关键字），从中间位置$\lceil\dfrac{m}{2}\rceil$（如果$m$为偶数则默认是$\lceil\dfrac{m}{2}\rceil-1$）分开，插入位置一定是最底层的某个非叶结点。**插入分裂结束后左部分的结点数少于等于右部分**。

  + 最坏情况下，插入B树共需$3h+1$次操作。从根节点查找到底需要$h$次，每次插入后分裂需要进行两次操作并逐层向上传导，**此时会导致B树高度加一**。

+ B树删除

  - 若被删除关键字在终端结点，且结点关键字个数不低于下限，则直接删除该关键字，并移动后面的关键字；
  - 若被删除关键字在非终端结点，则用直接前驱或直接后继来替代被删除关键字，然后后面的元素直接前移；
  - 若被删除关键字在终端结点，但是结点关键字个数删除后低于下限，**左右兄弟够借（补位）**
    1. 将原结点在父结点对应连接的前/后一个关键字下移到原结点并放在最前/后面；
    2. 将左/右兄弟结点的最后一个/第一个关键字上移插入到下移的元素的空位；

    3. 左/右兄弟结点里的关键字全部后/前移一位。
  - 若被删除关键字在终端结点，但是结点关键字个数删除后低于下限，**左右兄弟都不够借（兄弟合并，父亲下沉）**
    1. 将原结点的父结点连接后的关键字插入到原结点关键字最后面。
    2. 将原结点的左或右兄弟结点的关键字合并到原结点（前插或后插），并将连接也转移到原结点上。
    3. 若父结点的关键字个数又不满于下限，则父结点同样要于与它的兄弟父结点进行合并，并不断重复这个过程。
    4. 若父结点为空则删除父结点。

+ $B+$树相比于$B$树：①内部节点只是索引，所有数据都保存在叶节点中；②叶节点之间通过链表连接，**可以进行范围查询**。

----

+ 所有插入结点后需要进行调整的数据结构（堆、AVL树、红黑树等）在插入节点后求其性质，**默认先进行调整操作**。

+ 算法题通用

  + $\mathrm{solution}$ n.解决方案；
  + **次优解只扣两分，放心写**；
  + 欲求某关系式的最大最小值，先把关系式化简；
  + 算法题一定是基于数据结构的基本操作出的，做不出来的时候想想这种数据结构有什么基本操作；
  + 【**无关元素值只考虑树形**，王四-41】例，判断两棵树是否为镜像对称：若两棵树都是空树，则他们一定对称；若仅有一课是空树，则他们一定不对称。如此**递归判断**两棵树；
  + **算法题的核心是分而治之**；
  + 线性表（链表或数组）的长度为$n$，则其中间结点的索引为`(n+1)>>1;`；
  + 若考20年算法题，所有所求数据可以变形成有关$\max$和$\min$的关系式均可以使用这种类似贪心的方法；
  + 非算法题要求设计算法的一般使用伪代码；

+ 算法题-树

  + 后序遍历：求树高，求平衡度；

    `int leftHeight = getTreeHeight(root->left);`

    `int rightHeight = getTreeHeight(root->right);`

    `return max(leftHeight, rightHeight) + 1;`

  + 若树$\mathrm{T}$使用孩子兄弟链表表示，则其向$\mathrm{firstChild}$域递归时$\mathrm{degree}$不变，向$\mathrm{nextBro}$域递归时$\mathrm{degree}$加一；

  + 逆置链表

    ```cpp
    while (curr) {
        ListNode* nextTemp = curr->next;
        curr->next = prev;  // 当前节点的next指向前一个节点
        prev = curr;        // 更新前一个节点为当前节点
        curr = nextTemp;    // 移动到下一个节点
    }
    return prev; 
    ```

+ 冷门知识点

  + 折半查找适用于`B+`树；
  + 散列表的装填因子：只给出了装填因子$\alpha$，则此时平均查找长度为：$ASL=\dfrac{1}{2}(1+\dfrac{1}{1-\alpha})$；

+ 外部排序：若内存中最多存放$k$条记录，则进行$k$路归并排序，可①使用**置换-选择排序**增大归并段长度来减少归并段个数；②使用**败者树**减少关键字比较次数、减少归并时间；③使用**最佳归并树**优化归并次序。

+ 【败者树】：①在$k$个初始为升序（或降序）的序列中选择最小（或最大）元素，从而实现合并排序；②记录“冠军”的结点只能是**最小关键字所在段号**；③构建败者树时需要$n-1$次对比，从$k$个归并段选出一个最大或最小元素只需要对比关键字$\lceil\log_2k\rceil$次；④败者树深度，$k$路归并排序表示**败者树有$k$个叶节点**；⑤败者树的构造，所有关键字所在段号视为叶节点，逐层比较后并冠军结点后更新败者树（即将原冠军结点对应叶节点的指针往后移并重新逐层比较）；

+ 置换-选择排序：①在工作区内选择最大最小记录的过程需要使用败者树；②对于$m$个记录进行$k$路归并排序，最多可分为$\lceil\frac{m}{k} \rceil$组、故**最初会形成$\lceil\frac{m}{k} \rceil$个初始归并段**；

+ 最佳归并树：使用的$\mathrm{I/O}$次数为$\mathrm{2WPL}$，$\mathrm{WPL}$即为其**带权路径长度**。

+ 栈和共享栈：二者均可能在栈空时出栈发生下溢在满栈时入栈发生上溢，但是共享栈中两个的空间比较灵活，所以**共享栈发生上溢的可能性较低**。

  + 链栈不会溢出

+ 共享栈栈满：`low.top-high.top==1`，此时**低位栈的栈顶指针高于高位栈的栈顶指针**。

+ 卡特兰数：总方案数$-$不合法方案数。
  $$
  Catalan_n =C_{2n}^{n}-C_{2n}^{n-1} =\frac{1}{n+1} C_{2n}^{n}
  $$

  1. **括号匹配问题**：给定$n$对括号，有多少种合法的括号匹配方式。
  2. **二叉树**：有$n$个节点的不同二叉树的数量。
  3. **栈的出栈序列**：一个栈的进栈序列为$1,2,\ldots,n$，有多少种不同的出栈序列。

+ 队列：**先进先出**。

  + 队尾指针$rear$<$adj.$后方的，后面的>：一般指向**队尾元素**或队尾元素的**下一个位置**（数组编号增大的方向）。
    + 指向**队尾元素**：先`rear++`再赋值。
    + 指向队尾元素的**下一个位置**：先赋值再`rear++`
  + 队头指针$front$<$adj.$前面的，正面的>：指向**队头元素**。
    + 先来的人先打到饭，**出队**时先赋值再`front++`。
  + 若循环队列不采用【牺牲最后一个存储单元的方法】的方法，那么队空队满时均有`front==rear`（即不能用作判断条件），而是采用另外增设的成员`length`或`tag`判断。
  + 若循环队列采用【牺牲最后一个存储单元的方法】的方法：
    + 队满条件`(rear+1)%MAXSIZE==front`。
    + 队空条件`front==rear`。
    + 队列元素个数`(rear+MAXSIZE-front)%MAXSIZE`，其中`MAXSIZE`为数组大小。
  + 在协调计算机部件间速度不匹配的问题（缓冲区）和多用户的资源竞争问题（排队，请求处理机）的问题上常使用队列解决。

+ 后缀表达式：若栈顶运算符优先级**大于**当前运算符，先将栈顶所有优先级较大的运算符弹出，然后将当前运算符入栈。也可构造二叉树后进行**后序遍历**直接转换。

+ 稀疏矩阵：只存储非零元素，压缩后就失去了随机存取的特性。非零元素采用【行标，列标，值】标识位置并存储。

  + 三元组法：直接使用数组存储三元组。
  + 十字链表法：每个结点除了使用【行标，列标，值】外，还有两个分别指向同一行和同一列的下一个非零元素的指针。

+ 稀疏矩阵存储：总行数、总列数、三元组表。其中三元组表大小为非零元素个数乘表项大小，表项大小等于元素大小与所在行所在列数字的大小。

+ $\mathrm{KMP}$算法-`next`数组

  1. 先通过题目给定条件确定索引从`0`开始还是从`-1`开始（这里以从`-1`开始为例）并将模式串（记为$\mathrm{T}$）依次编号，然后前两位`next`依次设置为`-1,0`；
  2. 记$A$为【上一位字符】，$k$为【上一位`next`值】，比较$A$与$\mathrm{T}[k]$进行比较，若相等则将当前`next`设置为$k+1$；
     + 注意这里以及之后的所有比较都是拿$A$作为比较的基准。
  3. 若不相等，则将$k$重置为上一步比较中$\mathrm{T}[k]$对应的`next`值，再次比较直到相等或$k=0$；
  4. 当$k=0$时，即与模式串首位字符比较时，若$A==\mathrm{T}[0]$成立则直接置当前`next`设置为$k+1=1$，若不成立则置当前`next`设置为$0$。

+ $\mathrm{KMP}$算法-`nextval`数组、改良后的数组、修正后的`next`数组（**看清楚使用的是什么数组**）

  + 写出`next`数组后，从低到高检查是否有`T[i]=T[next[i]]`，若存在就将其`j=next[i]`值设置为`next[j]`。

+ （下标从零开始）【`nextval`数组值为`-1`】：**主串指针加一**，模式串指针归零。

+ 树的带权路径长度$WPL$：树中所有**叶子**的带权路径长度之和称为树的带权路径长度。

  1.   **等于树中所有非叶节点的权值之和**；
  2.   等于树中全部叶节点的带权路劲长度之和。

+ ※※结点数$=$总度数（总边数）$+1$。最开始只有根节点，总度数（总边数）为零，之后每加一个节点，总度数和结点数同时加一。

  + 注意区分树的度和总度数：树的度表示其最大孩子数，即m叉树。

+ 对于任意一颗完全二叉树，$a_0=\left \lfloor  \frac{n+1}{2}\right \rfloor $，$a_2=\left \lfloor  \frac{n-1}{2}\right \rfloor $，其中$n$为节点个数。

+ 对于任意一颗二叉树，若其叶结点数为$n$，则其所有结点数为$2n+1$。

+ 将一棵满$m$叉树依次编号，对于编号为$n$的结点

  + 其第$k$个孩子结点编号为$(n-1)\times m+1+k$，即**编号减一乘叉加一加k**；

  + 其双亲结点为$\left \lfloor  \frac{n-2}{m}\right \rfloor+1 $；

  + 记住【**其倒数第二个孩子编号为$mn$**】即可。

+ $n$个结点的二叉树不同的形态数量为其卡特兰数$\frac{1}{n+1} \mathrm{C}^n_{2n}$。

  + 若对于$n+1$个结点的一般树转化为二叉树后，**其根节点一定没有右孩子**，故其转化后不同形态数等价于$n$个结点的二叉树不同的形态数量。

+ 二叉树的**前序遍历和中序遍历对应入栈和出栈次序**。

+ 层序遍历在同一层中**可以从前往后遍历也可以从后往前遍历**。

+ 从中序线索树的最小结点，即最左结点，不断查找后继，一定能遍历完所有结点。

+ 森林和二叉树：假设森林为$F$，树为$T$，转换而来的二叉树为$B$。

  + $B$中无右孩子的结点数始终等于$T/F$中非终端结点数加一。
    + $T$有$n$个结点，叶子结点个数为$m$，则$B$中无右孩子的结点个数为$n-m+1$个。
    + $F$有$n$个非终端结点，则$B$中无右孩子的结点有$n+1$个。

  + $F$有$n$条边、$m$个结点，则$F$包含$T$的个数为$m-n$。

- 后缀表达式：遇到运算符时，依次弹出栈中优先级**高于或等于**当前运算符的所有运算符并加入后缀表达式。
- 完全图边数：$C^2_n=\frac{1}{2}n(n-1)$，其中$n$为结点个数。
- 图的连通就记三种特殊情况就行：环、最小生成树和完全图加边。
- 【有向图$\mathrm{G}$的**强连通分量**】：①同一强连通分量中任意两点之间一定存在至少一条路径；②两相异强连通分量之间一定不存在两条不同路径，若存在一条路径则其一定为单向路径；③向有向图$\mathrm{G}$中增加有向边，当且仅当**该边连接两相异强连通分量**且**使其之间形成双向路径**时，有向图$\mathrm{G}$的强连通分量可能减少。
- 无向图中结点$i$的度为第$i$行所有有效元素之和，有向图则为第$i$行和第$i$列所有有效元素之和。
- **邻接矩阵是上、下三角矩阵并非图存在唯一拓扑序列的充要条件，其唯一性取决于具体结构。**
- 画哈夫曼树前先打草稿。
- M叉（度为M）哈夫曼树：若叶节点个数（已经添加虚段）为n，则非叶节点数（合并次数）为$\frac{n-1}{m-1}$。

  - 设所求为$x$，则由结点数等于度数加一有$x+n=xm+1\to x=\frac{n-1}{m-1}$。
- m路归并排序每经过一趟排序剩下的记录数为原来的$\frac{1}{m}$。

  - 故若n条记录恰好进行k趟排序后完成，则$\frac{n}{m^k}<1<\frac{n}{m^{k+1}}$。
- 最小生成树：边数=顶点数$-1$。减去一条则不连通，增加一条则会出现回路。
- $\mathrm{MST}$唯一性定理：若最小生成树没有使用无向图中相同权值的边，则$\mathrm{MST}$唯一。
- 简单路径：一条**每个顶点只能出现一次**的路径。无环，无自指，环路不是简单路径。
- 直接插入排序和二分插入（二分用于寻找插入位置）一组，简单选择排序和堆排序一组（每次选取待排序序列中的最值直接追加放入有序序列。）
- 直接插入排序：从第二个元素开始，将每个元素插入到前面已排序的部分中。

  - 适用于链表，稳定的。元素序列**基本有序**的前提下，直接插入排序效率最高的；
  - 进行$n$躺后能保证前$n+1$个元素是有序的，但是不能保证其都在最终的位置上。
- 向量并行CPU可显著提高快速排序、归并排序、希尔排序的运行效率。
- 最后一趟排序结束前没有一个元素到达最终位置：希尔排序，归并排序，**基数排序**。
- 散列表的映射冲突-开放定址法

  - 线性探测法：$d_i=1,2,3,\cdots,m-1$。一定可以探测到散列表的每个位置。
  - 二次（平方）探测法：$di=1,-1,2^2,-2^2\cdots,(\dfrac{m}{2})^2,-(\dfrac{m}{2})^2$。
    - 散列表长度$m$必须是一个可以表示为$4j+3$的素数才能探测到所有位置。
    - 至少可以探测到散列表中一半的位置。
- 散列表的装填因子：$\alpha$代表一个散列表中的满余情况，越大则查找效率越低。$\alpha=\frac{n}{m}$，其中$n$表示表中记录数，$m$表示散列表长度。

  - 散列表的查找效率取决于三个因素：**散列函数、处理冲突的方法和装填因子**，与表长**无直接关系**；
  - **$\alpha$大于一当且仅当使用链地址法解决冲突**；
  - 若只给出了装填因子$\alpha$，则此时平均查找长度为：$ASL=\dfrac{1}{2}(1+\dfrac{1}{1-\alpha})$。
- 若待排序元素个数为$n$，每组元素个数为$k$并平分，则其使用基于比较的排序算法的时间下界为$O(n\log_2k)$。