# 第二章 进程管理

## 导读

### 【考纲内容】

1. 进程与线程
    + 进程与线程的基本概念
    + 进程/线程的状态与转换
    + 线程的实现
        + 内核支持的线程
        + 线程库支持的线程
    + 进程与线程的组织与控制
    + 进程间通信
        + 共享内存
        + 消息传递
        + 管道

2. $ CPU $调度与上下文切换

    + 调度的基本概念
    + 调度的目标

    + 调度的实现
        + 调度器/调度程序
        + 调度的时机与调度方式(抢占式/非抢占式)
        + 闲逛进程
        + 内核级线程与用户级线程调度
    + 典型调度算法
        + 先来先服务调度算法
        + 短作业(短进程、短线程)优先调度算法
        + 时间片轮转调度算法
        + 优先级调度算法
        + 高响应比优先调度算法
        + 多级队列调度算法
        + 多级反馈队列调度算法
    + 上下文及其切换机制

3. 同步与互斥
    + 同步与互斥的基本概念
    + 基本的实现方法
        + 软件方法
        + 硬件方法
    + 锁
    + 信号量
    + 条件变量
    + 经典同步问题
        + 生产者-消费者问题
        + 读者-写者问题
        + 哲学家进餐问题

4. 死锁
    + 死锁的基本概念
    + 死锁预防
    + 死锁避免
    + 死锁检测和解除

### 【知识导图】

### 【复习提示】

进程管理是操作系统的核心,也是每年必考的重点。

其中,进程的概念、进程调度、信号量机制实现同步和互斥、进程死锁等更是重中之重,必须深入掌握。需要注意的是,除选择题外,本章还容易出综合题,其中信号量机制实现同步和互斥、进程调度算法和死锁等都可能命制综合题,如利用信号量进行进程同步就在往年的统考中频繁出现。

## 进程与线程

![image-20230611110201119](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306111102169.png)

### 进程概念

+ 程序指一个指令序列。
+ 进程为了满足操作系统的并发性和共享性。
+ 进程和程序的根本区别在于其动态性。（<span style="color:orange">注意：</span>所以进程不能与程序相等）
+ 系统为每个运行的程序配置一个数据结构，称为**进程控制块PCB**，用来描述进程的各种信息，如程序代码存放位置。
+ $PCB$、程序段、数据段三个部分构成了进程实体（进程映像）
+ 创建进程就是创建$PCB$，销毁进程就是销毁$PCB$，$PCB$是进程存在的唯一标志。
+ 进程映像是静态的，而进程是动态的。
+ 进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。
+ 进程和进程实体（进程映像）的区别(一般可以认为是同一个东西,不过区别还是要记得)
    + **进程是系统进行资源分配和调度的基本单位**
    + 进程实体由$PCB$、程序段、数据段组成,进程是进程实体的运行过程

+ 系统资源这里指处理机、存储器和其他设备服务于某个进程的时间单位。

#### 进程结构

![image-20230611103859745](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306111038787.png)

![image-20230611103717845](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306111037906.png)

+ 程序段（代码段）：包括程序代码，程序运行时使用、产生的运算数据，往往是只读的。
+ 数据段：存放程序运行过程中处理的各种数据。如全局变量、静态变量、宏定义的常量。
+ 进程控制块$(Process\; Control\; Block,PCB)$：操作系统用$PCB$来管理进程，所以$PCB$包含所有管理进程所需的信息。
    + 进程描述信息：
        + 进程标识符$PID$：标识进程。
        + 用户标识符$UID$：标识进程归属的用户，用于共享和保护服务。
    + 进程控制和管理信息：
        + 进程当前状态：进程状态信息，作为处理机发分配调度的依据。
        + 进程优先级：进程抢占处理机的优先级。
        + 代码运行入口地址。
        + 程序外存地址。
        + 进入内存时间。
        + 处理机占用时间。
        + 信号量使用。
    + 资源分配清单：说明有关内存地址空间或虚拟地址空间的状况，打开文件的列标与使用的输入输出设备信息。
        + 代码段指针。
        + 数据段指针。
        + 堆栈段指针。
        + 文件描述符。
        + 键盘。
        + 鼠标。
    + 处理机相关信息：主要处理机中各种寄存器值。
        + 通用寄存器值。
        + 地址寄存器值。
        + 控制寄存器值。
        + 标志寄存器值。
        + 状态字。
+ 堆：用来存放动态分配的变量，如调用`malloc`函数动态地向高地址分配空间。
+ 栈：用来实现函数调用，保存局部变量、函数传递参数，从用户空间的高地址向低地址增长。

#### 进程特征

+ 动态性：是进程最基本的特征，进程是程序的一次执行过程，是动态地产生、变化和消亡的。
+ 并发性：内存中有多个进程实体，各进程可并发执行。
+ 独立性：进程是资源分配、接受调度、能独立运行、独立获得资源、独立接受调度的基本单位。
+ 异步性：各进程按各自独立的、不可预知的速度向前推进。
    + 异步性会导致并发程序执行结果的不确定性, 操作系统要提供“进程同步机制”来解决异步问题

+ 结构性：每个进程都会配置一个$PCB$。结构上看，进程由程序段、数据段、$PCB$组成。

#### 进程组织

当一个系统中存在多个$PCB$时，需要以适当的方式组织$PCB$。

+ 链接方式：
    + 按照进程状态将$PCB$分为多个队列。如执行指针（指针数为最大执行并行数）、就绪队列指针（一般会把优先级高的进程放在队头）、阻塞队列指针（许多操作系统会根据阻塞原因的不同将其分为多个阻塞队列）。
    + 操作系统持有指向各个队列的指针。
    + ![image-20230611112722015](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306111127068.png)
+ 索引方式：
    + 根据进程状态的不同建立索引表。如执行指针、就绪表指针、阻塞表指针。
    + 操作系统持有指向各个索引表的指针。
    + ![image-20230611112756465](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306111127510.png)

#### 进程与程序

执行一条命令或运行一个应用程序时，进程和程序之间形成一对一的关系。进程在执行过程中可以加载执行不同的应用程序，从而形成一对多的关系；以不同的参数或数据多次执行同一个应用程序时，形成多对一的关系；并发地执行不同的应用程序时，形成多对多的关系。

### 进程状态

![image-20230611112836892](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306111128940.png)

#### 基本进程状态

进程$PCB$中，会有一个变量$state$来表示进程的当前状态。

具有三种基本状态和其他两种状态：

+ 运行态：占有$CPU$并已经在$CPU$上运行。
    + 单核$CPU$的情况下，同一时刻只会有一个进程处于运行态，多核$CPU$情况下，可能有多个进程处于运行态

+ 就绪态：已经具备运行条件（除处理机外的一切所需资源），但是由于没有空闲$CPU$，导致暂时不能运行。
+ 阻塞态（等待态）：因等待某一事件而暂时不能运行，只有分配其他资源到位才能考虑分配$CPU$。
+ 创建态（新建态）：为进程分配所需的内存空间等系统资源，将转为就绪态。
    + 申请一个空白$PCB$。
    + 向$PCB$填写一些控制和管理进程的信息。
    + 系统为进程分配运行所需资源。
    + 进程转为就绪态。
+ 终止态（结束态）：进程运行结束或出现错误导致进程被撤销，操作系统需要回收进程资源，撤销$PCB$等工作，以防止内存泄漏。
    + 一个进程可以执行$exit$系统调用，请求操作系统终止该进程。

+ 挂起态：暂时不能获得服务，进程映像调到外存等待（对应进程的$PCB$还在内存中等待并允许被修改）。分为：
    + 就绪挂起态：准备好后在外存中，只要允许可以随时进入内存。
    + 阻塞挂起态：等待事件在外存中，必须等待一定时间发生。

#### 进程状态转换

![image-20230611112454100](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306111124163.png)

+ 创建态到就绪态：系统完成创建进程等工作并准备好处理机等资源。
+ 就绪态到运行态：占有$CPU$资源，进程被调用。
+ 运行态到就绪态：时间片到或处理机（包含$CPU$和内存的一系列硬件）被抢占。
+ 运行态到阻塞态：进程主动用系统调用的方式申请某种系统资源（由用户态程序调用操作系统内核），或请求等待某个事件发生。
+ 阻塞态到就绪态：申请的资源被分配或等待的事件发生，是被动发生。
+ 运行态到终止态：进程运行结束或运行过程中遇到不可修复的错误。
+ 就绪挂起态到就绪态：激活。
+ 就绪态到就绪挂起态：挂起。
+ 阻塞挂起态到阻塞态：激活。
+ 阻塞态到阻塞挂起态：挂起。
+ 阻塞挂起态到就绪挂起态：阻塞事件发生。
+ 运行态到就绪挂起态：运行中内存空间不足，或优先级更高的进程进入队列。
+ 创建态到就绪挂起态：创建后发现内存空间不足。

### 进程控制

#### 进程控制概念

+ 进程控制主要功能是对系统中的所有进程实施有效的管理，具有创建新进程、撤销已有进程、实现进程状态转换功能。
+ 如进程组织所说，通过将$PCB$指针放入各种状态的进程队列中转换进程状态来实现控制。
+ 进程控制由**原语**实现。
    + 特点是执行期间不能中断。
    + 这种不能中断的操作就是原子操作。
    + 原语采取“关中断指令”（屏蔽外部中断信息）和“开中断指令”（开始监听外部中断信息）实现。
    + 关/开中断指令的权限很大，所以必然是核心态下执行的特权指令。从而原语必然运行在核心态。

#### 父子进程

允许一个进程创建另一个进程。此时创建者称为父进程，被创建的进程称为子进程。子进程可以继承父进程所拥有的资源。当子进程被撤销时，应将其从父进程那里获得的资源归还给父进程。此外，在撤销父进程时，必须同时撤销其所有的子进程。

父进程创建子进程后，父进程与子进程同时执行（并发）。主程序调用子程序后，主程序暂停在调用点，子程序开始执行，直到子程序返回，主程序才开始执行。

父进程和子进程可以共享一部分资源，但是不能共享虚拟地址空间，因为这是逻辑地址。且其有不同的$PCB$用于区分进程。

#### 进程控制原语

前四种是必要的。

+ 过程创建：
    + 创建原语：
        + 分配一个唯一的进程标识号$PID$，**申请空白$PCB$**，若申请失败，则创建失败。
        + 为新进程**分配所需资源**，若资源不足，则进入阻塞态。
        + **初始化$PCB$**，主要包括标志信息、处理机状态信息、处理机控制信息、进程优先级。
        + 将$PCB$**插入就绪队列**。
            + 创建态$\to$就绪态
    + 引起进程创建的事件：
        + 用户登录：分时系统中，用户登录成功，系统会为其建立一个新进程。
        + 作业调度：多道批处理系统中，有新的作业进入内存时，会为其创建一个新进程。
        + 提供服务：用户向系统提出请求时，会创建一个新进程来处理请求。
        + 应用请求：由用户进程主动请求创建一个子进程。
+ 进程终止：
    + 撤销原语(就绪态/阻塞态/运行态$\to$终止态)：
        + 根据被终止进程的标识符，从$PCB$集合中找到终止进程的$PCB$，读取进程的状态。
        + 若进程正在运行，则立刻剥夺其$CPU$交给其他进程。
        + 若是普通的终止，父进程终止时会将其子进程交给$init$进程收养。
        + 若是整个进程组的进程，则终止其所有子进程。
        + 将进程所有的资源交给父进程或操作系统。
        + 从所在队列或链表中删除$PCB$。
    + 引起进程终止的事件：
        + 正常结束：任务完成。
            + 进程自己请求终止($exit$系统调用)
        + 异常结束：内部异常，如存储区越界、保护错、运行超时等。
            + 例如整数除以$0$、非法使用特权指令，
        + 外界干预：外部请求而终止运行，如操作员或操作系统干预、父进程请求、父进程终止。
+ 进程阻塞：
    + 阻塞原语(运行态$\to$阻塞态)：
        + 找到要阻塞的进程对应的$PCB$。
        + 保护进程运行现场，将$PCB$状态信息设置为阻塞态，暂停进程。
        + 将$PCB$插入事件等待队列，将处理机资源调度给其他就绪态进程。
    + 引起进程阻塞的事件：
        + 需要等待系统分配资源。
        + 需要等待相互合作的其他进程完成工作。
+ 进程唤醒：
    + 唤醒原语(阻塞态$\to$运行态)：
        + 在事件等待队列中找到$PCB$。
        + 将$PCB$从等待队列中移除，设置进程为就绪态。
        + 将$PCB$插入就绪队列，等待被调度。
    + 引起进程唤醒的事件：
        + 等待的事件的发生（因什么事件被阻塞就应该被什么事件唤醒）。
        + 所以进程阻塞和进程唤醒应该是成对出现的
+ 进程切换：
    + 切换原语：
        + 将处理机上下文信息，包括程序计数器$PC$和其他寄存器信息存入$PCB$。
        + $PCB$移入相应队列。
        + 选择另一个进程执行，并更新其$PCB$。
        + 更新内存管理的数据结构。
        + 根据$PCB$恢复新进程所需的运行环境。
    + 引起进程切换的事件：
        + 当前时间片到。
        + 有更高优先级进程到达。
        + 当前进程主动阻塞。
        + 当前进程终止。

### 进程通信

进程通信是两个进程之间的数据交互。

为了保证安全，一个进程不能直接访问另一个进程的地址空间，但是又必须有进程通信。$PV$操作是低级通信方式，高级通信方式有：

+ 共享存储：分配一个可以共同使用的共享空间，进程对其的使用必须是互斥的（使用同步互斥工具如$PV$操作）。
    + 基于数据结构：共享空闲只能放固定的数据结构如数组等。速度慢，限制多，是低级通信方式。
    + 基于存储：内存中划出一块共享存储区，数据的形式、存放位置都由进程控制而非操作系统。速度更快，限制少，是高级通信方式。
    + ![image-20230611123227178](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306111232224.png)
+ 信息传递：进程间的数据交换以格式化的消息为单位。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。
    + 消息包括消息头和消息体，消息头包括：发送进程$ID$、接受进程$ID$、消息类型、消息长度等格式化的信息。
    + 消息传递包括：
        + 直接通信方式：消息直接挂到接受进程的信息缓冲队列上。
        + 间接通信方式：消息先发送到中间实体（信箱）中，因此也称为信箱通信方式，如计算机网络中的电子邮件系统。
    + ![image-20230611123849695](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306111238747.png)
+ 管道通信：是消息传递的特殊方式，指用于链接各自一个的读写进程的一个共享文件，又名$pipe$文件，其实就是内存中开辟一个大小**固定**的缓冲区。  
    + 只能使用半双工的通信，**同一时间段**内只能**单向**传输(但传输结束释放空间后可以进行方向相反的传输)，若要**双向同时**通信则必须设置两个管道。
    + 两个进程使用生产者-消费者的方式进行通信
    + 进程需要互斥访问管道，需要满足互斥、同步、确定对方存在。
    + 数据以字符流的形式写入管道，当满时，写进程的$write()$系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的$read()$系统调用将被阻塞。
    + 如果没有**写满**则不允许读，如果没有**读空**则不允许写。所以读写都可能被堵塞。
    + 管道中的数据一旦被读出，就彻底消失。因此，当多个进程读同一个管道时，可能会错乱。对此，通常有两种解决方案
        1. 一个管道允许多个写进程一个读进程($2014$年$408$真题高教社官方答案)
            + 以这个说法为主
        2. 允许有多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据($Linux$的方案)。
            + 但这个说法也没错
+ 共享文件（文件系统）：利用操作系统提供的文件共享功能实现进程之间的通信。
+ 信号量：也需要信号量来解决文件共享操作中的同步和互斥问题。

由于不同进程拥有不同代码段和数据段，全局变量是针对同一个进程而言，所以全局变量不能用来交换数据。
