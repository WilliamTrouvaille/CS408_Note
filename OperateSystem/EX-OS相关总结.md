# EX-OS总结

## 强化梳理

### 考频

![23September20-222342-1695219822-dadc9ce3-dd22-41f7-b079-d8315906aa14](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309202224469.png)

>   二级标题后面括号里面的数字表示09-22年的考频

### 第二章PV大题(10)

#### 问题分类

1.   生产者消费者问题——进程间关系为“生产资源-消费资源”

2. 理发师问题——进程间关系为“服务-被服务”
3. 读者写者问题——同类进程不互斥、异类进程互斥
  +   从未考过但是==大纲明确要求==
4. 哲学家进餐问题——只有一类进程，每个进程需要同时拥有多种资源才能运行
5. 单纯的同步问题——前驱后继图

#### 解题思路

1.   确定函数的个数（有几类进程？）：梳理题目中有几个进程，一个进程对应一个函数（根据动作是否一致区分是否为统一进程）
2.   确定函数的动作：
     1.   动作是什么：在函数内部，用中文描述动作（==允许用中文的伪代码形式答题==）
          +   ==伪代码也要打分号`;`，不要忘记打分号==`;`
     2.   动作的次数：只做一次（不加`while`）还是重复进行（`while(1)`循环）
3.   确定函数是否在每个动作之前需要进行`P`操作，==如果需要进行`P`操作，则一定有与之对应的`V`操作==，需要思考这个`V`操作应该被放在哪
     1.   消耗资源型的`P`操作：题目一般会显性给出，例如每次动作需要消耗一个缓冲区空间（`P`操作减少缓冲区空间，`V`操作增加缓冲区空间，缓冲区无空间时无法进行动作）
          +   ==实现同步的$P$操作一定要在实现互斥的$P$操作之前.可以理解为要先拿到这个空间再上锁==
     2.   互斥型的`P`操作：需要注意隐含的互斥关系，例如缓冲区的互斥访问`P(mutex)`
4.   确定信号量`Semaphore`的个数：==所有`PV`操作定义完成后，再确定信号量`Semaphore`的个数==
     +   定义完再思考每个信号量的初值是多少
     +   使用注释对定义的信号量`Semaphore`进行解释
5.   检查是否发生死锁：连续进行多个`P`操作的地方是否会发生死锁（只有一个`P`操作不会发生死锁）
     +   某信号量的`PV`连续出现（中间没有夹杂别的`P`操作），则不会发生死锁：破坏死锁条件`请求和保持`
     +   ==实现同步的$P_{同步}$操作一定要在实现互斥的$P_{互斥}$操作之前，可以理解为要先拿到这个空间再上锁==
         +   ==用实现互斥的$P_{互斥}$操作把动作夹在里面==
6.   （以上步骤先在草稿纸上进行）检查符合题意没问题后将答案誊写到答题卡上，并写上相应的注释
     +   草稿纸上的语言可以比较通俗，空位满位什么的搞不清楚就在草稿纸上写清楚点`缸有空`，`缸中水`这样的

>   王道的强化网课中以下内容的答案每年都在变，找资料的时候发现不能和以上的解题思路很好的统一，以下内容的答案全部参考24版王道教材的答案，可能会和网课有部分出入，这边建议以王道教材为准

#### 生产者 - 消费者类型

##### 生产者 - 消费者类型(1)

![image-20230828115006942](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308281150064.png)

1.   确定函数的个数：
     +   生产车间A和生产车间B虽然都是生产车间，但是它们俩执行的动作不一致，故不是同一个进程，即生产车间A和生产车间B需要对应不同的函数
     +   进程 = 生产车间A（`A`） + 生产车间B（`B`） + 装配车间（`C`）

2.   确定函数的动作：
     1.   动作是什么：
          +   `P1`和`P2`分别生产`A、B`两种零件，并将分别把它们送到货架`F1、F2`上
          +   `C`从货架上分别取出`A、B`后，组装成`A + B`
     2.   动作的次数：
          +   `P1、P2`和`C`都是不断重复 → `while(1)`

3.   确定函数是否在每个动作之前需要进行`P`操作：如果需要进行`P`操作，则一定有与之对应的`V`操作；需要思考这个`V`操作应该被放在哪进

     1.   P1生产A零件之前不需要消耗资源
          +   `P1`将`A`放到`F1`前需要消耗1个`F1`货架（`A`缓冲区）的剩余容量 → `C`从`F1`上取`A`后会释放1个`F1`货架的剩余容量
          +   `empty1`对应货架`F1`上的空闲空间，初值为`10`； `full1`对应货架`F1`上面的`A`产品，初值为`0`：
     2.   P2生产B零件之前不需要消耗资源
          +   `P2`将`B`放到`F2`前需要消耗`1`个`F2`货架（`B`缓冲区）的剩余容量 → `C`从`F2`上取`B`后会释放`1`个`F2`货架的剩余容量
          +   `empty2`对应货架`F2`上的空闲空间，初值为`10`；`full2`对应货架`F2`上面的`B`产品，初值为`0`

     3.   `C`从`F1`取`A`前需要消耗1个F1货架上的A产品 → P1把A放到F1后释放1个`F1`货架上的A产品
          +   `C`从`F2`取`B`前需要消耗1个`F2`货架上的`B`产品 → `P2`把`B`放到`F2`后释放`1`个`F2`货架上的B产品
          +   C组装成A+B前不需要消耗资源

     4.   P1和C对F1的访问是互斥的（`mutex1`）；P2和C对F2的访问是互斥的（`mutex2`）

4.   确定信号量的个数：
     +   `empty1 = empty2 = 10，full1 = full2 = 0，mutex1 = mutex2 = 1`

5.   检查是否发生死锁：连续进行多个`P`操作的地方是否会发生死锁（只有一个`P`操作不会发生死锁）
     +   先P同步信号量（`empty1、empty2、full1、full2`），再P互斥信号量(`mutex1、mutex2`）

![image-20230828115303663](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308281153236.png)

##### 生产者 - 消费者类型(2)

![image-20230828121437525](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308281214633.png)

1.   确定函数的个数（2），确定函数的动作：
     +   老和尚`喝水`
     +   小和尚`取水`
2.   动作是什么：
     1.   老和尚（取桶、）从缸中打水、喝水
     2.   小和尚（取桶、）从井中打水、放水
3.   动作的次数：
     +   不断进行 → `while(1)`
4.   确定函数是否在每个动作之前需要进行`P`操作，实现同步的`P`操作一定要在实现互斥的`P`操作之前：
     1.   老和尚打水前消耗1个桶 → 老和尚喝水后增加1个桶
          +   老和尚喝水前消耗1个水缸里的水 → 小和尚打水后增加1个水缸里的水
     2.   小和尚打水前消耗1个桶 → 小和尚放水后增加1个桶
          +   小和尚打水前消耗1个水缸的剩余容量 → 老和尚喝水后增加1个水缸的剩余容量
     3.   小和尚之间对井的访问是互斥的（`mutex1`）；老和尚间和小和尚间、老和尚和小和尚对水缸的访问是互斥的（`mutex2`）
5.   确定信号量的个数：
     +   互斥访问信号量为1，其余为资源数量
6.   检查是否发生死锁：
     1.   如果老和尚和小和尚都是先对tong进行P操作（先进行取水桶操作），则可能发生：三个老和尚同时取水，并取得水桶（此时完成了三个P(tong)，则tong = 0），但是水缸中没有水（full = 0），即老和尚进程被阻塞在P（full）；而若干个小和尚想去打水，水桶却被取光（tong = 0），即小和尚进城被阻塞在P(tong)，这样就形成了死锁
     2.   同理，也可能发生三个小和尚分别拿着桶，而水缸中水满（empty = 0），被阻塞在P（empty）；而老和尚苦于没有水桶，被阻塞在P（tong）
     3.   解决方法：调整老和尚进程和小和尚进程的取桶顺序
          +   老和尚先判断水缸中有没有水，水缸有水的情况下才去取桶喝水，即先P（full）再P（tong）
          +   小和尚先判断水缸中有没有剩余容量，水缸中有剩余容量的情况下才去取桶打水，即先（empty）再P（tong）

![23August28-203245-1693225965-07aadabe-9997-444f-8a22-52cf809430f8](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282033927.png)

##### 生产者 - 消费者类型(3)

![image-20230828202814748](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282028901.png)

1.   确定函数的个数（2）：
     +   所有生产者动作一致，故所有生产者视为一类进程
     +   所有消费者动作一致，故所有消费者视为一类进程

2.   确定函数的动作：

     1.   动作是什么：
          1.   P生产产品，并将产品放入缓冲区
          2.   C从缓冲区取10个产品

     2.   动作的次数：
          +   P和C都是不断重复 → `while`

3.   确定函数是否在每个动作之前需要进行P操作：

     1.   P生产产品前不需要消耗资源
          +   P将产品放入缓冲区前需要消耗1个缓冲区剩余容量 → C从缓冲区取10个产品后增加10个缓冲区剩余容量（每取出1个产品，增加1个缓冲区容量，通过for循环实现）
     2.   C从缓冲区取10个产品前需要消耗10个缓冲区产品数量（`for`循环实现） → P将产品放入缓冲区后增加1个缓冲区产品数量
     3.   P和C对缓冲区的访问是互斥的（`mutex`）
     4.   多个C之间P操作是互斥的：如果只是简单的使用for循环设置在取10个产品前，则可能发生多个C轮流的取产品

![image-20230828214546119](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282145337.png)

#### 理发师问题

1.   服务与被服务的关系

2.   区别：需要额外设置变量记录当前等待的顾客有多少个，且该变量的访问是要互斥进行的，即需要夹在PV操作中

3.   理发师问题实际上是生产者 - 消费者问题的变式：
     1.   生产者 - 消费者问题：生产者生产资源，消费者消费资源；缓冲区限制资源上限
     2.   理发师问题：将顾客和服务员分别视为一种资源
          1.   顾客：每个顾客到店时，生产一个顾客资源；在被服务前，消耗一个服务员资源
          2.   服务员：提供服务前，消耗一个顾客资源；确定有顾客时，生产一个服务员资源；再提供服务

##### 理发师问题(1)

![23August28-212531-1693229131-27b4137a-7c05-466f-86ca-c7807f6b4062](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282125663.png)

特点：

1.   顾客无上限
2.   服务员在没有顾客的时候可以休息，通过`P(customer)`实现

![image-20230828214945063](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282149256.png)

##### 理发师问题(2)

![23August28-213808-1693229888-3d5ee02f-d0c8-4c14-8e9a-7f31f51e6b02](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282138483.png)

特点：顾客到店时，会检查`waiting`变量是否小于`m`，即等待数量有上限

![image-20230828213927729](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282139878.png)

##### 理发师问题(3)

![23August28-214003-1693230003-c0f04c89-2818-4b34-b8ea-65e8e0db7295](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282140847.png)

特点：

1.   在没有顾客时，服务员不能休息，必须忙等，即不断的轮询（`while`）检查`waiting`变量，判断当前是否有正在等待的顾客
2.   此情况下无需申明`customer`变量，即服务员无需阻塞
3.   用`waiting`变量判断服务员当前是否需要为顾客提供服务

![image-20230828214136567](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282141723.png)

#### 读者 - 写者问题

1.   第一个进程上锁，最后一个进程解锁：通过`count`变量记录该进程当前的数量
     +   读者写者问题主要是解决互斥
     +   他的访问关系分为两种类型，一种是可以同时访问（读和读），另一种是必须互斥访问（写和读，写和写)
     +   因为多种关系，所以引入了计数器`count`

2.   ==同类进程不互斥，不同类进程互斥（读者 - 写者问题的最主要特点）==

3.   写者进程不用判断是否自己是第一个/最后一个进程

##### 读者 - 写者问题(1)

![image-20230828215600872](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282156992.png)

特点

1.   从南往北的车只要有一辆占据，其余从南到北的车就可以一直使用该路；从北往南的车同上（同类的进程可以共享资源，不同类的进程互斥资源）

2.   声明`count1`变量和`count2`变量分别用于记录当前`P1/P2`有几个进程正在使用该临界资源，初始为`0`

3.   在每个进程开始时，通过`count`是否为`0`判断自己是不是第一个进程，如果是，则对临界资源进行上锁

4.   进行`count++`，表示自己正在使用临界资源，并在使用完临界资源后进行`count--`

5.   在每个进程结束时，通过`count`是否为0判断自己是不是最后一个进程，如果是，则对临界资源进行解锁

![image-20230828220100097](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282201198.png)

![image-20230828220520797](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282205963.png)

##### 读者 - 写者问题(2)

![image-20230828220732681](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282207808.png)

1、2、3种不同的录像片对应不同的进程，不同进程互斥访问录像厅（临界资源），统一进程共享录像厅 

![image-20230828221532455](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282215677.png)

##### 读者 - 写者（写优先）

![23August28-225328-1693234408-4a367299-7bfb-435e-a5a0-d38b2d62802e](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282253634.png)

![image-20230828225713745](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282257993.png)

#### 哲学家进餐

+   特征：==只有一类进程，且该类进程只有同时拥有多种资源才能进行==

+   哲学家问题关键点是限制并行，主要是三种思路

    1.   限制申请条件（对应破坏死锁循环等待条件)：解法一==不通用，不建议使用==

         +   比如规定单号哲学家先取左筷子，双号先取右筷子

    2.   信号量限制并行数（对应破坏死锁发生的循环等待条件）：==解法二通用，但并发度不高，也不建议使用==，参考`2.4`小题第8题确定最大进程数

         +   如`P89`代码就是同一时间只能有一个哲学家就餐（禁止并行）

    3.   限制哲学家只有能够取得两个筷子的时候才会就餐（对应破死锁条件)：解法三==很通用，且并发度高==，暴力美学

         +   `P(Lock);if(检查是否全满足);V(Lock);`

+   第三个思路最通用：

    +   通常的思路为
        1.   将每种资源通过int类型的变量定义（使用变量将资源数量具象化）
        2.   在进程开始运行时，先使用`P(mutex)`操作实现对各种资源进行互斥的访问，目的是逐一判断当前进程所需的各种资源是否满足运行的需要
        3.   如果资源都满足，则拿走这些资源（一口气拿走），然后`V(mutex)`，再执行动作

    +   循环条件下：如果只要有一个资源不满足，则`V(mutex)`，然后结束此次循环，进行下一次循环（`continue`）；
    +   只进行一次：如果只要有一个资源不满足，则使用`goto`语句返回函数的第一句重新进行判断（手动实现循环）
    +   其中`2.`实现同一时间只可能有一个进程在进行判断/拿走临界资源
    +   最后完成动作归还资源时也要进行上锁，保证归还动作一气呵成的完成
    +   代码示例如下：

    ![image-20230905194647152](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309051946435.png)

##### 哲学家进餐(1)

![image-20230828223900539](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282239653.png)

1.   变量`bowl`表示剩余碗的数量
     +   数组a中`a[i] = 1`表示第i个哲学家的左手有筷子，`a[(i + 1) % n] = 1`表示第i个哲学家的右手有筷子
         +   （需要对右手边的筷子进行取模操作，第n个哲学家的右手边筷子就是第1个哲学家左手的筷子）

2.   `P（mutex）`实现对临界资源的上锁

3.   判断`bowl`变量和左右筷子是否都在，任意条件不满足则`V（mutex）`（解锁）并结束循环；条件都满足时，则对这两个变量进行 - 1操作，表示取出该临界资源

4.   `V（mutex）`实现对临界资源的解锁

5.   进餐（即自己的主体动作）

6.   归还拥有的临界资源
     +   另一个哲学家进行上锁并判断

![image-20230828224501610](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282245740.png)

##### 哲学家进餐(2)

![23August28-224746-1693234066-b51c0023-fb6b-4e1a-96a6-b4e4aa8d1051](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282247271.png)

检查当前是否有4个盆和1个座位，再去完成打饭和坐落（主体动作）

解法一：信号量

![image-20230828225100384](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282251540.png)

~~这里的一口气拿四个盆我看一下笑一次~~

解法二：`int`类型变量（此时每个干饭人只进行一次，不能使用`continue`）

![image-20230828225228119](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282252288.png)



#### 单纯的同步问题

这类题通常会给一个前驱后继图，让你根据图实现同步关系，送分题，不需要过多关注

>   前驱关系其实是多组同步.
>
>   进程$P_1$中有句代码$S_1$，$P_2$中有句代码$S_2$……$P_6$中有句代码$S_6$
>
>   这些代码要求按如下前驱图所示的顺序来执行：
>
>   ![image-20230619235155088](http://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306192351183.png)
>
>   其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作）因此：
>
>   1. 要为每一对前驱关系各设置一个同步变量.
>   2. 在“前操作”之后对相应的同步变量执行$V$操作.类似表示当前动作$S_i$已经完成.
>   3. 在“后操作”之前对相应的同步变量执行$P$操作.类似检测前一个动作$S_i$是否完成.
>
>   ![image-20230619235433357](http://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306192354443.png)
>
>   每个$S_i$操作都设置一个进程$P_i$.
>
>   每一条线段靠近根的对当前信号量进行$V$操作，靠近尾的对当前信号量进行$P$操作.
>
>   再将每个代码结点旁边的操作聚拢在一起，就是每个进程所应该执行的操作.
>
>   ![image-20230619235341960](http://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306192353047.png)