# EX-第四章 串知识总结

## 导读

### 【考纲内容】

1. 字符串模式匹配

### 【复习提示】

选择题：字符串模式匹配、$KMP$匹配算法的原理及`next`数组的推理过程，手工求`next`数组可以先计算出部分匹配值表然后变形，或根据公式来求解

## 选择题考点总结

### 模式匹配

1.   模式匹配：指在主串中找到与模式串相同的子串并返回其所在位置。

     +   子串：主串的一部分，一定存在。
     +   模式串：要找的串，不一定能在主串中找到。

2.   朴素模式匹配算法：从主串$T$、模式串$P$（子串）的第一个位置开始比较（$i=0,j=0$），若相等，则$i$，$j$各自$+1$，然后比较下一个字符。若不等，主串指针回溯到上一轮比较位置的下一个位置，子串回溯到$0$，再进行下一次比较。令子串长度为$m$，主串长度为$n$,则最多对比$n-m+1$次。

     1.   匹配成功的最好时间复杂度：$O(m)$：刚好第一个就匹配上了，总对比次数为子串长度。
     2.   匹配失败的最好时间复杂度：$O(n-m+1)=O(n-m)=O(n)$：匹配成功之前，每一个与第一个字符都匹配失败。
     3.   匹配失败的最坏时间复杂度：$O(nm-m^2+m)= O(nm)$：子串除了最后一个对不上，其余的都能对上，则每次遍历完一边后，又要走回头路；直到匹配成功/失败一共需要比较$m\times(n-m+1)$次。$m$：每次需要移动$m$次，$i$需要移动$n-m+1$次。

3.   $KMP$算法：不适配时，只有模式串指针回溯，主串指针不变，找到失配前模式串的最长公共前后缀并跳转到最大公共后缀开始匹配，且最大公共前后缀要小于左端子串长度。不匹配的字符之前，一定是和模式串一致的。

4.   $next$数组：子串中第$i$号元素对应的$next[i]$表示扫描失败时**可以跳过匹配的字符个数**。扫描失败时主串指针不动，子串指针根据最后一个匹配成功元素对应的$next[i]$​跳过相应匹配字符后进行下一次扫描。
     $$
     \operatorname{next}[j]=\left\{\begin{array}{ll}
     0, & j=1 \\
     \max \left\{k \mid 1<k<j \text { 且 }{ }^{\prime} p_{1} L p_{k-1}{ }^{\prime}={ }^{\prime} p_{j-k+1} L p_{j-1}{ }^{\prime}\right\},& \text {当此集合不为空时 }\\
     1, & \text {其他情况 }
     \end{array}\right.
     $$
     其中，主串为$s_1s_2s_3\cdots s_n$，模式串为$p_1p_2p_3\cdots p_m(m\le n)$。

     1.   当模式串第一个字符($j = 1$)与主串第$i$个字符发生失配时，规定$next[1]=0$，代表模式串移动到下一个匹配位置。
          +   可理解为将主串第$i$个字符和模式串第一个字符的前面空位置对齐，也即模式串右移一位。
     2.   当模式串中第$j(1<j<m)$个字符即$p_{j-1}$与主串中第$i$个字符失配时。假设此时应与模式中第$k (1<k<j)$个字符继续比较（第$k$个字符应该刚好不匹配），则模式中前$k-1$​个字符的子串必须满足下列条件
          1.   $'p_1p_2 \cdots p_{k-1}\; ' = ' p_{j-k+1}+p_{j-k+2}+\cdots p_{j-1}\;'$。
               +   表示从模式串开头的连续的$k-1$个的元素（即${ }^{\prime} p_{1} L p_{k-1}{ }^{\prime}$或$'p_1p_2 \cdots p_{k-1}\; '$）和从当前字符倒着的连续的$k-1$个的元素（即${ }^{\prime} p_{j-k+1} L p_{j-1}{ }^{\prime}$或$' p_{j-k+1}+p_{j-k+2}+\cdots p_{j-1} '$,其中$p_{j-1}$是当前字符）相匹配。
          2.   不存在$k'>k$满足条件$1.$
               +   表示$k$应该是满足条件$1.$的集合中的最大值。

5.   $next$数组求法

     1.   求$next[j+1]$，则已知前面的所有$next$表值$next[1],next[2]\cdots next[j]$。
     2.   假设数组值$next[j]=k_1$（跳转索引），则有$P_1\cdots P_{k_1-1}=P_{j-k_1+1}\cdots P_{j-1}$（前$k_1-1$位字符与后$k_1-1$位字符重合）。
     3.   如果$P_{k_1}=P_j$（即最后一位也一样，则得到在之前匹配基础上的更长的公共前后缀），则$P_1\cdots P_{k_1-1}P_{k_1}=P_{j-k_1+1}\cdots P_{j-1}P_j$，则$next[j+1]=k_1+1$，否则进入下一步。
     4.   假设$next[k_1]=k_2$、则有$P_1\cdots P_{k_2-1}=P_{k_1-k_2+1}\cdots P_{k1-1}$。
     5.   $2. \&3.$联合得到$P_1\cdots P_{k_2-1}=P_{k_1-k_2+1}\cdots P_{k1-1} =P_{j-k_1+1}\cdots P_{k_2-k_1+j-1}=P_{j-k_2+1}\cdots P_{j-1}$，即四段重合。
     6.   这时候．再判断如果$P_{k_2}=P_j$，则$P_1\cdots P_{k_2-1}P_{k_2}=P_{j-k_2+1}\cdots P_{j-1}P_j$，则$next[j+1]=k_2+1$，否则再取$next[k_2]=k_3$回到$4.$。
     7.   如果遇到$0$还没有结果，则表示前面的全部不重合，赋值为$0+1=1$。

6.   $KMP$算法优化：$KMP$算法的$next$数组存在一定问题，若当前索引的值匹配失败，那么模式串的其他同样值的地方也一定会匹配失败。

     1.   问题在于不应该出现$p_j=p_{next[j]}$。理由是：当$p_j\ne s_j$时，下次匹配必然是$p_{next[j]}$跟$s_j$比较
          +   如果$p_j=p_{next[j]}$，那么相当于拿一个和$p_j$相等的字符跟$s_j$比较，这必然导致继续失配，这样的比较毫无意义。
     2.   则如果出现了$p_j=p_{next[j]}$应该如何处理
          +   可以直接将模式串所有相同值的部分的$next$值全部取为其$next$值对应索引的$next$值。
          +   所以需要再次递归，将$next[j]$变为$next[next[j]]$直到两者不相等，令更新后数组为$nextval$。

     



