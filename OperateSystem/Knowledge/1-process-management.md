# 第二章 进程管理

## 导读

### 【考纲内容】

1. 进程与线程
    + 进程与线程的基本概念
    + 进程/线程的状态与转换
    + 线程的实现
        + 内核支持的线程
        + 线程库支持的线程
    + 进程与线程的组织与控制
    + 进程间通信
        + 共享内存
        + 消息传递
        + 管道

2. $ CPU $调度与上下文切换

    + 调度的基本概念
    + 调度的目标

    + 调度的实现
        + 调度器/调度程序
        + 调度的时机与调度方式(抢占式/非抢占式)
        + 闲逛进程
        + 内核级线程与用户级线程调度
    + 典型调度算法
        + 先来先服务调度算法
        + 短作业(短进程、短线程)优先调度算法
        + 时间片轮转调度算法
        + 优先级调度算法
        + 高响应比优先调度算法
        + 多级队列调度算法
        + 多级反馈队列调度算法
    + 上下文及其切换机制

3. 同步与互斥
    + 同步与互斥的基本概念
    + 基本的实现方法
        + 软件方法
        + 硬件方法
    + 锁
    + 信号量
    + 条件变量
    + 经典同步问题
        + 生产者-消费者问题
        + 读者-写者问题
        + 哲学家进餐问题

4. 死锁
    + 死锁的基本概念
    + 死锁预防
    + 死锁避免
    + 死锁检测和解除

### 【知识导图】

### 【复习提示】

进程管理是操作系统的核心,也是每年必考的重点。

其中,进程的概念、进程调度、信号量机制实现同步和互斥、进程死锁等更是重中之重,必须深入掌握。需要注意的是,除选择题外,本章还容易出综合题,其中信号量机制实现同步和互斥、进程调度算法和死锁等都可能命制综合题,如利用信号量进行进程同步就在往年的统考中频繁出现。

## 进程与线程

![image-20230611110201119](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306111102169.png)

### 进程概念

+ 程序指一个指令序列。
+ 进程为了满足操作系统的并发性和共享性。
+ 进程和程序的根本区别在于其动态性。（<span style="color:orange">注意：</span>所以进程不能与程序相等）
+ 系统为每个运行的程序配置一个数据结构，称为**进程控制块PCB**，用来描述进程的各种信息，如程序代码存放位置。
+ $PCB$、程序段、数据段三个部分构成了进程实体（进程映像）
+ 创建进程就是创建$PCB$，销毁进程就是销毁$PCB$，$PCB$是进程存在的唯一标志。
+ 进程映像是静态的，而进程是动态的。
+ 进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。
+ 进程和进程实体（进程映像）的区别(一般可以认为是同一个东西,不过区别还是要记得)
    + **进程是系统进行资源分配和调度的基本单位**
    + 进程实体由$PCB$、程序段、数据段组成,进程是进程实体的运行过程

+ 系统资源这里指处理机、存储器和其他设备服务于某个进程的时间单位。

#### 进程结构

![image-20230611103859745](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306111038787.png)

![image-20230611103717845](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306111037906.png)

+ 程序段（代码段）：包括程序代码，程序运行时使用、产生的运算数据，往往是只读的。
+ 数据段：存放程序运行过程中处理的各种数据。如全局变量、静态变量、宏定义的常量。
+ 进程控制块$(Process\; Control\; Block,PCB)$：操作系统用$PCB$来管理进程，所以$PCB$包含所有管理进程所需的信息。
    + 进程描述信息：
        + 进程标识符$PID$：标识进程。
        + 用户标识符$UID$：标识进程归属的用户，用于共享和保护服务。
    + 进程控制和管理信息：
        + 进程当前状态：进程状态信息，作为处理机发分配调度的依据。
        + 进程优先级：进程抢占处理机的优先级。
        + 代码运行入口地址。
        + 程序外存地址。
        + 进入内存时间。
        + 处理机占用时间。
        + 信号量使用。
    + 资源分配清单：说明有关内存地址空间或虚拟地址空间的状况，打开文件的列标与使用的输入输出设备信息。
        + 代码段指针。
        + 数据段指针。
        + 堆栈段指针。
        + 文件描述符。
        + 键盘。
        + 鼠标。
    + 处理机相关信息：主要处理机中各种寄存器值。
        + 通用寄存器值。
        + 地址寄存器值。
        + 控制寄存器值。
        + 标志寄存器值。
        + 状态字。
+ 堆：用来存放动态分配的变量，如调用`malloc`函数动态地向高地址分配空间。
+ 栈：用来实现函数调用，保存局部变量、函数传递参数，从用户空间的高地址向低地址增长。

#### 进程特征

+ 动态性：是进程最基本的特征，进程是程序的一次执行过程，是动态地产生、变化和消亡的。
+ 并发性：内存中有多个进程实体，各进程可并发执行。
+ 独立性：进程是资源分配、接受调度、能独立运行、独立获得资源、独立接受调度的基本单位。
+ 异步性：各进程按各自独立的、不可预知的速度向前推进。
    + 异步性会导致并发程序执行结果的不确定性, 操作系统要提供“进程同步机制”来解决异步问题

+ 结构性：每个进程都会配置一个$PCB$。结构上看，进程由程序段、数据段、$PCB$组成。

#### 进程组织

当一个系统中存在多个$PCB$时，需要以适当的方式组织$PCB$。

+ 链接方式：
    + 按照进程状态将$PCB$分为多个队列。如执行指针（指针数为最大执行并行数）、就绪队列指针（一般会把优先级高的进程放在队头）、阻塞队列指针（许多操作系统会根据阻塞原因的不同将其分为多个阻塞队列）。
    + 操作系统持有指向各个队列的指针。
    + ![image-20230611112722015](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306111127068.png)
+ 索引方式：
    + 根据进程状态的不同建立索引表。如执行指针、就绪表指针、阻塞表指针。
    + 操作系统持有指向各个索引表的指针。
    + ![image-20230611112756465](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306111127510.png)

#### 进程与程序

执行一条命令或运行一个应用程序时，进程和程序之间形成一对一的关系。进程在执行过程中可以加载执行不同的应用程序，从而形成一对多的关系；以不同的参数或数据多次执行同一个应用程序时，形成多对一的关系；并发地执行不同的应用程序时，形成多对多的关系。

### 进程状态

![image-20230611112836892](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306111128940.png)

#### 基本进程状态

进程$PCB$中，会有一个变量$state$来表示进程的当前状态。

具有三种基本状态和其他两种状态：

+ 运行态：占有$CPU$并已经在$CPU$上运行。
    + 单核$CPU$的情况下，同一时刻只会有一个进程处于运行态，多核$CPU$情况下，可能有多个进程处于运行态

+ 就绪态：已经具备运行条件（除处理机外的一切所需资源），但是由于没有空闲$CPU$，导致暂时不能运行。
+ 阻塞态（等待态）：因等待某一事件而暂时不能运行，只有分配其他资源到位才能考虑分配$CPU$。
    + 进程映像还在**内存**

+ 创建态（新建态）：为进程分配所需的内存空间等系统资源，将转为就绪态。
    + 申请一个空白$PCB$。
    + 向$PCB$填写一些控制和管理进程的信息。
    + 系统为进程分配运行所需资源。
    + 进程转为就绪态。
+ 终止态（结束态）：进程运行结束或出现错误导致进程被撤销，操作系统需要回收进程资源，撤销$PCB$等工作，以防止内存泄漏。
    + 一个进程可以执行$exit$系统调用，请求操作系统终止该进程。

+ 挂起态：暂时不能获得服务，进程映像调到**外存**等待（对应进程的$PCB$还在内存中等待并允许被修改）。分为：
    + 就绪挂起态：准备好后在外存中，只要允许可以随时进入内存。
    + 阻塞挂起态：等待事件在外存中，必须等待一定时间发生。

#### 进程状态转换

![image-20230611112454100](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306111124163.png)

![image-20230612112344417](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306121123469.png)

+ 创建态到就绪态：系统完成创建进程等工作并准备好处理机等资源。
+ 就绪态到运行态：占有$CPU$资源，进程被调用。
+ 运行态到就绪态：时间片到或处理机（包含$CPU$和内存的一系列硬件）被抢占。
+ 运行态到阻塞态：进程主动用系统调用的方式申请某种系统资源（由用户态程序调用操作系统内核），或请求等待某个事件发生。
+ 阻塞态到就绪态：申请的资源被分配或等待的事件发生，是被动发生。
+ 运行态到终止态：进程运行结束或运行过程中遇到不可修复的错误。
+ 就绪挂起态到就绪态：激活。
+ 就绪态到就绪挂起态：挂起。
+ 阻塞挂起态到阻塞态：激活。
+ 阻塞态到阻塞挂起态：挂起。
+ 阻塞挂起态到就绪挂起态：阻塞事件发生。
+ 运行态到就绪挂起态：运行中内存空间不足，或优先级更高的进程进入队列。
+ 创建态到就绪挂起态：创建后发现内存空间不足。

### 进程控制

#### 进程控制概念

+ 进程控制主要功能是对系统中的所有进程实施有效的管理，具有创建新进程、撤销已有进程、实现进程状态转换功能。
+ 如进程组织所说，通过将$PCB$指针放入各种状态的进程队列中转换进程状态来实现控制。
+ 进程控制由**原语**实现。
    + 特点是执行期间不能中断。
    + 这种不能中断的操作就是原子操作。
    + 原语采取“关中断指令”（屏蔽外部中断信息）和“开中断指令”（开始监听外部中断信息）实现。
    + 关/开中断指令的权限很大，所以必然是核心态下执行的特权指令。从而原语必然运行在核心态。

#### 父子进程

允许一个进程创建另一个进程。此时创建者称为父进程，被创建的进程称为子进程。子进程可以继承父进程所拥有的资源。当子进程被撤销时，应将其从父进程那里获得的资源归还给父进程。此外，在撤销父进程时，必须同时撤销其所有的子进程。

父进程创建子进程后，父进程与子进程同时执行（并发）。主程序调用子程序后，主程序暂停在调用点，子程序开始执行，直到子程序返回，主程序才开始执行。

父进程和子进程可以共享一部分资源，但是不能共享虚拟地址空间，因为这是逻辑地址。且其有不同的$PCB$用于区分进程。

#### 进程控制原语

前四种是必要的。

+ 过程创建：
    + 创建原语：
        + 分配一个唯一的进程标识号$PID$，**申请空白$PCB$**，若申请失败，则创建失败。
        + 为新进程**分配所需资源**，若资源不足，则进入阻塞态。
        + **初始化$PCB$**，主要包括标志信息、处理机状态信息、处理机控制信息、进程优先级。
        + 将$PCB$**插入就绪队列**。
            + 创建态$\to$就绪态
    + 引起进程创建的事件：
        + 用户登录：分时系统中，用户登录成功，系统会为其建立一个新进程。
        + 作业调度：多道批处理系统中，有新的作业进入内存时，会为其创建一个新进程。
        + 提供服务：用户向系统提出请求时，会创建一个新进程来处理请求。
        + 应用请求：由用户进程主动请求创建一个子进程。
+ 进程终止：
    + 撤销原语(就绪态/阻塞态/运行态$\to$终止态)：
        + 根据被终止进程的标识符，从$PCB$集合中找到终止进程的$PCB$，读取进程的状态。
        + 若进程正在运行，则立刻剥夺其$CPU$交给其他进程。
        + 若是普通的终止，父进程终止时会将其子进程交给$init$进程收养。
        + 若是整个进程组的进程，则终止其所有子进程。
        + 将进程所有的资源交给父进程或操作系统。
        + 从所在队列或链表中删除$PCB$。
    + 引起进程终止的事件：
        + 正常结束：任务完成。
            + 进程自己请求终止($exit$系统调用)
        + 异常结束：内部异常，如存储区越界、保护错、运行超时等。
            + 例如整数除以$0$、非法使用特权指令，
        + 外界干预：外部请求而终止运行，如操作员或操作系统干预、父进程请求、父进程终止。
+ 进程阻塞：
    + 阻塞原语(运行态$\to$阻塞态)：
        + 找到要阻塞的进程对应的$PCB$。
        + 保护进程运行现场，将$PCB$状态信息设置为阻塞态，暂停进程。
        + 将$PCB$插入事件等待队列，将处理机资源调度给其他就绪态进程。
    + 引起进程阻塞的事件：
        + 需要等待系统分配资源。
        + 需要等待相互合作的其他进程完成工作。
+ 进程唤醒：
    + 唤醒原语(阻塞态$\to$运行态)：
        + 在事件等待队列中找到$PCB$。
        + 将$PCB$从等待队列中移除，设置进程为就绪态。
        + 将$PCB$插入就绪队列，等待被调度。
    + 引起进程唤醒的事件：
        + 等待的事件的发生（因什么事件被阻塞就应该被什么事件唤醒）。
        + 所以进程阻塞和进程唤醒应该是成对出现的
+ 进程切换：
    + 切换原语：
        + 将处理机上下文信息，包括程序计数器$PC$和其他寄存器信息存入$PCB$。
        + $PCB$移入相应队列。
        + 选择另一个进程执行，并更新其$PCB$。
        + 更新内存管理的数据结构。
        + 根据$PCB$恢复新进程所需的运行环境。
    + 引起进程切换的事件：
        + 当前时间片到。
        + 有更高优先级进程到达。
        + 当前进程主动阻塞。
        + 当前进程终止。

### 进程通信

进程通信是两个进程之间的数据交互。

为了保证安全，一个进程不能直接访问另一个进程的地址空间，但是又必须有进程通信。$PV$操作是低级通信方式，高级通信方式有：

+ 共享存储：分配一个可以共同使用的共享空间，进程对其的使用必须是互斥的（使用同步互斥工具如$PV$操作）。
    + 基于数据结构：共享空闲只能放固定的数据结构如数组等。速度慢，限制多，是低级通信方式。
    + 基于存储：内存中划出一块共享存储区，数据的形式、存放位置都由进程控制而非操作系统。速度更快，限制少，是高级通信方式。
    + ![image-20230611123227178](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306111232224.png)
+ 信息传递：进程间的数据交换以格式化的消息为单位。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。
    + 消息包括消息头和消息体，消息头包括：发送进程$ID$、接受进程$ID$、消息类型、消息长度等格式化的信息。
    + 消息传递包括：
        + 直接通信方式：消息直接挂到接受进程的信息缓冲队列上。
        + 间接通信方式：消息先发送到中间实体（信箱）中，因此也称为信箱通信方式，如计算机网络中的电子邮件系统。
    + ![image-20230611123849695](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306111238747.png)
+ 管道通信：是消息传递的特殊方式，指用于链接各自一个的读写进程的一个共享文件，又名$pipe$文件，其实就是内存中开辟一个大小**固定**的缓冲区。  
    + 只能使用半双工的通信，**同一时间段**内只能**单向**传输(但传输结束释放空间后可以进行方向相反的传输)，若要**双向同时**通信则必须设置两个管道。
    + 两个进程使用生产者-消费者的方式进行通信
    + 进程需要互斥访问管道，需要满足互斥、同步、确定对方存在。
    + 数据以字符流的形式写入管道，当满时，写进程的$write()$系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的$read()$系统调用将被阻塞。
    + 如果没有**写满**则不允许读，如果没有**读空**则不允许写。所以读写都可能被堵塞。
    + 管道中的数据一旦被读出，就彻底消失。因此，当多个进程读同一个管道时，可能会错乱。对此，通常有两种解决方案
        1. 一个管道允许多个写进程一个读进程($2014$年$408$真题高教社官方答案)
            + 以这个说法为主
        2. 允许有多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据($Linux$的方案)。
            + 但这个说法也没错
+ 共享文件（文件系统）：利用操作系统提供的文件共享功能实现进程之间的通信。
+ 信号量：也需要信号量来解决文件共享操作中的同步和互斥问题。

由于不同进程拥有不同代码段和数据段，全局变量是针对同一个进程而言，所以全局变量不能用来交换数据。

### 线程

#### 线程概念

传统而看，进程是程序的一次执行，但是程序的多个功能不能由一个程序顺序处理就能完成，所以一个进程需要同时进行多个任务，所以就引入了线程来增加并发度。

由线程$ID$、程序计数器$PC$、寄存器集合和堆栈组成。

线程是$CPU$**执行**的基本单元，是程序执行流的最小单位，是处理机的分配单元。进程只作为除$CPU$之外的系统资源的分配单元，即打印机等都是分配给线程而不是进程。

#### 线程与进程

+ 系统分配调度：
    + 传统进程机制中，进程是资源分配、调度的基本单位。
    + 引入线程后，进程是**资源分配**的基本单位，线程是**调度**的基本单位。
    + 同一进程中，线程切换不会导致进程切换，在不同进程进行线程切换才会引起进程切换。
+ 拥有资源：
    + 进程都是拥有资源的基本单位，线程除了必备的资源不拥有系统资源。
    + 线程可以拥有同进程的所有资源。
    + 同进程的所有线程共享进程地址空间。
+ 并发性：
    + 传统进程机制中，只能进程间并发。
    + 引入线程后，各线程间也能并发，提升了并发度。
+ 系统开销：
    + 传统的进程间并发，需要切换进程的运行环境，系统开销很大。
    + 线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小。
    + 引入线程后，并发所带来的系统开销减小。
    + 同一进程多个线程共享进程地址空间，所以线程同步通信非常容易。
+ 地址空间和其他资源：
    + 进程间不可见，同一进程的线程间可见。
+ 通信：
    + 进程间通信$IPC$需要进程同步和互斥来保证一致性。
    + 线程间可以直接读写进程数据段如全局变量完成。

#### 线程属性

+ 线程是处理机调度的单位。
+ 多$CPU$计算机中，各个线程可占用不同的$CPU$。
+ 每个线程都有一个线程$ID$、线程控制块$TCB$（记录线程执行的寄存器和栈等现场状态）。
+ 线程也有就绪、阻塞、运行三种基本状态。
+ 线程几乎不拥有系统资源。
+ 同一进程的不同线程间共享进程的资源。
+ 由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预。
+ 没有独立地址空间。
+ 同一进程中的线程切换，不会引起进程切换。
+ 不同进程中的线程切换，会引起进程切换。
+ 切换同进程内的线程，系统开销很小。
+ 切换进程，系统开销较大。
+ 只有执行、就绪、阻塞三种状态。

#### 线程实现

![image-20230612105036603](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306121050661.png)

线程库（$thread\,library$）是为程序员提供创建和管理线程的$API$。线程库中的线程都是单例模式，所以不同的进程使用线程库中的同名线程都是同一个线程。实现线程库主要的方法有如下两种：

1. 在用户空间中提供一个没有内核支持的库。这种库的所有代码和数据结构都位于用户空间中。这意味着，调用库内的一个函数只导致用户空间中的一个本地函数的调用。
2. 实现由操作系统直接支持的内核级的一个库。对于这种情况，库内的代码和数据结构位于内核空间。调用库中的一个$API$函数通常会导致对内核的系统调用。

用户级线程$(User-Level\;Thread,ULT)$：

![image-20230612104426282](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306121044334.png)

+ 用户级线程由应用程序通过线程库实现。所有的线程管理工作都由应用程序负责（包括线程切换）。
+ 用户级线程中，线程切 换可以在用户态下即可完成，无需操作系统干预。
+ 在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。用户级线程对用户不透明，对操作系统透明。
+ 所以操作系统无法操作用户级线程，就不会给用户级线程分配$TLB$。
    <!-- + 操作系统无法进行线程调度，只能进行进程调度。 -->

优点：

+ 线程切换不需要转换到内核空间，节省了模式切换的开销。
+ 调度算法可以是进程专用的，不同的进程可根据自身的需要，对自己的线程选择不同的调度算法。
+ 用户级线程的实现与操作系统平台无关，对线程管理的代码是属于用户程序的一部分。

缺点：

+ 系统调用的阻塞问题，当线程执行一个系统调用时，不仅该线程被阻塞，而且进程内的所有线程都被阻塞。
+ 不能发挥多处理机的优势，内核每次分配给一个进程的仅有一个$CPU$，因此进程中仅有一个线程能执行。

内核级线程（内核支持的线程）$KLT$：

![image-20230612104409533](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306121044601.png)

+ 内核级线程的管理工作由操作系统内核完成。
+ 线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。
+ 内核级线程就是从操作系统内核视角看能看到的线程。
    <!-- + 由于操作系统只能看见内核级线程，所以只有内核级线程才是处理机分配的单位，此时操作系统才能进行线程调度。 -->

优点：

+ 能发挥多处理机的优势，内核能同时调度同一进程中的多个线程并行执行。
+ 如果进程中的一个线程被阻塞，内核可以调度该进程中的其他线程占用处理机，也可运行其他进程中的线程。
+ 内核支持线程具有很小的数据结构和堆栈，线程切换比较快、开销小。
+ 内核本身也可采用多线程技术，可以提高系统的执行速度和效率。

缺点：

+ 同一进程中的线程切换，需要从用户态转到核心态进行，系统开销较大。这是因为用户进程的线程在用户态运行，而线程调度和管理是在内核实现的。

组合方式：

+ 有些系统使用组合方式的多线程实现。
+ 在组合实现方式中，内核支持多个内核级线程的建立、调度和管理，同时允许用户程序建立、调度和管理用户级线程。
+ 一些内核级线程对应多个用户级线程，这是用户级线程通过时分多路复用内核级线程实现的。
+ 同一进程中的多个线程可以同时在多处理机上并行执行，且在阻塞一个线程时不需要将整个进程阻塞。

#### 多线程模型

组合方式同时支持用户线程和内核线程，对于用户级线程如何映射到内核级线程的问题出现了“多线程模型”问题。

+ 多对一模型：
    + 多个用户级线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。多个用户级线程共用一个线程控制块。
    + 优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高。
    + 缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。
    + ![image-20230612104659344](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306121046397.png)
+ 一对一模型：
    + 一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。操作系统给每个用户线程建立一个线程控制块。
    + 优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。
    + 缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。
    + ![image-20230612104727535](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306121047591.png)
+ 多对多模型：
    + 在同时支持用户级线程和内核级线程的系统中，可以使用二者结合的方式，将$n$个用户级线程映射到$m$个内核级线程上（$n\geqslant m$）。
    + 克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。
    + ![image-20230612104849035](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306121048088.png)

### 线程的状态与转换

与进程的状态与转换类似

![image-20230612105147478](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306121051531.png)

#### TCB

线程控制块$TCB$是与进程的控制块$PCB$相似的子控制块，只是$TCB$中所保存的线程状态比$PCB$中保存少而已：

+ 线程标识符。
+ 寄存器。
+ 运行状态。
+ 优先级。
+ 专有存储区。
+ 堆栈指针。

![image-20230612105438770](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306121054816.png)

实际上只有内核级线程才有$TCB$。

#### 线程表

![image-20230612110559956](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306121105999.png)

## 处理机调度

### 处理机调度的概念

+ 处理机：包括中央处理器，主存储器，输入输出接口，加接外围设备就构成完整的计算机系统。处理机是处理计算机系统中存储程序和数据，并按照程序规定的步骤执行指令的部件。
+ 处理机调度：在多道程序设计系统中，内存中有多道程序运行，他们相互争夺处理机这一重要的资源。处理机调度就是从就绪队列中，按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程并发地执行。

### 处理机调度的层次

|        &nbsp;        |                           工作内容                           |       发生位置        |         发生频率         |         对进程状态的影响         |
| :------------------: | :----------------------------------------------------------: | :-------------------: | :----------------------: | :------------------------------: |
| 高级调度（作业调度） | 按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程 | 外存→内存（面向作业） | 一个作业一个调入一次调出 |         无→创建态→就绪态         |
| 中级调度（内存调度） |   按照某种规则，从挂起队列中选择合适的进程将其数据调回内存   | 外存→内存（面向进程） |           中等           | 挂起态→就绪态（阻塞挂起→阻塞态） |
| 低级调度(进程调度）  |     按照某种规则，从就绪队列中选择一个进程为其分配处理机     |      内存→$CPU$       |           最高           |          就绪态→运行态           |

#### 高级调度

即作业调度：

+ 由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业从外存调入内存的顺序。一般一个作业包含多个进程。
+ 高级调度按一定的原则从外存上处于后备队列的作业中挑选一个(或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立$PCB$），以使它（们）获得竞争处理机的权利。
+ 高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的$PCB$，作业调出时才撤销$PCB$。
+ 多道批处理系统多具备，其他系统一般不需要。
+ 高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。
+ 调动执行频率低。

#### 中级调度

即内存调度：

+ 引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。
+ 目的是为了提高内存利用率和系统吞吐量。
+ 暂时调到外存等待的进程状态为挂起状态。值得注意的是，$PCB$并不会一起调到外存，而是会常驻内存。$PCB$中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的$PCB$来保持对各个进程的监控、管理。被挂起的进程$PCB$会被放到内存里的挂起队列中，当条件具备转为就绪态。
+ 中级调度就是要决定将哪个处于挂起状态的进程重新调入内存。
+ 一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。

#### 低级调度

即进程调度：

+ 其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。
+ 进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。
+ 进程调度的频率很高，一般几十毫秒一次。

### 进程调度的目标(评价指标)

#### 算法评价指标

+ $CPU$利用率：$CPU$忙碌时间占总时间的比例。其中利用率=$CPU$忙碌（运行）时间÷进程运行总时间。
+ 系统吞吐量：单位时间内完成作业的数量。系统吞吐量=总共完成多少道作业÷总时间。
+ 周转时间：从作业被提交到系统开始到作业完成为止的时间间隔。
    + 它包括四个部分：作业在外存后备队列上等待作业调度（高级调度）的时间、进程在就绪队列上等待进程调度（低级调度）的时间、进程在$CPU$上执行的时间、进程等待$I/O$操作完成的时间。后三项在一个作业的整个处理过程中，可能发生多次。
    + （作业）周转时间=作业完成时间-作业提交时间。
    + 平均周转时间=各作业周转时间之和÷作业数。
    + 带权周转时间=作业周转时间÷作业实际运行的时间=(作业完成时间-作业提交时间)÷作业实际运行的时间（$\geqslant1$）。是一个比值，越靠近$1$越合理。
    + 平均带权周转时间=各作业带权周转时间之和÷作业数。
+ 等待时间：指进程或作业处于等待处理机状态时间之和。
    + 对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待$I/O$完成的期间其实进程也是在被服务的，所以不计入等待时间。
    + 对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。
    + 一个作业总共需要被$CPU$服务多久，被$I/O$设备服务多久一般是确定不变的，因此调度算法其实只会影响作业或进程的等待时间。当然，与前面指标类似，也有“平均等待时间”来评价整体性能。
    + 如果一个进程到达后要么等待要么运行，则等待时间=周转时间-运行时间。
    + 如果一个进程又有计算又有$I/O$操作，则等待时间=周转时间-运行时间-$I/O$操作时间。
+ 响应时间：从用户提交请求到首次产生响应所用的时间。主要用于交互式系统。

### 进程调度

进程调度是最低级的调度也是其他调度的基础，是内核程序。

#### 调度程序

即调度器，用于调度和分派$CPU$的组件。

+ 排队器。
+ 分派器。
+ 上下文切换器。

#### 进程调度的时机

需要进行进程调度和切换：

+ 当前运行程序主动放弃处理机（非剥夺调度）：
    + 进程正常终止。
    + 出现异常终止。
    + 进程主动请求阻塞（如等待$I/O$）。
+ 当前运行程序被动放弃处理机（剥夺式调度）：
    + 分配时间片用完。
    + 有更紧急的事件需要处理（如$I/O$中断）。
    + 优先级更高进程进入就绪队列。
    + 中断处理结束。
    + 自陷处理结束。

不能进行进程调度和切换：

+ 在处理中断的过程中。中断处理过程复杂，很难做到在中断处理过程中进行进程切换；与硬件密切相关，不属于某一进程。
+ 进程在操作系统**内核程序临界区**中。
    + 临界资源：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。
    + 临界区：访问临界资源的那段代码。
    + 内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的$PCB$组成）。
    + 进程访问时会上锁，而如果还没退出临界区（还没解锁）就进行进程调度但是进程调度相关的程序也需要访问就绪队列，但此时就绪队列被锁住了，因此无法顺利进行进程调度。
    + 内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此在访问内核程序临界区期间不能进行调度与切换。
    + 而如果是普通程序临界区时，如在打印机打印完成之前，进程一直处于临界区内，临界资源不会解锁。但打印机又是慢速设备，此时如果一直不允许进程调度的话就会导致$CPU$一直空闲，所以为了保证效率进程在操作系统普通程序临界区时运行进程调度。
+ 在原子操作过程中（原语）。原子操作不可中断，更不能切换进程，要一气呵成（如修改$PCB$中进程状态标志，并把$PCB$放到相应队列）。

进程切换往往在调度完成后立刻发生，它要求保存原进程当前切换点的现场信息，恢复被调度进程的现场信息。

现场切换时，操作系统内核将原进程的现场信息推入当前进程的内核堆栈来保存它们，并更新堆栈指针。

内核完成从新进程的内核栈中装入新进程的现场信息、更新当前运行进程空间指针、重设$PC$寄存器等相关工作之后，开始运行新的进程。

#### 进程调度的方式

针对操作系统是否可以剥夺进程处理机，进程调度方式分为：

+ 非剥夺调度方式，又称非抢占方式：
    + 只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。
    + 实现简单，系统开销小但是无法及时处理紧急任务。
    + 适合于早期的批处理系统。
+ 剥夺调度方式，又称抢占方式：
    + 当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。
    + 可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。
    + 适合于分时操作系统、实时操作系统。

#### 闲逛进程

在进程切换时，如果系统中没有就绪进程，就会调度闲逛进程（$idle$）运行，如果没有其他进程就绪，该进程就一直运行，并在执行过程中测试中断。闲逛进程的优先级最低，没有就绪进程时才会运行闲逛进程，只要有进程就绪，就会立即让出处理机。

闲逛进程不需要$CPU$之外的资源，它不会被阻塞。

#### 线程调度

+ 用户级线程调度：
    + 由于内核并不知道线程的存在，所以内核还是和以前一样，选择一个进程，并给予时间控制。
    + 由进程中的调度程序决定哪个线程运行。
    + 用户级线程的线程切换在同一进程中进行，仅需少量的机器指令。
+ 内核级线程调度：
    + 内核选择一个特定线程运行，通常不用考虑该线程属于哪个进程。
    + 对被选择的线程赋予一个时间片，如果超过了时间片，就会强制挂起该线程。
    + 内核级线程的线程切换需要完整的上下文切换、修改内存映像、使高速缓存失效，这就导致了若干数量级的延迟。
