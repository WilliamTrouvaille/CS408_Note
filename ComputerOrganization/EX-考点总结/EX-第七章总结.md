# EX-第七章 输入输出$(I/O)$系统总结

## 导读

### 【考纲内容】

1. $I/O$接口（$I/O$控制器）
    + $I/O$接口的功能和基本结构
    + $  I/O$端口及其编址

2. $I/O$方式
    + 程序查询方式
    + 程序中断方式：中断的基本概念、中断响应过程、中断处理过程、多重中断和中断屏蔽的概念
    + $DMA $方式：$DMA $控制器的组成、$DMA $传送过程

### 【复习提示】

$I/O$方式是本章的重点和难点，每年不仅会以选择题的形式考查基本概念和原理，而且可能会以综合题的形式考查，特别是**各种$I/O$方式效率的相关计算，中断方式的各种原理、特点、处理过程、中其屏蔽，$DMA $方式的特点、传输过程、与中断方式的区别**等。

选择题：基本概念和原理，各种$I/O$方式效率的相关计算，中断方式的各种原理、特点、处理过程、中其屏蔽，$DMA $方式的特点、传输过程、与中断方式的区别

综合题：各种$I/O$方式的相关计算

## 选择题考点总结

### $I/O$概述

1.   *外部设备，了解刷新存储器$VRAM$：为了不断提高刷新图像的信号，必须把一帧图像信息存储在刷新存储器中。$VRAM$容量$=$分辨率$\times$灰度级位数。$VRAM$带宽$=$分辨率$\times$灰度级位数$\times$帧频，即显存带宽，单位为$MB/s$。

### $I/O$接口（$I/O$控制器）

$I/O$接口（$I/O$控制器）：主机和外设之间的交接界面，通过接口可以实现主机和外设之间的信息交换。

1.   主要功能
     1.   进行地址译码和设备选择：$CPU$送来选择外设的地址码后，对地址进行译码以使主机能和指定外设交换信息。
     2.   实现主机和外设的通信联络控制：解决主机与外设时序配合问题，协调不同工作速度的外设和主机之间交换信息，以保证整个计算机系统能统一、协调地工作。
     3.   实现数据缓冲：为消除$CPU$与外设之间的速度差异，设置数据缓冲寄存器用于数据的暂存，以避免因速度不一致而丢失数据。
     4.   **信号/数据**格式的转换：提供计算机与外设的信号格式的转换功能。如电平转换、并/串或串/并转换、模/数或数/模转换等。
     5.   传送控制命令和状态信息：$CPU$要启动某一外设时，通过接口中的**命令寄存器**向外设发出启动命令。外设准备就绪时，则将内容为`准备好`的状态信息送回接口中的状态寄存器，并反馈给$CPU$外设向$CPU$提出中断请求时，$CPU$也应有相应的响应信号反馈给外设。**包括$I/O$操作的定时**。
2.   常见**$I/O$接口**：打印机适配器，网络控制器，可编程中断控制器
3.   基本结构
     1.   主机侧（内部接口）：通过$I/O$总线与内存、$CPU$相连。状态寄存器和控制寄存器在传送方向上是相反的。 对数据缓冲寄存器、状态/控制寄存器的访问操作是通过相应的指令来完成的，通常称这类指令为$I/O$指令，$I/O$指令只能在操作系统内核的底层$I/O$软件中使用，它们**是一种特权指令**。（**有关$I/O$的都是特权指令**）
          1.   数据缓冲寄存器：通过**数据线**交换数据。
          2.   状态/控制寄存器：通过**数据线**交换接口和设备的状态信息、$CPU$​对外设的控制命令。一般将其送到$I/O$接口的控制寄存器。
          3.   地址译码和$I/O$控制逻辑：通过**地址线**传输要访问的$I/O$​接口中的寄存器的地址和读/写控制信号，通过**控制线**传送来的读/写信号确认是读寄存器还是写寄存器， 此外**控制线**还会传送一些仲裁信号和握手信号。还要能对控制寄存器中的命令字进行译码，并将译码得到的控制信号通过外设界面控制逻辑送到外设，同时将数据缓冲寄存器的数据发送到外设或从外设接收数据到数据缓冲寄存器。另外，它还要具有收集外设状态到状态寄存器的功能
     2.   设备侧（外部接口）：外部接通过接口电缆与外设相连，外部接口的数据传输可能是串行方式，因此$I/O$接口需具有串/并转换功能。

![image-20231031191935672](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202310311919749.png)

3.   $I/O$接口类型

     1.   按数据传送方式：并行接口（一个字节或一个字所有位同时传送）、串行接口（一位一位地传送）、
     2.   按主机访问$I/O$设备的控制方式：程序查询接口、中断接口、$DMA$接口。
     3.   按功能选择的灵活性：可编程接口、不可编程接口。

4.   $I/O$端口与$I/O$地址：$I/O$端口要想能够被$CPU$​访间，必须要有端口地址，每一个端口都对应着一个端口地址。数据端口可读可写，控制端口只写，状态端口只读。

     1.   统一编址/存储器映射方式：把$I/O$端口当做存储器的单元进行地址分配，在内存中$I/O$设备和内存是**连续**的，用统一的访存指令就可以访问$I/O$端口。靠不同的**地址码**区分内存$I/O$设备。

          优点：不需要专门的输入/输出指令；使端口有较大的编址空间。

          缺点：端口占用了主存地址空间，使内存容量变小；利用存储器编址的$I/O$设备进行数据输入/输出操作，执行速度较慢。

     2.   独立编址/$I/O$映射方式：与存储器地址无关，独立编址$CPU$需要设置专门的$I/O$指令访问端口。靠不同的指令来区分。只有独立编址才有$I/O$空间的概念。需要设置专门的$I/O$指令来访问$I/O$端口。

          优点：使用专门的$I/O$指令；$I/O$端口地址位数少，地址译码快；$I/O$端口的地址不占用主存地址空间。

          缺点：$I/O$指令少，程序灵活性差；需要分别为$CPU$和$I/O$设备提供存储器读/写两组控制信号，增加了控制的复杂性。

### ※※※异常和中断

#### 异常和中断概述

本部分集中了$OS$第一章的中断，$CO$第五章和第七章的中断。

当你看到这行字时请默念三遍：**缺页中断不是中断**。

1.   **异常/内中断/例外/陷入**：信号来自$CPU$​内部，与当前执行的命令有关，必须立刻处理，且对于无法恢复故障的需要终止进程。**无法被屏蔽**。
     1.   异常由指令在执行中产生，而中断不与指令相关，也不阻止指令的完成。
     2.   异常的**检测由$CPU$完成**，不需要外部信号通知。而中断必须$CPU$通过总线获取中断源标记信息才能知道中断的类型。
2.   **中断/外中断**：来自$CPU$外部的设备向$CPU$发出的中断请求，通常用于信息的输入和输出，与当前执行的命令无关。

     1.   包括$I/O$设备发出的$I/O$中断（如键盘输入、打印机缺纸等），或发生某种特殊事件（如用户按$Esc$键、**定时器计数时间到（时钟中断属于中断）**）等。
     2.   外部$I/O$设备通过特定的中断请求信号线向$CPU$提出中断请求，**$CPU$每执行完一条指令就检查中断请求信号线**，如果检测到中断请求，则进入中断响应周期。
3.   中断和异常的区别：在本质上是一样的，但它们之间有以下两个重要的不同点

     1.   “缺页”或“溢出”等**异常**事件是**执行特定指令的过程**中产生的；而**中断不和任何指令相关联**，也不阻止任何指令的完成。
     2.   异常的检测由$CPU$自身完成，不必通过外部的某个信号通知$CPU$；而对于中断，$CPU$必须通过通过总线（中断请求线）获取**中断源标记信息**，才能知道哪个设备发生了何种中断。
4.   **异常**的分类：异常是由$CPU$**内部**产生的意外事件，分为**硬故障中断**和**程序性异常**。

     1.   硬故障中断是由硬连线出现异常引起的，如存储器校验错、总线错误等。
     2.   程序性异常也称软件中断，是指在$CPU$内部因执行指令而引起的异常事件。如**整除$0$**、**溢出**、断点、单步跟踪、非法指令、栈溢出、地址越界、**※※缺页（缺页中断是异常）**等。
5.   **异常**按发生原因和返回方式分类：故障$Fault$、自陷$Trap$和终止$Abort$。
     1.   故障$Fault$：属于程序性异常/软件中断。
          1.   断点为当前发生故障的指令：“**缺段**”“**缺页**”等异常事件。经处理后，可将所需的段或页面从磁盘调入主存，**回到发生故障的指令继续执行**。
          2.   必须终止进程的执行：“**非法操作码**”“**除数为$0$**”。无法通过异常处理程序恢复故障，不能回到原断点执行。
     2.   自陷$Trap$：属于程序性异常/软件中断。也称陷阱或陷入。是预先安排的一种“异常”事件。根据不同“陷阱”类型进行相应的处理，之后**返回到自陷指令的下一条指令**继续执行。
          1.   当自陷指令是**转移指令**时， 并不是返回到下一条指令执行，而是**返回到转移目标指令**执行。 
          2.   在$x86$机器中，用于程序调试“断点设置”和单步跟踪的功能就是通过自陷机制实现的。
          3.   系统调用指令、条件自陷指令等都属于自陷指令， 执行到这些指令时，无条件或有条件地自动调出操作系统**内核程序**进行执行。 
     3.   终止$Abort$：和外中断都属于硬件中断。如果在执行指令的过程中发生了使计算机无法继续执行的硬件故障，如控制器出错、**存储器校验错**等，那么程序将无法继续执行，只能终止，并**调出中断服务程序重启系统**。这种异常与故障和自陷不同，不是由特定指令产生的，而是随机发生的。 
6.   中断的分类：分为可屏蔽中断和不可屏蔽中断。

     1.   可屏蔽中断：指通过可屏蔽中断请求线$INTR$向$CPU$发出的中断请求。$CPU$可以通过在**中断控制器**中设置相应的**屏蔽字**来屏蔽它或不屏蔽它，被屏蔽的中断请求将不被送到$CPU$。
     2.   不可屏蔽中断：指通过专门的不可屏蔽中断请求线$NMI$向$CPU$发出的中断请求，通常是非常紧急的硬件故障，如电源掉电等。这类中断请求信号不可被屏蔽，以让$CPU$快速处理这类紧急事件。 
7.   ※※常见中断事件：
     1.   浮点数上溢，表示超过了浮点数的表示范围，属于**内中断**；浮点数运算下溢，直接当作机器零处理，而不会引发中断。
     2.   需要请求操作系统服务（例如需要进行$I/O$操作时）以及使用系统调用时时会引起**访管中断**，属于内中断。
     3.   $I/O$操作完成时：属于外设请求，是外中断。
     4.   定时器/时间片到时：时钟中断，属于外中断。
     5.   网络数据包到达：是$CPU$执行指令以外的事件，属于外中断。
     6.   $DMA$请求：属于外中断。指$DMA$开始传数据前申请总线传数据，优先级仅次于非屏蔽中断且高于$CPU$当前干的所有事情，**不及时处理就会丢失数据**。
     7.   $DMA$中断：属于外中断的可屏蔽中断。指$DMA$传送数据完毕后报告，优先度较低。
8.   多重中断技术：又称中断嵌套，执行中断服务程序时可响应新的中断请求。一般使用**中断屏蔽技术**实现。中断屏蔽技术又通过屏蔽触发器和中断屏蔽标志实现。中断屏蔽标志可以改变多个中断服务程序的**执行次序**，但是不能改变开始执行的次序，因为中断请求响应顺序由排队器控制。屏蔽字设置规律：
     1.   `1`表示屏蔽该中断源的请求，`0`表示可以正常申请。
     2.   屏蔽字中$1$越多，优先级越高。
     3.   每个屏蔽字中至少有一个$1$，**自己不可以中断自己**。

#### 中断响应和中断处理

1.   ※※中断响应和中断处理基本过程：中断隐指令部分一定关中断，中断处理过程部分可能开中断。

     1.   ※※中断响应过程：中断隐指令，由硬件自动完成。此时不能响应更高级中断源的中断请求。
          1.   关中断。
          2.   保存断点和程序状态字，即保存**程序计数器$PC$**的值和程序状态字寄存器的值。
          3.   识别中断源并引出中断服务程序。
     2.   ※中断处理过程：由**中断服务程序**即软件完成。
          4.   保存现场（即保存**$CPU$主要寄存器**的内容）和中断屏蔽字。
          5.   开中断：允许更高级中断请求得到响应，实现中断嵌套。 
          6.   中断事件处理：执行中断服务程序。如通过程序控制需打印的字符代码送入打印机的缓冲存储器中。此时可能修改各寄存器的值。
          7.   关中断：保证在恢复现场和屏蔽字时不被中断。 
          8.   恢复现场和屏蔽字。即恢复各寄存器的值。
          9.   开中断，中断返回：通过中断返回指令返回源程序，可能是从下一条指令开始执行（自陷指令），可能是回到发生故障的指令继续执行（缺页中断等）。

2.   中断隐指令/中断响应过程：从$CPU$检测到异常或中断事件，到调出相应的处理程序，整个过程称为异常和中断的响应（实际上就是**中断隐指令**）。中断隐指令**不可被打断（关中断了）**。中断隐指令结束后，$CPU$就从$PC$中取出**中断服务程序**并开始执行，直至中断返回。中断隐指令不是指令系统的真实指令，本质是硬件的一系列自动操作，没有操作码。

     1.   关中断：通过设置中断允许触发器$IF$实现。若$IF=1$，则为开中断，表示允许响应中断。反之为关中断。

     2.   保存断点和程序状态：将程序的断点（返回地址）和**程序状态字寄存器**$PSWR$中的内容送到栈或特定寄存器中，一遍返回后继续执行。为了支持异常或中断的嵌套，信息**通常保存在栈中**。

     3.   识别异常和中断并转到相应的处理程序：软件识别和硬件识别。**异常**大多采用**软件识别**方式，而**中断**可以采用软件识别方式或硬件识别方式。 

          1.   软件识别方式：$CPU$设置一个异常状态寄存器，用于记录异常原因。操作系统使用一个统一的异常或中断查询程序，按优先级顺序查询异常状态寄存器，以检测异常和中断类型，先查询到的先被处理，然后转到内核中相应的处理程序。 

          2.  硬件识别方式/向量中断：异常或中断处理程序的首地址称为中断向量，所有中断向量都存放在**中断向量表**中。

              每个异常或中断都被指定一个中断类型号。在中断向量表中，类型号和中断向量一一对应，因而可以根据类型号快速找到对应的处理程序。 

3.   现场信息和断点信息：现场和断点都不能被中断服务程序破坏，即保存时不能响应其他中断请求。

     1.   断点信息：即程序计数器$PC$的值。由$CPU$在中断响应时自动保存到栈或专门寄存器中，由**中断隐指令**保存，**硬件**实现。
     2.   现场信息：即$CPU$主要寄存器（$ACC$，通用寄存器，程序状态字寄存器$PSW$等）的内容。现场信息因为用指令可直接访问（对汇编程序员可见），所以通常在**中断服务程序**中通过指令把它们保存到栈中，即由**软件**实现。

#### 中断请求

1.   中断请求标记：为了记录中断事件并区分不同的中断源，中断系统需对每个中断源设置中断请求标记触发器$INTR$。当状态为“$1$"时，表示中断源有请求。$CPU$响应中断的时间是在**每条指令执行阶段的结束时刻**，不过每个**中断源**向$CPU$发出中断请求的时间是随机的，一台计算机允许有多个中断源。
2.   中断的条件：$CPU$响应中断必须满足以下三个条件
     1.   中断源有中断请求。
     2.   $CPU$允许中断即开中断。
     3.   一条指令执行完毕，且没有更紧迫的任务。
3.   中断响应判优：即多个中断发生时处理顺序的训责。中断响应的判优通常由硬件**排队器**实现。也可用软件实现，使用查询程序实现。排队器既可以设置在$CPU$中，也可以分散在各个中断源中。
4.   中断优先级：
     1. **不可屏蔽中断** $$>$$ 内部**异常** $$>$$ **可屏蔽中断**
         +   内部异常中：硬件故障 $$>$$ 软件中断
     2. $DMA$请求$$>$$$I/O$设备传送的中断请求。
     3. 在$I/O$传送类中断请求中，高速设备$$>$$低速设备，输入设备$$>$$输出设备，实时设备$$>$$普通设备。

### $I/O$方式

#### 程序查询方式

1.   运行过程：$CPU$一旦启动$I/O$，必须停止现行程序的运行，并在现行程序中插入一段程序。$CPU$有“踏步”等待现象，$CPU$与$I/O$串行工作。

     1. $CPU$执行初始化程序，并预置传送参数：设置计数器、设置数据首地址。
     2. 向$I/O$接口发送命令字，启动$I/O$设备。
     3. $CPU$从接口读取设备状态信息。
     4. $CPU$不断查询$I/O$设备状态，直到外设准备就绪。
     5. 状态就绪后传输一次数据，一般为一个字。
     6. 修改地址和计数器参数。
     7. 判断传送是否结束，如果没有结束则转第三步，直到计数器为$0$。
2.   优点：接口设计简单、设备量少。
3.   缺点：$CPU$在信息传送过程中要花费很多时间用于查询和等待。而且在一段时间内只能和一台外设交换信息。效率低。

#### 程序中断方式

1.   程序中断方式：允许$I/O$设备主动打断$CPU$的运行并请求服务。外设为某进程准备数据时，可令该进程阻塞，$CPU$运行其他进程。
     +   ※※※**若准备数据的时间小于中断响应和中断处理时间总和，则数据会被刷新，造成丢失**
2.   完成读写的流程
     1.   由于$I/O$设备速度很慢，因此在$CPU$发出读/写命令后，可将等待$I/O$的进程阻塞，先切换到别的进程执行
          + $CPU\to I/O$
     2.   当$I/O$完成后，控制器会向$CPU$发出一个中断信号，$CPU$检测到中断信号后，会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断
          + $I/O\to CPU$
     3.   处理中断的过程中，$CPU$从$I/O$控制器读一个字的数据传送到$CPU$寄存器，再写入主存
          + $I/O\to CPU$
     4.   接着，$CPU$恢复等待$I/O$的进程（或其他进程）的运行环境，然后继续执行
          + $CPU\to $存储器
3.   $CPU$干预的频率：每次$I/O$操作开始之前、完成之后需要$CPU$介入。等待$I/O$完成的过程中$CPU$可以切换到别的进程执行。
4.   数据传送的单位：每次读/写一个字。
5.   数据的流向：$I/O$设备直接与$ CPU$交换数据，交换的信息一定不可能是主存地址。
     1.   读操作（数据输入）：$I/O$设备$\to CPU$的寄存器$\to$内存。
     2.   写操作（数据输出）：内存$\to CPU$的寄存器$\to I/O$设备。
6.   优点：$CPU$不需要轮询，可与$I/O$设备并行工作，$CPU$利用率得到明显提升。
7.   缺点：由于每个字在$I/O$设备与内存之间的传输，都需要经过$CPU$，导致频繁的中断处理依然会消耗较多的$CPU$时间。

#### $DMA$方式

1.   $DMA$控制器（$DMA$接口）：硬件。直到完成一整块的数据读写才会向$CPU$发送一次中断请求。磁盘控制器中的数据缓冲区每充满一次，$DMA$控制器就需要发出一次总线请求。$DMA$控制器必须具有控制系统总线的能力。
     +   $DMA$总线：主存和$DMA$接口之间的一条直接数据通路，不需要经过$CPU$。
2.   $DMA$方式：通过$DMA$控制器（$DMA$接口）向$CPU$提出$DMA$传送请求，$CPU$响应之后将让出系统总线，由$DMA$控制器接管总线进行数据传送。$DMA$请求的响应可以发生在任意一个机器周期结束时（取指、间址、执行周期后均可）。
     +   在$DMA$传送过程中，$DMA$控制器将接管$CPU$的地址总线、数据总线和控制总线，和对主存的控制权；$CPU$的主存控制信号被禁止使用且没有对主存的控制权。当$DMA$传送结束后，才恢复$CPU$的一切权利并开始执行其操作。
3.   主要流程
     1.   接受外设发出的$DMA$请求，并向$CPU$发出总线请求。
     2.   在每个存储周期（机器周期）后$CPU$检查是否存在$DMA$请求，若有则响应此总线请求，发出总线响应倍号，接管总线控制权，进入$DMA$操作周期。
     3.   确定传送数据的主存单元地址及长度，并能自动修改主存地址计数和传送长度计数。
     4.   规定数据在主存和外设间的传送方向，发出读写等控制信号，执行数据传送操作。
     5.   向$CPU$报告$DMA$操作的结束，发出中断。
4.   数据的流向：主存和$I/O$设备之间交换信息时，不通过$CPU$。
     1.   读操作（数据输入）：$I/O$设备$\to$内存。
     2.   写操作（数据输出）：内存$\to I/O$设备。
5.   冲突解决：当$I/O$设备和$CPU$同时访问主存时，可能发生冲突，为了有效地使用主存，$DMA$控制器与$CPU$通常采用以下三种方法使用主存。
     1.   停止$CPU$访问主存：当$I/O$设备有$DMA$请求时，由$DMA$控制器向$CPU$发送一个停止信号， 使$CPU$脱离总线，停止访问主存，直到$DMA$传送一块数据结束。
     2.   周期挪用（周期窃取）：当$I/O$接口没有$DMA$请求时，$CPU$按程序要求访问内存，一旦$I/O$接口有$DMA$请求，则$I/O$接口挪用一个或几个周期。周期挪用指主存的**存取周期**。
          +   此时$DMA$优先级比$CPU$高：$I/O$不立即访存就可能丢失数据。
     3.   $DMA$和$CPU$交替访存：将一个$CPU$周期分为两个周期，一个给$DMA$使用一个给$CPU$使用。不需要总线使用权的申请、建立和归还过程。适用于$CPU$的工作周期比主存存取周期长的情况。
6.   $DMA$传送过程：$CPU$只在开始和结尾参与控制，$DMA$控制整个传输过程，分为预处理、数据传送和后处理$3$个阶段。
     1.   预处理：初始化$DMA$控制器、（$I/O$设备）发送$DMA$请求、$DMA$控制器向$CPU$发送总线请求。
     2.   数据传送：完全由$DMA$控制。$DMA$的数据传输可以以单字节（或字）为基本单位，也可以以数据块为基本单位。
     3.   后处理：$DMA$控制器向$CPU$发送中断请求，$CPU$执行中断服务程序做$DMA$结束处理
7.   $DMA$方式特点
     1.   $DMA$方式传送数据不需要经过$CPU$，因此不必中断现行程序。
     2.   只有$DMA$方式是靠硬件电路实现的。
     3.   $DMA$方式只能用于数据传输，不具有对异常事件的处理能力。（$DMA$方式不能中断现行程序，而**键鼠等均要求$CPU$立即响应**）
     4.   在数据块传送时，主存地址的确定、传送数据的计数等都由硬件电路（$DMA$控制器）直接实现。
     5.   不用保护和恢复现场。

#### $I/O$方式对比

1.   $DMA$方式与中断控制方式的区别：

     1.   中断控制方式在每个数据传送完成后中断$CPU$，而$DMA$控制方式则在所要求传送的一批数据全部传送结束时中断$CPU$。
     2.   中断控制方式的数据传送在中断处理时由$CPU$控制完成，而$DMA$控制方式则在$DMA$控制器的控制下完成。
          + 不过，在$DMA$控制方式中，**数据传送的方向、存放数据的内存始址及传送数据的长度等信息仍然由$CPU$控制**。
     3.   $DMA$方式传输批量（字节、字、数据块）的数据，中断控制方式的传输则以字节为单位。
     4.   从数据传送来看，中断方式靠程序传送，$DMA$方式靠硬件传送。
     5.   $DMA$方式只能用于数据传输，无法处理异常事件，需要鼠标键盘等时还是采用中断控制方式（或轮询）。
     6.   对中断请求的响应只能发生在每条指令执行结束时（执行周期后），而对$DMA$请求的响应可以发生在任意一个机器周期结束时（取指、间址、执行周期后均可）。
     7.   中断方式是程序的切换，需要保护和恢复现场；而$DMA$方式不中断现行程序，无需保护现场，除了预处理和后处理，其他时候不占用任何$CPU$资源。
2.   下面用一个例子来总结这$4$种$I/O$方式。想象一位客户要去裁缝店做一批衣服的情形

     1.   采用程序控制方式时，裁缝没有客户的联系方式，客户必须每隔一段时间去裁缝店看看裁缝把衣服做好了没有，这就浪费了客户不少的时间。
     2.   采用中断方式时，裁缝有客户的联系方式，每当他完成一件衣服后，给客户打一个电话，让客户去拿，与程序直接控制能省去客户不少麻烦， 但每完成一件衣服就让客户去拿一次，仍然比较浪费客户的时间。
     3.   采用$DMA$方式时，客户花钱雇一位单线秘书，并向秘书交代好把衣服放在哪里（存放仓库），裁缝要联系就直接联系秘书， 秘书负责把衣服取回来并放在合适的位置，每处理完$100$件衣服，秘书就要给客户报告一次（大大节省了客户的时间）。
     4.   采用通道方式时，秘书拥有更高的自主权，与$DMA$方式相比，他可以决定把衣服存放在哪里，而不需要客户操心。而且，何时向客户报告，是处理完$100$件衣服就报告， 还是处理完$10000$件衣服才报告，秘书是可以决定的。客户有可能在多个裁缝那里订了货，一位$DMA$类的秘书只能负责与一位裁缝沟通，但通道类秘书却可以与多名裁缝进行沟通

## 大题总结

![image-20230914204341550](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309142043633.png)

1.   若准备数据的时间小于取走数据的时间，则数据会被刷新，造成丢失
     1.   准备数据的时间：**①缓冲区大小**$\div $ **②I/O速率**=**③最大准备数据时间**，单位每轮的查询时间必须小于等于这个时间，才能来得及把数据取走
          +   若取**④取走数据的时间**=**③最大准备数据时间**，则**⑤每秒的查询次数**最小，**⑤每秒的查询次数**至少为$1\div$**④取走数据的时间**=**②I/O速率**$\div $**①缓冲区大小**
     2.   取走数据的时间：每轮的查询时间
          +   中断$I/O$方式：中断响应和中断处理的总时间
          +   $DMA$：会自己把数据取出
2.   $CPU$用于查询的时间占总时间的最小比例：一秒内$CPU$用于设备$A$输入/输出的所需时钟周期占总时钟周期（即主频）的比率
     +   先算出一次数据传送所用的时钟周期，然后算出每秒的总数据传输次数（即每秒申请的中断次数），相乘得到用于中断的开销时钟周期，除以主频即为所求
3.   $DMA$方式：后处理包含对$DMA$中断的处理。$DMA$⑤每秒的查询次数最多$=$②I/O速率$\div $①缓冲区大小
