# EX-第三章 栈 、队列和数组考点总结

## 导读

### 【考纲内容】

1. 栈和队列的基本概念
2. 栈和队列的顺序存储结构
3. 栈和队列的链式存储结构
4. 多维数组的存储
5. 特殊矩阵的压缩存储
6. 栈、队列和数组的应用 

### 【复习提示】

选择题：栈（出入栈的过程、出栈序列的合法性）和队列的操作及其特征、栈和队列的顺序存储、链式存储及其特点、双端队列的特点、栈和队列的常见应用，以及数组和特殊矩阵的压缩存储

综合题：出入栈的过程、栈的应用和队列的操作及其特征

## 选择题考点总结

### 栈概述

1.   顺序栈：栈顶指针初始化为$-1$，因为索引最小为$0$，注意题上所给栈顶指针：初值为$-1$时，栈顶指针指向当前元素；初值为$0$时，栈顶指针指的是当前元素的下一个位置

     1.   栈空：$S.top=-1$或$S.top=0$
     2.   栈满：$S.top=MaxSize-1$或$S.top=MaxSize$
     3.   栈长：$length=S.top+1$或$length=S.top$
2.   共享栈：栈底不变，让两个顺序栈（分别为0号和1号）共享一个一维数组，将两个栈的栈底设在数组两端，栈顶向共享空间延伸。

     1.   两个栈的栈顶指针都指向栈顶元素，$top0=-1$时$0$号栈为空，$top1=MaxSize$时$1$号栈为空；仅当两个栈顶指针相邻即$top1-top0=1$时，判断为栈满。当$0$号栈进栈时$top0$先加$1$再赋值，$1$号栈进栈时$top1$先减$1$再赋值；出栈时则刚好相反。 
     2.   栈满的条件：$top0+1=top1$。
3.   链栈：链栈的操作与链表类似，入栈和出栈的操作都在链表的表头进行。
4.   括号匹配：最后出现的左括号最先被匹配$LIFO$。思想如下：
     1.   自左至右扫描表达式，若遇左括号，则将左括号入栈
     2.   若遇右括号，则将其与栈顶的左括号进行匹配
          1.   若配对，则栈顶的左括号出栈，否则出现括号不匹配错误
          2.   如果需要匹配但是栈空说明有单独的左或右括号，也匹配失败
          3.   如果结束，栈为空则正常结束，否则不匹配。
5.   递归：最后被调用的函数最先执行结束$LIFO$。可以用栈来让递归算法转换为非递归算法。递归可以将原始问题拆分为属性相同、规模较小的问题。但是**如果太多层会造成栈溢出**。
6.   迷宫问题：以栈$S$记录当前路径，则栈顶中存放的是“当前路径上最后一个位置信息”。若当前位置“可通”，则纳入路径（入栈），继续前进。若当前位置“不可通”，则后退（出栈），换方向继续探索。若四周“均无通路”，则将当前位置从路径中删除出去。
7.   进制转换：在计算机科学中，常见的进制有二进制、八进制、十进制和十六进制。
     1.   初始化一个空栈。
     2.   将要转换的十进制数除以目标进制的基数，将得到的余数压入栈中。
     3.   将得到的商作为新的被除数，继续执行第$ 2 $步直到商为$ 0$。
     4.   从栈顶开始依次弹出元素，即可得到转换后的目标进制数。
8.   卡特兰数：如果有$n$个不同的元素进栈，**合法的**出栈元素不同排列的个数为$\dfrac{1}{n+1}C_{2n}^n$，这就是卡特兰数。
     1.   将进栈表示为` +1`，出栈表示为` -1`，则` 1 3 2` 的出栈序列可以表示为`：+1 -1 +1 +1 -1 -1`。
     2.   根据栈本身的特点，每次出栈的时候，必定之前有元素入栈，即对于每个` -1 `前面都有一个` +1 `相对应。因此，出栈序列的 **所有前缀和** 必然大于等于$ 0$，并且` +1 `的数量 **等于**` -1 `的数量。
     3.   接下来让我们观察一下$ n = 3 $的一种出栈序列：`+1 -1 -1 +1 -1 +1`。序列前三项和小于 $0$，显然这是个非法的序列。
     4.   如果将 **第一个** 前缀和小于$ 0 $的前缀，即前三项元素都进行取反，就会得到：`-1 +1 +1 +1 -1 +1`。此时有 $3 + 1 $个` +1 `以及$ 3 - 1$ 个` -1`。
     5.   因为这个小于$ 0 $的前缀和必然是 `-1`，且` -1` 比` +1 `多一个，取反后，`-1 `比` +1` 少一个，则` +1 `变为$ n + 1 $个，且` -1 `变为` n - 1 `个。进一步推广，对于$ n $个元素的每种非法出栈序列，都会对应一个含有$ n + 1 $个 `+1` 以及$ n - 1$个` -1 `的序列。
     6.   如何证明这两种序列是一一对应的？
     7.   假设非法序列为$ A$，对应的序列为$ B$。每个$ A$ 只有一个"**第一个前缀和小于$ 0 $的前缀**"，所以每个$ A $只能产生一个$ B$。而每个$ B $想要还原到$ A$，就需要找到"**第一个前缀和大于$ 0$ 的前缀**"，显然$ B $也只能产生一个 A。
     8.   每个$ B $都有$ n + 1 $个` +1 `以及$ n - 1 $个` -1`，因此 B 的数量为 $C_{2n}^{n+1}$ ，相当于在长度为$ 2n $的序列中找到$n + 1$个位置存放` +1`。相应的，非法序列的数量也就等于 $C_{2n}^{n+1}$ 。
     9.   共有 $C_{2n}^{n}$ ，因此，合法的出栈序列的数量为 $C_{2n}^{n} - C_{2n}^{n+1} = \dfrac{C_{2n}^n}{n + 1}$ 。
     10.   此时我们就得到了卡特兰数的通项 $\dfrac{1}{n + 1}C_{2n}^n$ 



### 表达式求值

1.   中缀转后缀的手算方法：后缀表达式中运算符从左往右的先后顺序等于中缀表达式中的运算顺序。如$A+B*(C-D)-E/F$就是$ABCD-*+EF/-$和$ABCD-*EF/-+$。
     1.   确定中缀表达式中各个运算符的运算顺序进行排序。
     2.   选择下一个运算符，按照**左操作数 右操作数 运算符**的方式组合一个个新的操作数。
     3.   如果还有运算符没有处理就重复步骤二。
2.   后缀表达式计算的程序实现
     1.   从左往右扫描下一个元素，直到处理所有元素。
     2.   若扫描到操作数则压入栈，并回到$1$，若扫描到运算符则执行$3$。
     3.   扫描到运算符则弹出两个栈顶元素，执行相应操作，运算结果压入栈，回到步骤一。
          +   先出栈的是“右操作数”
          +   其实就是左边的数是左操作数，右边的数是右操作数
     4.   先出栈的是右操作数，后出栈的是左操作数。
3.   后缀表达式转换的程序实现
     1.   初始化一个栈，用于保存暂时不能确定运算顺序的运算符。
     2.   从左到右处理每个元素，可能遇到以下三种情况
          1. 如果遇到操作数，直接加入后缀表达式。
          2. 如果遇到界限符，如果遇到左括号$'('$直接入栈，如果遇到右括号$')'$依次弹出栈内运算符并加入到后缀表达式中，直到遇到新的左括号为止。
              +   左括号$'('$不加入后缀表达式
          3. 遇到运算符，**依次弹出栈中优先级高于或等于当前运算符的所有运算符并加入后缀表达式**，若碰到左括号或栈空停止，之后再将当前运算符入栈。

     3.   处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀运算符。
4.   使用栈进行中缀转后缀的手算方法：从左到右遍历中缀表达式的每个数字和运算符。
     1. 若当前字符是数字，则直接输出成为后缀表达式的一部分。
     2. 若当前字符为运算符，则判断其与栈顶运算符的优先级
         1. 当前运算符优先级**大于**栈顶运算符：若当前运算符$+$、$-$，而栈顶运算符为$\times$、$\div$，则当前运算符$+$、$-$直接进栈。
         2. 当前运算符优先级**小于等于**栈顶运算符：若当前运算符为$\times$、$\div$栈顶运算符为$+$、$-$，则先将栈顶部分所有的$\times$、$\div$出栈直到遇到$+$、$-$或左括号$($，然后再把当前运算符$+$、$-$入栈。
     3. 若当前字符为**左括号$($**，进栈。
         +   **左括号$($**不会影响其他非)符号的入栈出栈，在**左括号$($**前的符号不会因为**左括号$($**入栈而弹出，在$)$后的符号也不用判断是否弹出，直接入栈。
     4. 若当前字符为**右括号$)$**，则从栈顶起，依次将栈中运算符出栈成为后缀表达式的一部分，直到碰到**左括号$($**。将栈中**左括号**$($出栈，不需要成为后缀表达式的一部分，然后继续扫描表达式直到最终输出后缀表达式为止。
5.   使用栈进行中缀表达式求值的程序实现：设定两个栈，一个用于存储运算符称之为运算符栈，另一个用于存储操作数称之为操作数栈。首先置操作数栈为空，表达式起始符“#”为运算符栈的栈底元素。依次读入表达式中每个字符：
     1. 若是操作数则进**操作数栈**。
     2. 若是运算符则和运算符栈栈顶元素比较优先级。
         1. 若栈顶元素优先级高于即将入栈的元素，则栈顶元素出栈运算符入栈，否则栈顶元素不动运算符入栈
             +   优先级高的先出栈，再把优先级低的放进来。
         2. 操作数栈弹出两个操作数和运算符一起进行运算，将运算后的结果放入操作数栈，直至整个表达式求值完毕
             +   即运算符栈顶元素和要放入元素均为$\#$。

### 队列

1.   队列：只允许一端进行插入（入队或进队），另一端进行删除（出队或离队）的线性表。
     1.   队尾指针$rear$指向队尾元素的下一个位置。进队时队尾指针$rear+1$。排队排在队尾。
     2.   队头指针$front$指向队头元素。出队时队头指针$front+1$。前面的人先打到饭。
2.   顺序队列的假溢出：如果出队，则前面的空间会空闲，但是假如队尾指针会依照插入而不断加$1$，则我们的队尾指针最后会指向最后一个区域，计算机不知道前面是怎么样，所以就认为空间已经满了，实际上没有。这就是假溢出。一般采用循环队列解决。
3.   循环队列：将队尾指针不仅仅是加一，而是加一后再取整个静态数组大小$MAXSIZE$的模，这样如果队列尾指针超过了范围也仍能回到最开始插入数据。
     1.   初始时：$Q. front=Q. rear=0$。
     2.   队首指针进 1: $Q.front= (Q.front+1) \%MaxSize $。
     3.   队尾指针进 1: $Q.rear=(Q.rear+1)\%MaxSize$。
     4.   队列长度：$(Q. rear+MaxSize-Q. front) \%MaxSize$
4.   循环队列判断满队
     1.   牺牲最后的一个存储单元。入队少用一个队列单元。
          1.   队满条件$(rear+1)%MAXSIZE==front$。
          2.   队空条件$front==rear$。
          3.   队列元素个数$(rear+MAXSIZE-front)%MAXSIZE$。
     2.   增设一个用来表示数据个数的成员$length$。
          1.   队满条件$length==MAXSIZE$。
          2.   队空条件$length==0$。
          3.   队空和队满都是$front==rear$。
     3.   可以定义一个$int$类型的$tag$，当进行删除操作就置$tag$为$0$，插入操作时置$tag$为$1$，只有删除才可能队空，只有插入才可能队满，所以就可以根据这个来判断。
          +   队空和队满都是$front==rear$。
5.   链队：定义链队需要定义一个队头指针和一个队尾指针，队头指向队头结点，队尾指向队尾结点，即单链表最后一个结点，这跟顺序存储不同。一般都定义为带头节点的链表。
6.   双端队列：只允许从两端插入、两端删除的线性表。
     1.   输入受限的双端队列：只允许从一端插入，两端删除的线性表。
     2.   输入受限的双端队列：只允许从一端删除，两端插入的线性表。
7.   队列应用
     1.   树的层次遍历
          1.   根结点入队。
          2.   若队空（所有结点都已处理完毕)，则结束遍历，否则重复三操作。
          3.   队列中第一个结点出队，并访问之。若其有左孩子，则将左孩子入队；若其有右孩子，则将右孩子入队，返回二。
     2.   图的广度优先遍历$BFS$：从图的一个起始节点开始，逐层遍历图中的节点，先访问起始节点的邻居节点，然后再访问邻居节点的邻居节点，依次类推，直到遍历完图中所有可达节点。
     3.   计算机系统
          1.   进程争用$FCFS$策略。
          2.   解决$CPU$与外设速度不匹配问题。
          3.   解决请求处理机问题。

### 数组概述

1.   数组：由同类型的数据元素构成的有序集合。每个元素是数组元素，每个元素受$n$个线性关系的约束。其中每个元素在$n$个线性关系中的序号就是元素的下标，可以通过下标来访问元素。
     +   数组一旦被定义其维数和维界就不能改变，所以数组只能对结构的初始化和销毁，以及元素的存取和修改。数组的重点在于其存储。
2.   数组的存储结构
     1.   一维数组：各数组元素大小相同，且物理上连续存放。
          +   数组下标从$0$开始：数组元素$a[i]$的存放地址$=LOC+i\times sizeof(ElemType)$。
     2.   二维数组：二维数组存储方式还是同一维数组一样连续的。已知二维数组$b[M][N]$。数组下标从$0$开始。
          1.   行优先：一行一行存储。$b[i][j]$的存储地址$=LOC+(i\times N+j)\times sizeof(ElemType)$。
          2.   列优先：一列一列存储。$b[i][j]$的存储地址$=LOC+(j\times M+i)\times sizeof(ElemType)$。

### 特殊数组的压缩

特殊矩阵是指具有许多相同矩阵元素或零元素，并且这些相同矩阵元素或零元素的分布有一定规律的矩阵。

1.   对称矩阵：若对一个$n$阶方阵$A[1，n][1，n]$中的任意一个元素$a_{ij}$都有$a_{ij}=a_{ji}$，即主对角线对称元素相等的矩阵，就是对称矩阵。其中元素可以分为上三角区域、主对角线和下三角区域，上下三角区域对应元素相等。

     所以可以将$A$存放在一维数组$B[\dfrac{n(n+1)}{2}]$中，从而$a_{ij}=b_k$，比如只存放下三角部分与主对角线部分元素。

     对于$a_{ij}$而言，其在$i$行$j$列，第一行有$1$个元素，第二行有$2$个元素，$\cdots$，第$i-1$行有$i-1$个元素，则$i$行$j$列的$a_{ij}$数组下标$k=1 + 2 +\cdots(i-1) + (j-1) = \dfrac{i \times (i-1)}{2} + (j - 1)$。

     +   下标从$0$开始时，某元素之前元素的个数等于该元素下标。
     +   数组下标从$0$开始，矩阵行列都是从$1$开始的。
     +   $\dfrac{i \times (i-1)}{2}$为前$i-1$行一共存在的元素个数。
     +   $j-1$表示$a_{ij}$所在第$i$行在$a_{ij}$之前的元素个数。

     从而数组$B$大小$k_{max}=\dfrac{(1+n)\times n}{2}$。

     当$i\geqslant j$时，即下三角区域与主对角线元素对应在数组$B$中的下标$k = \dfrac{i \times (i-1)}{2} + (j - 1)$。

     当$i<j$时，即上三角区域对应在数组$B$中的下标$k = \dfrac{j \times (j-1)}{2} + (i - 1)$。

     +   对称矩阵中上三角区域$(i，j)$的值与$(j，i)$相同

2.   下三角矩阵：下三角矩阵指上三角区域的元素均为同一常量，其存储思想与对称矩阵一样，但是需要最后多一个存储空间存储上三角的常量。所以可以将$A$存放在一维数组$B[\dfrac{n(n+1)}{2}+1]$中。

     当$i\geqslant j$时，即下三角区域与主对角线元素：$k=\dfrac{i(i+1)}{2}+j-1$。

     当$i<j$时，即上三角区域：$k=\dfrac{n(n+1)}{2}$（最后一位）。

3.   上三角矩阵：上三角矩阵指下三角区域的元素均为同一常量，其存储思想与下三角矩阵一样，不过下标不同。

     1.   第$1\sim i-1$行有$n+(n-1)+\cdots+(n-i+2)$个元素
          +   第$1$行有$n$个元素
          +   第$2$行有$n-1$个元素
          +   $\cdots$
          +   第$i-1$行有$n-(i-2)$个元素
     2.   第$i$行$a_{ij}$之前有$j-i$个元素。
          +   考虑$a_{ij}$所在行第$i$行一共需要存储$n+1-i$个元素。

          +   $a_{ij}$所在行在$a_{ij}$之后还有$n-j$个元素。
          +   则$a_{ij}$之前有$(n+1-i)-(n-j)-1=j-i$个元素。

     从而$a_{ij}$对应的下标$k=n+(n-1)+\cdots+(n-i+2)+(j-i)=\dfrac{(i-1)(2n-i+2)}{2}+(j-i)$。

     1.   当$i\leqslant j$时，即上三角区域与主对角线元素下标$k=\dfrac{(i-1)(2n-i+2)}{2}+(j-i)$。
     2.   当$i>j$时，即下三角区域下标$k=\dfrac{n(n+1)}{2}$。

4.   三对角矩阵：对角矩阵也称为带状矩阵。对于$n$阶方阵$A$的任意元素$a_{ij}$，当$\vert i-j\vert>1$时，有$a_{ij}=0$，则是三对角矩阵。三对角矩阵除了以主对角线为中心的三条对角线的区域上的元素并不是完全为零外，其他元素都是零。所以可以将三条对角线上的元素行优先地存储在一维数组中。

     第$1$行是两个元素，而$2$到$i-1$行一共$i-1-2+1=i-2$行每行$3$个元素，所以前$i-1$行一共$2+(i-2)\times3$个元素，第$i$行一共$j-(i-1)$个元素。

     即$k=2+(i-2)\times3+j-i+1$，所以得到$k=2i+j-3$。

     反之，若已知三对角线矩阵中某元素$a_{ij}$存放于一维数组$B$的第$k$个位置，则可得$i=\left \lfloor \dfrac{k+1}{3}+1 \right \rfloor$、$j=k-2i+3$。

5.   稀疏矩阵：矩阵中非零元素的个数$t$，相对矩阵元素的个数$s$来说非常少，即$s\gg t$的矩阵称为**稀疏矩阵**。 稀疏矩阵压缩后就失去了随机存取的特性。

     1.   三元组法：使用【（行标，列标，值）】存储非零元素。
     2.   十字链表法：使用【（同一行中下一个元素的位置，同一列中下一个元素的位置，值）】存储非零元素。

