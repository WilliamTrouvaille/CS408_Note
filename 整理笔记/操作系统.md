# 操作系统

+ $\mathrm{semaphore}$  $n.$信号量、$\mathrm{progress}$  $n.$进程。
+ 【不同**进程**之间的资源共享】：①私有的，即**打开文件表**、**堆栈指针**、进程的全局变量和静态变量、**页表指针**；②共享的，共享内存（用于进程间通信）、信号量和消息队列、设备。
+ 【父子进程】：可以共享一部分资源，但是**不能共享虚拟地址空间**。因为是逻辑地址且其有不同的$PCB$用于区分进程。
+ 【同一进程下，各个**线程**之间】：①私有的，即执行上下文（包括程序计数器、**堆栈指针**等）、寄存器；②共享的，即进程的**虚拟地址空间**、代码段数据段、**全局变量**和堆，打开文件表，信号量机构（**互斥锁**、条件变量）等同步机制。
  + 不同线程均需要访问原进程的源代码（进程=动起来的程序），所以应当**共享地址空间**；而每个线程需要进行自己的线程调用，所以堆栈指针（执行上下文）等私有。
  + 在支持**硬件多线程**的计算机中，每个线程都拥有独立的通用寄存器组和程序计数器。
+ 【**系统调用流程**】：①传递参数；②使用软中断指令即自陷指令；③**软中断指令的中断响应阶段**，即保存断点和$PSW$；④**硬件操作切换到内核态**并查找中断向量表以跳转到系统调用处理程序；⑤**软中断指令的中断处理阶段**，保存现场等，后略。
+ 【进程同步】：①**仅纪录型（带等待队列）的信号量完全遵守了四条互斥访问准则**，整数型信号量、$\mathrm{Peterson}$算法、互斥锁均不满足让权等待；②`wait`、`signal`操作可以解决一切同步问题，但无法防止系统死锁。
+ 【判断算法是否能够保证互斥是否会导致饥饿】：首先将所有可能的进程的执行代码全写出来并标号，**若存在一个执行序列能使多个进程进入临界区说明该算法不能保证互斥**；而若进程地位平等，一般可以认为不会导致饥饿。
  + `while(FLAG);`中若`FLAG`为真会一直开在这里，即若想通过应该使`FLAG`为假才行。
+ 【处理死锁】：①预防死锁（破坏死锁条件）、避免死锁（银行家算法）、检测死锁（进程资源图）；②**限制申请资源顺序**统一理解为按序号顺序递增，属于预防死锁；③进程资源图用于**检测死锁**，在每个资源均为单实例时使用拓扑排序检测若出现环路说明**可能发生死锁**否则**一定不会发生死锁**，非单实例时不能简单的通过有无环判断。
+ 【管程】：①管程通过条件变量来实现阻塞进程，条件变量【**没有值**】，调用这两个操作时**都不用判断条件**；②只能通过调用管程内的过程访问**共享数据**，**无法访问私有数据**；③同一时刻内管程内函数只能被一个进程使用；④能实现同步和互斥。
+ 【进程通信】：①低级通信方式是$\mathrm{PV}$操作，高级通信方式有共享存储、信息传递、管道通信（还有共享文件等）；②共享存储，可以分别基于数据结构（只能存放固定数据、是低级通信方式）和存储区（存放位置由进程控制、高级通信方式）实现；③信息传递，通过操作系统提供的原语实现，可以直接发送到接受进程的信息缓冲队列上（直接通信）也可以先发送到中间实体信箱中（间接通信）；④管道通信，即内存中开辟一个大小固定的缓冲区。
+ 【管道通信】：①管道只能**半双工通信**；②读写都可能被堵塞，如果没有**写满**则不允许读、如果没有**读空**则不允许写；③一个管道允许多个写进程一个读进程。
+ 【用户级线程】：①**对操作系统透明**；②线程切换不需要转换到内核空间，开销较小；③某线程阻塞时，**进程内的所有线程都被阻塞**（罪魁祸首）；④由用户空间的线程库实现，可以在不支持内核线程的系统中实现。
+ 【多对一模型】：①多个用户级线程映射到一个内核级线程；②**一个线程被阻塞后与该进程中所有线程也都被阻塞**；③一对一模型和多对多模型不会发生以上情况。
+ 【程序运行时的内存映像】：①一般包含代码段（只读、可共享）、数据段（包括全局变量和静态变量）、进程控制块$\mathrm{PCB}$、堆、栈；②堆用于存放动态分配的变量，通过调用`malloc`函数动态地**从低地址向高地址**分配空间；③栈用于实现函数调用，**从最大地址**往低地址方向增长；
+ 【虚拟内存】：①基于**离散分配**（和请求机制）实现，动态分区分配的连续分配方式不能用于虚拟内存；②最大容量等于逻辑地址空间的大小、同时也等于虚拟存储器的容量，实际容量等于主存辅存的容量之和；③**进程的虚拟地址空间的大小**仅由虚拟地址空间的位数决定；④主要特征为虚拟性。
  + 虚拟内存$\ne$虚拟存储器；
  + 【虚拟内存的实现】：离散分配、请求机制、内存和外存、页表或段表、中断机构、地址变换机构。
+ $\mathrm{I/O}$软件层次结构：用户层软件，设备独立性软件，设备驱动程序，中断处理程序。
  + 设备独立性软件：**实现系统调用**。与设备的硬件特性无关的功能几乎都在这一层实现。
  + 设备驱动程序：控制$\mathrm{I/O}$设备工作，执行$read$和$write$命令、**计算柱面号、磁头号和扇区号**、设置设备寄存器、检查设备状态等。凡是包含物理设备、**设备操作**的功能都在这一层实现。
+ 【柱面号、磁头号和扇区号】
+ **【设备驱动程序】**：①与硬件平台、操作系统、$\mathrm{I/O}$控制方式有关；②其中的一部分必须用**汇编语言**书写，**部分内容已固化在$\mathrm{ROM}$中**；③允许可重入，⼀个正在运行的驱动程序通常会在一次调用完成前被再次调用；④驱动程序**不允许系统调用**。
+ 【设备驱动程序的处理过程】：①将抽象要求转换成具体要求，如将$\mathrm{ read }$命令中的盘块号按地址寄存器的格式转化为盘面号、磁道号和扇区号；②检验权限、检查设备状态；③传递参数，如将磁盘地址、内存地址和传送字节数等传送到设备控制器的寄存器中；④启动$\mathrm{I/O}$。
+ 【打开文件前后使用的参数不同】：①$\mathrm{open}$系统调用，文件存放路径、文件名、要对文件的操作类型；②$\mathrm{read}$系统调用，文件描述符、缓冲区首址、传输字节数，**不需要文件名和存放路径**。
+ 【**※※※成组链接法**】：用来存放一组**空闲盘块号**的盘块称为**成组链块**，每一组成组链块的最后一个（指**最后一个进行分配的**）空闲盘块作为成组链块，用于保存另一组空闲盘块号，每个成组链块使用**空闲盘块计数**表示当前组中空闲的盘块数量。
  + 分配时，对于每一个请求的盘块，分配给用户后依次将指针下移一格；若该指针指向的是最后一个盘块（成组链块），则直接在下一组中选取盘块进行分配，**当前组中指向下一组的空闲盘块不参与分配**；
  + 回收时，指针上移一格，若当前成组链块已满还有一个盘块进行回收，则将现有已记录n个空闲盘块号的成组链块号记入新回收的盘块，**将当前回收的盘块作为新的成组链块**。
+ 【文件系统】：①文件系统中利用**目录**组织大量文件；②为了允许不同用户使用相同文件名，文件系统采用多级目录；③文件系统中每个目录项都是$\mathrm{FCB}$，$\mathrm{UNIX}$系统中的目录项则为文件名和索引节点指针。
+ 【内存映射文件】：①可以将文件的内容直接映射到进程的虚拟内存中，使得文件的访问就像对内存的访问一样；②创建时，使用$\mathrm{open}$系统调用和$\mathrm{mmap}$系统调用，返回可以用于后续内存操作的指针；③访问时，通过操作**内存映射区域**来访问文件内容，进程可以直接读取和写入内存映射区域**而不需要$\mathrm{read}$系统调用和$\mathrm{write}$系统调用**，且由于内存映射区域与文件内容直接关联，**对映射区域的修改也会直接反映到文件中**；④**多个进程可以映射同一个文件**以实现共享；
+ 【虚拟文件系统$\mathrm{VFS}$】：①屏蔽了不同文件系统的差异和操作细节，为用户程序提供了文件系统操作的统一接口而无需关心底层文件系统的具体实现；②采用了**面向对象**的思想，定义了通用文件系统都支持的接口并要求下层的文件系统必须实现这些函数功能；③**只存在于内存中而不存在于任何外存空间中**，在系统启动时建立在系统关闭时消亡；④可以提高系统性能；
+ 【文件系统挂载】：①初始化$\mathrm{VFS}$中的挂载表、向$\mathrm{VFS}$提供函数地址列表、将新文件系统加到挂载点（某个父目录）下；②$\mathrm{UNIX}$使用系统的根文件系统（由内核在引导阶段直接安装），其他文件系统由初始化脚本或用户安装。
  + $\mathrm{UNIX}$本身是一个固定的目录树，只要安装就有，但是如果不给它分配存储空间，就不能对它进行操作，所以需要先给根目录分配空间才能操作这个目录树。
+ 【操作系统引导】：①执行$JMP$指令跳转到$BIOS$；②开始执行$BIOS$的指令；③硬件自检并加载带有操作系统的硬盘；④在$ROM$中加载主引导记录$MBR$，$MBR$加载硬盘活动分区和分区引导记录$PBR$；⑤加载活动分区中的引导程序、加载启动管理器、加载操作系统内核。
+ 【应用程序$\mathrm{I/O}$接口】：①字符设备接口，以字符为单位、传输速率较低、不可寻址（只能使用顺序存取方式）、采用**中断驱动方式**；②块设备接口即**磁盘**，传输速率较高、可以寻址、采用$\mathrm{DMA}$方式，通过内存的字节数组来访问磁盘而**不提供读/写磁盘操作**；③网络设备接口，使用$\mathrm{socket}$系统调用创建**套接字**并通过此连接发送和接收数据、必须指明网络协议（$\mathrm{UDP/TCP}$）；④阻塞或非阻塞$\mathrm{I/O}$。
+ 【阻塞或非阻塞$\mathrm{I/O}$】：①阻塞$\mathrm{I/O}$，执行$\mathrm{I/O}$操作时会被阻塞、等待直到数据准备就绪才能进行读取或写入操作、**大多数操作系统提供的$\mathrm{I/O}$接口都是采用阻塞$\mathrm{I/O}$**；②非阻塞$\mathrm{I/O}$，执行$\mathrm{I/O}$操作时不会被阻塞（而是立即返回，无论数据是否准备就绪）、数据未准备好时应用程序可以继续执行并定期检查直到数据就绪；③异步$\mathrm{I/O}$，发起$\mathrm{I/O}$后可以继续执行其他任务无需等待、$\mathrm{I/O}$操作完成后操作系统会通知程序并提供数据、需要使用特定的系统调用或库函数实现。
+ 【设备分配方式】：①静态分配，主要用于对**独占设备**的分配、一次性分配、不会出现死锁但设备使用率低；②动态分配，在进程执行过程中根据执行需要进行、有利于提高设备利用率但有可能造成进程死锁。
+ 【设备分配过程】：①根据物理设备名查找**系统设备表**$SDT$；②根据**系统设备表**$SDT$找到**设备控制表**$DCT$；③根据**设备控制表**$DCT$找到**控制器控制表**$COCT$；④根据**控制器控制表**$COCT$找到**通道控制表**$CHCT$；只有**设备、控制器、通道**三者都分配成功时这次设备分配才算成功，之后便可以启动数据传送。
  + 系统设备表$\to$设备控制表$\to$控制器控制表$\to$通道控制表。
+ 【缓冲寄存器相关计算题】：例，若在$\mathrm{I/O}$接口的通信速率为$9600\mathrm{bps}$设置的数据缓冲寄存器的宽度为$8$位，则$\mathrm{I/O}$接口每【$\frac{8\mathrm{bit}}{9600\mathrm{bps}}=0.8\mathrm{ms} $】就要中断一次$\mathrm{CPU}$，且要求$\mathrm{CPU}$在【$0.8ms\times\frac{1\mathrm{bit}}{8\mathrm{bit}}=0.1\mathrm{ms} $】内响应。
  + 【$\frac{8\mathrm{bit}}{9600\mathrm{bps}}=0.8\mathrm{ms} $】：思路同$\mathrm{I/O}$中断方式的$\mathrm{CPU}$中断时间；
  + 【$0.8ms\times\frac{1\mathrm{bit}}{8\mathrm{bit}}=0.1\mathrm{ms} $】：必须在数据缓冲寄存器填满后**下一个比特数据到达前把数据移走**。

------

+ 系统开机后操作系统被加载到内存中的系统区，这段区域是$RAM$。
+ **软中断指令=自陷指令**。
+ 通用寄存器清零不是特权指令、不需要切换到内核态执行。
+ 时间片轮转实现了对于CPU的虚拟化，内存分区实现了对内存资源的虚拟化。
+ 处理机被抢占会从运行态$\to$就绪态，不会阻塞。
+ 进程$P$由阻塞态转化为就绪态（唤醒）是由$\mathrm{wakeup}$原语实现的，该原语是由进程$P$相关的进程（“**协作进程**”）调用的。
+ 切换进程后TLB作废，Cache一般不清空。
+ 高低调度调作业，低级调度调进程。中级调度恢复挂起。
+ **进程之间的切换是通过中断实现的**，有了中断才有了多任务处理系统。
+ 【进程的撤销】：①正常结束后回收，是最主要的因素；②异常终止，包括越界、$\mathrm{I/O}$故障、算术错误等；③外界干预，用户、操作系统、父进程等均可终止。
+ 说法『~~**一个进程的状态发生改变时一定会导致其他进程的状态发生变化**~~』**是错误的**，当系统队列中只有其一个进程时。
+ 【**逻辑地址和物理地址**】：①堆栈指针指向的都是逻辑地址，**所有指针指向的可以认为都是逻辑地址**；②存储向量的寄存器（如页基址寄存器）均存储的是物理地址，避免循环依赖等问题（指向的地址又映射到自己）。
  + 即可能存在循环依赖问题的是物理地址（即在内存中有物理存储的），否则就为逻辑地址。
+ 交换区`swap`：物理内存不足时，用于临时存储当前系统中不活跃的**页面或进程**。
+ 进程优先级与分配资源和作业长短无关。
+ 【进程控制块$\mathrm{PCB}$】：①包含进程$\mathrm{PID}$、进程状态、源程序程序段、数据地址、$\mathrm{CPU}$现场保护区、堆栈指针、$\mathrm{PC}$指针、$\mathrm{FCB}$指针；
+ 【**线程**】：①最小的**分配和调度**单位，不拥有系统资源；②可以访问隶属于进程的资源，**共享**进程的地址空间，**没有独立地址空间**；③**同一进程中的线程切换不会引起进程切换**，不同进程中的线程切换则会引起进程切换；④只有内核级线程才有$TCB$。
+ 子程序调用：一定会保存$PC$信息，而一定不会保存$PSW$的信息。
+ **可重入代码/纯代码一定不是临界资源**。
+ 【※程序载入过程】：**编译、链接、装入(装载)、（执行）**。
  + 其中，编译将程序翻译成汇编代码，链接将程序与库函数合并形成可执行文件期间地址变换机构进行地址重定位**将逻辑地址翻译成物理地址**。
+ 【重定位】：静态重定位/**可重定位装入**在**装入时**进行地址转换（重定位），动态重定位在**执行时**进行地址转换（重定位）。
+ 【同时分配内存空间、打印机和处理机的题】：①每个进程到达时即被分配可用资源；②**一个进程必须获得除CPU外所有所需资源才能参与进程调度**；③太复杂了一定要全写出来。
+ 【伙伴算法】：①每次回收可能进行多次合并、每次合并只将两个相同大小的块进行合并；②回收一个大小为$2^k$的块时若已经存在一个同样为$2^k$的空闲块，则将其合并为一个大小为$2^{k+1}$的块并继续检查；
+ 【内部碎片】：单一连续分配、固定分区分配、请求分页、段页式存储。
+ 【外部碎片】：动态分区分配、请求分段。
+ 外部碎片可通过紧凑技术使用动态重定位寄存器解决
+ 【※没有**全局置换固定分配**策略】：因为**全局置换意味着进程拥有的物理块数量必然会改变**，因此不可能是固定分配。
+ 【工作集】：对于某进程访问页面的序列，某时刻的工作集为该时刻之前n个访问的页面（去重），n为工作集大小。
+ 【改进型时钟置换算法】：在其他条件都相同时，应优先淘汰**有修改过的页面**，避免$\mathrm{I/O}$操作。
  + 没访问没修改，没访问**有修改**，有访问没修改，有访问有修改。
+ `open`系统调用：文件存放路径、文件名、要对文件的操作类型。
+ `read`系统调用：文件描述符、缓冲区首址、传输字节数。**不需要文件名和存放路径**。
+ 对访问的文件执行`close`系统调用时，若引用计数值仍大于0，即仍然存在进程使用该文件，则不能将文件写回外存。
+ 【※※※以$\mathrm{scanf()}$为例，使用键盘输入数据时发生了什么】：①执行函数时触发系统调用、$CPU$切换至内核态后执行系统调用；②系统调用初始化后启动外设并**阻塞当前用户进程**直到键盘输入数据；③键盘中断例程（设备驱动程序）将数据从键盘控制器（**$\mathrm{I/O}$接口**）传送到**内核缓冲区**后，**唤醒当前用户进程**；④最后系统调用返回，当前用户进程再次运行时将内核缓冲区的数据送至**用户缓冲区**。
  + 中断例程结束后数据在内核缓冲区，系统调用返回后可以认为送往用户缓冲区。
+ 【程序在运行中调用$\mathrm{I/O}$，问进程状态变化】：应该完整回答执行$\mathrm{I/O}\to$阻塞$\to$就绪$\to$重新运行的过程。
+ 对于任意文件系统，若用户类别有$n$种，访问权限有$m$中，则需要描述文件权限的位数至少为$nm$位。
+ 多级目录结构中，从根目录到任何文件有且只有一条路径，与用户名和用户目录无关。
+ 引入索引节点前目录项存放文件的$FCB$，引入后仅需要存储文件名和索引节点编号。
+ 文件索引节点维护的是文件的物理结构。
+ 【提高文件访问速度】：①提前读；②延迟写；③分配连续簇；④使用磁盘高速缓存；⑤内存映射文件。
  + 提前读：使用**顺序访问**时，提前将下一块数据读入内存，故**对随机访问无效**。
  + 延迟写：在内存中设置**页缓冲区队列**（属于共享资源），若进程再次访问其中的数据直接读出避免启动$\mathrm{I/O}$。
+ 文件索引节点是实现文件共享的其中一种方式、即**硬链接**。
+ 【不同进程共享文件】：①可使用读或写的方法打开，操作系统不保证其互斥性；②系统打开文件表$\mathrm{FTB}$只有一个对应的表项；
+ 【不同进程共享表或段】：①每个进程各自的页表或段表指向共享内容的起始位置，在物理内存中只存在一份内容，但对应的段号或页号各自维护；
+ 【**簇**】：①对**文件存储空间的分配以簇为单位**，所以**一个文件占用的空间一定是簇大小的整数倍**，文件小于一簇也要占用一簇的空间；②可以减少$\mathrm{FAT}$表表项、降低$\mathrm{FAT}$表占用空间、减少$\mathrm{FAT}$表存取开销。
+ 逻辑记录是对文件进行存取的基本单位。
+ 【存储区前后均有足够的空间】：大概率前移。
+ 每次要读或写一大批记录时，顺序文件的效率是所有逻辑文件中最高的。
+ 【传送$ASCII$的设备（键盘、$FTP$）】：每传送传输一个$ASCII$字符，除了需要传输$ASCII$字符的七位外，还需要额外传输起始位、停止位、校验位各一位。
+ 无论硬链接还是软链接都会导致每个共享文件存在重复的文件名，且每增加一个硬链接\软链接均会多增加一个文件名，故若**将目录中的所有文件全部转储到磁带等顺序存储载体上时会产生多个文件副本**。
+ 每移动一个磁盘块需要访问磁盘两次（读+写）。
+ 【最大文件长度】若地址或索引位数为$m$位，每块大小为$N$字节：①链接分配：【$2^{m}\cdot(N-\frac{1}{8}m)$】字节，尤其注意要减索引占用；②索引分配：【$\sum_{k=1}^{n}(\frac{N\times8}{m})^k\cdot N$】字节，其中$n$为间接地址项次数；
+ 文件控制块需要额外存储的字段：链接分配【文件首地址、最后一块物理块块号】，连续分配【文件首地址、文件大小】。
+ FCB中有A个直接地址项和一、二、三次间址项各一个，若每页可以存储地址项k个，当前访问的逻辑页号为n，则
  + $n < A$：直接地址项；
  + $A \leq n < A + k$：一次间址项中第$n - A$个地址项；
  + $A + k \leq n < A + k + k^2$：二次间址项中一级索引为$\left\lfloor \frac{n - a - k}{k} \right\rfloor$，其中第$(n - a - k) \mod k$个地址项；
  + $A + k + k^2 \leq n < A + k + k^2 + k^3$：三次间址项中二级索引为$\left\lfloor \frac{n - a - k - k^2}{k^2} \right\rfloor$，一级索引为$\left\lfloor \frac{(n - a - k - k^2) \mod k^2}{k} \right\rfloor$，其中第$(n - a - k - k^2) \mod k$个地址项。
+ 计算页表项或页目录项时对于类似【$\mathrm{LA}+0041\mathrm{H}\times4$】的计算式，一般使用移位进行运算不需要将后半部分算出具体值。
+ 【缓冲区平均耗时】：数据$\to$缓冲区$\to$用户区$\to$处理的三个箭头耗时记为$A$、$B$、$C$，则单缓冲区为$\max(A,C)+B$，双缓冲区$\max[A,(B+C)]$。
+ 统一编址：把$\mathrm{I/O}$端口当做存储器的单元进行地址分配，用统一的访存指令访问$\mathrm{I/O}$端口，靠不同的**地址码**区分内存$\mathrm{I/O}$设备。
  + 端口需要**占用主存地址空间**。
+ 独立编址：使用专门的$\mathrm{I/O}$指令访问$\mathrm{I/O}$端口，靠不同的**指令**区分，速度快，不占用主存地址空间。
+ $SPOOLing$必要条件：①**外存/硬盘**作为输入井和输出井；②多道程序**并发**处理技术；③$SPOOLing$软件；④进行虚拟独占设备。
+ $SPOOLing$的输出井和设备之间存在一个内存中的输出缓冲区作为中介，没有直连数据通路。
+ $SPOOLing$技术所用的输入进程和输出进程均是**和用户进程一起参与CPU调度**，均**运行在内核态下**，且其输出进程至少需要两种设备驱动程序的支持。
+ 磁盘初始化
  1. 低级格式化/物理格式化：**扇区的划分**。低级格式化为每个扇区**使用特殊的数据结构填充磁盘**（确定扇区校验码位数）。
  2. 逻辑格式化：**创建文件系统**，**建立文件系统根目录**，初始化存储空闲磁盘块信息的数据结构（**空闲磁盘表**）。
+ 【外存空闲磁盘管理】：空闲表法、空闲链接法、位示图法、成组链接法，还有索引节点也可表示空闲磁盘。
+ 引导扇区在安装操作系统时写入，由操作系统决定。
+ 寻道距离指的是磁道，若给出的是盘块号，则应当转化为对应磁道号
+ 磁盘操作时间：总平均存取时间$T_a$=寻道时间$T_s$+延迟时间$T_r$+传输时间$T_t$。其中寻道时间$T_s$与磁盘调度算法密切相关。
  1. **寻找时间/寻道时间**$T_s$：移动磁头，$T_s=s+m\times n$。
     + 启动磁头臂是需要时间的，假设耗时为$s$。
     + 移动磁头也是需要时间的，假设磁头匀速移动，每跨越一个磁道耗时为$m$，总共需要跨越$n$条磁道。
  2. 旋转延迟时间$T_r$：通过旋转磁盘，使磁头定位到目标扇区所需要的时间。$T_r=\dfrac{1}{2}\times\dfrac{1}{r}=\dfrac{1}{2r}$。
     + 磁盘转速为$r$，$\dfrac{1}{r}$就是转一圈需要的时间，找到目标扇区平均需要转半圈，因此再乘$\dfrac{1}{2}$。
  3. 传输时间$T_t$：从磁盘读出或向磁盘写入数据所经历的时间。$T_t=\dfrac{b}{rN}$。
     1.   其中磁盘转速为$r$，读/写的字节数为$b$，每个磁道上的字节数为$N$。
     2.   每个磁道要可存$N$字节的数据，因此$b$字节的数据需要$\dfrac{b}{N}$个磁道才能存储，而读/写一个磁道所需的时间刚好又是转一圈所需要的时间$\dfrac{1}{r}$，$T_t=\dfrac{1}{r}\times\dfrac{b}{N}$。
+ 周转时间：周转时间等于**完成时刻减到达时刻**，带权带权时间等于**周转时间除以运行时间**，平均周转时间等于**各个进程带权带权时间的平均值**。
+ 磁盘调度算法
  + 最短寻找时间优先算法$SSTF$可能导致饥饿。
  + 扫描算法$SCAN$：回头时**沿途处理请求**。不会导致饥饿。
  + **循环**扫描算法$C-SCAN$：回头时沿途**直接回到最前面**，不沿途处理请求。不会导致饥饿。
  + 仅FCFS算法不会导致磁头黏着。