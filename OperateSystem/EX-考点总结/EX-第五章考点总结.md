# EX-第五章 设备管理考点总结

## 导读

### 【考纲内容】

1. $I/O$管理基础
    + 设备：设备的基本概念，设备的分类，$I/O$接口。
    + $I/O$控制方式：轮询方式，中断方式，$DMA$方式。
    + $I/O$软件层次结构：中断处理程序，驱动程序，设备独立性软件，用户层$I/O$软件。
    + 输入输出应用程序接口：字符设备接口，块设备接口，网络设备接口，阻塞/非阻塞$I/O$。
2. 设备独立软件
    + 缓冲区管理。
    + 设备分配与回收。
    + 假脱机技术$SPOOLing$。
    + 设备驱动程序接口。
3. 外存管理
    + 磁盘：磁盘结构，格式化，分区，磁盘调度方法。
    + 固态硬盘：读写性能特效，磨损均衡。

### 【复习提示】

选择题：$I/O$接口、$I/O$软件、三种$I/O$控制方式、高速缓存与缓区、$SPOOLing$技术，磁盘特性和调度算法。

## 选择题考点总结

### $I/O$概述

以下内容见$CO$笔记：$I/O$接口、$I/O$ 端口、$I/O$控制方式（程序控制方式、中断方式、$DMA$方式）

1.   $I/O$设备：可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。计算机系统为每台设备确定一个编号以便区分和识别设备，这个确定的编号称为设备的绝对号。
2.   设备分类
     1.   按信息交换的单位分类
          1.   块设备：信息交换以数据块为单位，属于有结构设备，传输速率较高，可寻址，即对它可随机地读/写任一块，如硬盘、磁盘。
          2.   字符设备：信息交换以字符为单位，属于无结构设备，传输速率较慢，不可寻址，在输入/输出时常采用中断驱动方式，如键盘、鼠标。
     2.   按传输速率分类
          1.   低速设备：传输速率为每秒几个到几百字节。例如鼠标、键盘等。
          2.   中速设备：传输速率为每秒上千到上万字节。例如打印机等。
          3.   高速设备：传输速率为每秒上万到上万兆字节。例如硬盘，磁盘机、光盘机等。
     3.   按使用特性分类
          1.   人机交互类外部设备：数据传输速度慢，如鼠标、键盘。用于人机交互。
          2.   存储设备：数据传输速度块，如移动硬盘。用于数据存储。
          3.   网络通信设备：数据传输速度介于二者之间，如调制解调器。用于网络通信。

### $I/O$软件层次结构

1.   ※$I/O$软件层次结构：其中**设备驱动程序**由于需要调用中断，在层次结构中仅次于中断层。
     1.   用户层软件：用户层软件必须通过一组**系统调用**来获取操作系统服务。
     2.   设备独立性软件：**实现系统调用**。与设备的硬件特性无关的功能几乎都在这一层实现。详情见下。
          +   凡是包含**逻辑设备**的功能都在这一层实现。
     3.   设备驱动程序：控制$I/O$设备工作，执行$read$和$write$命令、**计算柱面号、磁头号和扇区号**、设置设备寄存器、检查设备状态等。不同的$I/O$设备有不同的硬件特性，具体细节只有设备的厂家才知道，因此厂家需要根据设备的硬件特性设计并提供相应的驱动程序。
          +   凡是包含物理设备、**设备操作**的功能都在这一层实现。
     4.   中断处理程序：进行进程上下文的切换，对处理中断信号源进行测试，读取设备状态和修改进程状态等。
2.   设备独立性软件/设备无关性软件：为实现设备独立性而引入了逻辑设备和物理设备这两个概念。
     1.   逻辑设备：增加设备分配的灵活性、易于实现$I/O$重定向。其中$I/O$重定向指用于$I/O$操作的设备可以更换（即重定向），而不必改变应用程序。
     2.   **逻辑设备表$LUT$**（$Logical\;UnitTable$）：设备独立性软件通过**逻辑设备表$LUT$**来确定逻辑设备对应的物理设备，并找到该设备对应的设备驱动程序。
     3.   **逻辑设备表**$LUT$的管理
          1.   整个系统只设置一张**逻辑设备表**$LUT$​：意味着所有用户不能使用相同的逻辑设备名，因此这种方式只适用于单用户操作系统。
          2.   为每个用户设置一张**逻辑设备表**$LUT$：各个用户使用的逻辑设备名可以重复，适用于多用户操作系统。系统会在用户登录时为其建立一个用户管理进程，而$LUT$就存放在用户管理进程的$PCB$中。
3.   设备独立性：为了实现设备独立性，必须再在驱动程序之上设置一层设备独立性软件。**设备独立性软件包括执行所有设备公有操作的软件**。设备独立性软件的主要功能如下。
     1.   执行所有设备的公有操作：对设备的分配与回收、**将逻辑设备名映射为物理设备名**、对设备进行保护、缓冲管理差错控制、提供独立于设备的大小统一的逻辑块，屏蔽设备之间信息交换单位大小和传输速率的差异。
     2.   向用户层（或文件层）提供统一接口：无论何种设备，它们向用户所提供的接口应是相同的。例如，对各种设备的读/写操作，在应用程序中都统一使用`read/write`命令等。

### 应用程序$I/O$接口

1.   字符设备接口：字符设备是指数据的存取和传输是以字符为单位的设备，基本特征是传输速率较低、**不可寻址**，并且在输入/输出时通常采用**中断驱动方式**。字符设备都属于**独占设备**，为此接口中还需要提供打开和关闭操作，以实现互斥共享。
2.   块设备接口（$Block\; Device \;Interface$）：数据的存取和传输是以数据块为单位的设备，典型的块设备是**磁盘**。基本特征是传输速率较高、可寻址。磁盘设备的$I/O$常采用$DMA$方式。
     1.   隐藏了磁盘的二维结构：块设备接口将磁盘的所有扇区从$0\sim n-1$依次编号，将二维结构变为一种线性序列。在原本的二维结构中，每个扇区的地址需要用（磁道号，扇区号）来表示。
     2.   将抽象命令映射为低层操作：块设备接口支持上层发来的对文件或设备的打开、读、写和关闭等抽象命令。该接口将上述命令映射为设备能识别的较低层的具体操作。
     3.   内存映射接口通过内存的字节数组来访问磁盘，而不提供读/写磁盘操作。
3.   网络设备接口（$Network\; Device\; Interface$​）：许多操作系统提供的网络I/O接口为网络套接字接口。
4.   阻塞或非阻塞$I/O$（$Blocking\; or \;Non-blocking\; I/O$）：操作系统的I/O接口还涉及两种模式，阻塞和非阻塞。
     1.   阻塞$I/O$：在阻塞$I/O$模式下，应用程序在执行$I/O$操作时会被阻塞，直到操作完成或出现错误。阻塞$I/O$将等待直到数据准备就绪才能进行读取或写入操作。大多数操作系统提供的$I/O$接口都是采用阻塞$I/O$。
     2.   非阻塞$I/O$：在非阻塞$I/O$模式下，应用程序在执行$I/O$操作时不会被阻塞，而是立即返回，无论数据是否准备就绪。如果数据未准备好，非阻塞$I/O$将返回一个错误或特殊的值，应用程序可以继续执行其他任务，然后定期检查$I/O$状态，直到数据就绪。
     3.   异步$I/O$：异步$I/O$是一种高级$I/O$模式，应用程序发起一个$I/O$操作后，可以继续执行其他任务，而无需等待$I/O$操作的完成当$I/O$操作完成时，系统会通知应用程序，并提供数据。

### 缓冲区管理

1.   磁盘高速缓存$Disk Cache$：利用内存中的存储空间暂存从磁盘中读出的一系列盘块中的信息，逻辑上是属于磁盘，物理上驻留在内存中，也被复制到$CPU$的二级和一级高速缓存中。不同于$CPU$的那个$Cache$，这里是指利用内存中的存储空间来暂存从磁盘中读出的一系列盘块中的信息。
2.   缓冲区$Buffer$：缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区。一般情况下利用内存作为缓冲区。
     1.   缓和$CPU$与$I/O$设备之间速度不匹配的矛盾。
     2.   减少对$CPU$的中断频率，放宽对$CPU$中断相应时间的限制。

     3.   解决**基本数据单元大小/数据粒度**不匹配的问题。

     4.   提高$CPU$与$I/O$设备之间的并行性。
3.   常用字母表示

     + $T$代表输入时间：设备把数据传入缓冲区。

     + $M$代表传输时间：把缓冲区数据传入用户区。

     + $C$代表处理时间：$CPU$对数据进行处理。
4.   单缓冲：在主存中设置一个缓冲区，当设备和处理机交换数据时，先将数据写入缓冲区，然后需要数据的设备或处理机从缓冲区取走数据，在缓冲区写入或取出的过程中，另一方需等待。若两个相互通信的机器只设置**单缓冲区**，在任一时刻只能实现**数据的单向传输**。
     1.   单缓冲区处理一块数据平均耗时$\max(C，T)+M$。
          1.   假设$T> C$，从初始状态开始，当工作区数据处理完后，时间为$C$，缓冲区还没充满，当缓冲区充满时，经历了$ T$时间。
          2.   停止再冲入数据，然后缓冲区向工作区传送数据，当工作区满了后， 缓冲区的数据同时也为空，用时为$M$。

          3.   到达下一个开始状态，整个过程用时$M+T$。

          4.   若$T<C$，同理，整个过程用时$M+C$。
     2.   连续处理$N$块数据所用时间$[Max(C,T)+M]*N+Min(C,T)$。
          1.   假设磁盘块与缓冲区大小相同，初始状态是工作区和缓冲区均为空。
          2.   先读入磁盘块$T_1$，然后送至用户区$M_1$，$M_1$执行完成以后，处理磁盘块$C_1$和读入下一个磁盘块$T_2$可以同时执行。
          3.   如果$T>C$（即$T_2>C_1$），第一个磁盘块处理完成后，还需要等待第二个磁盘块的读入，所以这段时间用时为$T_2$。
          4.   如果$T<C$（即$T_2<C_1$），第二个磁盘读入后，还需要第一个磁盘处理完成以后再传送到用户工作区，所以这段时间用时为$C_1$。
          5.   连续处理$N$块数据所用时间为$T+[M+Max(C,T)]\times (N-1)+M+C$ $=(N-1)(Max(C,T)+M)+M+T+C$ $=[Max(C,T)+M]*N+Min(C,T)$。
5.   双缓冲：$I/O$设备输入数据时先装填到缓冲区$1$，在缓冲区$1$填满后才开始装填缓冲区$2$，与此同时处理机可以从缓冲区1中取出数据送入用户进程。若两个相互通信的机器设置双缓冲区，则同一时刻可以实现**双向数据传输**。
     1.   一块存，一块可以取，处理一块数据平均耗时$\max[T，(C+M)]$。
          1.   $T<C+ M$时，缓冲区$2$开始向工作区传送数据，缓冲区$1$开始冲入数据，当工作区充满数据后，缓冲区为空，时间为$M$；然后工作区开始处理数据，缓冲区$1$继续冲入数据，因为此时只有一个$I/O$设备，所以缓冲区$2$虽然为空，但不能冲入数据；当缓冲区$1$充满数据后， 工作区的数据还未处理完毕，时间为$T$；当工作区数据处理完毕后，此时工作区为空，缓冲区$1$满，缓冲区$2$为空，达到下一个初始状态。
          2.   $T>C+ M$时，缓冲区$2$开始向工作区传送数据，缓冲区$1$开始冲入数据，当工作区充满数据并处理完后，用时$C + M$，但缓冲区$1$的数据还未充满；当时间为$T$时，缓冲区$1$的数据充满，到达下一个初始状态。
     2.   连续处理$N$块数据所用时间$Max(T,M+C)*N+Min(T,M+C)$
          1.   假设磁盘块与缓冲区大小相同，初始状态是工作区和缓冲区均为空。
          2.   不同于单缓冲区，双缓冲区将磁盘块读入缓冲区操作$T$和磁盘块送入用户区操作$M$可以并行执行。但是磁盘块送入用户区操作$M$和系统处理磁盘块操作$C$还是串行方式进行。
6.   循环缓冲：将多个大小相等的缓冲区链接成一个循环队列。每个缓冲区中有一个链接指针指向下一个缓冲区，最后一个缓冲区指针指向第一个缓冲区，多个缓冲区构成一个环形。循环缓冲用于输入/输出时，还需要有两个指针$in$和$out$。
     1.   $in$指针，指向下一个可以冲入数据的空缓冲区。对输入而言，首先要从设备接收数据到空缓冲区中。
     2.   $out$指针，指向下一个可以取出数据的满缓冲区。当运行进程需要数据时，从循环缓冲区中取一个装满数据的缓冲区，并从此缓冲区中提取数据。
7.   缓冲池：最好的方式。
     1.   缓冲池由系统中共用的缓冲区组成。这些缓冲区按使用状况可以分为三个队列：
          1.   空缓冲队列
          2.   输入队列：装满输入数据的缓冲队列。
          3.   输出队列：装满输出数据的缓冲队列。
     2.   根据一个缓冲区在实际运算中扮演的功能不同，又设置了四种工作缓冲区：
          1.   用于收容输入数据的工作缓冲区$hin$。
          2.   用于提取输入数据的工作缓冲区$sin$。
          3.   用于收容输出数据的工作缓冲区$hout$。
          4.   用于提取输出数据的工作缓冲区$sout$。
     3.   输入进程请求输入数据：取出空缓冲队列队头作为收容输入数据的工作缓冲区（$hin$），冲满数据后将缓冲区挂到输入队列队尾。
     4.   计算进程请求输入数据：取出输入队列队头作为提取输入数据的工作缓冲区（$cin$），缓冲区读空后挂到空缓冲区队列队尾。

     5.   计算进程将准备好的数据冲入缓冲区：取出空缓冲队列队头作为收容输出数据的工作缓冲区（$hout$），数据冲满后将缓冲区挂到输出队列队尾。

     6.   输出进程请求输出数据：取出输出队列队头作为提取输出数据的工作缓冲区（$sout$），缓冲区读空后挂到空缓冲区队列队尾。

### 设备分配

1.   设备特性
     1.   独占设备：同时只能被一个进程访问。如打印机、磁带机。独占式使用设备。进程分配到独占设备后，便由其独占，直至该进程释放该设备。
          + 破坏了“请求和保持”条件，不会发生死锁。
     2.   共享设备：同时能被多个进程访问，不会死锁。如磁盘。可寻址和可随机访问。分时式共享使用设备。对于共享设备，可同时分配给多个进程，通过分时共享使用。
          +   可能死锁。

     3.   虚拟设备：将独占设备改造成共享的虚拟设备。**以$SPOOLing$方式使用的外部设备**。$SPOOLing$技术实现了虚拟设备功能，可以将设备同时分配给多个进程。这种技术实质上就是实现了对设备的$I/O$操作的批处理。
2.   设备分配方式

     + 静态分配：静态分配主要用于对**独占设备**的分配，它在用户作业开始执行前，由系统一次性分配该作业所要求的全部设备、 控制器。一旦分配，这些设备、控制器就一直为该作业所占用，直到该作业被撤销。**静态分配方式不会出现死锁**，但设备的使用效率低。

     + 动态分配：动态分配在**进程执行过程中**根据执行需要进行。当进程需要设备时，通过系统调用命令向系统提出设备请求，由系统按某种策略给进程分配所需要的设备、控制器，一旦用完，便立即释放。这种方式有利于提高设备利用率，但若分配算法使用不当，则有**可能造成进程死锁**。
3.   设备分配数据结构：**系统设备表**$SDT$中每个表目有一个指向**设备控制表**$DCT$的指针，**设备控制表**$DCT$中的每个表目有一个指向**控制器控制表**$COCT$的指针，**控制器控制表**$COCT$中有一个**通道控制表**$CHCT$指针，**通道控制表**$CHCT$中有一个**控制器控制表**$COCT$指针
     1.   设备控制表$DCT$：系统为每个设备配置一张$DCT$，用于记录设备情况。
     2.   控制器控制表$COCT$：每个设备控制器都会对应一张**控制器控制表**$COCT$。因此每个**控制器控制表**$COCT$有一个表项存放指向相应**通道控制表**$CHCT$的指针，而一个通道可为多个设备控制器服务，因此**通道控制表**$CHCT$中必定有一个指针，指向一个表，这个表上的信息表达的是**通道控制表**$CHCT$提供服务的那几个设备控制器。
     3.   通道控制表$CHCT$：每个通道都会对应一张$CHCT$。
     4.   系统设备表$SDT$，整个系统只有一张，记录了系统中全部设备的情况，每个设备对应一个表目。
4.   设备名映射：使用了设备独立性，使用逻辑设备名来使用设备。系统中设置了一张**逻辑设备表**$LUT$。包括设备逻辑名、物理逻辑名、设备驱动程序入口。
     1.   有两种方式设置$LUT$
          1.   系统只有一张，所以只适合单用户系统。
          2.   每个用户一张，当用户登录，系统就为用户创建一个进程并建立一张$LUT$并放入$PCB$中。
     2.   逻辑设备表（$LUT$）建立了逻辑设备名与物理设备名之间的映射关系。
     3.   某用户进程第一次使用设备时使用逻辑设备名向操作系统发出请求，操作系统根据用户进程指定的设备类型（逻辑设备名）查找系统设备表，找到一个空闲设备分配给进程，并在$LUT$中增加相应表项。
     4.   如果之后用户进程再次通过相同的逻辑设备名请求使用设备，则操作系统通过$LUT$表即可知道用户进程实际要使用的是哪个物理设备了，并且也能知道该设备的驱动程序入口地址。
5.   设备分配过程：系统设备表（$SDT$）$\to$设备控制表（$DCT$）$\to$控制器控制表（$COCT$）$\to$通道控制表（$CHCT$）。
     1.   根据进程请求的物理设备名查找**设备控制表**$SDT$。物理设备名是进程请求分配设备时提供的参数。
     2.   根据**设备控制表$SDT$**找到**设备控制表$DCT$**，若设备忙碌则将进程$PCB$挂到设备等待队列中，不忙碌则将设备分配给进程。
     3.   根据**设备控制表$DCT$**找到**控制器控制表$COCT$**，若控制器忙碌则将进程$PCB$挂到控制器等待队列中，不忙碌则将控制器分配给进程。
     4.   根据**控制器控制表$COCT$**找到**通道控制表$CHCT$**，若通道忙碌则将进程$PCB$挂到通道等待队列中，不忙碌则将通道分配给进程。
     5.   只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后便可后动$I/O$设备进行数据传送。

### $SPOOLing$技术

1.   脱机输入/输出技术：操作系统中采用的一项将独占设备改造成共享设备的技术。**需要专门硬件**，将低速$I/O$设备上的数据传送到高速磁盘上，或者相反。
2.   $SPOOLing$技术：即假脱机技术。是用**纯软件**的方式模拟脱机技术，除了硬盘外，不需要专门硬件。
3.   虚拟设备：将独占设备改造成共享的虚拟设备。虚拟设备只会和$SPOOLing$技术在一起出现。
4.   $SPOOLing$系统组成
     1.   输入井/输出井：在磁盘上开辟出的两个存储区域。
     2.   输入/输出进程：用于模拟脱机输入/输出时的外围控制机。
     3.   输入缓冲区与输出缓冲区：在内存中开辟的两个缓冲区。
5.   ※$SPOOLing$必要条件：
     + 大容量、高速度的外存/硬盘作为输入井和输出井。
     + 多道程序并发处理技术（多道程序设计技术）。
     + $SPOOLing$软件。
     + 独占设备（需要对设备进行虚拟）。
6.   $SPOOLing$实例：共享打印机。

### 磁盘系统

#### 磁盘

1.   磁盘结构：可用【柱面号，盘面号，扇区号】来定位任意一个磁盘块。
     1.   磁道：磁盘盘面上的数据存储在一组同心圆中，称为**磁道**。最内侧磁道上的扇区面积最小，因此数据密度最大，硬盘的存储能力也受限于最内侧的最大记录密度。
     2.   柱面：所有盘面中相对位置相同的磁道组成**柱面**。所有磁头都链接在同一个磁臂上，所有磁头的移动方向都是一致的。
          +   柱面号$=\lfloor$簇号$\div$每个柱面的簇数$\rfloor$。
     3.   盘面：磁盘由多个盘片构成，盘片保存数据的一面就是**盘面**，一个盘片有一个或两个盘面。
          +   磁头号（盘面号）$=\lfloor($簇号$\%$每个柱面的簇数$)\div$每个磁道的簇数$\rfloor$。
     4.   扇区：每个磁道与磁头一样宽，一个盘面有上千个磁道，磁道又划分为几百个**扇区**，每个扇区固定存储大小，一个扇区称为一个**盘块**。**扇区是磁盘可寻址的最小单位**。
          +   扇区号$=$扇区地址$\%$每个磁道的扇区数。
     5.   物理块数：磁盘上能存储的物理块数目由**扇区数**、**磁道数及磁盘面数**决定。
2.   磁盘初始化
     1.   **低级格式化/物理格式化**：**扇区的划分**。低级格式化为每个扇区**使用特殊的数据结构填充磁盘**。大多数磁盘在工厂时作为制造过程的一部分就已经低级格式化，这种格式化能够让制造商测试磁盘，并且初始化逻辑块号到无损磁盘扇区的映射。
     2.   将磁盘**分区**：操作系统将自己的数据结构记录到磁盘上。

          1.   磁盘分区（即$C$盘等形式的分区）：每个分区的起始扇区和大小都记录在磁盘主引导记录$MBR$的分区表中。
          2.   物理分区进行**逻辑格式化**（创建文件系统）：操作系统将初始的文件系统数据结构存储到磁盘上，这些数据结构包括空闲空间和已分配的空间以及一个初始为空的目录，如位示图、空闲分区表。
               +   **建立文件系统根目录**。
     3.   初始化程序/自举程序：计算机开机时需要进行一系列初始化的工作，这些初始化工作是通过执行**初始化程序/自举程序**完成的。
          1.   自举程序找到磁盘上的操作系统内核，将它加载到内存， 并转到起始地址，从而开始操作系统的运行。
          2.   自举程序通常放在只读存储器$ROM$中，$ROM$中的数据在出厂时就写入了，并且以后不能再修改。
          3.   为了避免改变自举代码而需要改变ROM硬件的问题，通常只在ROM中保留很小的自举装入程序，而将完整功能的引导程序保存在磁盘的**启动块**上。
     4.   启动块：完整的自举程序放在磁盘的启动块（即引导块/启动分区）上，启动块位于磁盘的固定位置。具有启动分区的磁盘称为**启动磁盘/系统磁盘**。 
     5.   引导块：开机时计算机先运行自举装入程序出通过执行该程序就可找到**引导块**，并将完整的自举程序读入内存，完成初始化。
     6.   坏块：对坏块的处理实质上就是用某种机制使系统不去使用坏块。
          1.   坏扇区：手动处理。对于简单磁盘，可以在**逻辑格式化**时（建立文件系统时）对整个磁盘进行坏块检查，标明哪些扇区是坏扇区。在这种方式中，**坏块对操作系统不透明**。
          2.   坏块链表：控制器维护磁盘内的坏块列表。在磁盘出厂前进行**低级格式化/物理格式化**时就将坏块链进行初始化，并在磁盘的使用过程中不断更新。这种处理方式中，**坏块对操作系统透明**。
3.   磁盘操作时间：总平均存取时间$T_a$=寻道时间$T_s$+延迟时间$T_r$+传输时间$T_t$。在实际的磁盘$I/O$操作中，存取时间与磁盘调度算法密切相关。
     1.   **寻找时间/寻道时间**$T_s$：在读/写数据前，将磁头移动到指定磁道所花的时间。$T_s=s+m\times n$
          1.   启动磁头臂是需要时间的，假设耗时为$s$。
          2.   移动磁头也是需要时间的，假设磁头匀速移动，每跨越一个磁道耗时为$m$，总共需要跨越$n$条磁道。
     2.   旋转延迟时间$T_r$：通过旋转磁盘，使磁头定位到目标扇区所需要的时间。$T_r=\dfrac{1}{2}\times\dfrac{1}{r}=\dfrac{1}{2r}$。
          +   磁盘转速为$r$，$\dfrac{1}{r}$就是转一圈需要的时间，找到目标扇区平均需要转半圈，因此再乘$\dfrac{1}{2}$。
     3.   传输时间$T_t$：从磁盘读出或向磁盘写入数据所经历的时间，这个时间取决于每次所读/写的字节数$b$和磁盘的旋转速度$r$。$T_t=\dfrac{b}{rN}$。
          1.   其中磁盘转速为$r$，此次读/写的字节数为$b$，每个磁道上的字节数为$N$。
          2.   每个磁道要可存$N$字节的数据，因此$b$字节的数据需要$\dfrac{b}{N}$个磁道才能存储。
          3.   而读/写一个磁道所需的时间刚好又是转一圈所需要的时间$\dfrac{1}{r}$，$T_t=\dfrac{1}{r}\times\dfrac{b}{N}$。
4.   磁盘平均存取时间优化方法：传输时间是磁盘本身性质所决定的，不能通过一定的措施减少。可以减少**延迟时间$T_r$**或通过**磁盘调度算法**尽可能优化**寻道时间**$T_s$。
     1.   交替编号：让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小。
     2.   错位命名：磁盘是连续自转设备，磁头读/写一个物理块后，需要经过短暂的处理时间才能开始读/写下一块。若相邻的盘面相对位置相同处扇区编号相同，则会出现不能连续读取的问题。假设逻辑记录数据连续存放在磁盘空间中，若在盘面上按扇区交替编号连续存放，则连续读/写多条记录时能减少磁头的延迟时间。所以使用错位命名，同一柱面不同盘面的扇区编号不同，从而有足够的时间来处理。

### 磁盘调度算法

若无特别说明，也可以默认$SCAN$算法和$C-SCAN$算法为$LOOK$和$C-LOOK$调度。

需要注意的是最外侧磁道编号为$0$时，若某磁盘共$N$磁道，则磁头移动范围为$0\sim N-1$。

1.   先来先服务算法$FCFS$（$First\;Come \;First \;Served$）：$Flash$半导体存储器（$U$盘，$SSD$）的物理结构不需要考虑寻道时间和旋转延迟，可直接按$I/O$请求的先后顺序服务。当请求访问的磁道比较集中时算法性能比较好。
2.   最短寻找时间优先算法$SSTF$（$Shortest\; Seek \;Time \;First$）：优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短，但能提供比$FCFS$算法更好的性能。**可能产生饥饿现象**。
3.   扫描算法$SCAN$：也叫电梯算法。规定只有磁头移动到**最外侧磁道**的时候才能往内移动，移动到最内侧磁道的时候才能往移动。**不会产生饥饿现象**。
4.   循环扫描算法$C-SCAN$：规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求。
5.   $LOOK$调度算法：基于$SCAN$。如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向。
6.   $C-LOOK$调度算法：基于$C-SCAN$。规定如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向，且磁头只用返回到有磁道访问请求的位置即可。

#### 固态硬盘$SSD$

1.   固态硬盘$SSD$：属于电可擦除$ROM$，即$EEROM$。使用$Flash $芯片**可进行多次快速擦除重写**。 由于$Flash $需要先擦除再写入，因此**写速度比读速度要慢**。
2.   组成：闪存翻译层（负责管理闪存芯片中的数据存储和访问，找到对应的页$Page$）和存储单元（$Flash $芯片，每个芯片包含多个块$Block$，每个块包含多个页$Page$）
3.   读写性能特性：
     1.   以页$Page$为单位读/写：相当于磁盘的扇区
     2.   以块$Block$为单位"擦除"，擦干净的块，其中的每页都可以写一次，读无限次。
     3.   支持随机访问，系统给定一个逻辑地址，闪存翻译层可通过电路迅速定位到对应的物理地址。
     4.   读快、写慢。要写的页如果有数据，则不能写入，需要将块内其他页全部复制到一个新的（擦除过的）块中，再写入新的页。
4.   与机械硬盘相比的特点：
     1.   $SSD$读写速度快，随机访问性能高，用电路控制访问位置；机械硬盘通过移动磁背旋转磁盘控制访可位直，有寻道的间和旋转延达。
     2.   $SSD$安静无噪音、耐摔抗震、能耗低、造价更贵。
     3.   $SSD$的一个"块"被擦除次数过多（重复写同一个块）可能会坏掉而机械硬盘的扇区不会因为写的次数太多而坏掉。
5.   磨损均衡技术：将“擦除”平均分布在各个块上，以提升使用寿命。
     1.   动态磨损均衡：写入数据时，优先选择累计擦除次数少的新闪存块。
     2.   静态磨损均衡：$SSD$监测并自动进行数据分配、迁移，让老旧的闪存块承担以读为主的储存任务，让较新的闪存块承担更多的写任务。