# 第三章 内存管理

## 导读

### 【考纲内容】

1. 内存管理基础

    + 内存管理概念
        + 逻辑地址与物理地址空间
        + 地址变换
        + 内存共享
        + 内存保护
        + 内存分配与回收

    + 连续分配管理方式
    + 页式管理
    + 段式管理
    + 段页式管理

2. 虚拟内存管理

    + 虚拟内存基本概念
    + 请求页式管理
    + 页框分配
    + 页置换算法

    + 内存映射文件$(Memory-Mapped \;Files)$ 
    + 虚拟存储器性能的影响因素及改进方式

### 【知识导图】

### 【复习提示】

内存管理和进程管理是操作系统的核心内容,需要重点复习.

本章围绕分页机制展开; 通过分页管理方式在物理内存大小的基础上提高内存的利用率,再进一步引入请求分页管理方式,实现虚拟内存,使内存脱离物理大小的限制,从而提高处理器的利用率.

## 内存管理基础知识

![image-20230622210440836](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306222104921.png)

### 内存概念

+ 内存是用于存放数据的硬件.
    + 程序执行前需要先放到内存中才能被$CPU$处理.
    + 用于缓冲$CPU$和硬盘间的速度矛盾

+ 内存地址从$0$开始,每个地址对应一个存储单元.
+ 存储单元的大小不定：
    + 按**字节**编址,则每个存储单元大小为一个**字节**即$1B$,$8$个二进制位.
    + 按**字**编址,每个存储单元大小为一个**字**,根据计算机的字长确定大小,若字长为$16$位,则一个字大小为$16$个二进制位.
+ **【注意】：**
    + 字$（Word）$：字是计算机中数据处理的基本单元,表示为二进制位$（bit）$的组合
        + 字的长度取决于计算机的体系结构,通常为一个处理器的原生数据宽度
        + 例如,一个字可以是$16$位、$32$位或$64$位长.字的长度决定了处理器一次性能够处理的数据量

    + 字长$（Word Length）$
        + 字长指的是计算机系统中字的位数
        + 它表示一个字可以容纳的二进制位数目
        + 例如,一个32位的字长表示一个字可以容纳32个二进制位.字长通常与处理器的体系结构和寄存器的位数相关联.

    + 字节$（Byte）$
        + 字节是计算机中存储和传输数据的最小单位
        + 它一定是由$8$个二进制位（即$8$位）组成
        + 字节是计算机内存中数据的基本存储单位,也是计算机系统中常用的数据单位
        + 大部分计算机系统都以字节为基准进行数据的存储和传输.


### 内存管理功能

![image-20230622211153786](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306222111874.png)

#### 内存分配与回收

操作系统负责内存空间的分配与回收.即后面的普通内存管理内容.

#### 对内存空间进行扩充

详见<a href="#内存空间扩充">内存空间扩充</a>

#### 地址映射

操作系统需要提供某种技术从逻辑上对内存空间进行扩充,并且操作系统需要提供**地址转换**功能,通过内存管理部件$MMU$,负责程序的**逻辑地址**与**物理地址**的转换.

+ 相对地址（逻辑地址）
    + 从$0$号开始,程序员只用知道逻辑地址,可有相同逻辑地址

+ 绝对地址（物理地址）
    + 内存物理单元的集合,是地址转换的最终地址
    + 从逻辑地址到物理地址就是**地址重定位**.


#### 内存保护

操作系统需要提供内存保护功能.保证各进程在各自存储空间内运行,互不干扰：

+ 在$CPU$中设置一对上、下限寄存器,存放进程的上、下限地址
    + 进程的指令要访问某个地址时,$CPU$检查是否越界.

+ 采用重定位寄存器（又称基址寄存器,用于地址相加）和界地址寄存器（又称限长寄存器,用于地址比较）进行越界检查
    + 重定位寄存器中存放的是进程的起始物理地址
    + 界地址寄存器中存放的是进程的最大逻辑地址


#### 内存共享

只有只读区域才能共享,这种代码就是**可重入代码**（纯代码）允许多个进程同时访问但是不允许任何进程修改的代码.可以复制副本后自己修改.

减少了对程序段的调入/调出,因此减少了对换数量.

### 程序载入过程

+ 程序运行过程：
    1. 编译：由编译程序将用户源代码编译成若干个目标模块（编译就是把高级语言翻译为机器语言）.
    2. 链接：由链接程序将编译后形成的一组目标模块,以及所需库函数链接在一起,形成一个完整的装入模块.
    3. 装入（装载）：由装入程序将装入模块装入内存运行.
    4. 执行.

#### 链接

将独立的逻辑地址合并为完整的逻辑地址：

1. 静态链接：在**编程**时先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块）,之后不再拆开.
2. 装入时动态链接：将各目标模块**装入**内存时,边装入边链接的链接方式.
3. 运行时动态链接：在程序**执行**中需要该目标模块时,才对它进行链接,通过硬件转换机制进行转化.其优点是便于修改和更新,便于实现对目标模块的共享.

动态链接与程序逻辑结构有关,所以段式管理有利于动态链接.

#### 装入

将逻辑地址转换为物理地址：

1. 绝对装入（单道程序阶段、未产生操作系统）：

    + 在**编译**时,如果知道程序将放到内存中的哪个位置,编译程序将产生绝对地址的目标代码

    + 装入程序按照装入模块中的地址,将程序和数据装入内存

        + 绝对装入只适用于单道程序环境.

        + 程序中使用的绝对地址,可在编译或汇编时给出,也可由程序员直接赋予.

        + 通常情况下都是编译或汇编时再转换为绝对地址.

2. 静态重定位（可重定位装入）（多道批处理操作系统）

    + 编译、链接后的装入模块的地址都是从$0$开始的,指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址

    + 可根据内存的当前情况,使用单独的装入程序将装入模块装入到内存的适当位置

    + **装入**时对地址进行“重定位”,将逻辑地址变换为物理地址（地址变换是在装入时一次完成的）

        + 静态重定位的特点是在一个作业装入内存时,必须分配其要求的全部内存空间,如果没有足够的内存,就不能装入该作业.

        + 作业一旦进入内存后,在运行期间就不能再移动,也不能再申请内存空间.

3. 动态重定位（动态运行时装入）（现代操作系统）

    + 编译、链接后的装入模块的地址都是从$0$开始的

    + 装入程序把装入模块装入内存后,并不会立即把逻辑地址转换为物理地址,而是把地址转换推迟到程序真正要**执行**时才进行

    + 因此装入内存后所有的地址依然是逻辑地址

    + 这种方式需要一个专门的重定位寄存器的支持

        + 采用动态重定位时允许程序在内存中发生移动.

        + 可将程序分配到不连续的存储区中：在程序运行前只需裂入它的部分代码即可投入运行,然后在程序运行期间,根据需要动态申请分配内存.

        + 便于程序段的共享,可以向用户提供一个比存储空间大得多的地址空间.



## 普通内存管理

![image-20230622221001841](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306222210928.png)

内存空间的分配分为：

+ 连续分配管理：
    + 单一连续分配.
    + 固定分区分配.
    + 动态分区分配.
+ 非连续分配管理（离散分配方式）：
    + 基本分页存储管理.
    + 基本分段存储管理.
    + 段页式存储管理.

连续分配是指为用户进程分配的必须是一个连续的内存空间.而非连续分配反之.

**【注意】：**

+ 内部碎片,是**已经被分配出去**却不能被利用的内存空间.
    + **能明确指出属于哪个进程**

+ 外部碎片,是**还没有被分配出去**,但由于太小了无法分配给申请内存空间的新进程的内存空闲区域.
    + 不属于任何进程
    + 可以通过**紧凑**（拼接）技术来移动进程位置合并空闲空间.


### 单一连续分配

+ 内存被分为系统区和用户区
    + 系统区通常位于内存的低地址部分,用于存放操作系统相关数据
    + 用户区用于存放用户进程相关数据.

+ 内存中只能有一道用户程序,用户程序独占整个用户区空间.
+ 优点：
    + 实现简单.
    + **无外部碎片**.
    + 可以采用覆盖技术扩充内存.
    + 因为只有一道程序,所以肯定不会访问越界,不一定需要采取内存保护（如早期的$PC$操作系统$Ms-Dos$）.
+ 缺点：
    + 只能用于单用户、单任务的操作系统中.
    + **有内部碎片**.即分配给某进程的内存区域中,如果有些区域没有用上的部分
    + 存储器利用率极低.

### 固定分区分配

+ 将整个用户空间划分为若干个固定大小的分区,在每个分区中只装入一道作业.
+ 分区的方式
    + 分区大小相等
        + 缺乏灵活性
        + 但是很适合用于用一台计算机控制多个相同对象的场合.
    + 分区大小不等
        + 增加了灵活性,可以满足不同大小的进程需求
        + 根据常在系统中运行的作业大小情况进行划分
            + 比如划分多个小分区、适量中等分区、少量大分区
+ 记录分区的方法
    + 操作系统需要建立一个数据结构——**分区说明表**来实现各个分区的分配与回收
    + 每个表项对应一个分区,通常按分区大小排列
    + 每个表项包括对应分区的大小、起始地址、状态（是否已分配）.

+ 分区分配过程
    + 当某用户程序要装入内存时,由操作系统内核程序根据用户程序大小检索该表
    + 从中找到一个能满足大小的、未分配的分区,将之分配给该程序,然后修改状态为“己分配”.

+ 优点：
    + 实现简单.
    + **无外部碎片**.
+ 缺点：
    + 当用户程序太大时,可能所有的分区都不能满足需求,此时不得不采用覆盖技术来解决,但这又会降低性能.
    + **会产生内部碎片**,内存利用率低.

### 动态分区分配

+ 动态分区分配又称为**可变分区分配**
    + 这种分配方式**不会预先划分内存分区**
    + 而是在进程**装入**内存时,**根据进程的大小动态地建立分区**,并使分区的大小正好适合进程的需要
    + 因此系统分区的大小和数目是可变的.

+ 记录分区的方法(使用的数据结构)
    + 空闲分区表
        + 每空闲分区对应表项
        + 表项中包含分区号、分区大小、分区起始地址、分区状态等信息
        + ![image-20230622214735443](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306222147487.png)
        + **【注意】：**
            + 各表项的顺序不一定按照地址递增顺序排列,具体的排列方式需要依据**动态分区分配算法**来确定
    + 空闲分区链
        + 每个分区的起始部分和末尾部分分别设置前向指针和后向指针
        + 起始部分处还可记录分区大小等信息.
        + ![image-20230622214742894](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306222147936.png)
+ 动态分区分配(当很多个空闲分区都能满足需求时,应该选择哪个分区进行分配?)
    + 把一个新作业装入内存时,须按照一定的动态分区分配算法,从空闲分区表（或空闲分区链）中**选出一个分区**分配给该作业
    + 由于分配算法算法对系统性能有很大的影响,因此人们对它进行了广泛的研究。
    + 见下节<a href="#动态分区分配算法">动态分区分配算法</a>
+ 分配分区后修改数据结构
    + 把一个新作业装入内存时,在**按照某种分配算法已经分配好分区后**修改相应的记录分区的数据结构
    + 以使用空闲分区表为例
        + 当选择的分区分区大小大于分配空间,则分区大小相减,并修改起始地址。
        + 当选择的分区分区大小等于分配空间,则删除该表项。

+ 回收分区
    + 若回收区的后面或前面有一个相邻的空闲分区则两个表项合并为一个.
    + 若回收区的后面和前面都有一个相邻的空闲分区则三个表项合并为一个.
    + 若回收区的后面或前面都没有一个相邻的空闲分区,则新增一个表项.
+ 动态分区分配**没有内部碎片**,但是有外部碎片

### 动态分区分配算法

![image-20230622225651797](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306222256882.png)

为了解决动态分区分配方式中如何从多个空闲分区中选择一个分区分配

#### 首次适应算法（$First\,Fit$）

+ 算法思想
    + 每次都从低地址开始查找,找到第一个能满足大小的空闲分区.

+ 如何实现
    + 空闲分区以**地址**递增的次序排列
    + 每次分配内存时顺序查找空闲分区链（或空闲分区表）
    + 找到大小能满足要求的第一个空闲分区

+ 优点
    + 首次适应算法每次都要从头查找,每次都需要检索低地址的小分区
    + 但是这种规则也决定了当低地址部分有更小的分区可以满足需求时,会更有可能用到低地址部分的小分区,也会更有可能把高地址部分的大分区保留下来
    + 算法开销小,每次分区后不需要对分区队列重新排序
+ 缺点
    + 造成低分区大量内存碎片
    + 都要重复经过已经分配的底层区间,增加查找开销

#### 最佳适应算法（$Best\,Fit$）

+ 算法思想
    + 由于动态分区分配是一种连续分配方式,为各进程分配的空间必须是连续的一整片区域
    + 因此为了保证当“大进程”到来时能有连续的大片空间,可以尽可能多地留下大片的空闲区
        + 即优**先使用更小的空闲区**.

+ 如何实现
    + 空闲分区按**容量 递增次序**链接
        + 递增次序:从小到大

    + 每次分配内存时顺序查找空闲分区链（或空闲分区表）
    + 找到大小能满足要求的第一个空闲分区
    + 当分配完后需要重新调整空闲分区链（或空闲分区表）.

+ 优点：容易保存大分区.
+ 缺点：
    + 每次都选最小的分区进行分配,会留下越来越多的、很小的、难以利用的内存块.因此这种方法会产生**最多**的**外部碎片**且很难查找回收.
    + 算法开销大,每次分区外需要对分区队列进程重新排序.

#### 最坏适应算法（$Worst\,Fit$）

+ 算法思想
    + 为了解决最佳适应算法的问题――即留下太多难以利用的小碎片
    + 可以在每次分配时优先使用最大的连续空闲区,这样分配后剩余的空闲区就不会太小,更方便使用.
        + 即优**先使用更大的空闲区**.

+ 如何实现
    + 空闲分区按**容量** **递减次序**链接
        + 递减次序:从大到小

    + 每次分配内存时顺序查找空闲分区链（或空闲分区表）,找到大小能满足要求的第一个空闲分区
        + 由于是从大到小排列,一般每次都是选取最大的分区进行分配

    + 当分配完后需要重新调整空闲分区链（或空闲分区表）.

+ 优点：可用减少难以利用的小碎片.
+ 缺点：
    + 每次都选最大的分区进行分配,虽然可以让分配后留下的空闲区更大,更可用,但是这种方式会导致较大的连续空闲区被迅速用完
        + 如果之后有“大进程”到达,就没有内存分区可用了.
    + 算法开销大,每次分区外需要对分区队列进程重新排序.

#### 临近适应算法（$Next\,Fit$）

+ 算法思想
    + 首次适应算法每次都从链头开始查找的
    + 这可能会导致低地址部分出现很多小的空闲分区,而每次分配查找时,都要经过这些分区
    + 因此也增加了查找的开销
    + 如果每次都**从上次查找结束的位置**开始检索,就能解决上述问题.

+ 如何实现
    + 空闲分区以**地址 递增**的顺序排列（可排成一个循环链表）
        + 递增:从小到大

    + 每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表）
    + 找到大小能满足要求的第一个空闲分区.

+ 优点：减少了检索空闲分区的次数,提高了效率.
+ 缺点：邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用,也就导致了高地址部分的大分区更可能被使用,划分为小分区,最后导致无大分区可用.

所以综合效果来看,首次适应算法>最佳适应法?临近适应法>最大适应法.

首次适应法和临近适应法只用简单查找,最佳适应法和最大适应法都需要对可用块进行排序和遍历.

### 基本分页存储管理

![image-20230622235206918](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306222352013.png)

#### 分页

+ 页框和页框号
    + 将**内存空间**分为一个个大小相等的分区,每个分区就是一个“页框”（$Page\,Frame$）,或称“页帧”、“内存块”、“物理块”
        + 页框=页帧=内存块=物理块=物理页面

    + 每个页框有一个编号,即“页框号”（或者“内存块号”、“页帧号”、“物理块号”）
        + 页框号从$0$开始.
        + 页框号=页帧号=内存块号=物理块号=物理页面号
    
    + 页框不能太大,否则可能产生过大的内部碎片
    
    + 页框不能太小,否则会导致页面数过大,页表过长占用内存,同时增加硬件地址转换的开销,降低页面换入换出的效率.
    
+ 页和页号
    + 将**用户进程的地址空间**也分为**与页框大小相等**的一个个区域,称为“页”（$Page$）或“页面”.

    + 每个页面也有一个编号,即“页号”,页号也是从$0$开始.所以页面不同于页框,是进程的逻辑概念.（进程的最后一个页面可能没有一个页框那么大.）

+ 操作系统以页框为单位为各个进程分配内存空间.进程的每个页面分别放入一个页框中.也就是说,进程的页面与内存的页框有**一一对应**的关系.
+ 外存中也同样的单位进行划分,直接称为“块”（$Block$）.
+ 各个页面不必连续存放,也不必按先后顺序来,可以放到不相邻的各个页框中.
+ 为了方便计算页号、页内偏移量、页面大小一般设为$2$的整数幂.
+ 如果每个页面大小为$2^kB$,用二进制数表示逻辑地址,则末尾$k$位即为页内偏移量,其余部外就是页号.
+ 由于是对程序根据内存大小进行分页,所以只对硬件和操作系统是可见的,对于连接装配程序、编译系统、用户都是透明的.

#### 地址结构

+ 分为页面偏移量$W$和页号$P$两个部分.
+ 以32位计算机为例,地址长度为$32$位,$0\sim11$是页内地址,即**页内偏移量**,每页大小为$4KB$.
    + 如果有$K$位表示“页内偏移量”，则说明该系统中一个页面的大小是$2^K$个内存单元

+ $12\sim31$为**页号**,代表每个进程内的页的顺序,地址空间最多允许$2^{20}$页.
    + 如果有$M$位表示“页号”，则说明在该系统中，一个进程最多允许有$2^M$个页面

+ **【重要考点】：**
    + 页面大小$\rightleftharpoons $页内偏移量位数$\longrightarrow  $逻辑地址结构


#### 页表

+ 操作系统要为每个进程建立一张页表,其中页表大小也与页面一样被页框约束.
    + 进程的各个页能被**离散**的存储在内存不同的物理块
    + 在进行进程切换时,需要切换页表,即将新进程的页表加载到内存中,并将处理器的页表指针指向新的页表

+ 页表一般存放在$PCB$即进程控制块中
+ 页表组成
    1. 一个进程对应一张页表和一个逻辑地址
    2. 进程的每一页对应一个页表项
    3. 每个**页表项**由“页号”和“块号”组成
        + 页表项连续存放,因此页号可以是隐含的,**不占存储空间**（类比数组）
        + 块号的求法:参考以下例题
            1. 物理内存大小除以页面大小得到内存块号表示位数
                + 单位是$bit$
            2. $bit$除以$8$换算成字节得到页表项中块号至少占多少字节
        + **【注意】:**
            + **页表记录的只是内存块号,而不是内存块的起始地址！**
            + $J$号内存块的起始地址=$J\times$内存块大小
                + 页框号(内存块号)从$0$开始
    4. 页表记录进程**页面**和实际存放的**内存块**之间的映射关系.
    5. 每个页表项的长度是相同的 
+ 当进程未执行,则页表始址和页表长度在其$PCB$中,执行时将其装入$PTR$（页表始址寄存器）中从而进驻内存.

假设某系统物理内存大小为$4GB$,页面大小为$4KB$,则每个页表项至少应该为多少字节？

+ 首先$4GB=2^{32}B$,$4KB=2^{12}B$.
+ 因此$4GB$的内存总共会被分为$2^{32}\div2^{12}= 2^{20}$个内存块,因此内存块号的范围应该是$0\sim2^{20}-1$,因此至少要$20bit$($20$个二进制位)才能表示这么多的内存块号
    + 因此至少要$3$个字节才够,因为每个字节$8$位,$3\times8=24>20$.

+ 所以至少需要$3B$来表示块号.
    + **【注意】：重要重要重要重要考点**
        + 计算机中内存块的数量$\to$页表项中块号至少占多少字节

+ 由于页号是隐含的,因此每个页表项占$3B$
+ 深入来看
    + 因为每页表项会顺序连续存储在内存中,若该页表在内存中存放的起始地址是$X$
    + 则$M$号页对应的页表项存放在内存地址$X+3\times M$.
    + 同时因为页面大小为$4KB$,所以每个页框（即可用存放的最大值）大小为$4\times1024\div3=1365$个页表项
    + 但是此时每页会余下$4\times1024\mod3=1$页内碎片,所以一定会在中间空出内存
    + 所以$1365$号页在页框约束下会在新的下一个页框存储,表项会存放在$X+3\times1365+1$处
        + 这时候地址公式就不管用了.

    + 而如果每个页表项占$4$字节,则每个页框刚好能放下$1024$个页表项,从而没有余数,能减少查找的麻烦.

+ 所以理论上$3B$就能表示内存块的范围,但是为了方便页表查找（对齐）,实际上会多一些字节,使得每个页面能装下整数个页表项.

#### 页式基本地址变换机构

+ 每个页面的特点
    + 虽然进程的各个页面是离散存放的,但是页面内部是连续存放的

+ 可用借助页表进行转换,通常会在系统中设置**一个**页表寄存器（$PTR$）,存放页表在内存中的起始地址$F$和页表长度$M$（即这个进程里有多少页）
+ 进程未执行时,页表的始址和页表长度放在进程控制块（$PCB$）中,当进程被调度时,操作系统内核会把它们放到页表寄存器中.
+ 在页式存储管理的系统中时,只用确定页面大小和逻辑结构就能得到物理地址.

基本地址变换机构需要先查询页表,再查询内存两次操作：

1. 要算出逻辑地址$A$对应的页号$P$与页内偏移量$W$.
    + 页号$P$=逻辑地址$A\div$页面长度$L$
    + 页内偏移量$W$=$A$逻辑地址$\%$页面长度$L$
2. 检测页号$P$是否越界.如果页号$P$大于等于页表长度$M$,则内中断（因为页号从$0$开始,页表长度至少为$1$,从而$P=M$页会越界）.
3. 根据页表寄存器中的页表项地址$PA$=页表起始地址$F$+页号$P$×页表项长度$PL$,得到页表中对应的页表项,从而确定页面存放的内存块号$B$.
    + 页表长度指的是这个页表中总共有几个页表项,即总共有几个页.
    + 页表项长度指的是每个页表顶占多大的存储空间.
    + 页面大小指的是一个页面占多大的存储空间.
4. 最后物理地址$E$=内存块号$B$×页面大小$L$+页内偏移量$W$
    + 如果页面大小是$2$的整数次幂,则转换二进制直接拼接起来就是最终物理地址了



**【例题】：**

+ 在某计算机系统中，页面大小是$50B$。某进程逻辑地址空间大小为$200B$,则逻辑地址`110`对应
    的页号、页内偏移量是多少？

**【解答】：**

+ ![image-20230622234130894](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306222341944.png)
+ 页号$=110/50=2$
+ 页内偏移量$=110\%50=10$

#### 快表地址变换机构

+ 时间局部性：如果执行了程序中的某条指令,那么不久后这条指令很有可能再次执行;如果某个数据被访问过,不久之后该数据很可能再次被访问（因为程序中存在大量的循环）.
+ 空间局部性：一旦程序访问了某个存储单元,在不久之后,其附近的存储单元也很有可能被访问（因为很多数据在内存中都是连续存放的）.
+ 快表,又称相联寄存器（$TLB$）,是一种访问速度比内存快很多的高速缓冲存储器,用来存放当前访问的若干页表项,以加速地址变换的过程,此是其物理特性.与此对应,内存中的页表常称为慢表.
+ 由于查询快表的速度比查询页表的速度快很多,因此只要快表命中,就可以节省很多时间.
+ 因为局部性原理,一般来说快表的命中率可以达到$90\%$以上.
+ 快表的地址变换过程：
    1. $CPU$给出逻辑地址,由某个硬件算得页号、页内偏移量,将页号与快表中的所有页号进行比较.
    2. 如果找到匹配的页号（即命中）,说明要访问的页表项在快表中有副本,则直接从中取出该页对应的内存块号,再将内存块号与页内偏移量拼接形成物理地址,最后,访问该物理地址对应的内存单元.因此,若快表命中,则访问某个逻辑地址仅需一次访存即可.
    3. 如果没有找到匹配的页号,则需要访问内存中的页表,找到对应页表项,得到页面存放的内存块号,再将内存块号与页内偏移量拼接形成物理地址,最后,访问该物理地址对应的内存单元.同时将其存入快表,以便后面可能的再次访问.但若快表已满,则必须按照一定的页面置换算法对旧的页表项进行替换.因此,若快表未命中,则访问某个逻辑地址需要两次访存.

#### 多级页表

单级页表的缺点：

1. 单级页表的所有表项都必须连续存储,实现起来比较困难.
2. 进程在一段时间内只需要访问少数页面就可用正常运行,无需整个页表都常驻内存.

将页表进行分组离散地放入内存块,并为离散分组的页表再建立一张页表,称为页目录表、外层页表或顶层页表,页目录表页保存序号和内存块号两项.两级页表结构的逻辑地址结构分为一级页号、二级页号和页内偏移量三项.

地址转换过程：

1. 按照地址结构将逻辑地址拆分成三部分.
2. 从$PCB$中读出页目录表始址,再根据一级页号查页目录表,找到下一级页表在内存中的存放位置（物理地址）.
3. 根据二级页号查表,找到最终想访问的内存块号.
4. 结合页内偏移量得到物理地址.

注意点：

+ 若采用多级页表机制,则各级页表的大小不能超过**一个**页面.因为顶级页表只能有一个,否则一个页面放不下页表项.如果一个页面框放不下就需要多个页面框,而如果需要多个页面框就会导致多个页面框有相同的页号,就不能区分出哪个是顶级页表.
+ 两级页表的访存次数分析（假设没有快表机构）：
    1. 第一次访存：访问内存中的页目录表.
    2. 第二次访存：访问内存中的二级页表.
    3. 第三次访存：访问目标内存单元.

多级页表会使用页表基址寄存器（$PTBR$）来存储页表基址,此时$PTBR$会存储当前进程的一级页表的物理地址.

### 基本分段存储管理

#### 分段

+ 进程的地址空间：按照程序自身的逻辑关系划分为若干个不等长的段,每个段都有一个段名（在低级语言中,程序员使用段名来编程）,每段从$0$开始编址.
+ 内存分配规则：以段为单位进行分配,每个段在内存中占据连续空间,但各段之间可以不相邻.
+ 分段系统的逻辑地址结构由段号（段名$S$）和段内地址（段内偏移量$W$）所组成.
+ 段号的位数决定了每个进程最多可以分几个段段内地址位数决定了每个段的最大长度是多少.
+ 页式系统中逻辑地址的页号和页内偏移量对用户透明,但是段式系统段号和段内偏移量必须用户显式提供,一般由编译程序完成.
+ 程序分多个段,各段离散地装入内存,为了保证程序能正常运行,就必须能从物理内存中找到各个逻辑段的存放位置.为此,需为每个进程建立一张段映射表,简称“段表”：
    1. 每个段对应一个段表项,其中记录了段号、该段在内存中的起始位置（又称“基址”）和段的长度.
    2. 各个段表项的长度是相同的.
+ 即使段是共享的,但是不同的程序中使用,其段号也是不同的.

某系统按字节寻址,采用分段存储管理,逻辑地址结构为（段号$16$位,段内地址$16$位）,因此用$16$位即可表示最大段长.物理内存大小为$4GB$（可用$32$位表示整个物理内存地址空间).因此,可以让每个段表项占$16+32=48$位,即$6B$.由于段表项长度相同,因此段号可以是隐含的,不占存储空间.若段表存放的起始地址为$R$,则$K$号段对应的段表项存放的地址为$R+K\times6$,段号并不占内存空间.

分段的优点：

+ 方便共享和保护.
+ 方便编程.
+ 方便动态链接和增长.

#### 段式存储地址变换过程

1. 根据逻辑地址得到段号$S$和段内地址$W$.
2. 根据段号$S$是否大于等于段表寄存器的段表长度$M$,判断上是否越界,若是则越界中断.（段表长度至少为$1$）.
3. 查询段表寄存器中的段表,找到对应的段表项,段表项分为段长$C$和段基址$B$,段表项的存放地址$SA$=段表始值$F$+段号$S$×段表项长度$SL$.
4. 检测段内地址$W$是否大于等于段长$C$（这也是段式存储与页式存储的最大不同,段式存储不定长）,若是则越界中断.
5. 计算得到物理地址$E$=段基址$B$+段内地址$W$.

#### 分段分页管理的区别

| &nbsp; |  与信息的关系  |          主要目的           |                        是否对用户可见                        |            长度             |                       用户进程地址空间                       |
| :----: | :------------: | :-------------------------: | :----------------------------------------------------------: | :-------------------------: | :----------------------------------------------------------: |
|  分页  | 信息的物理单位 | 实现离散分配,提高内存利用率 |    仅仅是系统管理上的需要,完全是系统行为,对用户是不可见的    |  页的大小固定且由系统决定   |      是一维的,程序员只需给出一个记忆符即可表示一个地址       |
|  分段  | 信息的逻辑单位 |     更好地满足用户需求      | 一个段通常包含着一组属于一个逻辑模块的信息.分段对用户是可见的,用户编程时需要显式地给出段名 | 不固定,决定于用户编写的程序 | 二维的,程序员在标识一个地址时,既要给出段名,也要给出段内地址. |

+ 分段比分页更容易实现信息的共享和保护.
+ 只需让各进程的段表项指向同一个段即可实现共享.
+ 不能被修改的代码称为纯代码或可重入代码（不属于临界资源）,这样的代码是可以共享的.可修改的代码是不能共享的（比如,有一个代码段中有很多变量,各进程并发地同时访问可能造成数据不一致）.
+ 分页时页面不是按逻辑模块划分的.这就很难实现共享.

在计算地址时,段式存储的基址往往以十进制的位置给出,计算的结果需要与偏移量相加,最后转换为十六进制,页式存储的基址往往以十六进制的位置给出,计算的结果需要与偏移量直接拼接.

### 段页式存储管理

|  &nbsp;  |                          优点                          |                             缺点                             |
| :------: | :----------------------------------------------------: | :----------------------------------------------------------: |
| 分页管理 | 内存空间利用率高,不会产生外部碎片,只会有少量的页内碎片 |            不方便按照逻辑模块实现信息的共享和保护            |
| 分段管理 |         很方便按照逻辑模块实现信息的共享和保护         | 如果段长过大,为其分配很大的连续空间会很不方便.另外,段式管理会产生外部碎片 |

#### 段页式存储的过程

1. 将进程按逻辑模块分段,再将各段分页（如每个页面$4KB$）.
2. 再将内存空间分为大小相同的内存块/页框/页帧/物理块.
3. 进程前将各页面分别装入各内存块中.

#### 段页式系统逻辑地址结构

+ 由段号$S$、页号$P$、页内地址$W$（页内偏移量）组成.段号的位数决定了每个进程最多可以分几个段.页号位数决定了每个段最大有多少页.页内偏移量决定了页面大小、内存块大小是多少.
+ 系统含有一个段表寄存器,指出作业的段表始址和段表长度.
+ “分段”对用户是可见的,程序员编程时需要显式地给出段号、段内地址.而将各段“分页”对用户是不可见的.系统会根据段内地址自动划分页号和页内偏移量.
+ 因此段页式管理的地址结构是二维的.

地址表分为段表和页表,段表只能有一个,页表可以有多个：

+ 每个段对应一个段表项,每个段表项由段号、页表长度、页表存放块号（页表起始地址）组成.每个段表项长度相等,段号是隐含的.
+ 每个页面对应一个页表项,每个页表项由页号、页面存放的内存块号组成.每个页表项长度相等,页号是隐含的.
+ 一个进程对应一个段表,对应一个或多个页表项,一个段表项就相当于只存一个的页表寄存器.

#### 段页式存储地址变换过程

1. 根据逻辑地址得到段号$S$、页号$P$和页内偏移量$W$.
2. 根据段号$S$是否大于等于段表寄存器的段表长度$M$,判断上是否越界,若是则越界中断.（段表长度至少为$1$）.
3. 查询段表寄存器中的段表,找到对应的段表项.段表项分为段号$S$和页表长度$L$、段基址$F$和页表存放块号$D$.段表项的存放地址$SA$=段表始值$F$+段号$S$×段表项长度$SL$.
4. 检测页号$P$是否大于等于页表项长度$PL$,若是则越界中断.
5. 根据页表存放块号$D$和页号$P$查询页表,找到对应页表项.页表项分为页号$P$和内存块号$B$.
6. 计算得到物理地址$E$=内存块号$B$+页内偏移量$W$.
7. 也可引入快表机构,用段号和页号作为查询快表的关键字.若快表命中则仅两次访存.

### <a id='内存空间扩充'>内存空间扩充</a>

![image-20230622213216998](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306222132089.png)

内存空间的扩充（用容量小的内存运行大的程序）有三种技术：

1. 覆盖技术.
2. 交换技术.
3. 虚拟存储技术.使用覆盖和交换可以实现虚拟存储.

前两种技术不是重点.

覆盖和交换技术本质是通过不断换入换出数据,以时间换空间,所以对外存对换区的管理应该以提高交换速度减少交换时间为目标.

#### 覆盖技术*

覆盖技术在同一个程序或进程中执行.可以使用在单一连续分配和固定分区分配的方式.

+ 覆盖技术的思想
    + 将程序分为多个段（多个模块）
    + 常用的段常驻内存,不常用的段在需要时调入内存.

+ 内存中分为一个“固定区”和若干个“覆盖区”.
+ 需要常驻内存的段放在“固定区”中,调入后就不再调出（除非运行结束）.
+ 不常用的段放在“覆盖区”,需要用到时调入内存,用不到时调出内存.
+ 按照自身代码逻辑结构,让那些不可能同时被访问的程序段共享同一个覆盖区.
+ 覆盖技术只用于早期的操作系统中,现在已成为历史.
+ 缺点：
    + 必须由程序员声明覆盖结构,操作系统完成自动覆盖.
    + 对用户不透明,增加了用户编程负担.

#### 交换技术*

交换技术在不同进程或作业之间进行的.

+ 交换（对换）技术的设计思想
    + 内存空间紧张时,系统将内存中某些进程暂时换出外存,把外存中某些已具备运行条件的进程**换入**内存
    + 进程在内存与磁盘间动态调度

+ 交换的位置
    + 具有对换功能的操作系统中,通常把磁盘空间分为**文件区**和**对换区**两部分
    + 文件区主要用于存放文件,主要追求存储空间的利用率,因此对文件区空间的管理采用离散分配方式
    + 对换区空间只占磁盘空间的小部分,被换出的进程数据就存放在对换区
    + 由于对换的速度直接影响到系统的整体速度,因此对换区空间的管理主要追求换入换出速度,因此通常对换区采用连续分配方式
    + 总之,对换区的$I/O$速度比文件区的更快.

+ 交换的时机
    + 交换通常在许多进程运行且内存吃紧时进行,而系统负荷降低就暂停
    + 例如在发现许多进程运行时经常发生缺页,就说明内存紧张,此时可以换出一些进程
    + 如果缺页率明显下降、就可以暂停换出.

+ 交换进程的选择
    + 可优先换出**阻塞进程**.
    + 可换出**优先级低**的进程.
    + 为了防止优先级低的进程在被调入内存后很快又被换出,考虑进程在内存的驻留时间.
+ 暂时换出外存等待的进程状态是挂起状态.
+ 处理机调度的中级调度（内存调度）就是交换技术的实现.
+ 进程的$PCB$常驻内存,不会被换出外存

覆盖用于同一个进程或程序中,交换用于不同进程或作业之间.

