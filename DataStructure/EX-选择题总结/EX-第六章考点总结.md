# EX-第六章 图考点总结

## 导读

### 【考纲内容】

1. 图的基本概念
2. 图的存储及基本操作
    + 邻接矩阵
    + 邻接表
    + 邻接多重表
    + 十字链表
3. 图的遍历：深度优先搜索、广度优先搜索
4. 图的基本应用
    + 最小（代价）生成树
    + 最短路径
    + 拓扑排序
    + 关键路径

### 【复习提示】

选择题：深度优先搜索与广度优先搜索、图的基本概念及基本性质、图的存储结构（邻接矩阵、邻接表、邻接多重表和十字链表）及其特性、存储结构之间的转化、基于存储结构上的遍历操作和各种应用（拓扑排序、最小生成树、最短路径和关键路径）及图相关算法的基本思想和实现步骤

## 选择题考点总结

### 图概述

1.   无向图：若$E$是无向边（简称边）的有限集合时，则图$G$为无向图。边是顶点的无序对，记为$(v,w)$或$(w,v)$，因为$(v,w)=(w,v)$，边$(v,w)$依附于顶点$w$和$v$，或者说边$(v,w)$和顶点$v$、$w$相关联。
2.   有向图：若$E$是有向边（也称弧）的有限集合时，则图$G$为有向图。弧是顶点的有序对，记为$<v,w>$，其中$v$、$w$是顶点，$v$称为弧尾，$w$称为弧头，$<v,w>$称为从顶点$v$到顶点$w$的弧，也称$v$邻接到$w$，或$w$邻接自$v$。
3.   无向完全图：无向图中任意两个顶点之间都存在边。$\vert E\vert=\dfrac{|V|(|V|-1)}{2}$。
4.   有向完全图：有向图中任意两个顶点之间都存在方向相反的两条弧。$$\vert E\vert=\vert V\vert(\vert V\vert-1)$$。
5.   简单图：不存在重复边，且不存在顶点到自身的边。**含环的图一定不是简单图**。
6.   稀疏图：边数很少的图，一般$\vert E\vert<\vert V\vert\log\vert V\vert$。
7.   稠密图：边数很多的图，一般$\vert E\vert>\vert V\vert\log\vert V\vert$。
8.   树：不存在回路，且连通的无向图。**与图是逻辑上的区别**。
9.   有向树：一个顶点的入度为$0$，其余顶点入度均为$1$的有向图。
10.   无向图的度：顶点$v$的度是指依附于该顶点的边的条数，记为$TD(v)$。
11.   有向图的度：入度是指以顶点$v$为终点的有向边的条数，记为$ID(v)$；出度指以顶点$v$为起点的有向边的条数，记为$OD(v)$；顶点$v$的度就是其入度和出度之和。$TD(v)=ID(v)+OD(v)$。
12.   路径：从一个点到另一个点所经过的顶点序列。由顶点和相邻顶点序偶构成的边所形成的**序列**。
      +   路径是**序列**，距离是路径的长度是个**数**
13.   回路（环）：第一个顶点与最后一个顶点相同的路径。
      +   一个只含有一个顶点的图不是环，对于只含有一个顶点的图，由于没有边连接任何其他顶点，因此无法构成环。
14.   长度（无权图）：沿路径所经过的边数成为该路径的长度。
15.   简单路径：路径中的顶点不重复出现。
16.   简单回路：由简单路径组成的回路。除第一个和最后一个顶点外其余顶点不重复出现的回路。
17.   点到点的距离：从顶点$u$到顶点$v$的最短路径若存在，则此路径的长度就是从$u$到$v$的路径。若不存在路径，则记该路径为无穷$\infty$。
18.   连通：在**无向图**中，若从顶点$v$到顶点$u$有**路径**存在，则称$uv$是连通的。
19.   强连通：在**有向图**中，若从顶点$v$到顶点$u$和从顶点$u$到顶点$v$之间都有**路径**（而不是弧），则称$uv$是强连通。
20.   连通图：无向图中任意两个顶点之间都是连通的。只含有一个顶点的图是连通的

      + **当一个连通图包含至少三个节点时，它必定含有环**。
21.   强连通图：有向图中任意两个顶点之间都是强连通的。

      + **当一个强连通图包含至少三个节点时，它必定含有环**。
22.   子图：设有两个图$G=(V,E)$和$G'=(V',E')$，若$V'$是$V$的子集，$E'$是$E$的子集，则$G'$是$G$的子图。
      +   但是不是所有的子集都能构成子图，必须满足原图的关系（即为边和对应的端点，即存在$\varphi'\in\varphi$）的子集才算。
23.   生成子图：若有满足$V(G')=V(G)$的子图$G'$，则$G'$是$G$的生成子图。即子图包含所有顶点，但不一定包含所有的边。
24.   连通分量：无向图$G$中的极大连通子图称为$G$的连通分量

      + 对任何连通图而言，连通分量就是其自身。

      + 对非连通图而言，连通分量可能有多个。
25.   强连通分量：有向图$G$中的极大连通子图称为$G$的强连通分量

      + 对任何强连通图而言，强连通分量就是其自身。

      + 对非强连通图而言，强连通分量可能有多个。
26.   生成树：包含连通图中全部顶点的一个极小连通子图。顶点全部要有，边尽可能的少，但要保持连通。

      + 若图的顶点为$\vert V\vert$，则其生成树包含$\vert V\vert-1$条边。

      + 若去掉生成树的一条边则会变成非连通图，若加上一条边则会形成一个回路。
27.   无向图的极大连通子图：用来讨论**无向图**的连通分量，要求连通子图包含其所有的边。
      + 连通图的极大连通子图就是它本身。
      + 非连通图中有多个连通分量（不同的点相连从而连通），也就是可以有多个极大连通子图。
28.   无向图的极小连通子图：用来讨论**无向图**的生成树，要保持图连通也要让边数最小的子图。      
      + 极小连通子图只在无向图中才有。
      + 极小连通子图中包含图中全部的顶点（和极大不同，极大不要求包含所有的顶点）。
      + 用边将极小连通图中的所有边都连接起
      + 极小连通子图和生成树的概念不是等价的，生成树是包含图中全部顶点的一个极小连通子图。
29.   有向图的极大强连通子图：
      + 强连通图的极大强连通子图为其本身。（是唯一的）
      + 非强连通图有多个极大强连通子图。（非强连通图的极大强连通子图叫做强连通分量）
30.   有向图不存在极小强连通子图的概念，因为树没有方向性。

### 图性质总结

图$G$由顶点集$V$和边集$E$组成，$|V|$，$|E|$分别表示顶点数和边数。

#### 有向图

1.   有向完全图：有向图中任意两个顶点之间都存在方向相反的两条弧，即$\vert E\vert=\vert V\vert(\vert V\vert-1)$
2.   无向图的入度或出度的和均等于有向边的边数，因为每条有向边都有一个起点和终点。$\sum\limits_{i=1}^nID(v_i)=\sum\limits_{i=1}^nOD(v_i)=\vert E\vert$。
3.   强连通有向图，其边的个数至少为$n$，即构成一个有向环
4.   有向图出度之和与入度之和均为$\vert E\vert$，即与边数相等
5.   当一个强连通图包含至少$3$个节点时，它必定含有环
6.   对于$n$个顶点的有向图，每个顶点的度最大为$2n-2$。因为任意一个顶点可以与其他$n-1$个顶点有指向相反的两条边。
7.   对于$n$个顶点的有向图，若其是强连通图，则最少需要$n$条边，即形成环路的情况。
8.   邻接矩阵中，
     1.   第$i$个顶点的出度$=$第$i$行的非零元素个数
     2.   第$i$个顶点的入度$=$第$i$列的非零元素个数
     3.   第$i$个顶点的度$=$第$i$行的非零元素个数$+$第$i$列的非零元素个数。

#### 无向图

1.   无向完全图，无向图中任意两个顶点之间都存在边，即$\vert E\vert=\dfrac{|V|(|V|-1)}{2}$。
2.   对于$n$个顶点的无向图，每个顶点的度最大为$n-1$。
     +   因为任意一个顶点可以与其他$n-1$个顶点相联。默认是简单图，即不能自己连向自己。
3.   $\vert E\vert>n-1$时，一定存在回路
     +   若一个无向图有$n$个顶点和$n-1$条边，可以使它连通但没有环（即生成树）
     +   但若再加一条边，在不考虑重边的情形下，则必然会构成环
4.   一个有$|E|$条边的非连通无向图至少有$m$个顶点，求$m$

     +   考虑该非连通图最极端的情况，即它由一个无向完全图加一个独立的顶点构成，此时若再加一条边，则必然使图变成连通图
     +   由$\vert E\vert=\dfrac{|V|(|V|-1)}{2}$算出$\vert V\vert$
     +   加一个独立的顶点，即$m=\vert V\vert+1$
5.   连通无向图，其边的个数至少为$n-1$，即构成一棵树
6.   具有$\vert V\vert$个顶点的无向图，当有$m$条边时能确保是一个连通图，求$m$

     +   考虑该非连通图最极端的情况，即它由一个无向完全图加一个独立的顶点构成，此时若再加一条边，则必然使图变成连通图
     +   由$\vert E\vert=\dfrac{|V|(|V|-1)}{2}$算出$\vert E\vert$
     +   加一条边，即$m=\vert E\vert+1$
7.   由于每条边都与两个顶点关联，无向图的全部顶点的度的和等于$2\vert E\vert$，即边数的两倍。$\sum\limits_{i=1}^nTD(v_i)=2\vert E\vert$。
8.   无向连通图的每个顶点的度都是$2$。
9.   当一个连通图包含至少$3$个节点时，它必定含有环。
10.   对于$n$个顶点的无向图
      + 若其是连通图，则最少需要$n-1$条边。
      + 若其是非连通图，则最多有$C_{n-1}^2$条边，此时$n-1$个顶点构成一个完全图。
11.   对于$n$个顶点、$e$条边的无向图是一个森林，则一共有$n-e$棵树。
      +   设一共有$x$棵树，则只需要$x-1$条边就能将森林连接为一整棵树，所以边数$+1=$顶点数（树的性质）
      +   即$e+(x-1)+1=n$，解得$x=n-e$。
12.   邻接矩阵中，第$i$个顶点的度=第$i$行或第$i$列的非零元素个数。

#### 一般图

1.   图的顶点数为$\vert V\vert$，图的边数为$\vert E\vert$，当$\vert E\vert\ge\vert V\vert+1$时，图**一定有环**，可能是连通的。

2.   图的顶点数为$\vert V\vert$，图的边数为$\vert E\vert$​，当且仅当
     $$
     \vert E\vert\ge\dfrac{(|V|-1)(|V|-2)}{2}+1
     $$
     时，图才一定是连通的

     +   此时$\vert V\vert-1$个顶点构成一个完全图，若再加入一条边，则一定变成连通图

3.   图一定是非空的，即$V$一定是非空集。

4.   稀疏图：边数很少的图，一般$\vert E\vert<\vert V\vert\log\vert V\vert$

5.  稠密图：边数很多的图，一般$\vert E\vert>\vert V\vert\log\vert V\vert$

6.  若图的顶点为$\vert V\vert$，则其生成树包含$\vert V\vert-1$条边

7.  对于$n$个顶点的环，有$n$棵生成树。

    +   因为$n$个顶点的环的生成树的顶点为$n-1$，去掉任意一条边就能得到一棵生成树，环一共有$n$条边，所以可以去掉$n$条，得到$n$棵生成树。

8.  设图$G$的邻接矩阵为$A$，$A^n$的元素$A^n[i][j]$表示由顶点$i$到顶点$j$长度为$n$的路径数量。

9.  图的广度优先生成树的高度小于等于深度优先生成树的高度。

10.  深度优先遍历可以判断有向图中是否存在回路

11.  深度优先遍历可以得到逆拓扑有序

12.  对于无向图，调用$BFS$函数的次数等于连通分量数

13. 对于非带权图，使用$BFS$可以解决非带权图的单源最短路径问题，因为$BFS$按照距离有近到远

14. 对于同样一个图，基于邻接矩阵存储的遍历所得到的DFS序列和BFS序列是唯一的，基于邻接表存储的遍历所得到的DFS序列和BFS序列是不唯一的。

15. 广度优先生成树

    +   若图顶点为$n$个，则生成树边一共有$n-1$条
    +   若邻接矩阵存储则唯一，若邻接表存储则不唯一。

16. 深度优先生成树

    +   若图顶点为$n$个，则生成树边一共有$n-1$条

17. 最小生成树

    + 最小生成树边的权值总是唯一且最小的。
    + 如果没有权值相同的边，则最小生成树是唯一的。
        + $MST$唯一性定理：$MST$没有使用无向网中相同权值的边，那么$MST$一定唯一
            + 连通图的任意一个环中所包含的边的权值均不相同
        + 充要条件：不存在一条非最小生成树上的边，满足该边的权值与其两端顶点在最小生成树上的路径最小边权相等。
    + 最小生成树的边数=顶点数$-1$
        + 减去一条则不连通，增加一条则会出现回路。
    + 若一个连通图本身就是一棵树，则其最小生成树就是其本身。
    + 只用连通图才有生成树，非连通图只有生成森林。

18. Prim算法适用于边稠密图，Kruskal算法适用于边稀疏顶点多的图

19. 单源最短路径：$BFS$算法（无权图），$Dijkstra$迪杰斯特拉算法（无负权的带权图、无权图）。

20. 每对顶点间最短路径：$Floyd$弗洛伊德算法（带权图、无权图）。

    +   能解决带负权值的问题，但是不能解决带有负权回路的图，即有负权值的边组成回路，这种图可能没有最短路径。

21. 最短路径一定是简单路径（不存在环）。但是无论有没有环的有向图与是否存在最短路径无关。

22. $AOE$网中若有多条关键路径，则应加快包含所有关键路径上的关键活动才能缩短工期。

23. 关键路径是从源点到汇点路径长度量长的路径。

### 图的存储结构

默认矩阵的索引从$0$开始，而顶点编号从$1$开始。

1.   邻接矩阵：用一个一维数组保存顶点，用一个二维数组保存边，这个二维数组就是邻接矩阵。**邻接矩阵的表示方式是唯一的**。
     1.   对于无向图：第$i$个顶点的度=第$i$行或第$i$列的非零元素个数。
     2.   对于有向图：第$i$个顶点的出度$=$第$i$行的非零元素个数、第$i$个顶点的入度$=$第$i$列的非零元素个数、第$i$个顶点的度$=$第$i$行的非零元素个数$+$第$i$列的非零元素个数。
     3.   空间复杂度是$O(\vert V\vert^2)$。只和顶点数相关，和实际的边数无关，适用于存储稠密图（稠密图的边数接近于顶点数的平方级别）。
     4.   给定顶点找到其邻边要扫描一行，时间复杂度为$O(\vert V\vert)$。
     5.   对于无向图，因为没有方向，所以只有两点连接就是连通的，从而**无向图的邻接矩阵都是主对角线对称**的。
     6.   对于无向图，图的边数等于上三角或下三角不包括主对角线的区域内的非零点的数量。
     7.   对于有向图，图的边数等于矩阵内所有非零点的数量。
     8.   若一个有向图的邻接矩阵为三角矩阵（对角线以上或以下的元素为$0$），则图中必**不存在环**。
     9.   对有向图中的顶点适当地编号，使其邻接矩阵为三角矩阵且主对角元全为零（不存在环）的充分必要条件是，该有向图可以进行拓扑排序。
     10.   数学性质：设图$G$的邻接矩阵为$A$，$A^n$的元素$A^n[i][j]$表示由顶点$i$到顶点$j$长度为$n$的路径数量。若$A$矩阵元素为$0$或$1$，则$A^n$的元素$A^n[i][j]$表示由顶点$v_{i+1}$到顶点$v_{j+1}$的长度为$n$的路径的数目。
2.   邻接表：使用一个数组顺序保存图的每一个顶点，称为顶点表。使用链式存储让每一个顶点元素包含一个指向后一条边的指针，称为边表。邻接表的表示方式是不唯一的。
     1.   对于无向图，每个顶点的边链表的顶点数就是该顶点的度。
     2.   对于有向图，每个顶点的边链表的顶点数就是该顶点的出度，而对于入度就只能遍历所有顶点的顶点链表。
     3.   对于无向图，因为同一条边两端的点会重复存储，所以空间复杂度为$O(\vert V\vert+2\vert E\vert)$，而对于有向图空间复杂度为$O(\vert V\vert+\vert E\vert)$。
     4.   给定顶点找到其邻边只需要读取其邻接表，时间复杂度为$O(1)$。
     5.   找到两个顶点是否存在邻边，需要在相应边表中查找另一个顶点。
     6.   对于稀疏图，使用邻接表回更方便。
3.   十字链表：**只能用于存储有向图**。十字链表图表示是不唯一的。空间复杂度为$O(\vert V\vert+\vert E\vert)$。
     1.   表示顶点的顶点：数据域、该顶点作为弧头的第一条弧、该顶点作为弧尾的第一条弧。
     2.   弧顶点，被$1.$指向的顶点：弧尾顶点编号、弧头顶点编号、权值、弧头相同的下一条弧、弧尾相同的下一条弧。
4.   邻接多重表：**只能用于存储无向图**。邻接多重表表示是不唯一的。空间复杂度为$O(\vert V\vert+\vert E\vert)$。
     1.   表示顶点的顶点：数据域、该顶点作为弧尾的第一条边。
     2.   弧顶点，被$1.$​指向的顶点：边一端编号$i$、边另一端编号$j$、权值、依附于$i$的下一条边、依附于$j$的下一条边。

### 图的基本操作

1.   查找边
     1.   使用邻接矩阵只用根据对应行列的元素是否为$1$或某值就可以了，如果是$0$或无穷，就代表没有该邻边。时间复杂度为$O(1)$。
     2.   使用邻接矩阵需要从一端点出发遍历对应的顶点链表，如果能在链表中找到另一端点的索引，就代表有边。时间复杂度为$O(1)$到$O(\vert V\vert)$。
2.   查找点邻边
     1.   对于无向图，邻接矩阵需要遍历对应顶点的那一行，所有数值为$1$或某数值的列就是对应的有边的另一个端点。时间复杂度为$O(\vert V\vert)$。
     2.   对于有向图，邻接矩阵需要遍历对应顶点的那一行得到出边以及那一列代表入边，所有数值为$1$或某数值的列就是对应的有边的另一个端点。时间复杂度为$O(\vert V\vert)$。
     3.   对于无向图，邻接表只用遍历对应顶点的顶点链表就可以。时间复杂度为$O(1)$到$O(\vert V\vert)$。
     4.   对于有向图，邻接表用遍历对应顶点的顶点链表得到出边，而对于入边需要遍历所有邻接表的边顶点。出边时间复杂度为$O(1)$到$O(\vert V\vert)$，入边时间复杂度为$O(\vert E\vert)$。
3.   查找头邻接点
     1.   邻接矩阵只用扫描对应的行，找到顶点就可以了。时间复杂度为$O(1)$到$O(\vert V\vert)$。
     2.   对于无向图，邻接表只用找到顶点的边顶点的第一个顶点。时间复杂度为$O(1)$。
     3.   对于有向图，出边邻接表只用找到顶点的边顶点的第一个顶点。时间复杂度为$O(1)$。而对于入边需要遍历所有的顶点的第一个链表顶点。时间复杂度为$O(1)$到$O(\vert E\vert)$。
4.   查找下一个邻接点
     1.   邻接矩阵只用扫描对应的行，找到顶点就可以了。时间复杂度为$O(1)$到$O(\vert V\vert)$。
     2.   邻接表只用找到当前顶点的下一个顶点。时间复杂度为$O(1)$。
5.   图插入
     1.   邻接矩阵只用在最后增加一行一列。时间复杂度是$O(1)$。
     2.   邻接表只用在存储顶点的数组的末尾添加一个顶点，指针设置为$NULL$。时间复杂度是$O(1)$。
6.   图删除
     1.   邻接矩阵的删除元素分为两种方式，如果是直接删除对应元素行与列上的所有元素并移动其他元素，那么时间复杂度就是$O(\vert V\vert^2)$，如果删除对应元素行与列上的所有元素但是不移动其他元素，而是将保存顶点数据的数组中对应顶点的数据变为初始值，则时间复杂度就是$O(\vert V\vert)$。
     2.   对于无向图，邻接表的删除需要删除该顶点并删除顶点后连接的所有顶点链表元素，时间复杂度为$O(1)$到$O(\vert V\vert)$。
     3.   对于有向图，邻接表的删除需要删除该顶点并删除顶点后连接的所有顶点链表元素且还要遍历所有的边并删除，删除出边时间复杂度为$O(1)$到$O(\vert V\vert)$，删除入边时间复杂度为$O(\vert E\vert)$。

### 图遍历

1.   广度优先遍历$BFS$：类似二叉树的**层序遍历**。广度优先算法不需要回退，所以不是一个递归算法。

     1.   实现条件：找到一个与顶点相邻的所有顶点、标记哪些顶点被访问过、需要一个**辅助队列**保存顶点是否被访问的数据。
     2.   对于无向图，调用$BFS$函数的次数等于连通分量数。
     3.   对于非带权图，使用$BFS$可以解决非带权图的单源最短路径问题，因为$BFS$按照距离有近到远。
     4.   空间复杂度为$O(\vert V\vert)$。
     5.   邻接矩阵实现时的时间复杂度为$O(\vert V\vert^2)$
          + 访问$|V|$个结点需要$O(|V|)$的时间，查找每个顶点的邻接点都需要$O(|V|)$的时间，而总共有$|V|$个顶点
          + 则总的时间为$O(\vert V\vert^2)+O(\vert V\vert)=O(\vert V\vert^2)$
     6.   邻接表实现时的时间复杂度为$O(\vert V\vert+\vert E\vert)$
          + 访问$|V|$个结点需要$O(|V|)$的时间，查找每个顶点的邻接点都需要$O(|E|)$的时间
          + 则总的时间为$O(\vert V\vert+|E|)$
2.   广度优先遍历过程：

     1. 选择起始点并访问顶点$v$。
     2. 访问$v$的所有未被访问的邻接点。
     3. 依次从这些邻接点（在$2.$中访问的顶点）出发，访问它们的所有未被访问的邻接点
         +   依此类推，直到图中所有访问过的顶点的邻接点都被访问。
     4. 若图中尚未有顶点被访问，则另选一个未曾被访问的顶点作为起始点重复过程。
3.   广度优先生成树：根据广度优先遍历可以将所有第一次访问顶点时的路径组合生成一个广度优先生成树

     1.   若图顶点为$n$个，则生成树边一共有$n-1$条。
     2.   若邻接矩阵存储则唯一，若邻接表存储则不唯一。
     3.   广度优先生成森林：若图是不连通的，那会生成连通分量个广度优先生成树，就构成了广度优先生成森林。
4.   深度优先遍历：是一个递归算法，所以需要一个工作栈。
     1.   邻接表的深度优先序列会优先选择每个顶点的第一个相邻顶点，即顶点链中的第一个元素。

     2.   邻接矩阵方式唯一，所以深度优先序列唯一；而邻接表方式不唯一，所以深度优先序列不唯一。
     3.   可以判断有向图中是否存在回路。
     4.   使用$DFS$算法递归地遍历一个无环有向图，并在退出递归时输出相应顶点，这样得到的顶点序列是逆拓扑有序
          + 因为栈的先进后出特性 

     5.   邻接矩阵实现时的时间复杂度为$O(\vert V\vert^2)$，邻接表实现时的时间复杂度为$O(\vert V\vert+\vert E\vert)$；空间复杂度为$O(\vert V\vert)$。
5.   深度优先遍历过程：

     1. 访问顶点$v$。
     2. 依次从$v$的未被访问的邻接点出发，对图进行深度优先遍历。
     3. 直至图中和$v$有路径相通的顶点都被访问。
     4. 若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。
6.   深度优先生成树：根据深度优先遍历可以将所有第一次访问顶点时的路径组合生成一个深度优先生成树。
     1.   若图顶点为$n$个，则生成树边一共有$n-1$条
     2.   因为保存图的数据结构若是不唯一，则其深度优先生成树也是不唯一的
     3.   如果无向图非连通，则一个顶点出发只能一次性遍历到该顶点所在连通分量的所有顶点。
7.   **图的广度优先生成树的高度小于等于深度优先生成树的高度**。

### 图的应用

#### 最小生成树

1.   最小生成树$MST(Minimum-Spanning-Tree)$：已知生成树就是最小边的能到任意顶点的树，这种树只关心边数，所以有多个不同的生成树。而最小生成树就是带权生成树的最小权值和的情况。
     1.   最小生成树边的权值总是唯一且最小的。
     2.   如果没有权值相同的边，则最小生成树是唯一的。
          + $MST$唯一性定理：$MST$没有使用无向网中相同权值的边，那么$MST$一定唯一
              + 连通图的任意一个环中所包含的边的权值均不相同
          + 无向图中存在相同权值的边是最小生成树**不唯一**的必要条件（但不是充分条件，也可能唯一）
          + $MST$唯一充要条件：不存在一条非最小生成树上的边，满足该边的权值与其两端顶点在最小生成树上的路径最小边权相等。

     3.   最小生成树的边数=顶点数$-1$。减去一条则不连通，增加一条则会出现回路。

     4.   若一个连通图本身就是一棵树，则其最小生成树就是其本身。
     5.   只用连通图才有生成树，非连通图只有生成森林。
2.   普里姆算法$Prim$：从某个顶点开始构建生成树，每次将代价最小的新顶点纳入生成树，直到所有顶点都纳入为止。
     1.   需要遍历$\vert V\vert$个顶点，每次要遍历其他所有顶点。
     2.   时间复杂度为$O(\vert V\vert^2)$：从$V_0$开始,总共需要$n-1$轮处理，每一轮时间复杂度为$O(2n)$，总时间复杂度为$O(n^2)$,即$O(|V|)^2$。

     3.   适用于边稠密图。
3.   普里姆算法构造$MST$过程
     1.   假设$G=\{V,E\}$是连通图，其最小生成树$T=(U,E_T)$，$E_T$是最小生成树中边的集合。
     2.   初始化：向空树$T=(U,E_T)$中添加图$G=(V,E)$的任一顶点$u_0$，使$U=\{u_0\}$，$E_T=\varnothing$。
     3.   循环（重复下列操作直至$U=V$）：从图$G$中选择满足$\{(u,v)|u\in U,v\in V-U\}$且具有最小权值的边$(u,v)$，加入树$T$，置$U=U\cup\{v\}$，$E_T=E_T\cup\{(u,v)\}$。
4.   克鲁斯卡尔算法$Kruskal$：每次选择一条权值最小的边，使这条边的两头连通，若本就连通的就不选，直到所有的顶点都连通。
     1.   使用堆来存放边（所以可以二分查找），所以每次旋转最小权值的边只需要$O(\log\vert E\vert)$的时间。
     2.   时间复杂度为$O(\vert E\vert\log_2\vert E\vert)$。
     3.   适用于边稀疏顶点多的图。
5.   克鲁斯卡尔算法构造$MST$过程
     1.   假设$G=(V,E)$是连通图，其最小生成树$T=(U, E_T)$。
     2.   初始化：$U=V,E_T=\varnothing$。即每个顶点构成一棵独立的树，$T$此时是一个仅含$\vert V\vert$个顶点的森林。
     3.   循环（重复下列操作直至$T$是一棵树）：按$G$的边的权值递增顺序依次从$E-E_T$中选择一条边，若这条边加入$T$后不构成回路，则将其加入$E_T$，否则舍弃，直到$E_T$中含有$n-1$条边。

#### 最短路径

1.   $BFS$算法：适用于无权图的单源最短路径算法。定义两个数组，索引号就代表元素的序号，一个数组表示从起点开始到该点的最短路径长度，另一个数组表示从起点开始到该点的最短路径的上一个顶点的索引值。

2.   迪杰斯特拉算法$Dijkstra$：适用于无负权的带权图、无权图的单源最短路径算法。

     1.   与$Prim$算法类似，使用贪心算法，优先与最短的路径结合
     2.   使用邻接矩阵和带权的邻接表表示时，时间复杂度均为$O(\vert V\vert^2)$。
     3.   $Dijkstra$算法不适用于含有负权值的带权图。

3.   迪杰斯特拉算法的实现

     1.   从$v_0$开始，初始化三个数组
          1.   $final$：标记各顶点是否已找到最短路径
          2.   $dist$：源$v_0$到其他所有各顶点的最短路径长度，初始化为若从$v_0$到$v_i$有弧，则$dist[i]$为弧上的权值，否则置为$\infty$。
          3.   $path$：源$v_0$到其他所有各顶点最短路径上的前驱，$path[i]$表示从源点到顶点，之间的最短路径的前驱结点。
     2.   然后将$v_0$直连的点的$dist$值初始化为直连路径长度，对应的$path=0$
          +   但是不要将对应的$final=true$，因为还没有确定对应的直连路径就是最短路径，其他顶点的$dist=\infty$。
     3.   遍历所有顶点确定下一个最短路径的顶点，令其各顶点是否已找到最短路径的值$final=true$。
          1.   $final=0$：找到还没确定最短路径。
          2.   $dist$最小：最短路径长度值最小的的一个顶点。
     4.   检查所有邻接这个顶点的其他顶点，若其点还没有找到最短路径，则更新最短路径长度值与最短路径上前驱的值。
     5.   重复步骤二再次循环遍历所有顶点并找到没确定最短路径则最短路径长度最小的顶点。重复次数为$n-1$次。

4.   弗洛伊德算法$Floyd$：适用于带权图、无权图的每对顶点间最短路径算法。是一种动态规划算法。

     1.   时间复杂度为$O(\vert V\vert^3)$。不过由于其代码很紧凑，且并不包含其他复杂的数据结构，因此隐含的常数系数是很小的，即使对于中等规模的输入来说，它仍然是相当有效的。
     2.   空间复杂度为$O(\vert V\vert^2)$。
     3.   也可以用单源最短路径算法来解决每对顶点之间的最短路径问题，轮流将每个顶点作为源点，并且在所有边权值均非负时，运行一次$Dijkstra$算法，其时间复杂度为$O(\vert V\vert^2)\cdot\vert V\vert= O(\vert V\vert^3)$。

     4.   $Floyd$算法复杂度高，所以基本上都是四个顶点以下的图，**能解决带负权值的问题，但是不能解决带有负权回路的图**，即有负权值的边组成回路，这种图可能没有最短路径。

5.   弗洛伊德算法的实现：算法需要遍历$n$次，每次遍历都需要查看$n\times n$的矩阵中是否有更优的中转点。

     判断若$A^{(k-1)}[i][j]>A^{(k-1)}[i][k]+A^{(k-1)}[k][j]$是否成立。若成立则

     1.   $A^{(k)}[i][j]=A^{(k-1)}[i][k]+A^{(k-1)}[k][j]$，其中二维数组$A^{(k)}$表示的是允许$v_0\cdots v_k$个点中转后各顶点的最短路径长度。

          本式表示在添加中转结点$k$后结点$i$到结点$j$的距离($A[i][j]$)是否在路过结点$k$后变短，变短确认通过中间顶点$k$缩短了起始顶点$i$到目标顶点$j$的距离后更新最短路径$A^{(k)}[i][j]$。

     2.   $path^{(k)}[i][j]=k$，其中$path^{(k)}$表示允许$v_0\cdots v_k$个点中转后两个点之间的中转点。

          本式表示确认通过中间顶点$k$缩短了起始顶点$i$到目标顶点$j$的距离在$path$处做标记，表示通过结点$k$可以缩短路径。

     否则$A^{(k)}$和$path^{(k)}$保持原样。

#### 有向无环图

1.   有向无环图：若一个有向图中不存在环，则是有向无环图，简称$DAG$图。

2.   表达式应用：用树表示表达式，将操作数共同的顶点部分删除并将边合并到一起，这就形成了图，从而能精简表达式。顶点中**不可能出现重复的操作数**。表达式树不唯一。

     1.   把各个单个的操作数不重复的排成一排。

     2.   标出各个运算符的生效顺序。

     3.   按顺序加入运算符，并注意对运算符的优先级进行分层。

     4.   当构建完成后从底向上逐层检查同层的运算符是否可以合并。

3.   $AOV$网：用$DAG$图表示一个工程，顶点表示活动，有向边$<v_i,v_j>$表示活动$v_i$必须先于活动$v_j$进行。

4.   拓扑排序：在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序。拓扑排序简单来说就是找到工程执行的先后顺序。

     1.   每个顶点出现且只出现一次。
     2.   若顶点$A$在序列中排在顶点$B$的前面，则在图中不存在从顶点$B$到顶点$A$的路径。
     3.   时间复杂度若使用邻接表为$O(\vert V\vert+\vert E\vert)$，若使用邻接矩阵则是$O(\vert V\vert^2))$。

5.   拓扑排序的实现

     1.   从$AOV$网中选择一个没有前驱的入度为$0$的顶点并输出。
          +   即完成一件不需要前置的活动
     2.   从网中删除该顶点和所有以它为起点的有向边。
          +   即完成该活动后，所有以该活动为前置的后置活动都可以正常进行了
     3.   重复步骤一和二直到当前的$AOV$网为空或当前网中不存在无前驱的顶点（存在环路所以不能拓扑排序）为止。
          +   即一件事情一件事情的做完

6.   逆拓扑排序的实现

     1.   从$AOV$网中选择一个没有后继的出度为$0$的顶点并输出。
     2.   从网中删除该顶点和所有以它为起点的有向边。
     3.   重复步骤一和二直到当前的$AOV$网为空或当前网中不存在无前驱的顶点为止。

7.   图和拓扑序列的关系

     1.   如果有向图顶点不能排成一个拓扑序列，则有向图含有顶点大于$1$的强连通分量（即存在非自身环路）
     2.   有向无环图的唯一拓扑序列不能唯一确定该图。
     3.   对有向图中的顶点适当地编号，使其邻接矩阵为三角矩阵且主对角元全为零的充分必要条件是，该有向图可以进行拓扑排序

8. 关键路径：具有最大路径长度的路径称为关键路径（即决定完成整个工程所需的最小时间），而关键路径上的活动称为关键活动。

    1.   源点：只有一个入度为$0$的顶点，即开始顶点，表示整个工程的开始。$v_1$不一定是源点。
    2.   汇点：只有一个出度为$0$的顶点，即结束顶点，表示整个工程的结束。$v_n$不一定是汇点。
    3.   事件$v_k$的最早发生时间$ve(k)$：指从源点$v_1$到顶点$v_k$处的最长路径长度。$v_k$的最早发生时间决定了所有从$v_k$开始的活动能够开工的最早时间与以该事件为始的弧的活动的最早开始时间相同。
         1.   当$v_k$是源点时，$ve(v_k)=0$
         2.   当$v_k$是结点$v_j$任意后继时，$ve(k) = Max\{ve(j) + Weight(v_j,v_k)\}$，其中$Weight(v_j,v_k)$是弧$<v_j,v_k>$上的权值。
    4.   事件$v_k$的最迟发生时间$vl(k)$：在不推迟整个工程完成的前提下，该事件最迟必须发生的时间。一个事件的最迟发生时间等于$\min${以该事件为尾的弧的活动的最迟开始时间，最迟结束时间与该活动的持续时间的差}。
         1.   当$v_k$是汇点时，$vl(v_k)=0$。
         2.   当$v_k$是结点$v_j$任意前驱时，$vl(k) = Min \{vl(j) - Weight(v_k,v_j)\}$，其中$Weight(v_k,v_j)$是弧$<v_k,v_j>$上的权值。
    5.   活动$a_i$的最早开始时间$e(i)$：指该活动弧的起点所表示的事件最早发生时间。若弧$<v_k,v_j>$表示活动$a_i$,则有$e(i) = ve(k)$
    6.   活动$a_i$的最迟开始时间$l(i)$：指该活动弧的终点所表示的事件的最迟发生时间与该活动所需时间之差。若弧$<v_k,v_j>$表示活动$a_i$,则有$l(i) = vl(k)-Weight(v_k,v_j)$。
    7.   活动$a_i$的时间余量$d(i)=l(i)-e(i)$：在不增加完成整个工程所需总时间的情况下，活动可以拖延的时间。$d(i)=0$即$l(i)=e(i)$的活动$a_i$是关键活动，由关键活动组成的路径就是关键路径。

9. 求关键路径的步骤

    0.   求拓扑排序。

    1.   求所有**事件**的最早发生时间$ve$：根据拓扑排序序列，从源点出发，令$ve($源点$)= 0$，依次按照所有路径的最大值求出各个顶点的最早发生时间。
    2.   求所有**事件**的最迟发生时间$vl$：根据逆拓扑排序序列，从汇点出发，令$ve($汇点$)= 0$，回退依次将每个顶点按第一步计算的整个工程的时间减去本顶点需要处理的时间，得到每个活动的最迟发生时间$vl$，交叉的顶点取最小值。
    3.   求所有**活动**的最早发生时间$e$：根根据各顶点的$ve()$值求所有弧的最早开始时间$e()$，弧的最早开始时间$e()$等于起点顶点的$ve()$值。
    4.   求所有**活动**的最迟发生时间$l$：根根据各顶点的$vl()$值求所有弧的最迟发生时间$l$，最迟发生时间$l$等于终点顶点的$vl()$值减去弧的权值。
    5.   求所有**活动**的时间余量$d$。将$l-e$得到余量$d$。此时一定有$l>e$。
    6.   求关键活动和关键路径。余量为$0$的活动就是关键活动，表示如果该活动拖延就会影响整个工程的进度。

10. 关键活动和关键路径

    1.   关键活动时间增加，整个工程工期延长。
    2.   关键活动时间减少，整个工程工期缩短。关键活动时间减少，可能变为非关键活动。所以不是关键活动时间越少，整个工程工期越短

    3.   若有多条关键路径，则应加快包含所有关键路径上的关键活动才能缩短工期。
    4.   关键路径是从源点到汇点路径长度量长的路径。