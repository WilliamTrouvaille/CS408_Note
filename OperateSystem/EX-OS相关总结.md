# EX-OS总结

## 强化梳理

### 考频

![23September20-222342-1695219822-dadc9ce3-dd22-41f7-b079-d8315906aa14](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309202224469.png)

>   二级标题后面括号里面的数字表示09-22年的考频

### 第二章PV大题(10)

#### 问题分类

1.   生产者消费者问题——进程间关系为“生产资源-消费资源”

2. 理发师问题——进程间关系为“服务-被服务”
3. 读者写者问题——同类进程不互斥、异类进程互斥
  +   从未考过但是==大纲明确要求==
4. 哲学家进餐问题——只有一类进程，每个进程需要同时拥有多种资源才能运行
5. 单纯的同步问题——前驱后继图

#### 解题思路

1.   确定函数的个数（有几类进程？）：梳理题目中有几个进程，一个进程对应一个函数（根据动作是否一致区分是否为统一进程）
2.   确定函数的动作：
     1.   动作是什么：在函数内部，用中文描述动作（==允许用中文的伪代码形式答题==）
          +   ==伪代码也要打分号`;`，不要忘记打分号==`;`
     2.   动作的次数：只做一次（不加`while`）还是重复进行（`while(1)`循环）
3.   确定函数是否在每个动作之前需要进行`P`操作，==如果需要进行`P`操作，则一定有与之对应的`V`操作==，需要思考这个`V`操作应该被放在哪
     1.   消耗资源型的`P`操作：题目一般会显性给出，例如每次动作需要消耗一个缓冲区空间（`P`操作减少缓冲区空间，`V`操作增加缓冲区空间，缓冲区无空间时无法进行动作）
          +   ==实现同步的$P$操作一定要在实现互斥的$P$操作之前.可以理解为要先拿到这个空间再上锁==
     2.   互斥型的`P`操作：需要注意隐含的互斥关系，例如缓冲区的互斥访问`P(mutex)`
4.   确定信号量`Semaphore`的个数：==所有`PV`操作定义完成后，再确定信号量`Semaphore`的个数==
     +   定义完再思考每个信号量的初值是多少
     +   使用注释对定义的信号量`Semaphore`进行解释
5.   检查是否发生死锁：连续进行多个`P`操作的地方是否会发生死锁（只有一个`P`操作不会发生死锁）
     +   某信号量的`PV`连续出现（中间没有夹杂别的`P`操作），则不会发生死锁：破坏死锁条件`请求和保持`
     +   ==实现同步的$P_{同步}$操作一定要在实现互斥的$P_{互斥}$操作之前，可以理解为要先拿到这个空间再上锁==
         +   ==用实现互斥的$P_{互斥}$操作把动作夹在里面==
6.   （以上步骤先在草稿纸上进行）检查符合题意没问题后将答案誊写到答题卡上，并写上相应的注释
     +   草稿纸上的语言可以比较通俗，空位满位什么的搞不清楚就在草稿纸上写清楚点`缸有空`，`缸中水`这样的

>   王道的强化网课中以下内容的答案每年都在变，找资料的时候发现不能和以上的解题思路很好的统一，以下内容的答案全部参考24版王道教材的答案，可能会和网课有部分出入，这边建议以王道教材为准

#### 生产者 - 消费者类型

##### 生产者 - 消费者类型(1)

![image-20230828115006942](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308281150064.png)

1.   确定函数的个数：
     +   生产车间A和生产车间B虽然都是生产车间，但是它们俩执行的动作不一致，故不是同一个进程，即生产车间A和生产车间B需要对应不同的函数
     +   进程 = 生产车间A（`A`） + 生产车间B（`B`） + 装配车间（`C`）

2.   确定函数的动作：
     1.   动作是什么：
          +   `P1`和`P2`分别生产`A、B`两种零件，并将分别把它们送到货架`F1、F2`上
          +   `C`从货架上分别取出`A、B`后，组装成`A + B`
     2.   动作的次数：
          +   `P1、P2`和`C`都是不断重复 → `while(1)`

3.   确定函数是否在每个动作之前需要进行`P`操作：如果需要进行`P`操作，则一定有与之对应的`V`操作；需要思考这个`V`操作应该被放在哪进

     1.   P1生产A零件之前不需要消耗资源
          +   `P1`将`A`放到`F1`前需要消耗1个`F1`货架（`A`缓冲区）的剩余容量 → `C`从`F1`上取`A`后会释放1个`F1`货架的剩余容量
          +   `empty1`对应货架`F1`上的空闲空间，初值为`10`； `full1`对应货架`F1`上面的`A`产品，初值为`0`：
     2.   P2生产B零件之前不需要消耗资源
          +   `P2`将`B`放到`F2`前需要消耗`1`个`F2`货架（`B`缓冲区）的剩余容量 → `C`从`F2`上取`B`后会释放`1`个`F2`货架的剩余容量
          +   `empty2`对应货架`F2`上的空闲空间，初值为`10`；`full2`对应货架`F2`上面的`B`产品，初值为`0`

     3.   `C`从`F1`取`A`前需要消耗1个F1货架上的A产品 → P1把A放到F1后释放1个`F1`货架上的A产品
          +   `C`从`F2`取`B`前需要消耗1个`F2`货架上的`B`产品 → `P2`把`B`放到`F2`后释放`1`个`F2`货架上的B产品
          +   C组装成A+B前不需要消耗资源

     4.   P1和C对F1的访问是互斥的（`mutex1`）；P2和C对F2的访问是互斥的（`mutex2`）

4.   确定信号量的个数：
     +   `empty1 = empty2 = 10，full1 = full2 = 0，mutex1 = mutex2 = 1`

5.   检查是否发生死锁：连续进行多个`P`操作的地方是否会发生死锁（只有一个`P`操作不会发生死锁）
     +   先P同步信号量（`empty1、empty2、full1、full2`），再P互斥信号量(`mutex1、mutex2`）

![image-20230828115303663](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308281153236.png)

##### 生产者 - 消费者类型(2)

![image-20230828121437525](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308281214633.png)

1.   确定函数的个数（2），确定函数的动作：
     +   老和尚`喝水`
     +   小和尚`取水`
2.   动作是什么：
     1.   老和尚（取桶、）从缸中打水、喝水
     2.   小和尚（取桶、）从井中打水、放水
3.   动作的次数：
     +   不断进行 → `while(1)`
4.   确定函数是否在每个动作之前需要进行`P`操作，实现同步的`P`操作一定要在实现互斥的`P`操作之前：
     1.   老和尚打水前消耗1个桶 → 老和尚喝水后增加1个桶
          +   老和尚喝水前消耗1个水缸里的水 → 小和尚打水后增加1个水缸里的水
     2.   小和尚打水前消耗1个桶 → 小和尚放水后增加1个桶
          +   小和尚打水前消耗1个水缸的剩余容量 → 老和尚喝水后增加1个水缸的剩余容量
     3.   小和尚之间对井的访问是互斥的（`mutex1`）；老和尚间和小和尚间、老和尚和小和尚对水缸的访问是互斥的（`mutex2`）
5.   确定信号量的个数：
     +   互斥访问信号量为1，其余为资源数量
6.   检查是否发生死锁：
     1.   如果老和尚和小和尚都是先对tong进行P操作（先进行取水桶操作），则可能发生：三个老和尚同时取水，并取得水桶（此时完成了三个P(tong)，则tong = 0），但是水缸中没有水（full = 0），即老和尚进程被阻塞在P（full）；而若干个小和尚想去打水，水桶却被取光（tong = 0），即小和尚进城被阻塞在P(tong)，这样就形成了死锁
     2.   同理，也可能发生三个小和尚分别拿着桶，而水缸中水满（empty = 0），被阻塞在P（empty）；而老和尚苦于没有水桶，被阻塞在P（tong）
     3.   解决方法：调整老和尚进程和小和尚进程的取桶顺序
          +   老和尚先判断水缸中有没有水，水缸有水的情况下才去取桶喝水，即先P（full）再P（tong）
          +   小和尚先判断水缸中有没有剩余容量，水缸中有剩余容量的情况下才去取桶打水，即先（empty）再P（tong）

![23August28-203245-1693225965-07aadabe-9997-444f-8a22-52cf809430f8](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282033927.png)

##### 生产者 - 消费者类型(3)

![image-20230828202814748](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282028901.png)

1.   确定函数的个数（2）：
     +   所有生产者动作一致，故所有生产者视为一类进程
     +   所有消费者动作一致，故所有消费者视为一类进程

2.   确定函数的动作：

     1.   动作是什么：
          1.   P生产产品，并将产品放入缓冲区
          2.   C从缓冲区取10个产品

     2.   动作的次数：
          +   P和C都是不断重复 → `while`

3.   确定函数是否在每个动作之前需要进行P操作：

     1.   P生产产品前不需要消耗资源
          +   P将产品放入缓冲区前需要消耗1个缓冲区剩余容量 → C从缓冲区取10个产品后增加10个缓冲区剩余容量（每取出1个产品，增加1个缓冲区容量，通过for循环实现）
     2.   C从缓冲区取10个产品前需要消耗10个缓冲区产品数量（`for`循环实现） → P将产品放入缓冲区后增加1个缓冲区产品数量
     3.   P和C对缓冲区的访问是互斥的（`mutex`）
     4.   多个C之间P操作是互斥的：如果只是简单的使用for循环设置在取10个产品前，则可能发生多个C轮流的取产品

![image-20230828214546119](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282145337.png)

#### 理发师问题

1.   服务与被服务的关系

2.   区别：需要额外设置变量记录当前等待的顾客有多少个，且该变量的访问是要互斥进行的，即需要夹在PV操作中

3.   理发师问题实际上是生产者 - 消费者问题的变式：
     1.   生产者 - 消费者问题：生产者生产资源，消费者消费资源；缓冲区限制资源上限
     2.   理发师问题：将顾客和服务员分别视为一种资源
          1.   顾客：每个顾客到店时，生产一个顾客资源；在被服务前，消耗一个服务员资源
          2.   服务员：提供服务前，消耗一个顾客资源；确定有顾客时，生产一个服务员资源；再提供服务

##### 理发师问题(1)

![23August28-212531-1693229131-27b4137a-7c05-466f-86ca-c7807f6b4062](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282125663.png)

特点：

1.   顾客无上限
2.   服务员在没有顾客的时候可以休息，通过`P(customer)`实现

![image-20230828214945063](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282149256.png)

##### 理发师问题(2)

![23August28-213808-1693229888-3d5ee02f-d0c8-4c14-8e9a-7f31f51e6b02](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282138483.png)

特点：顾客到店时，会检查`waiting`变量是否小于`m`，即等待数量有上限

![image-20230828213927729](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282139878.png)

##### 理发师问题(3)

![23August28-214003-1693230003-c0f04c89-2818-4b34-b8ea-65e8e0db7295](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282140847.png)

特点：

1.   在没有顾客时，服务员不能休息，必须忙等，即不断的轮询（`while`）检查`waiting`变量，判断当前是否有正在等待的顾客
2.   此情况下无需申明`customer`变量，即服务员无需阻塞
3.   用`waiting`变量判断服务员当前是否需要为顾客提供服务

![image-20230828214136567](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282141723.png)

#### 读者 - 写者问题

1.   第一个进程上锁，最后一个进程解锁：通过`count`变量记录该进程当前的数量
     +   读者写者问题主要是解决互斥
     +   他的访问关系分为两种类型，一种是可以同时访问（读和读），另一种是必须互斥访问（写和读，写和写)
     +   因为多种关系，所以引入了计数器`count`

2.   ==同类进程不互斥，不同类进程互斥（读者 - 写者问题的最主要特点）==

3.   写者进程不用判断是否自己是第一个/最后一个进程

##### 读者 - 写者问题(1)

![image-20230828215600872](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282156992.png)

特点

1.   从南往北的车只要有一辆占据，其余从南到北的车就可以一直使用该路；从北往南的车同上（同类的进程可以共享资源，不同类的进程互斥资源）

2.   声明`count1`变量和`count2`变量分别用于记录当前`P1/P2`有几个进程正在使用该临界资源，初始为`0`

3.   在每个进程开始时，通过`count`是否为`0`判断自己是不是第一个进程，如果是，则对临界资源进行上锁

4.   进行`count++`，表示自己正在使用临界资源，并在使用完临界资源后进行`count--`

5.   在每个进程结束时，通过`count`是否为0判断自己是不是最后一个进程，如果是，则对临界资源进行解锁

![image-20230828220100097](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282201198.png)

![image-20230828220520797](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282205963.png)

##### 读者 - 写者问题(2)

![image-20230828220732681](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282207808.png)

1、2、3种不同的录像片对应不同的进程，不同进程互斥访问录像厅（临界资源），统一进程共享录像厅 

![image-20230828221532455](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282215677.png)

##### 读者 - 写者（写优先）

![23August28-225328-1693234408-4a367299-7bfb-435e-a5a0-d38b2d62802e](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282253634.png)

![image-20230828225713745](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282257993.png)

#### 哲学家进餐

+   特征：==只有一类进程，且该类进程只有同时拥有多种资源才能进行==

+   哲学家问题关键点是限制并行，主要是三种思路

    1.   限制申请条件（对应破坏死锁循环等待条件)：解法一==不通用，不建议使用==

         +   比如规定单号哲学家先取左筷子，双号先取右筷子

    2.   信号量限制并行数（对应破坏死锁发生的循环等待条件）：==解法二通用，但并发度不高，也不建议使用==，参考`2.4`小题第8题确定最大进程数

         +   如`P89`代码就是同一时间只能有一个哲学家就餐（禁止并行）

    3.   限制哲学家只有能够取得两个筷子的时候才会就餐（对应破死锁条件)：解法三==很通用，且并发度高==，暴力美学

         +   `P(Lock);if(检查是否全满足);V(Lock);`

+   第三个思路最通用：

    +   通常的思路为
        1.   将每种资源通过int类型的变量定义（使用变量将资源数量具象化）
        2.   在进程开始运行时，先使用`P(mutex)`操作实现对各种资源进行互斥的访问，目的是逐一判断当前进程所需的各种资源是否满足运行的需要
        3.   如果资源都满足，则拿走这些资源（一口气拿走），然后`V(mutex)`，再执行动作

    +   循环条件下：如果只要有一个资源不满足，则`V(mutex)`，然后结束此次循环，进行下一次循环（`continue`）；
    +   只进行一次：如果只要有一个资源不满足，则使用`goto`语句返回函数的第一句重新进行判断（手动实现循环）
    +   其中`2.`实现同一时间只可能有一个进程在进行判断/拿走临界资源
    +   最后完成动作归还资源时也要进行上锁，保证归还动作一气呵成的完成
    +   代码示例如下：

    ![image-20230905194647152](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309051946435.png)

##### 哲学家进餐(1)

![image-20230828223900539](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282239653.png)

1.   变量`bowl`表示剩余碗的数量
     +   数组a中`a[i] = 1`表示第i个哲学家的左手有筷子，`a[(i + 1) % n] = 1`表示第i个哲学家的右手有筷子
         +   需要对右手边的筷子进行取模操作，第n个哲学家的右手边筷子就是第1个哲学家左手的筷子

2.   `P（mutex）`实现对临界资源的上锁

3.   判断`bowl`变量和左右筷子是否都在，任意条件不满足则`V（mutex）`（解锁）并结束循环；条件都满足时，则对这两个变量进行 - 1操作，表示取出该临界资源

4.   `V（mutex）`实现对临界资源的解锁

5.   进餐（即自己的主体动作）

6.   归还拥有的临界资源
     +   另一个哲学家进行上锁并判断

![image-20230828224501610](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282245740.png)

##### 哲学家进餐(2)

![23August28-224746-1693234066-b51c0023-fb6b-4e1a-96a6-b4e4aa8d1051](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282247271.png)

检查当前是否有4个盆和1个座位，再去完成打饭和坐落（主体动作）

解法一：信号量

![image-20230828225100384](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282251540.png)

~~这里的一口气拿四个盆我看一下笑一次~~

解法二：`int`类型变量（此时每个干饭人只进行一次，不能使用`continue`）

![image-20230828225228119](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282252288.png)

#### 单纯的同步问题

这类题通常会给一个前驱后继图，让你根据图实现同步关系，送分题，不需要过多关注

>   前驱关系其实是多组同步.
>
>   进程$P_1$中有句代码$S_1$，$P_2$中有句代码$S_2$……$P_6$中有句代码$S_6$
>
>   这些代码要求按如下前驱图所示的顺序来执行：
>
>   ![image-20230619235155088](http://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306192351183.png)
>
>   其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作）因此：
>
>   1. 要为每一对前驱关系各设置一个同步变量.
>   2. 在“前操作”之后对相应的同步变量执行$V$操作.类似表示当前动作$S_i$已经完成.
>   3. 在“后操作”之前对相应的同步变量执行$P$操作.类似检测前一个动作$S_i$是否完成.
>
>   ![image-20230619235433357](http://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306192354443.png)
>
>   每个$S_i$操作都设置一个进程$P_i$.
>
>   每一条线段靠近根的对当前信号量进行$V$操作，靠近尾的对当前信号量进行$P$操作.
>
>   再将每个代码结点旁边的操作聚拢在一起，就是每个进程所应该执行的操作.
>
>   ![image-20230619235341960](http://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306192353047.png)

### 第三章内存管理(8)

#### 进程的内存映像

![0e8dca02-58c7-49cf-baac-3e3dadee65fa](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309242039770.jpg)

1.   进程虽然拥有很大的一块逻辑地址空间，但是有很大一部分空间可能是空着的，只有需要使用的时候才进行相应的分配

2.   通过将不同进程的某些页表项映射到同一内存空间（相同页框号）的方式实现页面共享（虚拟页号可以不同，两个进程的虚拟页号是相互独立的）

3.   低地址部分进程独享，==高地址部分（操作系统内核区）所有进程共享==，即都是映射到相同的一片物理页框中（通过页表映射的方式实现）
4.   不同于存放在硬盘上的可执行程序文件，当一个程序调入内存运行时，就构成了进程的内存映像。一个进程的内存映像一般有几个要素： 

     +   代码段/程序段：即程序的二进制代码，代码段是只读的，可以被多个进程共享。 
         +   上图中`只读代码/数据段`和`共享库的存储映射区`
     +   数据段：即程序运行时加工处理的对象，包括全局变量和静态变量。 
         +   其他的用户`栈`$Stack$、`堆`$Stack$和`读/写数据`等
     +   进程控制块$PCB$：存放在系统区。
         +   操作系统通过$PCB$来控制和管理进程。 
     +   堆$Heap$：用来存放动态分配的变量。
         +   通过调用`malloc`函数动态地向高地址分配空间。 
     +   栈$Stack$：用来实现函数调用。
         +   ==从用户空间的最大地址往低地址方向增长==。 
     +   操作系统内核区：==仅操作系统可以访问==
5.   每个进程的虚拟地址空间都是连续的，但某些页面可能没有数据

>   可以利用上图对考题、知识点进行串联

#### 存储系统

1.   磁盘以块为单位

2.   内存物理上被分为若干页框（考试中一般认为页框大小和磁盘块大小一致，但是现实中可能不一致）

3.   进程被分为若干页面，每个进程的页面被离散的放在内存中的页框中

4.   CPU访问进程某个页面时需要查询TLB/慢表进行地址转换：
     1.   进程的页面和页表项一一对应
     2.   每个页表项中记录页号和实际物理地址的页框号的映射关系，以及是否有效（是否已经调入内存/是否缺页）

5.   进程间有共享的页面（每个进程都有一个固定的地址部分映射到内核区的代码和内核数据，用于实现各种系统调用）：
     1.   当进程之间利用系统调用进行通信的时，进程A先通过系统调用（存放在内核代码区）将要通信的内容存放在内核数据区
     2.   进程B再通过系统调用将存放在内核数据区的内容取出，并放入自己的数据区中（进程A和进程B的内核区映射到的是同一片主存地址空间）

6.   进程的数据区由若干指令组成，执行指令时可能需要访问某个虚拟地址，CPU就会将虚拟地址从指令中拆分出来，并进行虚拟地址到物理地址的转换：
     1.   使用虚拟地址中的虚拟页号查询TLB（TLB存放的是虚拟页号和物理地址页框号的映射关系）
     2.   TLB命中（TLB中有和虚拟页号对应的表项）且有效位为1时，==不可能发生缺页==：
          1.   将该表项中存放的页框号和页内偏移量进行拼接得到物理地址
          2.   根据物理地址中的页框号找到对应页框
          3.   根据页内偏移量找到对应的具体数据，并取出该数据
     3.   TLB命中但有效位为0，或者TLB未命中：
          1.   根据页表始址寄存器中存放的内容（页表始址）得到存放该进程页表的页表始址（进程未运行，页表始址存放在PCB中；进程上处理机运行时，CPU将页表始址从PCB中取出并放入页表始址寄存器中）
          2.   查询该页的页表项得到物理地址的页框号，并将该映射关系复制到TLB中：该页的页表项（记录放该页号和其实际主存中物理页框的映射关系）的地址 = 页表始址 + 页号 * 单个页表项大小（页表项采用连续存储的方式，占用一片连续的存储空间）
          3.   根据页表项中记录的物理页框号和页内偏移量进行拼接，得到具体数据的物理地址，取出数据
     4.   TLB未命中，且慢表命中但有效位为0，即发生缺页：
          1.   发生缺页异常（页故障），操作系统检测到该异常后，会对该异常进行处理，即调页（读磁盘块），慢表中的页表项中保存着其外存地址，根据此外存地址将外存中的物理块（考试中默认大小与页相等）读入主存
          2.   主存仍有空闲页框：该块调入主存的空闲页框中，并修改相应页表项
          3.   主存没有空闲页框：先根据页面置换算法选择一个页面淘汰，并且根据其脏位判断是否应该写回外存；然后再将该页面放入被淘汰页面之前所占用的页框中（覆盖），并修改相应页表项（慢表和TLB）
          4.   执行完调页后，将会重新执行引发缺页异常的指令（重新执行一遍访存过程）：在408中，某一条指令引发缺页异常，操作系统处理完缺页异常（即完成调页），该指令重新执行时，TLB命中（缺页异常处理也会将TLB中的表项进行更新）

7.   假设物理页框中可以存放数组A的1024个数组元素（即A[0] - A[1023]），TLB表初始为空，执行以下代码：

     ```
     for (int i = 0; i < 1024; i++) a[i] = 0;
     ```

     共需要访问1025次内存：

     +   第1次访存，TLB未命中，根据内存中的慢表得到A[0]的逻辑地址得到A[0]的物理地址，并将该逻辑地址和物理地址的映射关系存入TLB中
     +   第2次访存：根据A[0]的物理地址取出A[0]的数据
     +   第3 $\sim$ 1025次访存：TLB命中，分别根据表中的映射关系得到A[1] - A[1023]的物理地址，取出A[1] - A[1023]的数据（A[1] - A[1023]的物理地址到逻辑地址的转换无需访存，此时TLB中已经有存放A[0] - A[1023]的主存块的逻辑地址和物理地址的映射关系，而查询TLB不用访存；故仅需从内存中取出数据一次访存）

#### 页表

1.   一级页表物理上连续存放
2.   多级页表：每一级页表大小不超过一个页面的大小

### 第四章文件管理(6)

#### 基本概念

1.   文件目录 = 目录文件

2.   文件的逻辑结构有
     1.   无结构文件（由记录组成） 
     2.   有结构文件

3.   MP3文件格式：
     1.   Mp3Frame（Mp3帧）是文件记录（相当于一个Struct结构体）：Mp3Fream由Mp3Header（头信息）和Mp3Data（数据信息）组成，即Mp3文件是记录式文件，即Mp3属于有结构文件
     2.   Mp3Header大小固定，而Mp3Data不一定
     3.   使用Mp3文件时，用户提供的是逻辑地址，操作 系统根据MpHeader中的各种信息将逻辑地址转换为物理地址
4.   DOS采用FAT文件分配表（显示链接），UFS采用混合索引

#### FAT文件系统

##### FAT文件系统的基本概念

1.   目录文件：即我们打开文件时所看到的各文件夹
2.   每个文件系统都有可能作为系统的启动盘，因此，每个文件系统的第一个块为启动块存放自举程序（ROM）引导程序，作用是完成一系列开机的动作
     +   区别于BIOS：BIOS存放在ROM中，自举程序是BIOS的最重要的组成部分
3.   **文件控制块**$FCB$
     +   一个**文件控制块**$FCB$就是一个文件目录项
     +   $FCB$的有序集合就是文件目录
4.   **文件分配表**$FAT$（$File\;Allocation\;Table$）
     +   **文件控制块**$FCB$目录中只需记录文件的起始块号，后续的盘块可通过查FAT找到
     +   $FAT$包含物理块号和下一块指针两项.
     +   ==$FAT$的各个表项在物理上连续存储==，且每一个表项长度相同，==因此“物理块号”字段可以是隐含的==.
5.   **文件分配表**$FAT$采用显示链接的文件物理结构，即**文件分配表**$FAT$文件分配表（类似操作系统中的静态链表）：说明第1 - n块分别在磁盘的什么地方
     +   隐式链接（类似链表）：每个文件**文件控制块**$FCB$中只记录文件的起始块号和结束块号，只支持从起始块号开始的顺序访问，使用指针表示块之间的关系
6.   **文件分配表**$FAT$文件分配表采用连续存放的方式：**文件分配表**$FAT$文件系统中会使用在引导块后的若干连续块存放**文件分配表**$FAT$文件分配表（开机时操作系统将FAT文件表读入内存中，即查询和访问FAT文件分配表无需进行度磁盘操作）
7.   根目录存放在**文件分配表**$FAT$表之后的固定位置：操作系统在完成一系列开机操作时以根目录为起点逐层往下寻找相应文件并执行（开机时操作系统将根目录读入内存中，并且常驻内存，即查询和访问根目录无需进行度磁盘操作）
8.   **文件分配表**$FAT$文件分配表的每个目录项大小（位数）决定**文件分配表**$FAT$文件系统的总块数：每个FAT表项16bit，则最多只能表示2^16个 块号

     1.   **文件分配表**$FAT$文件分配表的每个目录项大小（位数）决定FAT文件分配表的总大小：每个表项的大小*表项的数量 = **文件分配表**$FAT$的大小，即FAT文件分配表的总大小 = 2 ^ 16 * 16 bit
9.   文件类型即文件格式

##### FAT文件系统打开文件的过程

即使用`open`系统调用：

1.   将文件名传递给逻辑文件系统.
     +   当所读文件的数据不在内存时，产生中断(缺页中断)，==原进程进入阻塞态==，直到所需数据从外存调入内存后，才将该进程唤醒
     +   进程使用`open`系统调用打开某个文件时需指明该文件的存储路径
2.   先搜索**系统打开文件表**，操作系统维护一个包含所有打开文件信息的表，系统打开文件表
     +   所谓''打开”，是指调用`open`根据文件名搜索目录，将指明文件的属性（包括该文件在外存上的物理位置），==从外存复制到内存打开文件表的一个表目中， 并将该表目的编号（也称索引）返回给用户==
3.   如果已打开，则在进程打开文件表中创建新目录指向系统打开文件表对应条目
     +   当用户再次向系统发出文件操作请求时，可通过索引在打开文件表中查到文件信息，从而节省再次搜索目录的开销
4.   如果未打开，根据文件名搜索目录结构，并检查该用户是否有指定的操作权限.
     +   部分文件目录会缓存到内存中以加快检索
5.   找到文件后将目录项/**文件控制块**$FCB$复制到**系统打开文件表/活跃文件目录表**中.
     +   该文件存储在哪个目录下，则该文件的**文件控制块**$FCB$就存放在这级目录中
         +   通过对比这级目录中是否有与该文件名相同的文件的方式
     +   该文件**文件控制块**$FCB$上记录了该文件的起始块号，通过该起始块号操作系统就可以在**文件分配表**$FAT$中查到存储该文件所使用的每一个块的块号和存储位置
         +   从起始块号出发，逐块查找，直到最后一个块
6.   进程打开文件表中创建一个条目，然后通过指针将系统打开文件表条目和其他域相联.
7.   返回一个指向进程打开文件表条目的指针`fd`，通过指针操作文件.
     +   指针`fd`：文件描述符，相当于指向该文件的指针；作为对进程发出open系统调用的回应
     +   进程接下来对该文件的操作可以转化为对该`fd`的操作例如`read(fd)`
8.   文件打开后用户可以指定读取具体哪个块，即用户不需要每次都从头开始读，同样的，操作系统也可以只将用户指定的具体该进程的第几个块读入内存，读入内存后，操作系统还要建立起该文件虚拟地址到物理地址转换的映射关系，即修改页表
     +   ==打开文件后内核不能通过文件名访问文件，只能通过文件描述符（文件句柄）访问==

>   FCB确定起始块的位置，FAT文件分配表确定后续块的位置

#### UFS文件系统

##### UFS文件系统的基本概念

1.   采用混合索引的方式将FAT文件系统中**文件控制块**$FCB$的占用空间过大的问题进行优化：因此每个目录项只需包含 `文件名,inode号`，文件的具体属性包含在 $inode$中
2.   $inode$区：磁盘中专门划分出存放所有$inode$的区域，即==所有$inode$有共同的起始地址==
     +   索引节点是文件系统中的一种数据结构，用于描述文件或目录的元数据信息。
     +   每个索引结点$inode$大小固定（类似数组）
     +   可以根据$inode$编号迅速找到指定$inode$
3.   UFS文件系统下，所能支持的最大容量为
     +   直接索引：每个直接索引结点能够索引一个完整的数据块
     +   一级间接索引：每个物理块所能容纳多的FCB数，即物理块大小 / FCB大小
     +   二级间接索引：$($物理块大小 / FCB大小$)^2$

### 第五章磁盘(2)