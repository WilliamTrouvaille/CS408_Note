# EX-第八章 排序考点总结

## 导读

### 【考纲内容】

1. 排序的基本概念。
2. 插入排序：直接插入排序、折半插入排序、希尔排序$shell\;sort$。
3. 交换排序：冒泡排序$bubble\;sort$/、快速排序。
4. 选择排序。
5. 二路归并排序$merge\;sort$。
6. 基数排序。
7. 外部排序。
8. 排序算法的分析和应用。

### 【复习提示】

选择题：各种排序算法的思想、排序过程（能动手模拟）和特征（初态的影响、复杂度、稳定性、适用性等）

算法题：常用排序算法的关键代码。看到某特定序列，读者要有选择最优排序算法（根据排序算法特征）的能力。

## 选择题考点总结

### 排序算法总结

#### 相关总结

1.   稳定的排序：基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序、基数排序。
2.   不稳定的排序：堆排序、快速排序、希尔排序、直接选择排序。
3.   适合链表的排序算法：冒泡排序、选择排序、直接插入排序、基数排序。
4.   不稳定的排序：堆排序、快速排序、希尔排序、直接选择排序。
5.   适合链表的排序算法：冒泡排序、选择排序、直接插入排序、基数排序。
6.   不适合链表的排序算法：希尔排序、快速排序、归并排序、二分插入排序（以及包含所有需要二分查找优化的排序算法）。
7.   可以用于链表排序但不建议使用的排序算法：**堆排序**。
8.   每趟排序结束都**至少能够确定一个元素最终位置**：简单选择排序、快速排序、堆排序。
9.   **排序趟数**与关键字的初始排列初始状态无关：插入排序$n-1$趟、选择排序$n-1$趟、基数排序$d$趟。
10.   **比较次数**与关键字的初始序列初始状态无关：基数排序（不需要进行关键字的比较）、选择排序（简单选择排序、堆排序，比较次数始终为$\dfrac{n(n-1)}{2}$）。
11.   **移动次数**与关键字的初始排列初始状态无关：基数排序。
12.   **时间复杂度**与关键字的初始排列初始状态无关：直接选择排序$O(n^2)$、堆排序$O(n\log_2n)$、归并排序$O(n\log_2n)$、基数排序$O(d(n+r))$。

#### 内部排序算法的应用

1.    若$n$较小，可采用直接插入排序或简单选择排序
      +   由于直接插入排序所需的记录移动次数较简单选择排序的多，因而当记录本身信息量较大时，用简单选择排序较好。
2.    若文件的初始状态已按关键字基本有序，则选用直接插入或冒泡排序为宜。
3.    若$n$较大，则应采用时间复杂度为$O(log_2 n)$的排序方法：快速排序、堆排序或归并排序
      +   快速排序被认为是目前基于比较的内部排序方法中最好的方法，当待排序的关键字随机分布时，快速排序的平均时间最短
      +   堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况，这两种排序都是不稳定的
      +   若要求排序稳定且时间复杂度为$O(log_2 n)$，则可选用归并排序
      +   但本章介绍的从单个记录起进行两两归并的排序算法并不值得提倡，通常可以将它和直接插入排序结合在一起使用。先利用直接插入排序求得较长的有序子文件，然后两两归并
      +   直接插入排序是稳定的， 因此改进后的归并排序仍是稳定的
4.    在基于比较的排序方法中，每次比较两个关键字的大小之后，仅出现两种可能的转移， 因此可以用一棵二叉树来描述比较判定过程，由此可以证明
      +   当文件的$n$个关键字随机分布时，任何借助于“比较”的排序算法，至少需要$O(n\log_2 n)$的时间
5.    若$n$很大，记录的关键字位数较少且可以分解时，采用**基数排序**较好
6.    当记录本身信息量较大时，为避免耗费大量时间**移动**记录，可用**链表**作为存储结构。

#### 每个算法的特点

一趟排序定义为对尚未确定最终位置的所有元素进行一遍处理

1.   直接插入排序
     1.   在待排序的元素序列**基本有序**的前提下，直接插入排序效率最高的。
     2.   直接插入排序进行$n$躺后能保证前$n+1$个元素是有序的，但是**每一趟排序都不能保证有一个元素到达最终的位置上**。
2.   二分插入排序
     1.   对于直接插入的优化仅在于二分查找的比较次数，比较关键字的次数减少为$O(n\log_2n)$，移动元素的次数没变。
     2.   二分插入排序进行$n$趟后能保证前$n+1$个元素是有序的，但是**每一趟排序都不能保证有一个元素到达最终的位置上**。
3.   希尔排序特性
     1.   希尔排序在最后一趟前都不能保证元素在最后的位置上。
     2.   希尔排序在最后一趟前都不能保证元素是有序的。
4.   冒泡排序
     1.   冒泡排序产生的序列全局有序，$n$趟排序后第$n$个元素到达最终的位置上，前$n$个或后$n$个位置的元素确定。
          +   全局有序：有序子序列中的所有元素的关键字一定小于或大于无序子序列中所有元素的关键字
     2.   冒泡排序在本身有序时为全排序算法交换次数最小，为$0$，比较次数是$n-1$。
     3.   一共需要$n-1$趟排序。
5.   快速排序
     1.   排序的递归次数与**初始序列**和**选择的枢轴元素**有关，与分区处理顺序无关。
          1.   如果初始序列是有序的或逆序的，则快速排序性能最差（速度最慢），退化到$O(n^2)$。
          2.   对于每次的枢轴元素能尽量将表分为长度相同的子表，快速排序速度最快。
     2.   假设每趟排序确定的元素都不挨在一起，第$n$趟排序会确定在$2^{n-1}$个最终位置的元素
     3.   快速排序不产生有序子序列。
     4.   枢轴元素到达的位置是不确定的，但是每次都会到其最终的位置上，第$n$趟至少有$n$个元素到最终位置上。
     5.   每趟排序会确定在最终位置的元素。
     6.   快速排序不产生有序子序列。
6.   简单选择排序：选择排序算法的比较次数始终为$\dfrac{n(n-1)}{2}$，与序列状态无关。
7.   堆排序
     1.   堆就是层序存储的完全二叉树，堆中编号为$i$的结点，编号为$2i$的结点是它的左孩子，编号为$2i+1$的结点是它的右孩子。
     2.   选择排序算法的比较次数始终为$\dfrac{n(n-1)}{2}$，与序列状态无关。
     3.   堆的叶子结点范围是$\lfloor\log_2n\rfloor+1\sim n$
     4.   适合大量数据进行排序。
     5.   调整堆的时间与树高相关$O(\log_2n)$，建立堆的时间复杂度为$O(n)$，比较总次数不超过$4n$。
     6.   在含有$n$个关键字的小根堆中，关键字最大的记录存储范围为$\lfloor\dfrac{n}{2}\rfloor+1\sim n$。这是小根堆，关键字最大的记录一定存储在这个堆所对应的完全二叉树的叶子结点中；又因为二叉树中的最后一个非叶子结点存储在$\lfloor\dfrac{n}{2}\rfloor$中，所以得到范围。
8.   归并排序
     1.   二路归并排序在内部排序算法中空间消耗最大。
     2.   二路归并排序是一棵倒立的二叉树。
     3.   $n$个元素二路归并排序，**归并一共要$\log_2n$趟**，每次归并时间复杂度为$O(n)$，则算法时间复杂度为$O(n\log_2n)$。
     4.   需要辅助数组，空间复杂度为$O(n)$，而递归调用的调用栈的空间复杂度为$O(\log_2n)$，总的空间复杂度就是为$O(n)$，在内部排序算法中**空间消耗最大**。
     5.   对于$N$个元素进行$k$路归并排序时，排序的趟数$m$满足$k^m = N$，从而$m =\log_kN$，又由$m$为整数，所以$m=\lceil\log_kN\rceil$。
9.   基数排序
     1.   基数排序不是基于比较的排序算法，比较次数为$0$。
     2.   只能对整数进行排序。
     3.   需要$r$个辅助队列，所以空间复杂度为$O(r)$。
     4.   元素的移动次数与关键字的初始排列次序无关：一趟分配$O(n)$，一趟收集$O(r)$，一共有$d$趟分配收集，所以总的时间复杂度为$O(d\times(n+r))$。
     5.   ~~基你太稳~~：基数排序是稳定的。

### 插入排序

1.   插入排序：排序序列分为未排序序列和已排序序列。每一趟排序都不能保证有一个元素到达最终的位置上。
2.   直接插入排序：每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成为止。
     1.   空间复杂度为$O(1)$，平均时间复杂度是$O(n^2)$。
     2.   直接插入排序算法是稳定的，可以对链表进行直接插入排序
3.   直接插入排序过程
     1.   查找出$L(i)$在中的插入位置$k$。
     2.   将$L [k\cdots i-l]$中的所有元素依次后移一个位置。
     3.   将$L(i)$复制到$L(k) $。
4.   二分插入排序：也称为折半插入排序，是对直接插入排序的优化，在寻找插入位置时使用二分查找的方式。
     1.   时间复杂度为$O(n^2)$，空间复杂度为$O(1)$。
     2.   不能对链表进行二分插入排序。
     3.   二分插入排序是稳定的。

### 希尔排序

1.   希尔排序：又称缩小增量排序。也是对直接插入排序的优化。
     1.   空间复杂度为$O(1)$，最坏时间复杂度为$O(n^2)$，在某个范围内可以达到$O(n^{1.3})$。
     2.   希尔排序是不稳定的，因为相同的元素可能分到不同的子序列中进行重排打乱原有顺序。
     3.   希尔排序只适用于顺序表而不适合用于链表，无法快速进行增量的访问。
     4.   希尔排序在最后一趟前都不能保证元素在最后的位置上。
     5.   希尔排序在最后一趟前都不能保证元素是有序的。
2.   希尔排序过程
     1.   先将整个待排序元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）
     2.   分别进行**直接插入排序**

     3.   然后缩小增量重复上述过程，直到增量为$1$

     4.   每次对比只对比两个以上的个元素进行插入交换。

### 交换排序

1.   交换排序共性：交换排序即根据序列中两个元素关键的比较结构然后交换这两个记录在序列中的位置。$n$趟排序后就有$n$个元素到达最终的位置上。
2.   冒泡排序：从后往前或从前往后两两比较相邻元素的值，若逆序则交换这两个值，如果相等也不交换，直到序列比较完。这个过程是一趟冒泡排序，第$i$趟后第$i$个元素会已经排序完成。每一趟都会让关键字最小或最大的一个元素到未排序队列的第一个或最后一个。一共需要$n-1$趟排序。
3.   快速排序：基于分治法。
     1.   快速排序使用了递归，所以需要递归工作栈，空间复杂度与递归层数相关，所以空间复杂度为$O($递归层数$)$。每一层划分只需要处理剩余的待排序元素，时间复杂度不超过$O(n)$，所以时间复杂度为$O(n\times$归层数$)$。而快速排序会将所有元素组织成为二叉树，二叉树的层数就是递归调用的层数。所以对于$n$个结点的二叉树，最小高度为$\lfloor\log_2n\rfloor+1$，最大高度为$n$。从而最好时间复杂度为$O(n\log_2n)$，最坏时间复杂度为$O(n^2)$，平均时间复杂度为$O(n\log_2n)$。
     2.   所以如果初始序列是有序的或逆序的，则快速排序性能最差（速度最慢）。
4.   快排过程
     1.   取待排序序列中的某个元素$pivot$作为基准，一般取第一个元素。

     2.   通过一趟排序，将待排元素分为左右两个子序列。

     3.   若左子序列元素的关键字均小于或等于基准元素的关键字，右子序列的关键字大于基准元素的关键字，则称进行了一趟快速排序/一次划分，此时左右指针相等，均指向基准元素$pivot$应该在的地方。

     4.   这个$pivot$已经成功排序。然后分别对两个子序列继续进行快速排序，直至整个序列有序。

### 选择排序

1.   选择排序特性：选择排序算法的比较次数始终为$\dfrac{n(n-1)}{2}$，与序列状态无关。
     1.   选择排序也需要交换，但是与交换排序的不断交换不同的是选择排序时选择出一个最后进行交换，一趟只交换一次。
     2.   选择排序也需要插入，且也分为已排序和未排序序列，但是插入排序不需要选择，且元素移动方式是插入而不是交换。
2.   简单选择排序
     1.   空间复杂度为$O(1)$，时间复杂度为$O(n^2)$。
     2.   简单选择排序是不稳定的。因为选择后会进行交换，影响顺序。
     3.   简单选择排序也可以适用于链表。
3.   堆：堆就是用层序存储的完全二叉树，堆的叶子结点范围是$\lfloor\log_2n\rfloor+1\sim n$。
     1.   大根堆或大顶堆：根结点存储值大于等于其左右孩子结点存储值。
     2.   小根堆或小顶堆：根结点存储值小于等于其左右孩子结点存储值
4.   建立根堆过程：题目如果是给出序列，然后调整为堆，则证明他这个堆已经建立好了，只**需要调整顺序**；如果说的是依次插入，则要一边插入一边调整堆。
     1.   首先将这组数据按层序初始化为无序堆，然后从最后向前开始调整。
     2.   从$t<\lfloor\dfrac{n}{2}\rfloor$的结点开始往前遍历。
     3.   检查当前结点$i$与左孩子和右孩子是否满足根堆条件，若不满足则交换。
          + 若是建立大根堆，检查是否满足根大于等于左、右结点，若不满足，则当前结点与更大的一个孩子互换。
          + 若是建立小根堆，检查是否满足根小于等于左、右结点，若不满足，则当前结点与更小的一个孩子互换。
     4.   若元素互换破坏了下一级的堆，则采用同样的方法继续向下调整。
          + 若是建立大根堆，则小的元素不断下坠。
          + 若是建立小根堆，则大的元素不断下坠。 
5.   堆排序过程
     1.   每一趟将堆顶元素加入子序列（堆顶元素与待排序序列中的最后一个元素交换），此时后面的这个元素就排序好了，最右下的元素作为堆顶元素，原堆顶元素就是堆中最大的元素。
     2.   此时待排序序列已经不是堆了（堆顶不能保证是最小或最大的元素），需要将其再次调整为堆（小元素或大元素不断下坠）。
     3.   重复步骤一二。
     4.   直到$n-1$趟处理后得到有序序列。基于大根堆的堆排序会得到递增序列，而基于小根堆的堆排序会得到递减序列。

### 归并排序

1.   二路归并排序过程：归并排序趟数为$\lceil\log_2n\rceil$。
     1.   把长度为$n$的输入序列分成两个长度为$\dfrac{n}{2}$的子序列。
     2.   对这两个子序列分别采用归并排序。
     3.   将两个排序好的子序列合并成一个最终的排序序列。

### 基数排序

1.   基数排序：基数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。
2.   基数排序过程：有最高位优先$MSD$和最低位优先$LSD$两种方法。
     1.   初始化：设置$r$个空辅助队列$Q_{r-1}\;Q_{r-2}\;\cdots\;Q_0$。
     2.   按照每个关键字位**权重递增**的次序（个、十、百），对$d$个关键字位分别做分配和收集。
     3.   分配就是顺序扫描各个元素，若当前处理的关键字位为$x$，就将元素插入$Q_x$队尾。
     4.   收集就是把$Q_{r-1}\;Q_{r-2}\;\cdots\;Q_0$各个队列的结点依次出队并链接在一起。
3.   基数排序擅长解决的问题：

     1. 数据元素的关键字可以方便地拆分为$d$组，且$d$较小。
     2. 每组关键字的取值范围不大，即$r$较小。
     3. 数据元素个数$n$较大。

### 外部排序

1.   外部排序总结

     1.   为减少平衡归并中外存读写次数所采取的方法：增大归并路数和减少归并段个数
     2.   利用败者树增大归并路数
     3.   利用置换-选择排序增大归并段长度来减少归并段个数
     4.   由长度不等的归并段，进行多路平衡归并，需要构造最佳归并树。

2.   外部排序：针对数据元素太多，无法一次性全部读入内存进行排序而进行处理的在外部磁盘进行的排序处理方式。需要将待排序的记录存储在外存上，排序时再把数据一部分一部分地调入内存进行排序，在排序过程中需要多次进行内存和外存之间的交换。通常使用归并排序的方式，最少只用在内存分配三块大小的缓冲区（两个输入缓冲一个输出缓冲）即可堆任意一个大文件进行排序。然后对缓冲区里的数据进行内部排序。

     1.   每趟归并$n$个元素需要做$(n-1)(k-1)$次比较，$S$​趟归并总共需要的比较次数为
          $$
          \begin{align}
          S(n-1)(k-1) & = \left\lceil\log _{k} r\right\rceil(n-1)(k-1) \\
          & =\frac{\left\lceil\log _{2} r\right\rceil(n-1)(k-1)}{\left\lceil\log _{2} k\right\rceil}
          \end{align}
          $$

     2.   读写外存时间$=2\times$文件总数$\times1+2\times$文件总数$\times$归并排序躺数，其中$2\times$文件总数表示读一遍文件和写一遍文件一共需要的读/写次数，前面的$1$表示排序前生成初始归并段进行一遍读写，加上归并排序中进行的读写即为读写外存时间

3.   外部排序过程

     1.   生成初始归并段（大小为输入缓冲区的总大小），需要读写并进行内部排序。
     2.   重复读写，进行内部归并排序。填满输出缓冲就可以输出，输入缓冲空就应该立即输入新数据才能继续排序。
     3.   外部排序时间开销$=$读写外存时间（最大的时间开销）$+$内部排序所需时间$+$内部归并所需时间。

4.   外部排序的优化方法：增大归并路数和减少归并段个数

     1.   $k$路平衡归并：使用更多路的多路归并，减少归并趟数。
          1.   最多只能有$k$个段归并为一个，需要一个输出缓冲区和$k$个输入缓冲区
          2.   每一趟归并中，若有$m$个归并段参与归并，则经过这一趟处理得到$\lceil\dfrac{m}{k}\rceil$个新的归并段。
          3.   对$r$个初始归并段，使用$k$路归并，则归并树可以使用$k$叉树表示，若树高为$h$，则归并趟数为$h-1$。
               +   $k$叉树第$h$层最多有$k-1$个结点则$r\le k^{h-1}\to(h-1)_{\min}=\lceil \log_{k}r\rceil$，则归并趟数为$h-1=\lceil \log_{k}r\rceil$。
     2.   $k$值增大，多路归并会带来负面影响：

          1. $k$路归并时，需要开辟$k$个输入缓冲区，内存开销增加。
          2. 每挑选一个关键字需要对比关键字$(k-1)$次，内部归并时间增加。可以使用下面的败者树进行优化
     3.   若能增加初始归并段的长度则可减少初始归并段数量$r$：若共$N$个记录，内存工作区习以容纯$L$个记录，则初始归并段数量$r=\dfrac{N}{L}$。可以使用下面的置换选择排序进行优化。

5.   败者树（$Tournament -Tree$）：主要用于高效地实现多路归并排序（$k$路归并排序）。败者树的主要作用是在$k$个有序序列中选择最小（或最大）元素，从而实现合并排序。用于通过过去归并的经历减少归并次数。败者树可以看作一棵多了一个单个的根的完全二叉树。$k$个叶结点分别是当前参加比较的元素，非叶子结点用来记忆左右子树中的失败者，而让胜者往上继续比较，一直到根结点。

     1.   每个结点代表一个有序序列中的最小（或最大）元素，称为“胜者”。
     2.   叶子结点表示原始序列的元素，非叶子结点表示排序后的胜者。叶子结点是虚拟的
     3.   每个结点都有一个指向其父结点的指针，叶子结点没有指向左右孩子的指针。
     4.   败者树是一棵完全二叉树，有$N$个叶子结点，总共有$N-1$个非叶子结点。
     5.   当新元素进入某个序列时，从该叶子结点开始向上更新整个败者树，选择新的胜者。

6.   使用败者树进行$K$路归并排序的过程

     1.   初始化：将$k$个有序序列的首元素填入败者树的叶子结点，并根据它们的值构建初始的败者树。
     2.   合并：选取胜者结点，将其对应的序列中的下一个元素填入胜者结点，然后向上更新败者树，选择新的胜者。
     3.   重复：重复步骤`2`，直到所有序列都被合并为一个有序序列。

7.   败者树特性

     1.   传统方法从$k$个归并段选出一个最大或最小元素需要对比关键字$k-1$次，而使用$k$路归并的败者树只需要对比关键字$\lceil\log_2k\rceil$次（败者树层数，不包括成功结点）。

     2.   构建败者树时依然需要$n-1$次对比。

     3.  因为$k$路归并的败者树深度为$\lceil \log_{2}k\rceil$，因此$k$个记录中选择最小关键字，最多需要$\lceil \log_{2}k\rceil$​次比较。所以总的比较次数为
         $$
         \begin{align}
         S(n-1)\left\lceil\log _{2} k\right\rceil & = \left\lceil\log _{k} r\right\rceil(n-1)\left\lceil\log _{2} k\right\rceil \\
         & =(n-1)\left\lceil\log _{2} k\right\rceil
         \end{align}
         $$

     4.  可见，使用败者树后，内部归并的比较次数与$k$无关了。因此，只要内存空间允许，增大归并路数上将有效地减少归并树的高度，从而减少$I/O$次数，提高外部排序的速度。

8.   置换选择排序：用于构建更长的初始归并段，从而减少归并次数。假设初始始待排文件为$FI$，初始归并段输出文件为$FO$，内存工作区为$WA$，$FO$和$WA$的初始状态为空，$WA$可容纳$w$个记录。置换选择算法的步骤如下：

     1. 从$FI$输入$w$记录到工作区$WA$。
     2. 从$WA$中选出其中关键字取最小值的记录，记为$MINIMAX$记录。
     3. 将$MINIMAX$记录输出到$FO$中去。
     4. 若$FI$不空，则从$FI$输入下一个记录到$WA$中。
     5. 从$WA$中所有关键字比$MINIMAX$记录的关键字大的记录中选出最小关键字记录，作为新的$MINIMAX$记录。
     6. 重复步骤三到五，如果新输入到$FI$的关键字小于$MINIMAX$的值，则驻留在$WA$中，直至在$WA$中填满选不出新的$MINIMAX$记录为止，由此得到一个初始归并段，输出一个归并段的结束标志到$FO$中去。准备输出新的归并段。
     7. 重复步骤二到六，直至$WA$为空。由此得到全部初始归并段。

9.   最佳归并树：归并过程中的磁盘$I/O$次数$=$归并树的$WPL\times2$。

     1.   添加虚段：对于$k$叉归并来说，若初始归并段的数量无法构成严格的$k$叉归并树，此时嗯构造出来的归并树的$WPL$不是最小的则需要补充几个长度为$0$的虚拟段从而能保证严格$k$叉归并，再进行$k$叉哈夫曼树的构造。**补充的虚段一定是在叶结点上**。

          设度为$k$的结点有$n_k$个，度为$0$的结点有$n_0$个，归并树的总结点树为$n$

          则初始归并段数量$+$虚段数量$=n_0$，所以$n=n_0+n_k$，$kn_k=n-1$

          总结点数$=$度为$k$的结点数$+$度为$0$的结点数

          度总数$=k\cdot n_k=n-1$，度为$0$的结点不贡献度，对于树有结点数$=$总度数$+1$

          则$n_0=(k-1)n_k+1$

          所以$n_k=\dfrac{(n_0-1)}{(k-1)}$一定是可以整除的，即若$($初始归并段数量$-1)MOD(k-1)=0$，说明刚好可以构成严格$k$叉树，此时不需要添加虚段。

          如果不整除就要添加虚段，即若$($初始归并段数量$-1)MOD(k-1)=u\ne 0$，说明需要补充$k-1-u$个虚段。