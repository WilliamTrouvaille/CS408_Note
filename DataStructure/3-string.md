# 第四章 串

## 导读

### 【考纲内容】

1. 字符串模式匹配

### 【知识导图】

![1689255787t-20230713-2107-434.239](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/1689255787t-20230713-2107-434.239.png)

### 【复习提示】

+ 本章是统考大纲第$6$章内容，采纳读者建议单独作为一章
+ 大纲只要求举握字符串模式匹配，重点举握$KMP$匹配算法的原理及`next`数组的推理过程，手工求`next`数组可以先计算出部分匹配值表然后变形，或根据公式来求解
+ 了解`nextval`数组的求解方法。

## 串

重点是字符串匹配模式，其他只做了解。

### 基本概念

+ 串：零个或多个字符组成的有限序列。
    + 一般记为$S=a_1a_2\cdots a_n(n\ge 0)$
    + 其中，$S$是串名，单引号括起来的字符序列是串的值
    + $a_i$可以是字母、数字或其他字符
    + 串中字符的个数$n$称为串的长度

+ 子串：串中任意个连续的字符组成的子序列。
    + 子串在主串中的位置以子串的第一个字符在主串中的位置来表示

+ 空串：长度为零的串。
    + 使用空集符号$\varnothing$表示

+ 空白串（空格串）：仅由一个或多个空格组成的串。
    + 空格串不是空串

+ 空串是任意串的子串，任意串是其自身的子串。
+ 串的相等：当两个串的长度相等且每个对应位置的字符都相等时，称这两个串是相等的

串的基本操作是对子串的操作。

### 串定义

#### 顺序串(定长存储)

类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。在串的定长顺序存储结构中，为每个串变量分配一个固定长度的存储区，即定长数组。

![1689256016t-20230713-2156-525.201](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/1689256016t-20230713-2156-525.201.png)

顺序串的结构定义方案

![1689256143t-20230713-2103-881.483](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/1689256143t-20230713-2103-881.483.png)

1.   方案一：使用串末尾单独的变量$length$保存串长。
2.   方案二：使用$data[0]$记录充当变量$length$串长
     +   **使得字符位序与数组下标一致**
     +   但是由于$char$类型一个为一字节大小，所以能表示的数字是$0$到$255$
     +   太大的串无法表示，大于的部分会被==截断==。
         +   串的实际长度只能小于或等于`MAXLEN`,超过预定义长度的串值会被舍去，即截断
3.   方案三：没有表示串长的变量，使用$\backslash0$表示串结尾，对应$ASCII$码的$0$号字符。
4.   $data[0]$空余，使用单独的变量$length$保存串长
     +   比较常用
     +   默认使用这种方法

#### 堆串

堆分配存储表示仍然以一组地址连续的存储单元存放串值的字符序列，但它们的存储空间是在程序执行过程中动态分配得到的

```cpp
typedef struct{
	char *ch;	//按串长分配存储区，ch指向串的基地址
	int length; //串的长度
}HString;
```

#### 链串

![1689256321t-20230713-2101-487.194](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/1689256321t-20230713-2101-487.194.png)

+   如一般的链式存储结构定义一样，定义一个数据与指向下一位的指针。

+   但是如果你只在每个结点定义了一个字节的数据，但是又包含了四个字节的指针，那么存储利用率会很低。

+   如果是顺序表数据类型是整数类型，那么这种利用率低的情况确实无可奈何，但是对于串而言，因为一个字节存储一个字符，所以能一个字节存一个字符类型数据，所以为了提升数据存储利用率，可以每个结点存等多个字符。这就是**块链串**。

    +   由于串的特殊性（每个元素只有一个字符），在具体实现时，每个结点既可以存放一个字符，也可以存放多个字符

    ![1689256400t-20230713-2120-613.198](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/1689256400t-20230713-2120-613.198.png)
    
    +   如上图,每个结点存放$4$个字符,存储密度提高
    +   没存满的结点可以利用占位符

### 串的基本操作

1.   `StrAssign(&T,chars)`：赋值操作。把串`T`赋值为`chars`。

     1.   使用默认构造函数初始化：

          - 函数签名：`basic_string()`

          - 功能：创建一个空的字符串对象。

          - 返回值：一个空的string对象。

          - 示例：

              ```cpp
              std::string str;  // 初始化一个空的字符串对象
              ```

     2. 使用字符串字面值初始化：

         - 函数签名：`basic_string(const char*)`

         - 功能：使用给定的C风格字符串字面值初始化字符串对象。

         - 参数：一个以空字符（'\0'）结尾的字符数组，表示字符串字面值。

         - 返回值：一个包含了字符串字面值内容的string对象。

         - 示例：

             ```cpp
             std::string str("Hello, world!");  // 使用字符串字面值初始化字符串对象
             ```

     3. 使用部分字符序列初始化：

         - 函数签名：`basic_string(const char*, size_type count)`

         - 功能：使用给定的C风格字符串的前count个字符初始化字符串对象。

         - 参数：一个以空字符（'\0'）结尾的字符数组，表示字符串字面值；count表示要拷贝的字符数量。

         - 返回值：一个包含了部分字符序列的string对象。

         - 示例：

             ```cpp
             const char* source = "Hello, world!";
             std::string str(source, 5);  // 使用字符串的前5个字符初始化字符串对象
             ```

     4. 使用重复字符初始化：

         - 函数签名：`basic_string(size_type count, CharT ch)`

         - 功能：创建一个包含了count个重复字符ch的字符串对象。

         - 参数：count表示要重复的次数；ch表示要重复的字符。

         - 返回值：一个包含了重复字符的string对象。

         - 示例：

             ```cpp
             std::string str(5, 'A');  // 创建一个包含5个重复字符'A'的字符串对象
             ```

     5. 使用迭代器范围初始化：

         - 函数签名：`template <class InputIterator> basic_string(InputIterator first, InputIterator last)`

         - 功能：使用迭代器范围内的字符序列初始化字符串对象。

         - 参数：first和last分别表示字符序列的起始和结束迭代器。

         - 返回值：一个包含了迭代器范围内字符序列的string对象。

         - 示例：

             ```cpp
             std::vector<char> chars = {'H', 'e', 'l', 'l', 'o'};
             std::string str(chars.begin(), chars.end());  // 使用迭代器范围初始化字符串对象
             ```

2.   `StrCopy(&T,S)`：复制操作。由串`S`复制得到串`T`。

3.   `StrEmpty(S)`：判空操作。若`S`为空串，则返回`TRUE`,否则返回`FALSE`。

4.   `StrLength(S)`：求串长。返回串`S`的元素个数。

5.   `StrCompare (S,T)`：比较操作。若`S>T`,则返回值$>0$;若`S=T`,则返回值$=0$;若`S<T`,则返回值$<0$

     +   ![1689256932t-20230713-2212-875.252](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/1689256932t-20230713-2212-875.252.png)

     +   `compare` 函数：

         - 函数签名：`int compare(const string& str) const`

         - 功能：比较当前字符串与参数字符串 `str` 的大小关系。

         - 参数：`str` 是要进行比较的目标字符串。

         - 返回值：

             - 若当前字符串小于 `str`，则返回一个负整数。
             - 若当前字符串等于 `str`，则返回 0。
             - 若当前字符串大于 `str`，则返回一个正整数。

         - 示例：

             ```cpp
             std::string str1 = "apple";
             std::string str2 = "banana";
             
             int result = str1.compare(str2);
             if (result < 0) {
                 std::cout << "str1 小于 str2" << std::endl;
             } else if (result > 0) {
                 std::cout << "str1 大于 str2" << std::endl;
             } else {
                 std::cout << "str1 等于 str2" << std::endl;
             }
             ```

     +  `operator==`、`operator!=`、`operator<`、`operator>`、`operator<=`、`operator>=`：

         - 函数签名：这些是字符串类（`std::string`）重载的比较运算符。

         - 功能：对两个字符串进行比较，得到一个布尔值表示比较结果。

         - 参数：比较运算符的右侧是要进行比较的另一个字符串。

         - 返回值：布尔值 `true` 或 `false`。

         - 示例：

             ```cpp
             std::string str1 = "apple";
             std::string str2 = "banana";
             
             if (str1 == str2) {
                 std::cout << "str1 等于 str2" << std::endl;
             } else if (str1 != str2) {
                 std::cout << "str1 不等于 str2" << std::endl;
             }
             
             if (str1 < str2) {
                 std::cout << "str1 小于 str2" << std::endl;
             } else if (str1 > str2) {
                 std::cout << "str1 大于 str2" << std::endl;
             }
             ```

6.   `ClearString(&S)`：清空操作。将`S`清为空串。

     +   没有回收存储空间

7.   `DestroyString(&S)`：销毁串。将串`S`销毁

     +   回收存储空间

8.   `Concat(&T,S1,S2)`：串联接。用`T`返回由`S1`和`S2`联接而成的新串

9.   `SubString(&Sub,S,pos,len)`：求子串。用`Sub`返回串`S`的第`pos`个字符起长度为`len`的子串。

     ![1689256803t-20230713-2203-593.256](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/1689256803t-20230713-2203-593.256.png)

     +   `substr` 函数：

         - 函数签名：`string substr(size_type pos = 0, size_type count = npos) const`

         - 功能：从当前字符串中提取一个子串。

         - 参数：`pos` 表示子串的起始位置（默认为 0），`count` 表示要提取的字符数量（默认为 `npos`，提取从 `pos` 开始到字符串末尾的所有字符）。

         - 返回值：一个包含指定子串的新字符串对象。

         - 示例：

             ```cpp
             std::string str = "Hello, world!";
             
             std::string substr1 = str.substr(7);        // 提取从位置 7 开始到末尾的子串
             std::string substr2 = str.substr(0, 5);     // 提取从位置 0 开始的 5 个字符的子串
             std::string substr3 = str.substr(7, 5);     // 提取从位置 7 开始的 5 个字符的子串
             std::string substr4 = str.substr(7, 100);   // 提取从位置 7 开始到末尾的子串（超出字符串长度的部分会被忽略）
             ```

10.   `Index(S,T)`：定位操作。若主串`S`中存在与串`T`值相同的子串，则返回它在主串`S`中第一次出现的
      位置；否则函数值为`0`。

### 模式匹配

+   模式匹配指在主串中找到与模式串相同的子串并返回其所在位置。
    +   子串一一主串的一部分，一定存在
    +   模式串一一要找的串,不一定能在主串中找到

#### 朴素模式匹配算法

从主串$T$、模式串$P$（子串）的第一个位置开始比较（$i=0,j=0$），若相等，则$i$，$j$各自$+1$，然后比较下一个字符。若不等，主串指针回溯到上一轮比较位置的下一个位置，子串回溯到$0$，再进行下一次比较。令子串长度为$m$，主串长度为$n$,则最多对比$n-m+1$次

![1689257815t-20230713-2255-483.795](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/1689257815t-20230713-2255-483.795.png)

使用求子串函数的方法

![1689257412t-20230713-2212-746.252](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/1689257412t-20230713-2212-746.252.png)

不使用求子串函数的方法

![1689257483t-20230713-2223-410.362](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/1689257483t-20230713-2223-410.362.png)

+ 匹配成功的最好时间复杂度：$O(m)$：刚好第一个就匹配上了，总对比次数为子串长度。
+ 匹配失败的最好时间复杂度：$O(n-m+1)=O(n-m)=O(n)$：匹配成功之前，每一个与第一个字符都匹配失败。
+ 匹配失败的最坏时间复杂度：$O(nm-m^2+m)= O(nm)$：子串除了最后一个对不上，其余的都能对上，则每次遍历完一边后，又要走回头路；直到匹配成功/失败一共需要比较$m\times(n-m+1)$次。$m$：每次需要移动$m$次，$i$需要移动$n-m+1$次。

暴力匹配算法的最大问题就是对主串一位位进行对比，当后面的匹配失败后只能回溯主串，从主串中下一位字母从头开始匹配模式串

#### KMP算法

##### 原理

+   $KMP$算法是对朴素模式匹配算法的优化。
+   朴素模式匹配算法的缺点就是当某些子串与模式串能部分匹配时，主串的扫描指针$i$经常回溯，从而导致时间开销。
+   主要思想是不适配时，只有模式串指针回溯，主串指针不变，找到失配前模式串的最长公共前后缀并跳转到最大公共后缀开始匹配，且最大公共前后缀要小于左端子串长度。
+   而不是重复对比之前的内容。这是我们大脑默认处理的过程，$KMP$就是模拟这个处理过程。

+   ==不匹配的字符之前，一定是和模式串一致的==

+   引入`next`数组
    +   子串中第$i$号元素对应的==`next[i]`表示扫描失败时可以跳过匹配的字符个数==
        +   当`next`数组从$0$开始时下一次扫描时子串的指针`=next[i]`
        +   `next`数组的具体构造方法见下

    +   ==扫描失败时主串指针不动,子串指针根据最后一个匹配成功元素对应的`next[i]`跳过相应匹配字符后进行下一次扫描==
        +   主串指针指向上次匹配失败的位置


<div>
    <video src="https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/1689651198t-20230718-1118-.-b.mp4"/>
</div>

代码实现

```cpp
vector<int> kmpSearch(string text, string pattern) {
    vector<int> next = getNext(pattern);  // 调用getLPS函数生成模式串的最长前缀后缀匹配表
    
    int i = 0;	// 初始化主串指针
    int j = 0;  // 初始化模式串指针

    while (i < text.length()) {  // 在主串中循环搜索
        if (text[i] == pattern[j]) {  // 如果当前字符匹配
            i++;  // 向后移动主串指针i
            j++;  // 向后移动模式串指针j
        }
		else if(j>0){		//字符失配且不是在模式串的开头，根据next跳过子串前面的一些字符
            j=next[j-1];
        }
        else{		// 如果在模式串的开头
            i+=1;
        }
        if (j == pattern.length()){	//匹配成功
            return i-j;//返回匹配成功在主串中的索引
        }
    }
}

```



##### 公共前后缀

`next`数组只与模式串本身的最大公共后缀有关，于主串无关。

+ 前缀：对于字符串$A$，$B$，$A=B+S$，且$S$非空，则$B$是$A$的前缀。
+ 后缀：对于字符串$A$，$B$，$A=S+B$，且$S$非空，则$B$是$A$的后缀。
+ $PMT$值：前缀集合和后缀集合的交集中，最长元素的长度。
+ 部分匹配表：$PMT$值集合，字符串所有前后缀的$PMT$值。

当一个位置失配时，那么子串前面的所有字符串都是配对的，所以对于子串前面的部分都是已知的了，需要从模式串的最开始开始对比，而一般的模式匹配要从主串的下一个重新开始匹配，但是如果我们找到了主串当前失配位置的前缀和后缀最大重合的地方，即公共前后缀，$PMT$值，就代表从这里开始就可以匹配了，前面的地方没必要匹配，可以直接多跳几步移动到公共后缀去开始重新匹配。

|  字符串  |         前缀          |         后缀          |   交集    | PMT  |
| :------: | :-------------------: | :-------------------: | :-------: | :--: |
|   'a'    |           ∅           |           ∅           |     ∅     |  0   |
|   'ab'   |          'a'          |          'b'          |     ∅     |  0   |
|  'aba'   |       'a','ab'        |       'ba','a'        |    'a'    |  1   |
|  'abab'  |    'a','ab','aba'     |    'b','ab','bab'     |   'ab'    |  2   |
| 'ababab' | 'a','ab','aba','abab' | 'a','ba','aba','baba' | 'a','aba' |  3   |

所以字符串'$ababa$'的部分匹配值为$00123$，即可以得到部分匹配值表。

##### `next`数组

[^注意]:假设索引值以$0$为开头，如果是以$1$开始则全部加一即可。

+   `next[j]`的含义是：在子串的第`j`个字符与主串发生失配时，则跳到子串的`next[j]`位置重新与主串当前位置进行比较

+   `next`数组的函数表达式如下
    $$
    \operatorname{next}[j]=\left\{\begin{array}{ll}
    0, & j=1 \\
    \max \left\{k \mid 1<k<j \text { 且 }{ }^{\prime} p_{1} L p_{k-1}{ }^{\prime}={ }^{\prime} p_{j-k+1} L p_{j-1}{ }^{\prime}\right\},& \text {当此集合不为空时 }\\
    1, & \text {其他情况 }
    \end{array}\right.
    $$

    +   公式解释

        +   设主串为$s_1s_2s_3\cdots s_n$
        +   设模式串为$p_1p_2p_3\cdots p_m(m\le n)$

    +   具体分析:

        1.   当模式串第一个字符($j = 1$)与主串第$i$个字符发生失配时，规定$next[1]=0$

             +   可理解为将主串第$i$个字符和模式串第一个字符的前面空位置对齐，也即模式串右移一位
             +   模式串移动到下一个匹配位置

        2.   当模式串中第$j(1<j<m)$个字符即$p_{j-1}$与主串中第$i$个字符失配时

             1.   假设此时应与模式中第$k (1<k<j)$个字符继续比较(==第$k$个字符应该刚好不匹配==)，则模式中前$k-1$个字符的子串必须满足下列条件
                  $$
                  \begin{align}
                  &\text{(1)}'p_1p_2 \cdots p_{k-1}\; ' = ' p_{j-k+1}+p_{j-k+2}+\cdots p_{j-1}\;'\\
                  &\text{(2)}不存在k'>k满足条件(1)
                  \end{align}
                  $$

                  +   其中条件`(1)`表示从==模式串开头的==连续的$k-1$个的元素(即${ }^{\prime} p_{1} L p_{k-1}{ }^{\prime}$或$'p_1p_2 \cdots p_{k-1}\; '$)和从==当前字符倒着看的==连续的$k-1$个的元素(即${ }^{\prime} p_{j-k+1} L p_{j-1}{ }^{\prime}$或$' p_{j-k+1}+p_{j-k+2}+\cdots p_{j-1} '$,其中$p_{j-1}$是当前字符)相匹配
                  +   其中条件`(2)`表示`k`应该是满足条件$(1)$的集合中的最大值

<!-- 1. 求$next[j+1]$，则已知前面的所有$next$表值$next[1],next[2]\cdots next[j]$。

1. 假设数组值$next[j]=k_1$（跳转索引），则有$P_1\cdots P_{k_1-1}=P_{j-k_1+1}\cdots P_{j-1}$（前$k_1-1$位字符与后$k_1-1$位字符重合）。
2. 如果$P_{k_1}=P_j$（即最后一位也一样，则得到在之前匹配基础上的更长的公共前后缀），则$P_1\cdots P_{k_1-1}P_{k_1}=P_{j-k_1+1}\cdots P_{j-1}P_j$，则$next[j+1]=k_1+1$，否则进入下一步。
3. 假设$next[k_1]=k_2$、则有$P_1\cdots P_{k_2-1}=P_{k_1-k_2+1}\cdots P_{k1-1}$。
4. 第二第三步联合得到$P_1\cdots P_{k_2-1}=P_{k_1-k_2+1}\cdots P_{k1-1} =P_{j-k_1+1}\cdots P_{k_2-k_1+j-1}=P_{j-k_2+1}\cdots P_{j-1}$，即四段重合。
5. 这时候．再判断如果$P_{k_2}=P_j$，则$P_1\cdots P_{k_2-1}P_{k_2}=P_{j-k_2+1}\cdots P_{j-1}P_j$，则$next[j+1]=k_2+1$，否则再取$next[k_2]=k_3$回到四。
6. 如果遇到$0$还没有结果，则表示前面的全部不重合，赋值为$0+1=1$。

可以通过一定关系不用计算最大公共前后缀得到$next$值：

要计算当前位置的$next$值，就看前一位的$next$值所代表的索引指向的字符是否与前一位的字符相等，若相等，则是前一位的$next$值加一，若不等，则继续看前一位的$next$值指向的字符的$next$指向的字符与前一位字符是否相等，若相等则结果就是这个$next$值加一，否则继续按照$next$索引向前寻找。最后都不等则前一位$next$为$0$，当前位置的$next$为$1$。 -->

<video src="https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307181207903.mp4"/>

代码实现

```cpp
vector<int> getNext(string pattern) {
    vector<int> next(len, 0);  // 创建一个与模式串长度相同的数组next，并初始化为0
    
    int i = 1;	// 初始化模式串指针,指向当前元素next数组开头为0,手动设置
    int j = 0;  // 辅助指针
    
    next[1] = 0;	// next数组开头为0

    while (i < pattern.length()) {  // 循环计算每个位置的next值
        if (pattern[i] == pattern[j] || j==0) {  // 如果当前字符匹配
            next[i] = j + 1;  // 将next值设置为j+1
            i++;  // 向后移动指针i
            j++;  // 向后移动指针j
        }
        else {// 如果j不为0，则更新j为上一个位置的next值
        	j = next[j - 1];
        }
    }

    return next;  // 返回next
}
```

##### 算法性能

使用$KMP$算法时需要先计算不同模式串$P$的$next$数组，时间复杂度为$O(m)$，然后使用$KMP$算法计算，时间复杂度为$O(n)$，从而平均时间复杂度为$O(m+n)$。

虽然普通模式匹配算法复杂度$O(mn)$，但是一般情况下接近于$O(m+n)$。

$KMP$算法对于重复部分比较多的模式串匹配效果更好。

#### KMP算法优化

$KMP$算法的$next$数组存在一定问题，当当前索引的值匹配失败，那么模式串的其他同样值的地方也一定会匹配失败。

如主串$aaabaaaab$匹配模式串$aaaab$，其中$PMT$表格为：

![23July18-135338-1689659618-f04d83d1-8691-4868-9242-5facdc7e0f3c](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307181353227.png)

当$i=4、j=4$时，$s_4$跟$p_4(b\ne a)$失配，如果用之前的`next`数组还需要进行$s_4$与$p_3、s_4$
与$ p_2、s_4 $与$ p_1 $这$ 3 $次比较。事实上，因为$ p_{next [4]=3}=p_4=a、p_{next [3]=2} =p_3=a、p_{next [2] =1}=p_2=a,$
显然后面$3$次用一个和$p_4$相同的字符跟$s_4$比较毫无意义，必然失配。

+   问题在于不应该出现$p_j=p_{next[j]}$
    +   理由是：当$p_j\ne s_j$时，下次匹配必然是$p_{next[j]}$跟$s_j$比较
    +   如果$p_j=p_{next[j]}$，那么相当于拿一个和$p_j$相等的字符跟$s_j$比较，这必然导致继续失配，这样的比较毫无意义。
+    则如果出现了$p_j=p_{next[j]}$应该如何处理
    +   可以直接将模式串所有相同值的部分的$next$值全部取为其$next$值对应索引的$next$值。
    +   所以需要再次递归，将$next[j]$变为$next[next[j]]$直到两者不相等，令更新后数组为$nextval$。

|    序号    |  0   |  1   |  2   |  3   |  4   |  5   |
| :--------: | :--: | :--: | :--: | :--: | :--: | :--: |
|   模式串   |  g   |  o   |  o   |  g   |  l   |  e   |
|  next[j]   |  -1  |  0   |  0   |  0   |  1   |  0   |
| nextval[j] |  -1  |  0   |  0   |  -1  |  1   |  0   |

对于多个字符重复的字符串，则$nextval$的优化程度会更高：

|    序号    |  0   |  1   |  2   |  3   |  4   |
| :--------: | :--: | :--: | :--: | :--: | :--: |
|   模式串   |  a   |  a   |  a   |  a   |  b   |
|  next[j]   |  -1  |  0   |  1   |  2   |  3   |
| nextval[j] |  -1  |  -1  |  -1  |  -1  |  3   |

代码实现为

```cpp
vector<int> getNextVal(string pattern) {
    vector<int> nextVal(len, 0);  // 创建一个与模式串长度相同的数组next，并初始化为0
    
    int i = 1;	// 初始化模式串指针,指向当前元素next数组开头为0,手动设置
    int j = 0;  // 辅助指针
    
    nextVal[1] = 0;	// next数组开头为0

    while (i < pattern.length()) {  // 循环计算每个位置的next值
        if (pattern[i] == pattern[j] || j==0) {  // 如果当前字符匹配
            i++;  // 向后移动指针i
            j++;  // 向后移动指针j
            
            if (pattern[i] != pattern[j]){	//加了这步
                nextVal[i] = j;
            }
            else{
                nextVal[i] = j + 1;  // 将next值设置为j+1
            }
        }
        else {// 如果j不为0，则更新j为上一个位置的next值
        	j = nextVal[j - 1];
        }
    }

    return nextVal;  // 返回优化后的next
}
```

