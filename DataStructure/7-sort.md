# 第八章 排序

## 导读

### 【考纲内容】

1. 排序的基本概念
2. 插入排序
    + 直接插入排序
    + 折半插入排序
    + 希尔排序($shell\;sort$)
3. 交换排序
    + 冒泡排序($bubble\;sort$)
    + 快速排序
4. 选择排序
5. 二路归并排序($merge\;sort$)
6. 基数排序
7. 外部排序
8. 排序算法的分析和应用

### 【知识导图】

![image-20230722203235652](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307222032713.png)

![image-20230724194611557](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307241946664.png)

### 【复习提示】

+   堆排序、快速排序和归并排序是本章的重难点
+   读者应深入掌握各种排序算法的思想、排序过程（能动手模拟）和特征（初态的影响、复杂度、稳定性、适用性等），通常以选择题的形式考查不同算法之间的对比
+   此外，对于一些常用排序算法的关键代码，要达到熟练编写的程度；看到某特定序列，读者应具有选择最优排序算法（根据排序算法特征）的能力。

>   https://www.cs.usfca.edu/~galles/visualization/Algorithms.html
>
>   [排序（冒泡排序，选择排序，插入排序，归并排序，快速排序，计数排序，基数排序） - VisuAlgo](https://visualgo.net/zh/sorting)
>
>   算法学习网站

## 基本概念

+ 排序：将一个数据元素的任意序列重新排列成一个按关键字有序的序列。
+ 内部排序：待排序的记录存放在计算机的内存中所进行的排序操作称为内部排序。
    + 主要关注如何使算法时、空复杂度更低，而时间复杂度一般是由比较和移动次数决定的。
+ 外部排序：待排序的记录数量很大，以致内存一次不能容纳全部记录，在排序过程中需要访问外存的排序过程称为外部排序。
    + 除了关注时空间复杂度外，还要关注如何使读/写磁盘次数更少
+ 稳定的排序：比如一个序列是“$1\;4\;3\;3*\;2$”，按从小到大排序后变成“$1\;2\;3\;3*\;4$”，就叫做稳定排序，即3和3*相对顺序不变。如果相同关键字的顺序发生了改变，则是不稳定的排序
    + 稳定性的需要看具体的应用场景。
    + 稳定的排序
        1.   基数排序
        2.   冒泡排序
        3.   直接插入排序
        4.   折半插入排序
        5.   归并排序
        6.   桶排序
        7.   基数排序
    + 不稳定的排序
        1.   堆排序
        2.   快速排序
        3.   希尔排序
        4.   直接选择排序


>   对于不稳定的排序算法，只需举出一组关键字的实例，说明它的不稳定性即可。

+ 大部分排序算法都仅适用于顺序存储的线性表。
    + 适合链表的排序算法：~~那不就是大部分都可以吗~~
        1.   冒泡排序
        2.   选择排序
        3.   直接插入排序
        6.   计数排序
        8.   基数排序
    + 不适合链表的排序算法
        1.   希尔排序
        2.   快速排序
        3.   归并排序
        4.   二分插入排序
             +   以及包含所有需要二分查找优化的排序算法
    + 可以用于链表排序但不建议使用的排序算法：**堆排序**。
        + **堆排序**：堆排序所使用的最大堆 / 最小堆结构本质上是一棵完全二叉树。而完全二叉树适合采用顺序存储结构（数组）。因为数组存储的完全二叉树可以很方便的通过下标序号来确定父亲结点和孩子结点，并且可以极大限度的节省存储空间。
        + 而链表用在存储完全二叉树的时候，因为不支持随机访问的特性，导致其寻找子结点和父亲结点会比较耗时，如果增加指向父亲结点的变量，又会浪费大量存储空间。所以堆排序算法不适合进行链表排序。
        + 如果一定要对链表进行堆排序，则可以使用额外的数组空间表示堆结构。然后将链表中各个结点的值依次添加入堆结构中，对数组进行堆排序。排序后，再按照堆中元素顺序，依次建立链表结点，构建新的链表并返回新链表头结点。
+ 大部分排序需要经过比较和移动两个过程
    + ==基数排序不需要比较==
    + 排序时至少需要比较$\lceil\log_2(n!)\rceil$次
    + 每次比较两个关键字后，仅出现两种可能的转移
        + 假设整个排序过程至少需要做$t$次比较。则显然会有$2^t$种情况
        + 由于$n$个记录共有$n!$种不同的排列，因而必须有$n!$种不同的比较路径，于是有$2^t\geqslant n!$，所以得到不等式。

## 插入排序

![image-20230724194805331](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307241948112.png)

### 插入排序共性

+ 插入排序的排序序列分为未排序序列和已排序序列。
+ 插入排序就是将选定的目标值插入到对应的位置，然后不断增长已排序序列并缩减未排序序列的过程。
+ 每一趟排序都不能保证有一个元素到达最终的位置上。

### 直接插入排序

#### 直接插入排序过程

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/1/16769e2f8521af05~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成为止。

假设在排序过程中，待排序表`L[1..n]`在某次排序过程中的某一时刻状态如下： 

![image-20230724193746638](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307241937705.png)

要将元素`L(i)`插入已有序的子序列`L` \;需要执行以下操作（为避免混淆，下面用`L[]`表示一个表，而用`L()`表示一个元素）：

1.   查找出`L(i)`在中的插入位置`k`。
2.   将`L [k...i-l]`中的所有元素依次后移一个位置。
3.   将`L(i)`复制到`L(k) `

为了实现对`L[1..n]`的排序，可以将`L(2)~L(n)`依次插入前面已排好序的子序列，初始`L[1]`可以视为是一个已排好序的子序列。

![23July22-201442-1690028082-128eeaeb-7847-4c93-a2e7-11b2fef2b785](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307222014711.png)

#### 直接插入排序性能

+   空间复杂度为$O(1)$。
+   平均时间复杂度是$O(n^2)$
    +   时间复杂度主要来自对比关键字，移动元素，若有$n$个元素，则需要$n-1$趟处理。
    +   最好情况是原本的序列就是有序的，需要$n-1$趟处理，每次只需要对比一次关键字，不用移动元素，时间复杂度为$O(n)$。
    +   最坏情况是原本的序列是逆序的，需要$n-1$趟处理，第$i$趟处理需要对比关键字$i+1$次，移动元素$i+2$次，时间复杂度是$O(n^2)$。
+   直接插入排序算法是稳定的。
+   ==可以对链表进行直接插入排序==，如果使用链表实现直接插入排序，移动元素的次数变少了，但是关键字对比次数仍然是$O(n^2)$，从而整体时间复杂度依然是$O(n^2)$。
    +   不能对链表进行二分插入排序

#### 直接插入排序特性

+ 在待排序的元素序列基本有序的前提下，直接插入排序效率最高的。
+ 直接插入排序进行$n$躺后能保证前$n+1$个元素是有序的，但是不能保证其都在最终的位置上。

### 二分插入排序

#### 二分插入排序过程

![image-20230724203108743](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307242031983.png)

也称为折半插入排序，是对直接插入排序的优化，在寻找插入位置时使用二分查找的方式。

当`data[mid]==data[i]`时，为了保证算法的稳定性，会继续在$mid$所指位置右边寻找插入位置。

当$low>high$时停止折半查找，并将$low>i-1$内的元素全部右移，并把元素值赋值到$low$所指的位置。

折半插入排序是找到位置了后一起移动元素，而直接插入排序是边查找边排序。

>   注
>
>   本笔记中所有使用代码框的代码均是**OI**（Olympiad in Informatics，信息学奥林匹克竞赛）比赛使用的算法\;学有余力的朋友可以参考
>
>   ==408数据结构写这些代码不保证得分==
>
>   ~~我目前连能不能用STL都不知道~~

```cpp
void insertion_sort(int arr[]\; int len) {
    // 函数开始，插入排序的函数定义，接受一个整数数组 arr 和数组长度 len 作为参数

    if (len < 2) return;
    // 如果数组长度小于 2，也就是数组中只有 0 个或 1 个元素，直接返回，不需要排序

    for (int i = 1; i != len; ++i) {
        // 进入循环，从数组的第二个元素开始，将它依次插入到前面已排序的子数组中

        arr[0] = arr[i];
        // 使用数组开头存储当前待插入的元素值，这个元素将被依次插入到前面已排序的子数组中

        auto index = upper_bound(arr\; arr + i\; key) - arr;
        // 使用二分查找的方式在已排序的子数组中找到插入位置，并返回插入位置的索引

        // 使用 memmove 移动元素，比使用 for 循环速度更快，时间复杂度仍为 O(n)
        // 将已排序的子数组中大于待插入元素 key 的元素都向后移动一位，为 key 腾出插入位置
        memmove(arr + index + 1\; arr + index\; (i - index) * sizeof(int));

        // 将待插入元素 key 插入到已排序的子数组中的正确位置
        arr[i] = key;
    }
}

```

---

>   `memmove` 是 C++ STL 中的函数，用于在内存中移动一块数据。它类似于 `memcpy`，但处理了源内存和目标内存有重叠的情况，因此在这种情况下，`memmove` 会以一种安全的方式进行复制，保证数据正确性。
>
>   以下是 `memmove` 函数的详细信息：
>
>   - 函数签名：`void* memmove(void* dest\; const void* src\; size_t count);`
>   - 功能：在内存中移动数据。
>   - 参数：
>     - `dest`：指向目标内存区域的指针，表示数据将被复制到该内存区域。
>     - `src`：指向源内存区域的指针，表示要复制的数据来自该内存区域。
>     - `count`：要复制的字节数。
>   - 返回值：`void*`，指向目标内存区域的指针。
>
>   注意事项：
>   - `memmove` 在处理源内存和目标内存有重叠的情况下是安全的，即使两个内存区域有交叠，`memmove` 也能正确处理，不会产生未定义的行为。
>   - `memmove` 的使用方式与 `memcpy` 类似，但由于其处理重叠的特性，更适合在需要处理可能重叠内存区域的情况下使用。
>
>   示例：
>   ```cpp
>   #include <cstring>
>   #include <iostream>
>   
>   int main() {
>       char source[] = "Hello\; world!";
>       char destination[20];
>   
>       // 在内存中移动数据（可以处理重叠的情况）
>       std::cout << "Before memmove: " << destination << std::endl;
>       memmove(destination\; source\; strlen(source) + 1);
>       std::cout << "After memmove: " << destination << std::endl;
>   
>       return 0;
>   }
>   ```
>   输出：
>   ```
>   Before memmove: 
>   After memmove: Hello\; world!
>   ```
>

#### 二分插入排序性能

+   空间复杂度为$O(1)$。
+   ==二分插入排序是稳定的。==
+   时间复杂度为$O(n^2)$
    +   比起直接插入排序，比较关键字的次数减少为$O(n\log_2n)$，移动元素的次数没变

#### 二分插入排序特性

+ 对于直接插入的优化仅在于二分查找的比较次数。
+ 二分插入排序进行$n$躺后能保证前$n+1$个元素是有序的，但是不能保证其都在最终的位置上。

### 希尔排序

又称缩小增量排序。

#### 希尔排序过程

![image](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/1/16769b31d5689855~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

+   希尔排序也是对直接插入排序的优化
    +   直接插入排序对于基本有序的序列排序效果较好，所以就希望序列能尽可能基本有序
    +   从而希尔排序的思想就是先追求表中元素部分有序，然后逐渐逼近全局有序。

+   算法思路

    +   先将整个待排序元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）

    +   分别进行**直接插入排序**

    +   然后缩小增量重复上述过程，直到增量为$1$

    +   每次对比只对比两个以上的个元素进行插入交换。

        ![image-20230724203047818](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307242030032.png)

+   增量序列的选择建议是第一趟选择元素个数的一半，后面不断缩小到原来的一半。

~~但是打IO的时候一般使用三分法~~

~~但是这是考研，还是按课上讲的算法写~~

~~呜呜呜我的内省排序~~

```cpp
template <typename T>
void shell_sort(T array[]\; int length) {
    // 希尔排序函数，接受一个模板类型 T 的数组 array 和数组长度 length 作为参数

    int h = 1;
    // 定义变量 h，用于设置初始的增量值

    while (h < length / 3) {
        // 计算增量的初始值，这里采用 Knuth 序列，h 的初始值为 1，并按照 3 * h + 1 的规则逐渐增大 h
        h = 3 * h + 1;
    }

    while (h >= 1) {
        // 根据计算得到的增量 h 进行希尔排序，当 h 为 1 时，就是普通的插入排序

        for (int i = h; i < length; i++) {
            // 从 h 开始，依次对每个分组进行插入排序

            for (int j = i; j >= h && array[j] < array[j - h]; j -= h) {
                // 对当前分组进行插入排序，将 array[j] 插入到正确的位置，每次移动的步长是 h
                // 这里使用了类似插入排序的方式，不过步长是 h 而不是 1

                std::swap(array[j]\; array[j - h]);
                // 交换 array[j] 和 array[j - h]，将较小的元素向前移动
            }
        }

        h = h / 3;
        // 减小增量 h，继续进行下一轮的希尔排序，直到 h 变为 1，排序完成。
    }
}

```

#### 希尔排序性能

+   空间复杂度为$O(1)$。

+   最坏时间复杂度为$O(n^2)$，在某个范围内可以达到$O(n^{1.3})$。
    +   而时间复杂度和增量序列的选择有关，目前无法使用属性手段证明确切的时间复杂度。

+   希尔排序是不稳定的
    +   因为相同的元素可能分到不同的子序列中进行重排打乱原有顺序）
+   希尔排序只适用于顺序表而不适合用于链表，无法快速进行增量的访问。

#### 希尔排序特性

+ 希尔排序在最后一趟前都不能保证元素在最后的位置上。
+ 希尔排序在最后一趟前都不能保证元素是有序的。

## 交换排序

![image-20230724205202197](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307242052086.png)

### 交换排序共性

+ 交换排序即根据序列中两个元素关键的比较结构然后交换这两个记录在序列中的位置。
+ $n$趟排序后就有$n$个元素到达最终的位置上。

### 冒泡排序

重点就是相邻两两比较。

#### 冒泡排序过程

![image](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/1/16769b31ce224ee6~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

从后往前或从前往后两两比较相邻元素的值，若逆序则交换这两个值，如果相等也不交换，直到序列比较完。这个过程是一趟冒泡排序，第$i$趟后第$i$个元素会已经排序完成。每一趟都会让关键字最小或最大的一个元素到未排序队列的第一个或最后一个。一共需要$n-1$趟排序。

+   ==冒泡排序中所产生的有序子序列一定是全局有序的==
    +   （不同于直接插入排序）
    +   ==也就是说，有序子序列中的所有元素的关键字一定小于或大于无序子序列中所有元素的关键字==
    +   这样每趟排序都会将一个元素放置到其最终的位置上。

#### 冒泡排序性能

空间复杂度为$O(1)$。

最好情况下即本身序列有序，则比较次数是$n-1$，交换次数是$0$，从而时间复杂度是$O(n)$。

最坏情况是逆序情况，比较次数和交换次数都是$\dfrac{n(n-1)}{2}$，所以时间复杂度是$O(n^2)$。

从而平均时间复杂度是$O(n^2)$。

冒泡排序是稳定的。

==冒泡排序可以用于链表。==

#### 冒泡优化

对于每行冒泡进行优化：如果发现排序前几轮就已经实现了排序成功，那么后面的排序岂不是都浪费了时间进行比较？可以在第一轮循环中设置一个布尔值为$false$，如果在这一轮发生排序交换就设置为$true$，如果一轮结束后发现这个值还是$false$，说明这一轮没有进行交换，表示已经排序成功，就直接所有退出循环。

![image-20230724202831299](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307242028483.png)

对于每列冒泡进行优化：默认每一轮冒泡是从$[length-i]$结束，如一共$5$个元素排序，需要$4$轮排序，第二轮冒泡排序应该从$0$开始，到$3$结束，因为最后一个元素4已经在第一轮排序成功。但是如果在第二轮发现$2$，$3$已经排序成功了不需要交换，那么默认排序方法第三轮还是要从$0$到$2$进行排序，还要比较一次$1$和$2$位置的数据，这就造成了浪费，那么如何解决？记录每一轮发生比较的元素的最大索引值，下一轮比较到这个索引值直接结束，不需要继续比较后面的元素。如果最大索引值为$0$则直接退出。这就进一步优化了上面一种策略。

```c
void Bubble(int[] a) {
    // 冒泡排序函数，接受一个整数数组 a 作为参数

    int n = a.length - 1;
    // 获取数组的长度，并将其存储在变量 n 中，n 为最后一个元素的索引

    while (true) {
        // 进入一个无限循环，排序直到数组完全有序，或者没有交换操作发生为止

        int last = 0;
        // 表示最后一次交换元素位置的索引

        for (int i = 0; i < n; i++) {
            // 从数组的第一个元素开始，依次比较相邻的两个元素，并进行交换操作

            if (a[i] > a[i + 1]) {
                // 如果前一个元素大于后一个元素，进行交换操作

                swap(a\; i\; i + 1);
                // 调用 swap 函数，交换 a[i] 和 a[i + 1] 的值
                // swap 函数用于交换数组中两个位置的元素值

                last = i;
                // 更新最后一次交换的索引为 i
            }
        }

        n = last;
        // 更新 n 的值为最后一次交换的索引，即之后的元素已经有序

        if (n == 0) {
            // 如果最后一次交换的索引为 0，表示整个数组已经有序
            // 即没有发生交换操作，排序完成，可以退出循环
            return;
        }
    }
}

```

#### 冒泡排序特性

+ 冒泡排序产生的序列全局有序，$n$趟排序后第$n$个元素到达最终的位置上，前$n$个或后$n$个位置的元素确定。

### 快速排序

排序过程类似于构建二叉排序树。基于分治法。

#### 快速排序过程

![image](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/1/16769b3220291f72~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

![image-20230724203532797](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307242035015.png)

+   算法思路

    +   取待排序序列中的某个元素`pivot`作为基准

        +   一般取第一个元素

    +   通过一趟排序，将待排元素分为左右两个子序列

    +   若左子序列元素的关键字均小于或等于基准元素的关键字，右子序列的关键字大于基准元素的关键字

        +   则称进行了一趟快速排序/一次划分
        +   此时左右指针相等
            +   均指向基准元素`pivot`应该在的地方

    +   这个`pivot`已经成功排序。然后分别对两个子序列继续进行快速排序，直至整个序列有序。

        ![23July22-212632-1690032392-5d539351-03ed-4a13-81b0-e2d2a5050d8a](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307222126275.png)

---

==代码（全数据结构最重要的代码，要背）==

```cpp
#include <algorithm>
#include <iostream>
using namespace std;
//取在待排序列中取一个元素pivot作为枢轴（或基准，通常为首元素）
//把这个元素排到它该在的位置，即pivot前的元素都小于或等于它，pivot后的元素都大于或等于它，我们称这一步操作为一次划分
int poration(int* A\; int low\; int high) {
	int pivot = A[low];
	while (low < high) {
		while (low < high && A[high] >= pivot) high--; 
		A[low] = A[high];
		while (low < high && A[low] <= pivot) low++;
		A[high] = A[low];
	}
	return low;
}
//经过一次划分后会得到pivot左边的子表和pivot右边的子表，我们对左右子表同样进行一次划分操作
//最后我们会对只有一个元素的子表进行划分操作，整个序列就有序了
void quicksort(int* A\; int low\; int high) {
	if (low < high) {
		int pivot = poration(A\; low\; high);
		quicksort(A\; low\; pivot - 1);
		quicksort(A\; pivot + 1\; high);
	}
}
int main() {
	int n;
	cin >> n;
	int a[n];
	for (int i = 0; i < n; i++)
		cin >> a[i];
	quicksort(a\; 0\; n - 1);
	for (int j = 0; j < n; j++)
		cout << a[j] << " ";
}

```

---

>   三路快速排序
>
>   ```cpp
>   // 模板的 T 参数表示元素的类型，此类型需要定义小于（<）运算
>   template <typename T>
>   // arr 为需要被排序的数组，len 为数组长度
>   void quick_sort(T arr[]\; const int len) {
>     if (len <= 1) return;
>     // 随机选择基准（pivot）
>     const T pivot = arr[rand() % len];
>     // i：当前操作的元素下标
>     // arr[0\; j)：存储小于 pivot 的元素
>     // arr[k\; len)：存储大于 pivot 的元素
>     int i = 0\; j = 0\; k = len;
>     // 完成一趟三路快排，将序列分为：
>     // 小于 pivot 的元素 | 等于 pivot 的元素 | 大于 pivot 的元素
>     while (i < k) {
>       if (arr[i] < pivot)
>         swap(arr[i++]\; arr[j++]);
>       else if (pivot < arr[i])
>         swap(arr[i]\; arr[--k]);
>       else
>         i++;
>     }
>     // 递归完成对于两个子序列的快速排序
>     quick_sort(arr\; j);
>     quick_sort(arr + k\; len - k);
>   }
>   ```
>

#### 单边循环快排

即$lomuto$洛穆托分区方案。

1. 选择最右边的元素值做标杆，把标杆值放入$pivot$变量中。
2. 初始时，令$low$和$high$都指向最左边的元素。其中$low$用于被动向右移动，维护小于标杆值的元素的边界，即每次交换的目标索引，一旦交换$low$就向右移动一个；$high$用于主动向右移动，寻找比标杆值小的元素，一旦找到就与$low$指向元素进行交换。
3. 然后$high$开始移动，判断$high$指向的元素值是否小于$pivot$值，如果不小于就继续向右移动。
4. 当遇到比标杆小的值，$high$指向的值就和$low$指向的值进行交换，如果$high$和$low$指向的值为同一个则不进行交换，然后$low$右移一个，$high$继续右移查找。
5. $high$继续移动，最后$high>=pivot$时将基准点元素值与$low$指向值进行交换，该轮排序结束。此时$low$指向的位置就是$pivot$值所应该在的位置。
6. 返回基准点元素所在索引，从而确定排序上下边界，递归继续执行排序。

#### 双边循环快排

分为普通分区方案和$hoare$霍尔分区方案。逻辑基本上一样，只是边界选择方式不同。

1. 先选择个值做标杆，一般为最左边值，把标杆值放入$pivot$变量中。
2. 初始时，令$high$指向序列最右边的值，$low$指向序列最左边的值。
3. 然后从$high$开始不断左移，当遇到比标杆大或等于的值时$high--$。
4. 如果发现比标杆小的值，即$high<pivot$，需要交换，然后$high$不动，$low++$开始移动去找要交换的大于标杆的值。
5. 若$low$所指向的值比标杆小或等于，则$low++$进行寻找。（为什么要加上一个等于标杆值可以继续向右移动的条件？因为标杆值默认是第一个值，即初始化$pivot$跟$low$指向同一个值，如果只能小于标杆值才能继续移动不交换，则在第一个元素时，由于标杆值被初始化赋值为第一个值，则标杆$pivot$值等于$low$值，从而导致$low$值跟$high$值进行交换，导致$pivot$标杆值被交换走了，标杆值变为了最开始最右边的$high$值，导致了排序有问题）
6. 若$low$所指向的值比标杆大，则$low$值与$high$值进行交换。
7. 交换后$low$不动，$high--$开始移动。回到步骤三开始执行。
8. 当$low=high$时表示$low$和$high$之前的元素都比基准小，$low$和$high$之后的元素都比基准大，完成了一次划分。然后把基准元素放入$low==high$指向的位置。
9. 不断交替使用$low$和$high$指针进行对比。对左右子序列进行同样的递归操作即可，从步骤三开始。若左右两个子序列的元素数量小等于一，则无需再划分。

即对序列进行比较，有头尾两个指针，尾指针开始比较向前移动，若指向值比对比值小则要交换，交替让头指针开始移动，否则不改变指针则尾指针继续向前；同理头指针向后移动，若指向值比对比值大则交换，交替让尾指针移动，否则不改变指针则头指针继续向后。最后头尾指针指向一个位置，将对比值插入到当前值，此时一趟完成。

[洛穆托分区与霍尔分区比较](https://qastack.cn/cs/11458/quicksort-partitioning-hoare-vs-lomuto
)。

#### 快速排序性能

+   由于快速排序使用了递归，所以需要递归工作栈，空间复杂度与递归层数相关，所以空间复杂度为$O($递归层数$)$。
+   每一层划分只需要处理剩余的待排序元素，时间复杂度不超过$O(n)$，所以时间复杂度为$O(n\times$归层数$)$。
+   而快速排序会将所有元素组织成为二叉树，二叉树的层数就是递归调用的层数。所以对于$n$个结点的二叉树，最小高度为$\lfloor\log_2n\rfloor+1$，最大高度为$n$。
+   从而最好时间复杂度为$O(n\log_2n)$，最坏时间复杂度为$O(n^2)$，==平均时间复杂度为$O(n\log_2n)$==
+   最好空间复杂度为$O(\log_2n)$，最坏空间复杂度为$O(n)$，==平均空间复杂度为$O(\log_2n)$==
+   ==所以如果初始序列是有序的或逆序的，则快速排序性能最差（速度最慢）==
    +   若每一次选中的基准能均匀划分，尽量让数轴元素平分，则效率最高（速度最快）
    +   ==性能与分区处理顺序无关==
+   所以对于快速排序性能优化是选择尽可能能中分的基准元素，入选头中尾三个位置的元素，选择中间值作为基准元素，或随机选择一个元素作为基准元素。
+   每趟排序会确定在最终位置的元素
    +   ==其中"趟"定义为对尚未确定最终位置的所有元素进行一遍处理==
    +   第一趟排序确定一个在最终位置的元素后会把序列分成两份
    +   之后趟的排序若确定的两个元素不挨在一起，则会把序列多分出来一份
    +   ==每趟排序会在**每个**已经确定最终位置的元素隔开形成的"块"中选出来一个确定最终位置的元素==
    +   即假设每趟排序确定的元素都不挨在一起
        +   则第一趟确定一个元素
        +   第二趟确定两个元素
        +   第$3$趟确定$4$个元素
        +   $\cdots$

+   最好使用顺序存储，这样找到数轴元素与遍历时比较简单。
+   ==快速排序算法是不稳定的。==

>   证明时间复杂度是 $O(n\log_{\cdot}n)$
>
>   ![image-20230722210308891](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307222103009.png)
>
>   via [快速排序 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/basic/quick-sort/)

#### 快速排序特性

+ 快速排序不产生有序子序列。
+ 枢轴元素到达的位置是不确定的，但是每次都会到其最终的位置上
    + 第$n$趟有$n$个元素到最终位置上。

+ 求快速排序趟数就是找到符合这种性质的元素个数。
+ 快速排序在内部排序中的表现最好。
+ 对于基本有序或倒序的序列，快速排序速度最慢。
+ 对于每次的数轴元素能尽量将表分为长度相同的子表，快速排序速度最快。
+ 排序的递归次数与初始序列和选择的枢轴变量有关，与分区处理顺序无关。

## 选择排序

### 选择排序特性

+ 分为已排序和未排序序列。选择排序就是每一趟在待排序元素中选取关键字最小或最大的元素加入有序子序列。
+ ==选择排序算法的比较次数始终为$\dfrac{n(n-1)}{2}$，与序列状态无关。==

选择排序与其他排序的区别：

+ 选择排序也需要==交换==
    + 但是与交换排序的不断交换不同的是选择排序时选择出一个最后进行交换
    + 一趟只交换一次。

+ 选择排序也需要==插入==
    + 且也分为已排序和未排序序列
    + 但是插入排序不需要选择，且元素移动方式是插入而不是交换。


### 简单选择排序

#### 简单选择排序过程

![selection sort animate example](https://oi-wiki.org/basic/images/selection-sort-1-animate-example.svg)

![image](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/1/16769b31d0567de3~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

即每一趟在待排序元素中选取关键字最小的元素加入有序序列。交换发生在选出最值后，在每趟的尾部。经过$n-1$趟就可以完成。

```cpp
void selection_sort(int* a\; int n) {
  for (int i = 1; i < n; ++i) {
    int min = i;
    for (int j = i + 1; j <= n; ++j) {
      if (a[j] < a[ith]) {
        min = j;
      }
    }
    std::swap(a[i]\; a[min]);
  }
}

```

#### 简单选择排序性能

+   空间复杂度为$O(1)$。
+   时间复杂度为$O(n^2)$。
+   ==简单选择排序是不稳定的==
    +   因为选择后会进行交换，影响顺序。
+   ==简单选择排序也可以适用于链表==。

#### 直接插入排序与简单选择排序

插入排序和选择排序都是分为未排序和已排序两个部分，那么其中有什么区别？

如$18$、$23$、$19$、$9$、$23*$、$15$进行排序。

插入排序：

```txt
18 23 19 9 23* 15
18 19 23 9 23* 15
9 18 19 23 23* 15
9 18 19 23 23* 15
9 15 18 19 23 23*
```

选择排序：

```txt
9 23 19 18 23* 15
9 15 19 18 23* 23
9 15 18 19 23* 23
9 15 18 19 23* 23
9 15 18 19 23* 23
9 15 18 19 23* 23
```

### 堆排序

#### 堆的定义

若$n$个关键字序列$L$满足下面某一条性质，则就是堆：

1. 若满足$L(i)\geqslant L(2i)$且$L(i)\geqslant L(2i+1)\\;(1\leqslant i\leqslant\dfrac{n}{2})$则是大根堆或大顶堆。
    +   即根结点存储值大于等于其左右孩子结点存储值
2. 若满足$L(i)\leqslant L(2i)$且$L(i)\leqslant L(2i+1)\\;(1\leqslant i\leqslant\dfrac{n}{2})$则是小根堆或小顶堆。
    +   即根结点存储值小于等于其左右孩子结点存储值

>   对于堆(层序存储的完全二叉树)中编号为$i$的结点\;编号为$2i$的结点是它的左孩子\;编号为$2i+1$的结点是它的右孩子

所以堆就是用顺序存储的完全二叉树。

堆的叶子结点范围是$\lfloor\log_2n\rfloor+1\sim n$。

#### 堆的建立

==其实堆就是层序存储的完全二叉树==

其中：

+ $i\leqslant\lfloor\dfrac{n}{2}\rfloor$的结点都是非终端结点。
+ $i$的左孩子是$2i$。
+ $i$的右孩子是$2i+1$。
+ $i$的父结点是$\lfloor\dfrac{n}{2}\rfloor$。

所以建立根堆过程是：

1. 按照关键字序列依次添加关键字到二叉树，按照==层次遍历==顺序添加。
2. 初始化成功后再从下往上、从左至右按逆层次遍历顺序不断调整位置。
3. 如果是大根堆则大元素往上，且当前结点与==更大的孩子结点==互换；如果是小根堆则小元素往上，且当前结点与更小的孩子结点互换。
4. 递归往上时父子结点不断交换位置。
5. 如果元素互换破坏了调整好的下一级的堆，则使用同样的方法对下一层递归调整。

如用堆排序对$(15\;9\;7\;8\;20\;-1\;7\;4)$建立小根堆堆。首先将这组数据按层序初始化为无序堆，然后从最后向前开始调整：

![heapbuild](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307222006644.png)

1.   从$t<\lfloor\dfrac{n}{2}\rfloor$的结点开始往前遍历。

2. 检查当前结点$i$与左孩子和右孩子是否满足根堆条件，若不满足则交换。
    + 若是建立大根堆，检查是否满足根大于等于左、右结点，若不满足，则当前结点与更大的一个孩子互换。
    + 若是建立小根堆，检查是否满足根小于等于左、右结点，若不满足，则当前结点与更小的一个孩子互换。
3. 若元素互换破坏了下一级的堆，则采用同样的方法继续向下调整。
    + 若是建立大根堆，则小的元素不断下坠。
    + 若是建立小根堆，则大的元素不断下坠。 

#### 堆排序过程

![image](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/1/16769b32323373ee~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

由于选择排序是在每一趟都选择最大或最小的值进行排序，所以堆排序中就通过堆这个存储结构来完成对最值的选取——直接选择堆顶元素。

堆排序即每次将堆顶元素与堆底元素（堆最底层最右元素）进行交换，表示这个部分已经排序完成了不需要进行调整，第$i$趟表示倒数$i$个元素已经有序，所以无序的元素就是堆前面的元素。

1. 每一趟将堆顶元素加入子序列（堆顶元素与待排序序列中的最后一个元素交换）
    +   此时后面的这个元素就排序好了
    +   最右下的元素作为堆顶元素
    +   原堆顶元素就是堆中最大的元素
2. 此时待排序序列已经不是堆了（堆顶不能保证是最小或最大的元素），需要将其再次调整为堆（小元素或大元素不断下坠）。
3. 重复步骤一二。
4. 直到$n-1$趟处理后得到有序序列。基于大根堆的堆排序会得到递增序列，而基于小根堆的堆排序会得到递减序列。

调整堆从右边即序列末尾开始。

![23July22-223249-1690036369-8cd97f60-71e6-46ab-8e14-0c01a00c6c0d](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307222233251.png)

---

```cpp
void sift_down(int arr[]\; int start\; int end) {
    // 计算父结点和子结点的下标
    int parent = start;
    int child = parent * 2 + 1;
    while (child <= end) {  // 子结点下标在范围内才做比较
        // 先比较两个子结点大小，选择最大的
        if (child + 1 <= end && arr[child] < arr[child + 1]) child++;
        // 如果父结点比子结点大，代表调整完毕，直接跳出函数
        if (arr[parent] >= arr[child])
            return;
        else {  // 否则交换父子内容，子结点再和孙结点比较
            std::swap(arr[parent]\; arr[child]);
            parent = child;
            child = parent * 2 + 1;
        }
    }
}

void heap_sort(int arr[]\; int len) {
    // 从最后一个结点的父结点开始 sift down 以完成堆化 (heapify)
    for (int i = (len - 1 - 1) / 2; i >= 0; i--) sift_down(arr\; i\; len - 1);
    // 先将第一个元素和已经排好的元素前一位做交换，再重新调整（刚调整的元素之前的元素），直到排序完毕
    for (int i = len - 1; i > 0; i--) {
        std::swap(arr[0]\; arr[i]);
        sift_down(arr\; 0\; i - 1);
    }
}
```

via [堆排序 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/basic/heap-sort/)

<span style="color:orange">注意：</span>题目如果说是给出序列，然后调整为堆，则证明他这个堆已经建立好了，只需要调整顺序，如果说的是依次插入，则要一边插入一边调整堆。

#### 堆排序性能

+   空间复杂度为$O(1)$

    +   堆排序的存储就是它本身，不需要额外的存储空间
    +   要么只需要一个用于交换或临时存放元素的辅助空间。

+   总的时间复杂度也是$O(n\log_2n)$。

    +   若树高为$h$，某结点在第$i$层，则将这个结点向下调整最多只需要下坠$h-i$层，关键字对比次数不超过$2(h-i)$次。

    +   第$i$层最多$2^{i-1}$个结点，而只有第$1\cdots(h-1)$​层的结点才可能需要下坠调整。所以调整时关键字对比次数不超过
        $$
        \sum_{i=h-1}^12^{i-1}2(h-i)=\sum_{j=1}^{h-1}2^{h-j}j\leqslant2n\sum_{j=1}^{h-1}\dfrac{j}{2^j}\leqslant4n
        $$

    +   所以建堆过程中，关键字对比次数不超过$4n$，建堆的时间复杂度为$O(n)$。

    +   堆排序中处理时根结点最多下坠$h-1$层，而每下坠一层，最多对比关键字两次，所以每一趟排序的时间复杂度不超过$O(h)=O(\log_2n)$，一共$n-1$趟，所以时间复杂度为$O(n\log_2n)$。

+   ==堆排序是不稳定的。==

+   调整堆的时间与树高相关$O(\log_2n)$，建立堆的时间复杂度为$O(n)$。比较总次数不超过$4n$。

+   堆排序适合关键字较多的情况
    +   例如，在$1$亿个数中选出前$100$个最大值
    +   首先使用一个大小为$100$的数组，读入前$100$个数，建立小顶堆
    +   而后依次读入余下的教
    +   若小于堆顶则舍弃，否则用该数取代堆顶并重新调整堆
    +   待数据读取完毕，堆中$100$个数即为所求。

#### 堆的插入

+   新元素放到表尾（即最右下角元素），并与其$\lfloor\dfrac{i}{2}\rfloor$的父结点进行对比
+   若新元素比父元素更大（大根堆）或更小（小根堆），则二者互换，并保持上升
+   直到无法上升为止
+   时间复杂度为树高$O(\log_2n)$。

#### 堆的删除

+   先删除被删除的元素
+   被删除的元素的位置用堆底元素（即最右下角元素）代替
+   然后让这个元素不断下坠，直到无法下坠为止
+   时间复杂度为树高$O(\log_2n)$。

#### 堆排序特性

+ 适合大量数据进行排序。
+ 在含有$n$个关键字的小根堆中，关键字最大的记录存储范围为$\lfloor\dfrac{n}{2}\rfloor+1\sim n$。这是小根堆，关键字最大的记录一定存储在这个堆所对应的完全二叉树的叶子结点中；又因为二叉树中的最后一个非叶子结点存储在$\lfloor\dfrac{n}{2}\rfloor$中，所以得到范围。

## 归并排序

归并是指把两个（二路归并）或多个（多路归并）已经有序的序列合并为一个。

该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。

在较大数据进行排序时为了加快速度使用归并排序，用空间换时间。

### 二路归并排序

二路归并排序比较常用，且基本上用于内部排序，多路排序多用于外部排序。

#### 二路归并排序过程

![image](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/1/16769b31d567a6cc~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

1. 把长度为$n$的输入序列分成两个长度为$\dfrac{n}{2}$的子序列。
2. 对这两个子序列分别采用归并排序。
3. 将两个排序好的子序列合并成一个最终的排序序列。

归并排序趟数为$\lceil\log_2n\rceil$。

<img src="https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307231949761.png" alt="23July23-194928-1690112968-76b71674-e481-45c8-b6cd-4e1d0e78794a" style="zoom:150%;" />

>   上面的代码中，最后两个`while`循环只有一个会执行

```cpp
void merge_sort(int *a\; int l\; int r) {
  if (r - l <= 1) return;
  // 分解
  int mid = l + ((r - l) >> 1);
  merge_sort(a\; l\; mid)\; merge_sort(a\; mid\; r);
  // 合并
  int tmp[1024] = {};  // 请结合实际情况设置 tmp 数组的长度（与 a 相同），或使用
                       // vector；先将合并的结果放在 tmp 里，再返回到数组 a
  merge(a + l\; a + mid\; a + mid\; a + r\; tmp + l);  // pointer-style merge
  for (int i = l; i < r; ++i) a[i] = tmp[i];
}

```

via [归并排序 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/basic/merge-sort/)

#### 二路归并排序性能

+   二路归并排序是一棵倒立的二叉树。
+   空间复杂度主要来自辅助数组，所以为$O(n)$，而递归调用的调用栈的空间复杂度为$O(\log_2n)$，总的空间复杂度就是为$O(n)$，无论平均还是最坏，所以这个算法在内部排序算法中空间消耗最大。
+   $n$个元素二路归并排序，归并一共要$\log_2n$趟，每次归并时间复杂度为$O(n)$，则算法时间复杂度为$O(n\log_2n)$
+   归并排序是稳定的。

+   一般而言，对于$N$个元素进行$k$路归并排序时，排序的趟数$m$满足$k^m = N$\;从而$m =\log_kN$\;又考虑到$m$为整数，所以$m=\lceil\log_kN\rceil$

+   这和前面的$2$路归并是一致的。

## 分配排序

分配排序过程无须比较关键字，而是通过用额外的空间来“分配”和“收集”来实现排序，它们的时间复杂度可达到线性阶$O(n)$。简言之就是：用空间换时间，所以性能与基于比较的排序才有数量级的提高。

### 基数排序

==基数排序不是基于比较的排序算法==，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。

+ 只能对整数进行排序。
+ 元素的移动次数与关键字的初始排列次序无关。

#### 基数的定义

假设长度为$n$的线性表中每个结点$a_j$的关键字由$d$元组$(k_j^{d-1}\;k_j^{d-2}\;\cdots\;k_j^1\;k_j^0)$组成，其中$0\geqslant k_j^i\geqslant r-1\\(0\geqslant i\geqslant d-1)$，其中$r$就是基数。

#### 基数排序过程

![image](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/1/16769b3253ebc2fc~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

有最高位优先$MSD$和最低位优先$LSD$两种方法。

![23July23-195347-1690113227-b8a1632a-4bb2-4307-9d18-857d3f2b3418](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307231953003.png)

若是要得到递减序列：

1. 初始化：设置$r$个空辅助队列$Q_{r-1}\;Q_{r-2}\;\cdots\;Q_0$。
2. 按照每个关键字位**权重递增**的次序（个、十、百），对$d$个关键字位分别做分配和收集。
3. 分配就是顺序扫描各个元素，若当前处理的关键字位为$x$，就将元素插入$Q_x$队尾。
4. 收集就是把$Q_{r-1}\;Q_{r-2}\;\cdots\;Q_0$各个队列的结点依次出队并链接在一起。

```cpp
const int N = 100010;
const int W = 100010;
const int K = 100;

int n\; w[K]\; k\; cnt[W];

struct Element {
  int key[K];

  bool operator<(const Element& y) const {
    // 两个元素的比较流程
    for (int i = 1; i <= k; ++i) {
      if (key[i] == y.key[i]) continue;
      return key[i] < y.key[i];
    }
    return false;
  }
} a[N]\; b[N];

void counting_sort(int p) {
  memset(cnt\; 0\; sizeof(cnt));
  for (int i = 1; i <= n; ++i) ++cnt[a[i].key[p]];
  for (int i = 1; i <= w[p]; ++i) cnt[i] += cnt[i - 1];
  // 为保证排序的稳定性，此处循环i应从n到1
  // 即当两元素关键字的值相同时，原先排在后面的元素在排序后仍应排在后面
  for (int i = n; i >= 1; --i) b[cnt[a[i].key[p]]--] = a[i];
  memcpy(a\; b\; sizeof(a));
}

void radix_sort() {
  for (int i = k; i >= 1; --i) {
    // 借助计数排序完成对关键字的排序
    counting_sort(i);
  }
}

```

via [基数排序 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/basic/radix-sort/)

#### 基数排序性能

+   基数排序基本上使用链式存储而不是一般的顺序存储。

+   需要$r$个辅助队列，所以空间复杂度为$O(r)$。

+   一趟分配$O(n)$，一趟收集$O(r)$，一共有$d$趟分配收集，所以总的时间复杂度为$O(d\times(n+r))$
    +   与序列初始状态无关。

+   ==基数排序是稳定的。==
    +   ~~基你太稳~~

#### 基数排序的应用

对于一般的整数排序是可以按位排序的，也可以处理一些实际问题，如根据人的年龄排序，需要从年月日三个维度分别设置年份的队列、月份的队列（$1$到$12$）、日期的队列（$1$到$31$）。

所以基数排序擅长解决的问题：

1. 数据元素的关键字可以方便地拆分为$d$组，且$d$较小。
2. 每组关键字的取值范围不大，即$r$较小。
3. 数据元素个数$n$较大。

### 计数排序

作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。

#### 计数排序过程

1. 找出待排序的数组中最大和最小的元素。
2. 统计数组中每个值为`i`的元素出现的次数，存入数组`C`的第`i`项。
3. 对所有的计数累加
    +   从`C`中的第一个元素开始，每一项和前一项相加
4. 反向填充目标数组：将每个元素i放在新数组的第`C(i)`项，每放一个元素就将`C(i)`减去$1$。

当输入的元素是$n$个属于$[0\;k]$的整数时，时间复杂度是$O(n+k)$，空间复杂度也是$O(n+k)$，其排序速度快于任何比较排序算法。

当$k$不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。

计数排序是稳定的。

### 桶排序

桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。

#### 桶排序过程

![image](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/1/16769b3253a38dc5~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

1. 设置一个定量的数组当作空桶。
2. 遍历输入数据，并且把数据一个一个放到对应的桶里去。
3. 对每个不是空的桶进行排序。
4. 从不是空的桶里把排好序的数据拼接起来。

```cpp
const int N = 100010;

int n\; w\; a[N];
vector<int> bucket[N];

void insertion_sort(vector<int>& A) {
  for (int i = 1; i < A.size(); ++i) {
    int key = A[i];
    int j = i - 1;
    while (j >= 0 && A[j] > key) {
      A[j + 1] = A[j];
      --j;
    }
    A[j + 1] = key;
  }
}

void bucket_sort() {
  int bucket_size = w / n + 1;
  for (int i = 0; i < n; ++i) {
    bucket[i].clear();
  }
  for (int i = 1; i <= n; ++i) {
    bucket[a[i] / bucket_size].push_back(a[i]);
  }
  int p = 0;
  for (int i = 0; i < n; ++i) {
    insertion_sort(bucket[i]);
    for (int j = 0; j < bucket[i].size(); ++j) {
      a[++p] = bucket[i][j];
    }
  }
}

```

via [桶排序 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/basic/bucket-sort/)

#### 桶排序性能

桶排序最好情况下使用线性时间$O(n)$，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为$O(n)$。桶排序的平均时间复杂度为线性的$O(n+C)$，其中$C=n\times(\log n-\log m)$，其中$m$代表桶划分的数量。

很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。

桶排序是稳定的。

## 内部排序

### 内部排序算法的比较

指在排序期间元素全部存放在内存中的排序。除了分配排序，其他的内部排序往往要经过比较和移动。

|   算法种类   | 最好时间复杂度 | 平均时间复杂度 | 最好时间复杂度 |  空间复杂度  | 是否稳定 |   趟数    |
| :----------: | :------------: | :------------: | :------------: | :----------: | :------: | :-------: |
| 直接插入排序 |     $O(n)$     |    $O(n^2)$    |    $O(n^2)$    |    $O(1)$    |    是    |   $n-1$   |
|   希尔排序   |      $?$       |      $?$       |      $?$       |    $O(1)$    |    否    |    $s$    |
| 简单选择排序 |    $O(n^2)$    |    $O(n^2)$    |    $O(n^2)$    |    $O(1)$    |    否    |   $n-1$   |
|   快速排序   | $O(n\log_2n)$  | $O(n\log_2n)$  |    $O(n^2)$    | $O(\log_2n)$ |    否    | 初始序列  |
|   冒泡排序   |     $O(n)$     |    $O(n^2)$    |    $O(n^2)$    |    $O(1)$    |    是    | 初始序列  |
|    堆排序    | $O(n\log_2n)$  | $O(n\log_2n)$  | $O(n\log_2n)$  |    $O(1)$    |    否    | 初始序列  |
| 二路归并排序 | $O(n\log_2n)$  | $O(n\log_2n)$  | $O(n\log_2n)$  |    $O(n)$    |    是    | $\log_2n$ |
|   基数排序   |  $O(d(n+r))$   |  $O(d(n+r))$   |  $O(d(n+r))$   |    $O(r)$    |    是    |    $r$    |

+ 每趟排序结束都至少能够确定一个元素最终位置的方法：选择、交换。（插入和归并则不行）
+ 从稳定性看
    + 稳定的排序
        1.   基数排序
        2.   冒泡排序
        3.   直接插入排序
        4.   折半插入排序
        5.   归并排序
        6.   桶排序
        7.   基数排序
    + 不稳定的排序
        1.   堆排序
        2.   快速排序
        3.   希尔排序
        4.   直接选择排序

+ 大部分排序算法都仅适用于顺序存储的线性表。
    + 适合链表的排序算法：~~那不就是大部分都可以吗~~
        1.   冒泡排序
        2.   选择排序
        3.   直接插入排序
        4.   计数排序
        5.   基数排序
    + 不适合链表的排序算法
        1.   希尔排序
        2.   快速排序
        3.   归并排序
        4.   二分插入排序
             +   以及包含所有需要二分查找优化的排序算法
    + 可以用于链表排序但不建议使用的排序算法：**堆排序**。
        + **堆排序**：堆排序所使用的最大堆 / 最小堆结构本质上是一棵完全二叉树。而完全二叉树适合采用顺序存储结构（数组）。因为数组存储的完全二叉树可以很方便的通过下标序号来确定父亲结点和孩子结点，并且可以极大限度的节省存储空间。
        + 而链表用在存储完全二叉树的时候，因为不支持随机访问的特性，导致其寻找子结点和父亲结点会比较耗时，如果增加指向父亲结点的变量，又会浪费大量存储空间。所以堆排序算法不适合进行链表排序。
        + 如果一定要对链表进行堆排序，则可以使用额外的数组空间表示堆结构。然后将链表中各个结点的值依次添加入堆结构中，对数组进行堆排序。排序后，再按照堆中元素顺序，依次建立链表结点，构建新的链表并返回新链表头结点。
+ 特别的算法性质
    + 可能发生==在最后一趟排序开始时所有元素都不在最终位置上==的情况
        + 直接插入排序

    + 每趟排序结束都至少能够确定一个元素最终位置
        + ==对尚未确定最终位置的所有元素进行一遍处理称为一趟排序==
        + 简单选择排序
        + 快速排序
        + 堆排序

    + ==比较次数==与关键字的初始序列初始状态无关
        + 基数排序
            + 不需要进行关键字的比较

        + 选择排序
            + 简单选择排序
            + 堆排序

    + ==移动次数==与关键字的初始排列初始状态无关
        + 基数排序

    + ==时间复杂度==与关键字的初始排列初始状态无关
        + 直接选择排序$O(n^2)$
        + 堆排序$O(n\log_2n)$
        + 归并排序$O(n\log_2n)$
        + 基数排序$O(d(n+r))$
    + ==排序趟数==与关键字的初始排列初始状态无关
        + 插入排序$n-1$
        + 选择排序$n-1$
        + 基数排序

    + 不需要进行关键字的比较
        + 基数排序


### 内部排序算法的应用

1.    ==若$n$较小，可采用直接插入排序或简单选择排序==
     +   由于直接插入排序所需的记录移动次数较简单选择排序的多，因而当记录本身信息量较大时，用简单选择排序较好。
2.   ==若文件的初始状态已按关键字基本有序，则选用直接插入或冒泡排序为宜。==
3.   若$n$较大，则应采用时间复杂度为$O(log_2 n)$的排序方法：==快速排序、堆排序或归并排序==
     +   快速排序被认为是目前基于比较的内部排序方法中最好的方法，当待排序的关键字随机分布时，快速排序的平均时间最短
     +   堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况，这两种排序都是不稳定的
     +   若要求排序稳定且时间复杂度为$O(log_2 n)$，则可选用归并排序
     +   但本章介绍的从单个记录起进行两两归并的排序算法并不值得提倡，通常可以将它和直接插入排序结合在一起使用。先利用直接插入排序求得较长的有序子文件，然后两两归并
     +   直接插入排序是稳定的， 因此改进后的归并排序仍是稳定的
4.   在基于比较的排序方法中，每次比较两个关键字的大小之后，仅出现两种可能的转移， 因此可以用一棵二叉树来描述比较判定过程，由此可以证明
     +   当文件的$n$个关键字随机分布时，任何借助于“比较”的排序算法，至少需要$O(n\log_2 n)$的时间
5.   若$n$很大，记录的关键字位数较少且可以分解时，采用基数排序较好
6.   当记录本身信息量较大时，为避免耗费大量时间移动记录，可用链表作为存储结构。

## 外部排序

外部排序可能会考查相关概念、方法和排序过程，外部排序的算法比较复杂，不会在算法设计上进行考查

本节的主要内容有

1.   外部排序指待排序文件较大，内存一次放不下，需存放在外存的文件的排序
2.   为减少平衡归并中外存读写次数所采取的方法
     +   增大归并路数和减少归并段个数
3.   ==利用败者树增大归并路数==
4.   ==利用置换-选择排序增大归并段长度来减少归并段个数==
5.   由长度不等的归并段，进行多路平衡归并，需要构造最佳归并树。

### 外部排序的原理

#### 外部排序过程

磁盘的读写是以块为单位，数据读入内存后才能被修改，修改完成后还需要写回磁盘。

外部排序就是针对数据元素太多，无法一次性全部读入内存进行排序而进行处理的在外部磁盘进行的排序处理方式。

因此，需要将待排序的记录存储在外存上，排序时再把数据一部分一部分地调入内存进行排序，在排序过程中需要多次进行内存和外存之间的交换

通常使用归并排序的方式，最少只用在内存分配三块大小的缓冲区（两个输入缓冲一个输出缓冲）即可堆任意一个大文件进行排序。然后对缓冲区里的数据进行内部排序。

外部排序过程：

1. 生成初始归并段（大小为输入缓冲区的总大小），需要读写并进行内部排序。
2. 重复读写，进行内部归并排序
    +   填满输出缓冲就可以输出
    +   ==输入缓冲空就应该立即输入新数据才能继续排序==

+   外部排序时间开销=读写外存时间（最大的时间开销）+内部排序所需时间+内部归并所需时间。
    +   读写外存时间=$2\times$文件总数$\times1$+$2\times$文件总数$\times$归并排序躺数
        +   $2\times$文件总数表示读一遍文件和写一遍文件一共需要的读/写次数
        +   前面的`1`表示排序前生成初始归并段进行一遍读写
        +   加上归并排序中进行的读写即为读写外存时间
    
+   每趟归并$n$个元素需要做$(n-1)(k-1)$次比较，$S$​趟归并总共需要的比较次数为
    $$
    \begin{align}
    S(n-1)(k-1) & = \left\lceil\log _{k} r\right\rceil(n-1)(k-1) \\
    & =\frac{\left\lceil\log _{2} r\right\rceil(n-1)(k-1)}{\left\lceil\log _{2} k\right\rceil}
    \end{align}
    $$

#### 外部排序的优化方法

优化方法就是使用更多路的多路归并，减少归并趟数。

$k$路平衡归并：

+   最多只能有$k$个段归并为一个，需要一个输出缓冲区和$k$个输入缓冲区
+   每一趟归并中，若有$m$个归并段参与归并，则经过这一趟处理得到$\lceil\dfrac{m}{k}\rceil$个新的归并段。

+   对$r$个初始归并段，使用$k$路归并，则归并树可以使用$k$叉树表示
    +   若树高为$h$，则归并趟数为$h-1$。
    +   $k$叉树第$h$层最多有$k-1$个结点则$r\le k^{h-1}\to(h-1)_{\min}=\lceil \log_{k}r\rceil$
    +   ==则归并趟数为$h-1=\lceil \log_{k}r\rceil$==

若能增加初始归并段的长度$k$，也可以减少初始归并段数量$r$从而进行优化。

+   但是$k$值增大，多路归并会带来负面影响：

    1. $k$路归并时，需要开辟$k$个输入缓冲区，内存开销增加。
    2. 每挑选一个关键字需要对比关键字$(k-1)$次，内部归并时间增加。
        +   可以使用下面的败者树进行优化
+   若能增加初始归并段的长度则可减少初始归并段数量$r$
    +   若共$N$个记录，内存工作区习以容纯$L$个记录，)则初始归并段数量$r=\frac{N}{L}$
        +   可以使用下面的置换选择排序进行优化

### 败者树

败者树（$Tournament -Tree$）是一种特殊的树形数据结构，主要用于高效地实现多路归并排序（$k$路归并排序）。败者树的主要作用是在$k$个有序序列中选择最小（或最大）元素，从而实现合并排序。

用于通过过去归并的经历减少归并次数。败者树可以看作一棵多了一个单个的根的完全二叉树。$k$个叶结点分别是当前参加比较的元素，非叶子结点用来记忆左右子树中的失败者，而让胜者往上继续比较，一直到根结点。

![image-20230724232326022](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307242323152.png)

以下是败者树的基本概念和性质：

1. 每个结点代表一个有序序列中的最小（或最大）元素，称为“胜者”。
2. 叶子结点表示原始序列的元素，非叶子结点表示排序后的胜者。
    +   叶子结点是虚拟的
3. 每个结点都有一个指向其父结点的指针，叶子结点没有指向左右孩子的指针。
4. 败者树是一棵完全二叉树，有$N$个叶子结点，总共有$N-1$个非叶子结点。
5. 当新元素进入某个序列时，从该叶子结点开始向上更新整个败者树，选择新的胜者。

使用败者树进行K路归并排序的过程如下：

1. 初始化：将$k$个有序序列的首元素填入败者树的叶子结点，并根据它们的值构建初始的败者树。
2. 合并：选取胜者结点，将其对应的序列中的下一个元素填入胜者结点，然后向上更新败者树，选择新的胜者。
3. 重复：重复步骤`2`，直到所有序列都被合并为一个有序序列。

使用败者树可以有效地减少多路归并排序中的比较次数，从而提高排序效率。它在外部排序等需要大量的多路归并操作的场景中得到广泛应用，特别适用于内存有限的情况下。

![23July23-202704-1690115224-58a9a3d0-4f97-4438-9869-ef606a82a6f5](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307232027185.png)

+   传统方法从$k$个归并段选出一个最大或最小元素需要对比关键字$k-1$次，而使用$k$路归并的败者树只需要对比关键字$\lceil\log_2k\rceil$次（败者树层数，不包括成功结点）。

+   构建败者树时依然需要$n-1$次对比。

+   因为$k$路归并的败者树深度为$\lceil \log_{2}k\rceil$，因此$k$个记录中选择最小关键字，最多需要$\lceil \log_{2}k\rceil$​次比较。所以总的比较次数为
    $$
    \begin{align}
    S(n-1)\left\lceil\log _{2} k\right\rceil & = \left\lceil\log _{k} r\right\rceil(n-1)\left\lceil\log _{2} k\right\rceil \\
    & =(n-1)\left\lceil\log _{2} k\right\rceil
    \end{align}
    $$

+   可见，==使用败者树后，内部归并的比较次数与$k$无关了==

    +   因此，只要内存空间允许，增大归并路数上将有效地减少归并树的高度，从而减少$I/O$次数，提高外部排序的速度。

+   值得说明的是，==归并路数$k$并不是越大越好==

    +   归并路数$k$增大时，相应地需要增加输入缓冲区的个数

    +   若可供使用的内存空间不变，势必要减少每个输入缓冲区的容量，使得内存、外存交换数据的次数增大

    +   当$k$值过大时，虽然归并趟数会减少，但读写外存的次数仍会增加


### 置换选择排序

如果内存工作区只能容纳$l$个记录，则初始归并段也只能包含$l$条记录，若文件共有$n$条记录，则初始归并段的数量为$r=\lceil n/l\rceil$。

用于构建更长的初始归并段，从而减少归并次数。

假设初始始待排文件为$FI$，初始归并段输出文件为$FO$，内存工作区为$WA$，$FO$和$WA$的初始状态为空，$WA$可容纳$w$个记录。置换选择算法的步骤如下：

1. 从$FI$输入$w$记录到工作区$WA$。
2. 从$WA$中选出其中关键字取最小值的记录，记为$MINIMAX$记录。
3. 将$MINIMAX$记录输出到$FO$中去。
4. 若$FI$不空，则从$FI$输入下一个记录到$WA$中。
5. 从$WA$中所有关键字比$MINIMAX$记录的关键字大的记录中选出最小关键字记录，作为新的$MINIMAX$记录。
6. 重复步骤三到五，如果新输入到$FI$的关键字小于$MINIMAX$的值，则驻留在$WA$中，直至在$WA$中填满选不出新的$MINIMAX$记录为止，由此得到一个初始归并段，输出一个归并段的结束标志到$FO$中去。准备输出新的归并段。
7. 重复步骤二到六，直至$WA$为空。由此得到全部初始归并段。

此时输出的初始归并段可以超过$WA$，且初始归并段长度是不一定相等的。

如$FI$：$17\;21\; 05\; 44\; 10\; 12\;56\;32\;29$，$WA$长度为$3$

![image-20230724233238257](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307242332454.png)

>   $FI$和$FO$文件放在磁盘里面，读入/输出的序列都会先放到输入/输出缓冲区里面，输入/输出完毕后一次性传送

### 最佳归并树

因为现实中的每个归并段的长度不同，所以归并的次序比较重要。

#### 最佳归并树的衡量

每个初始归并段可以看作一个叶子结点，归并树的长度作为结点权值，则归并树的带权路径长度$WPL$等于读写磁盘的次数。

从而==归并过程中的磁盘$I/O$次数=归并树的$WPL\times2$。==

#### 最佳归并树的构造

所以就需要一棵类似哈夫曼树来成为最佳的归并树，不断选择最小的$k$段进行归并。

![23July23-204528-1690116328-fa8de2ad-761e-4e01-9720-3a3b0bf26d70](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307232045878.png)

#### 添加虚段

+   对于$k$叉归并来说，若初始归并段的数量无法构成严格的$k$叉归并树，

    +   此时嗯构造出来的归并树的$WPL$不是最小的

+   则需要补充几个长度为$0$的虚拟段从而能保证严格$k$叉归并，再进行$k$叉哈夫曼树的构造。

    ![23July23-204740-1690116460-6b3a065e-06a0-404f-9da0-07eadef30908](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307232047540.png)

    +   ==补充的虚段一定是在叶结点上==

+   $k$叉的最佳归并树一定是一棵严格的$k$叉树，即树中只包含度为$k$和$0$的结点。

+   设度为$k$的结点有$n_k$个，度为$0$的结点有$n_0$个，归并树的总结点树为$n$，则初始归并段数量+虚段数量=$n_0$。
    +   所以$n=n_0+n_k$，$kn_k=n-1$
        +   总结点数=度为$k$的结点数+度为$0$的结点数
        +   度总数=$k\cdot n_k=n-1$
            +   度为$0$的结点不贡献度
            +   对于树有结点数$=$总度数$+1$
    +   则$n_0=(k-1)n_k+1$
    +   所以$n_k=\dfrac{(n_0-1)}{(k-1)}$一定是可以整除的
        +   即若(初始归并段数量$-1)MOD(k-1)=0$\;说明刚好可以构成严格$k$叉树，此时不需要添加虚段
    +   如果不整除就要添加虚段。
        +   即若(初始归并段数量$-1)MOD(k-1)=u\ne 0$，说明需要补充$k-1-u$个虚段

### 锦标赛树*

锦标赛树（Tournament Tree），也称为胜者树（Winner Tree），是一种特殊的树形数据结构，主要用于高效地进行多路归并排序。锦标赛树的主要作用是在K个有序序列中选择最小（或最大）元素，从而实现合并排序。

锦标赛树的构建过程如下：

1. 初始化：将K个有序序列的首元素填入锦标赛树的叶子结点，每个结点表示序列中的一个元素，并且每个结点有一个指向其父结点的指针。
2. 锦标赛：从树的叶子结点开始，进行一系列的比较，每次比较两个叶子结点的值，并将较小的结点向上提升到其父结点，并继续进行比较，直到找到最小（或最大）的元素，这个元素将被称为“冠军”。
3. 选择冠军：经过一系列比较后，冠军的结点将成为锦标赛树的根结点，表示选出了最小（或最大）的元素。

锦标赛树的性质保证了高效的多路归并排序：

1. 锦标赛树是一棵完全二叉树，具有K个叶子结点和K-1个内部结点。
2. 每个内部结点都表示K个元素中的一个“冠军”，即其中的最小（或最大）元素。
3. 锦标赛树的高度是O(log K)，因此选择冠军的时间复杂度为O(log K)。

使用锦标赛树进行多路归并排序的过程如下：

1. 初始化：将K个有序序列的首元素填入锦标赛树的叶子结点。
2. 归并：选择冠军，将冠军结点对应的元素放入结果序列，并将选出的冠军结点对应的序列的下一个元素填入该结点。然后向上更新整个锦标赛树，继续选择下一个冠军，直到所有序列都被合并为一个有序序列。

锦标赛树的时间复杂度为O(K log K)，相比较于常规的多路归并排序算法，锦标赛树减少了比较次数，使得归并排序更加高效。因此，锦标赛树是多路归并排序中的一种优化方法，特别适用于内存有限的情况下。

## 附录/拓展

### `std::sort`

`std::sort` 是 $Cpp\; STL$ 中的排序函数，用于对指定范围内的元素进行排序。它使用快速排序（$Quick Sort$）算法来实现，在大多数情况下，其时间复杂度为 $O(N log N)$。

以下是 `std::sort` 的使用方法和一些注意事项：

1. `std::sort` 函数的基本用法：
   - 函数签名：`template <class RandomAccessIterator> void sort(RandomAccessIterator first\; RandomAccessIterator last);`
   - 功能：对 `[first\; last)` 范围内的元素进行升序排序。
   - 参数：`first` 是排序范围的起始迭代器，`last` 是排序范围的结束迭代器（不包含在排序范围内）。
   - 示例：
     ```cpp
     #include <algorithm>
     #include <vector>
     #include <iostream>
     
     int main() {
         std::vector<int> numbers = {5\; 2\; 9\; 1\; 5\; 6};
         
         std::sort(numbers.begin()\; numbers.end());
         
         for (int num : numbers) {
             std::cout << num << " ";
         }
         return 0;
     }
     ```
     输出：`1 2 5 5 6 9`

2. 自定义排序方式：
   `std::sort` 还支持传入自定义的比较函数或 Lambda 表达式，以实现自定义排序规则。
   - 函数签名：`template <class RandomAccessIterator\; class Compare> void sort(RandomAccessIterator first\; RandomAccessIterator last\; Compare comp);`
   - 功能：对 `[first\; last)` 范围内的元素进行自定义排序。
   - 参数：`comp` 是一个比较函数或 Lambda 表达式，用于定义排序规则。
   - 示例：
     ```cpp
     #include <algorithm>
     #include <vector>
     #include <iostream>
     
     int main() {
         std::vector<int> numbers = {5\; 2\; 9\; 1\; 5\; 6};
         
         std::sort(numbers.begin()\; numbers.end()\; [](int a\; int b) {
             return a > b;  // 降序排序
         });
         
         for (int num : numbers) {
             std::cout << num << " ";
         }
         return 0;
     }
     ```
     输出：`9 6 5 5 2 1`

3. 注意事项：
   - `std::sort` 对指定范围进行就地排序，即对原始容器进行修改，而不会创建新的容器。
   - 排序范围是左闭右开区间 `[first\; last)`，因此 `last` 不在排序范围内。
   - 使用 `std::sort` 前，请确保迭代器范围有效且可访问。对于数组，使用数组名和数组名+数组大小作为迭代器范围。对于容器（例如 `std::vector`、`std::list` 等），使用 `begin()` 和 `end()` 成员函数来获得迭代器范围。
   - 对于自定义类型，确保比较函数或 Lambda 表达式定义了严格的弱排序（Strict Weak Ordering）规则，以避免未定义的行为。

### `std::nth_element`

`std::nth_element` 是 $C++ STL$ 中的函数，用于部分排序（$Partial Sort$）一个范围内的元素，将第$ n $小（或大）的元素放在正确的位置上，而==不会对其他元素进行排序==。它对于只关心部分排序结果的情况非常有用。

以下是 `std::nth_element` 的详细信息：

- 函数签名：`template <class RandomAccessIterator> void nth_element(RandomAccessIterator first\; RandomAccessIterator nth\; RandomAccessIterator last);`

- 函数用法

    ```cpp
    std::nth_element(first\; nth\; last);
    std::nth_element(first\; nth\; last\; cmp);
    ```

- 功能：对 `[first\; last)` 范围内的元素进行部分排序，使第 n 小（或大）的元素处于正确的位置。

- 参数：
  - `first`：排序范围的起始迭代器。
  - `nth`：排序后，第 n 小（或大）的元素将被放置在该位置上。
  - `last`：排序范围的结束迭代器（不包含在排序范围内）。
  
- 返回值：无。

注意事项：
- 在使用 `std::nth_element` 之前，请确保迭代器范围有效且可访问。
- `std::nth_element` 重排 `[first\; last)` 中的元素，使得 `nth` 所指向的元素被更改为 `[first\; last)` 排好序后该位置会出现的元素
    - 这个新的 `nth` 元素前的所有元素小于或等于新的 `nth` 元素后的所有元素。

- 实现算法是未完成的内省排序。
- 对于以上两种用法，$Cpp $标准要求它的平均时间复杂度为 O(n)，其中$ n $为 `std::distance(first\; last)`。
- 常用于构建$ K-D\; Tree$。

示例：
```cpp
#include <algorithm>
#include <iostream>
#include <vector>

int main() {
    std::vector<int> numbers = {5\; 2\; 9\; 1\; 5\; 6\; 3\; 8};
    int n = 4; // 找第4小的元素

    std::nth_element(numbers.begin()\; numbers.begin() + n\; numbers.end());

    std::cout << "The " << n << "th smallest element: " << numbers[n] << std::endl;

    return 0;
}
```

### std::stable_sort

`std::stable_sort` 是 C++ STL 中的排序函数，它与 `std::sort` 类似，都用于对指定范围内的元素进行排序。然而，`std::stable_sort` 与 `std::sort` 不同之处在于，它保持相等元素的相对顺序，即对于相等的元素，它们在排序后的结果中仍然保持原来的相对位置。

以下是 `std::stable_sort` 的详细信息：

- 函数签名：`template <class RandomAccessIterator> void stable_sort(RandomAccessIterator first\; RandomAccessIterator last);`
- 函数用法

    ```cpp
    std::stable_sort(first\; last);
    std::stable_sort(first\; last\; cmp);
    ```
- 功能：对 `[first\; last)` 范围内的元素进行稳定排序。

- 参数：
  - `first`：排序范围的起始迭代器。
  - `last`：排序范围的结束迭代器（不包含在排序范围内）。
- 返回值：无。

注意事项：
- 在使用 `std::stable_sort` 之前，请确保迭代器范围有效且可访问。
- `std::stable_sort` 保持相等元素的相对顺序，即对于相等的元素，它们在排序后的结果中仍然保持原来的相对位置。

示例：
```cpp
#include <algorithm>
#include <iostream>
#include <vector>

int main() {
    std::vector<int> numbers = {5\; 2\; 9\; 1\; 5\; 6\; 3\; 8};

    std::stable_sort(numbers.begin()\; numbers.end());

    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

### std::partial_sort

`std::partial_sort` 是 C++ STL 中的部分排序函数，用于部分排序一个范围内的元素，将前 n 个最小（或最大）的元素放在前面，而不会对其他元素进行排序。它类似于 `std::nth_element`，但 `std::partial_sort` 可以在一次函数调用中找到部分排序结果。

以下是 `std::partial_sort` 的详细信息：

- 函数签名：`template <class RandomAccessIterator> void partial_sort(RandomAccessIterator first\; RandomAccessIterator middle\; RandomAccessIterator last);`
- 函数用法

    ```cpp
    // mid = first + k
    std::partial_sort(first\; mid\; last);
    std::partial_sort(first\; mid\; last\; cmp);
    ```

    将序列中前 `k` 元素按 `cmp` 给定的顺序进行原地排序，后面的元素不保证顺序。未指定 `cmp` 函数时，默认按从小到大的顺序排序。
- 功能：对 `[first\; last)` 范围内的元素进行部分排序，将前 n 个最小（或最大）的元素放在 `[first\; middle)` 范围内，并保持它们的相对顺序。

- 参数：
  - `first`：排序范围的起始迭代器。
  - `middle`：排序后，第 n 个最小（或最大）的元素将放置在该位置上。
  - `last`：排序范围的结束迭代器（不包含在排序范围内）。
- 返回值：无。
- 原理：

    `std::partial_sort` 的思想是：对原始容器内区间为 `[first\; mid)` 的元素执行 `make_heap()` 操作，构造一个大根堆，然后将 `[mid\; last)` 中的每个元素和 `first` 进行比较，保证 `first` 内的元素为堆内的最大值。如果小于该最大值，则互换元素位置，并对 `[first\; mid)` 内的元素进行调整，使其保持最大堆序。比较完之后，再对 `[first\; mid)` 内的元素做一次堆排序 `sort_heap()` 操作，使其按增序排列。注意，堆序和增序是不同的。

注意事项：
- 在使用 `std::partial_sort` 之前，请确保迭代器范围有效且可访问。
- `std::partial_sort` 会将前 n 个最小（或最大）的元素放在 `[first\; middle)` 范围内，并保持它们的相对顺序，但对于 `[middle\; last)` 范围内的元素，它们的顺序是未定义的。

示例：
```cpp
#include <algorithm>
#include <iostream>
#include <vector>

int main() {
    std::vector<int> numbers = {5\; 2\; 9\; 1\; 5\; 6\; 3\; 8};
    int n = 4; // 找前4个最小的元素

    std::partial_sort(numbers.begin()\; numbers.begin() + n\; numbers.end());

    for (int i = 0; i < n; ++i) {
        std::cout << numbers[i] << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

