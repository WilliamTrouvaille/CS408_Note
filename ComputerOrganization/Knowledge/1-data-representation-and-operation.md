# 第二章 数据的表示与运算

## 【考纲内容】

1. 数制与编码
    - 进位计数制及其相互转换，定点数的编码表示
2. 运算方法和运算电路
    - 基本运算部件，加法器，算法逻辑单元 ($ALU$)
    - 加/减运算:补码加/减运算器，标志位的生成
    - 乘/除运算: 乘/除法运算的基本原理，乘法运算和除法电路的基本结构
3. 整数的表示和运算
    - 无符号整数的表示和运算，带符号整数的表示和运算
4. 浮点数的表示和运算
    - 浮点数的表示: $IEEE\,\,754$ 标准，浮点数的加/诚运算



### 知识导图

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/1BB3CFD0434748BB836E32A0B3C9A2E4.png)

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/D5B4D246B03D49C2B456C4CDC6A20E10.png)



![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/AA80B3FA8E8343B6A5DFA11B4B2E77D3.png)

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/8E87101F98DC42F8B63EA88BF26C77DE.png)

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/09BAE5B9728D419392B24B896330DFA5.png)

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/4FB6EB9E4A474460B1CC4DEA66B7C706.png)

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/F2DB54B4C1734300AE96BAC9217E0AE7.png)

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/BE01B0C824104573BB78BA5750676E25.png)

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/1483AFEC982C44F18D77B0A7CB6DCD52.png)

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/0A5B68E7070446DFBAFACD39FB7C4E8B.png)

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/15D2891365BE4C9481C7C8DE3CFB7724.png)



## 定点数

### 数据表示的作用

数据表示的作用是将**数据按照某种方式组织起来，以便计算机硬件能直接识别和使用。**

在设计和选择计算机内的数据表示方式时，一般需要综合考虑以下几方面的因素。

1. 数据的类型: 满足应用对数据类型的要求，一般要支持数值数据和非数值数据，前者
    如小数、整数、实数等，后者如 ASCII 码和汉字等。
2. 表示的范围和精度: 满足应用对数据范围和精确度的要求，这要通过选择适当的数据
    类型与字长来实现。
3. 存储和处理的代价: 应尽量使设计出的数据格式易于表示、存储和处理; 易于设计处
    理数据的硬件，如运算器设计等赶要综合考虑性能需求和硬件开销。

4. 软件的可移植性: 从保护用户软件投资的角度看，应使设计的数据格式在满足应用需
    求的前提下，符合相应的规范，方便软件在不同计算机之间的移植。

二进制由于数码最少、容易与简单的物理状态对应、算术逻辑运算电路更容易实现等优势成为现代计算机中数据表示的不二之选，采用二进制可以表示任何数据信息。

### 定点数表示

**书写时用“+”和“-”来表示数据的书写格式称为真值。**

由符号和数值一起编码表示的二进制数称为机器数或机器码。

常用的定点数机器码有原码、反码、补码和移码等，不同的机器码具有不同的特点。

![image-20230522170034441](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230522170034441.png)



#### 原码

- **正数符号位用$0$表示, 负数符号位用 $1$ 表示，数值位保持不变。**
- **对于数据$0$，原码有$+0$和$-0$两个编码。**

+ 若机器字长$n+1$位，则原码整数的表示范围是$[-(2^n-1),2^n-1]$。
+ 若机器字长$n+1$位，则原码小数的表示范围是$[-(1-2^{-n}),-2^{-n}]\cup[2^{-n},1-2^{-n}]$。

定点小数的原码公式

![image-20230522161021822](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230522161021822.png)

定点整数的原码公式

![image-20230522161026922](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230522161026922.png)



原码的加减法运算复杂，**符号位不能直接参与运算**。加法运算需要”同号求和，异号求差”, 减法运算需要“异号求和, 同号求差”, 求差时还需要先比较大小，然后用大数减去小数，最后结果的符号选择也相对复杂。

显然，利用原码作为机器数在实现加减法运算方面是不方便的，**原码在计算机中目前仅仅用于表示浮点数的尾码。**

#### 反码

反码又称 1 的补码，其符号位和原码相同，**真值为正数时，反码和原码相同；真值为负数时，反码数值位为真值数值位取反。**

- **同样反码也存在$+0$和$-0$两个 $0$。**

+ 范围表示没有变化与原码一致,如下

+ 若机器字长$n+1$位，则反码整数的表示范围是$[-(2^n-1),2^n-1]$。
+ 若机器字长$n+1$位，则反码小数的表示范围是$[-(1-2^{-n}),-2^{-n}]\cup[2^{-n},1-2^{-n}]$。

定点小数的反码公式

![image-20230522160957632](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230522160957632.png)

定点整数的反码公式

![image-20230522161043531](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230522161043531.png)

反码的加减运算较原码略简单，其符号位可以直接参与运算，加法运算直接将反码相加即可，但最高位进位要从运算结果最低位相加 ( 循环进位 ) 。减法运算只需要将被减数的反码加上被减数负数的反码即可，同样也要采用循环进位的运算方法。

但尽管如此，现代计算机中并没有采用反码进行数据表示和运算，这是因为人们找到了更好的编码一一补码。



#### 补码

+ 补码：若符号位为$0$，则反码与原码相同，若符号位为$1$，则数值位全部取反再加一，即反码加一。
+ 补码表示时真值$0$只有一种形式$0000\,0000$。
+ 多出来的一种形式$1000\,0000$表示整数的$-2^7$和小数的$-1$。
+ 若机器字长$n+1$位，则补码整数的表示范围是$[-2^n,2^n-1]$。（比原码多个$-128$）
+ 若机器字长$n+1$位，则补码小数的表示范围是$[-1,1-2^{-n}]$。（比原码多个$-1$）
+ 负数补码转回原码：尾数取反，末位加一；或是负数补码中，最右边的$1$以及右边不变，最右边的$1$的左边取反。
+ 数值的补码求其负数的补码：全部位包括符号位取反，末位加一。
+ 对一个整数的补码再求补码，等于该整数自身。
+ 补码算术移位：将补码的符号位与数值位一起右移一位并保持原符号位的值不变，表示除二。

定点小数的补码公式

![image-20230522161507622](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230522161507622.png)

定点整数的补码公式

![image-20230522161521871](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230522161521871.png)

##### 变形补码

变形补码，又称模 $4 $补码 或 双符号补码，采用两个二进制位来表示数据的符号，其余与补码相同。

**符号位为 $00 $ 时表示正数，符号位为 $11$ 时表示负数。**对定点小数而言，采用变形补码后，其模为 4。

因此，变形补码也称为“模 $4 $补码”。对定点整数而言，采用变形补码后，其模为$2^{n+2}$ (为数值位的位数 ) 。

用于完成算术运算的$ALU$部件中。

定点小数变形补码

![image-20230522162614722](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230522162614722.png)

定点整数变形补码

![image-20230522162626352](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230522162626352.png)



##### 补码作用

+ 原码在计算时由于首位表示的是符号，所以需要考虑将加减运算转换的问题，而减法实现起来比较困难，就考虑是否可以将减法通过加法来实现。
+ 由于计算机码操作若最高位进一就被舍弃，则天然是进行模运算，所以可以通过数学模运算来实现机器码的运算。
+ 带余除法：设$x,m\in Z$，$m>0$则存在唯一决定的整数$q$和$r$，使得$x=q\cdot m+r\,,0\leqslant r<m$。
+ 若两个数绝对值之和为模，则互为补数。即模-数的绝对值=数的补数（正数）。从而数加上数的补数就得到了模。
+ 补码就是正数不变，负数取模的结果。如$-66=-0100\,0010$，而$(1000\,0000-0100\,0010)\mod(1111\,1111)=1011\,1110$，也就是其补码。
+ 从而就可以用补数的加法（**被减数转为其负数的补码**）替代原码转换的加减法。
+ 所以**补码可以让减法操作转换为加法操作，减少硬件成本**。

#### 移码

+ 一般是在补码的基础上只将符号位取反，即在真值上加上一个常数偏移量$2^n$。也可能加上不同的偏移量。
+ 移码只能用于表示整数，而不能表示定点小数。一般用来表示浮点数的阶码。
+ 若机器字长$n+1$位，则移码整数的表示范围是$[-2^n,2^n-1]$。
+ 若机器字长$n+1$位，则移码小数的表示范围是$[-1,1-2^{-n}]$。
+ 只有一个零的表示$10\cdots0$。
+ 移码全 $0$ 时，对应真值的最小值$-2^{n}$，移码全 $1$ 时，对应真值的最大值 $2^{n}-1$
+ 移码保持了数据原有的大小顺序，移码大真值就大，移码小真值就小。

#### 对照表、对照数轴

|  机器数   | 无符号数 | 原码 | 反码 | 补码 | 移码 |
| :-------: | :------: | :--: | :--: | :--: | :--: |
| 0000 0000 |    0     |  +0  |  +0  |  0   | -128 |
| 0000 0001 |    1     |  +1  |  +1  |  +1  | -127 |
|    ...    |          |      |      |      |      |
| 0111 1101 |   125    | +125 | +125 | +125 |  -3  |
| 0111 1110 |   126    | +126 | +126 | +126 |  -2  |
| 0111 1111 |   127    | +127 | +127 | +127 |  -1  |
| 1000 0000 |   128    |  -0  | -127 | -128 |  0   |
| 1000 0001 |   129    |  -1  | -126 | -127 |  1   |
| 1000 0010 |   130    |  -2  | -125 | -126 |  2   |
|    ...    |          |      |      |      |      |
| 1111 1101 |   253    | -125 |  -2  |  -3  | 125  |
| 1111 1110 |   254    | -126 |  -1  |  -2  | 126  |
| 1111 1111 |   255    | -127 |  -0  |  -1  | 127  |

![image-20230522165301372](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230522165301372.png)

#### 相互转换







原码转补码:

符号位不动,在右起第一个1的左边画一条竖线,竖线右边的数字不动,左边的数据位(即**除了符号位以外**的所有数字全部取反)



#### 总结

1. 原码、补码、反码的符号位相同，正数的机器码相同。

2. 原码、反码的表示在数轴上对称，二者都存在$+0$ 和$-0$ 两个零。

3. 补码、移码的表示在数轴上不对称，零的表示唯一，它们比原码、反码多表示一个数。

4. 整数的补码、移码的符号位相反，数值位相同。

5. 负数的反码、补码末位相差 $1$。

6. 原码很容易判断大小。而**负数的反码、补码**很难直接判断大小，可采用如下规则**快速判**
    **断**：**对于负数，数值部分越大，绝对值越小，真值越大（更靠近 $0$）。**





### 计算机中的运算

#### C语言中的位运算

C 语言中的位运算操作符主要包括“&”，“|”，“~“，”^” 4种,分别对应逻辑与、或、非、异或操作。这些位运算操作符会在编译器的作用下被翻译成与之对应的汇编指令，如 x86 中的逻辑与指令 and 、逻辑或指令 or、逻辑非指令 not、逻辑异或指令 xor.


| A    | B    | A AND B与 | A OR B或 | NOT A非 | A XOR B异或 |
| :--- | :--- | :-------- | :------- | :------ | :---------- |
| 0    | 0    | 0         | 0        | 1       | 0           |
| 0    | 1    | 0         | 1        | 1       | 1           |
| 1    | 0    | 0         | 1        | 0       | 1           |
| 1    | 1    | 1         | 1        | 0       | 0           |

与：所有输入为真时，才会有输出真。

或：所有输入为假时，才会有输出假。

非：逆转输入的真假。

 异或：输入相同时输出为假，否则为真。



#### C语言中的逻辑运算

C 语言中的逻辑运算操作符主要包括“&&”，“||”，“!”3 种，逻辑运算和位运算的区别在它属于非数值运算，操作数只能是“0”和“1”两个值,所有非“0”值都被当作“1”处理。

所以逻辑运算翻译成汇编程序时不会对应具体的运算指令，而会演变成相应的程序分支结构。



#### C语言中的移位运算

C 语言中的移位运算操作符主要包括“<<”，“>>”两种，分别代表左移和右移。

左移运算操作符对应汇编指令中的逻辑左移，而右移运算操作符则根据操作数是无符号还是有符号类型分别对应汇编指令中的逻辑右移和算术右移指令。

逻辑左移将高位移出，低位补零; 逻辑右移则是将低位移出，高位补零; 算术右移的高位不是直接补零，而是填充原数据的符号位。

**每左移一位，数据就扩大一倍; 每右移一位，数据就缩小一半。**所以高级语言中 $2x$ 、$4x$、$x/8$、$x/16$ 这样的运算在编译时都会转换成对应的汇编移位指令实现，而不是转换成运算时间较长的乘除法指令。

**需要注意的是，左移运算可能会因为超出表示范围而发生溢出。**



#### C语言中的算术运算

C 语言中的算术运算操作符主要包括“+”，“-”，“*”，“/”4 种，分别对应算术运算中的加、减、乘、除。

对于定点数的加减运算，由于有符号数采用补码表示，符号位也可以参与运算，因此编译程序通常直接转换成汇编语言中的 add、sub 指令，并不区分符号数据类型。定点数的乘除运算则会根据操作数符号类型进行不同的转换，而所有浮点数的算术运算都会被编译成汇编浮点算术运算指令。



### 运算方法和运算电路

#### 基本运算部件

在计算机中，运算器由算术逻辑单元$ (Arithmetic\,Logic\,Unit,ALU)$、移位器、状态寄存器和通用寄存器组等组成。运算器的基本功能包括加、减、乘、除四则运算，与、或、非、异或等逻辑运算，以及移位、求补等操作。ALU 的核心部件是加法器。

##### 一位全加法器

注：参考资料[【硬件科普】带你认识CPU第02期——CPU是怎么计算加法的（上）_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1aQ4y1v7QP/?spm_id_from=333.337.search-card.all.click&vd_source=58d3a366b06c1c094d0731d6732f7441)

###### 基本概念 本位和数和进位

本位和数 Sum 简写为S

进位 Carry 简写为C

![image-20230523154300713](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230523154300713.png)



###### 运算思路

![image-20230527214738312](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230527214738312.png)

对于本位可以发现,**只要不一样就输出1一样就输出0**,符合异或运算的思想

对于进位C可以发现,当且仅当AB均为1时才输出1,符合与运算或相乘的思想

即$S=A\oplus B,C_{out}=A\times B$



###### 一位半加法器

半加法器没有进位输入,只能计算一位二进制加法

![image-20230527215240654](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230527215240654.png)

###### 一位全加法器

计算多位加法可需要将进位$C_{out}$作为下一个加法器的$C_{in}$参与运算

由加法表可知

对于本位S来说,$S=A\oplus B\oplus C_{in}$即可

对于进位$C_{out}$来说,$A,B,C_{in}$中至少要有两个1

![image-20230527220236696](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230527220236696.png)

计算时考虑AB相同和AB不同的情况

AB相同时相乘(进行与运算),均为0则输出为0($A,B,C_{in}$中已经有两个0了,进位$C_{out}$一定是0),均为1则输出为1($A,B,C_{in}$中已经有两个1了,进位$C_{out}$一定是1)

AB不同时,进行异或运算结果一定是1(此时$AB$中只要有一个1,只需要判断$C_{in}$即可),此时与$C_{in}$相乘判断$C_{in}$是0还是1

![image-20230527220143755](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230527220143755.png)

而AB相同与AB不同两种情况互斥可以相加(进行与运算),得到最终逻辑表达式

$C_{out}=A\times B+(A\oplus B)\times C_{in}$



即全加法器逻辑表达式为:
$$
S=A\oplus B\oplus C_{in}\\
C_{out}=A\times B+(A\oplus B)\times C_{in}
$$

#### 串行进位全加法器

将以上一位全加法器的$C_{in},C_{out}$首尾相连即可得到

![image-20230527221104467](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230527221104467.png)

在串行进位全加法器中，每个位的进位是依次计算的，需要等待前一位的进位计算完成后才能进行下一位的计算。

这种计算方式需要串行操作，即逐位地进行计算，因此速度较慢,且一位的错误输出可能会导致全部输出错误。



#### 并行进位加法器

考虑进位$C_{out}$逻辑表达式$C_{out}=A\times B+(A\oplus B)\times C_{in}$

可以写成
$$
C_{i}=A_{i}\times B_{i}+(A_{i}\oplus B_{i})\times (A_{i-1}\times B_{i-1}+(A_{i-1}\oplus B_{i-1})\times C_{i-2})
$$
…

继续对$C_{i-2}$展开可以一直展开到$C_0$

则**第$i$位向更高位的进位$C_{i}$可根据被加数、加数的第1~i位，再结和$C_{0}$即可确定**

记$G_{i}=A_{i}\times B_{i} \quad P_{i}=A_{i} \oplus B_{i}$

则上式可以化为

$C_{i}=A_{i}\times B_{i}+\left(A_{i} \oplus B_{i}\right) C_{i-1}=G_{i}+P_{i} C_{i-1}$
$$
\begin{aligned}
&C_{1}= G_{1}+P_{1}C_{0}  \\
&C_{2}= G_{2}+P_{2}C_{1}=G_{2}+P_{2}G_{1}+P_{2}P_{1}C_{0}  \\
&C_{3}= G_{3}+P_{3}C_{2}=G_{3}+P_{3}G_{2}+P_{3}P_{2}C_{1}+P_{3}P_{2}P_{1}C_{1}\\
&C_{4}= G_{4}+P_{4}C_{3}=G_{4}+P_{4}G_{3}+P_{4}P_{3}G_{2}+P_{4}P_{3}P_{2}G_{1}+P_{4}P_{3}P_{2}P_{2}P_{2}P_{1}  \\
...
\end{aligned}
$$
其中每一位的$A_{i}, B_{i}$都预先知道,则$G_{i},P_{i}$可以通过简单的运算得知

则每一位的运算结果几乎可以同时产生

**并行进位的并行加法器：各级进位信号同时形成，又称为先行进位、同时进位**



这种进位方式是快速的，与位数无关。

但随着加法器位数的增加，$C_{i}$的逻辑表达式会变得越来越长，这会使电路结构变得很复杂。**因此，当位数较多时采用全先行进位是不现实的。**



更多位数的加法器可通过将$CLA$部件或全先行进位加法器串接起来实现。 

例如，对于 16 位加法器，可以分成4组，组内为 4 位先行进位，组间串行进位。为了进一步提高运算速度，也可以采用组内和组间都并行的进位方式。因为两级先行进位加法器组内和组间都采用先行进位方式，其延迟和加法器的位数没有关系。所以，通常采用两级或多级先行进位加法器。



#### 带标志加法器

##### 补码计算器

![image-20230528161717724](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230528161717724.png)

计算减法$(A-B)$时,先将减数全部按位取反并末位加1,得到$[-B]_{\text{补}}$即$B$的相反数的补码,此时计算$A+[-B]_{\text{补}}$即可 

加法时不必改变,按位相加即可

![image-20230528170248482](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230528170248482.png)

- 当$Sub$信号为$0$时识别为加法,直接输出加数$B$,$C_{in}$此时为0

- 当$Sub$信号为$1$时识别为减法,先在非门中按位取反再输出加数$B$,且此时$C_{in}$此时为1

**但此时无法检测溢出,检测溢出可以使用标志位**



本电路也可以实现无符号数的运算(逻辑表达式相同),且无需考虑溢出

##### 带标志加法器

###### 标志位

![image-20230528171805353](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230528171805353.png)

###### 溢出标志位

即$OF$（$Overflow\,Flag$）。表示带符号整数运算时结果发生溢出。

+ $OF=1$表示溢出。
+ 对于无符号整数运算，$OF$没有意义。

对于有符号数的溢出判断方式有：

1. 采用一位符号位：思想为：正正得负或负负得正则为溢出，其他情况无溢出。
    + 设$A$符号为$A_S$、$B$符号为$B_S$、运算结果符号为$S_S$。
    + 溢出逻辑表达式为$V=A_SB_S\overline{S_S}+\overline{A_SB_S}S_S$。
2. 采用双符号位：$s1$、$s2$表示运算结果的两个符号位：
    + $s1s2=00$：表示正数，无溢出。
    + $s1s2=01$：表示结果正溢出 ，即正正得负，且$s2$表示当前运算符号为负，$s1$表示原本正确的符号应该为正。
    + $s1s2=10$：表示结果负溢出 ，即负负得正，且$s2$表示当前运算符号为正，$s1$表示原本正确的符号应该为负。
    + $s1s2=11$：表示结果为负数，无溢出
3. 采用一位符号位，根据数据位和符号位的进位情况判断溢出：
    + $C0$：表示运算时符号位(最高位)是否产生进位，若符号位产生进位则为$1$，否则为$0$。
    + $C1$：表示运算时最高数值位(次高位)是否产生进位，若最高数值位产生进位则为$1$，否则为$0$。
    + $V=C0\oplus C1$：若$V=0$表示无溢出；$V=1$表示有溢出。



###### 符号标志位

即$SF$（$Symbol\,Flag$）。判断当前结果符号。

+ $SF=1$表示结果为负值。
+ 当产生溢出时，符号标志位置出错。
+ $SF=F_{i=max}$,$F_{i=max}$即为运算结果的最高位
+ 对于无符号整数运算，$SF$没有意义。



###### 零标志位

即$ZF$（$Zero\,Flag$）。判断当前数字是否为全0值。

+ $ZF=1$表示结果为$0$。
+ **无论是有符号数还是无符号数，$ZF$都有意义。**
+ 通过加法电路和最后的取反操作实现。



###### 进/借位标志位

即$CF$（$Carry\,Flag$）。表示无符号整数数加/减运算时的进位/借位（溢出）。

+ $CF=1$表示无符号数加法溢出/减法借位。
+ $CF=C_{out}\oplus Sub,Sub$即为加减法控制信号,加法0减法1;$C_{out}$即为最高位产生的进位
+ **对于有符号数的整数运算，$CF$没有意义。**



### 定点数运算

#### 定点数移位运算

首先明确一件事情

在不产生溢出的情况下,左移相当于原数乘二

在不考虑因移出而舍弃的末位尾数的情况下,右移相当于原数除以二

+ 算术移位：针对**有符号数**，符号位保持不变，通过改变各个数码位和小数点的相对位置，从而改变各数码位的位权。可用移位运算实现乘法、除法。
    + 原码的算数移位——仅对数值位进行移位：
        + 若右移高位补$0$，低位舍弃，右移代表除$2$，若移出的是$0$则刚好整除，若移出的是$1$则会整除余$1$丢失精度。
        + 若左移低位补$0$，高位舍弃，左移代表乘$2$，若移出的是$0$则刚好乘$2$，若移出的是$1$，则会溢出严重误差。
    + 反码的算术移位——正数的反码与原码相同，所以正数的处理跟原码一样。而对于负数而言，反码的$1$等于原码的$0$，反码的$0$等于原码的$1$：
        + 若右移低位补$1$，高位舍弃。
        + 若左移高位补$1$，低位舍弃。
    + 补码的算术移位——正数的补码与原码相同，所以正数的处理跟原码一样。由于负数补码=反码末位加一，导致反码最右边几个连续的$1$都因进位而变为$0$，直到进位碰到第一个$0$为止。所以得到规律：
        + 负数补码中，最右边的$1$及其右边同原码一样。最右边的$1$的左边同反码一样。
        + 右移同反码，高位补$1$，低位舍弃。
        + 左移同原码，低位补$0$，高位舍弃。
+ 逻辑移位，逻辑的移位可以视为对无符号数的算术移位：
    + 逻辑右移：高位补$0$，低位舍弃。
    + 逻辑左移：低位补$0$，高位舍弃。
+ 循环移位，将移出的一位放到另一端的端点，类似队列：
    + 进位位$CF$：保存计算是否进位。$1$代表产生进位，$0$代表未产生进位。
    + 带$CF$就是大循环，不带$CF$的就是小循环。不论带不带$CF$进行循环移位，最高位的值都必定与$CF$的值相等。
    + 循环右移：将最低位的一位移出放到最高位，其余右移一位。
    + 循环左移：将最高位的一位移出放到最低位，其余左移一位。
    + 带进位位的循环左移：需要加上进位位数值的循环左移。
    + 带进位位的循环右移：需要加上进位位数值的循环右移。
    + 适合将数据的低字节数据和高字节数据互换。



#### 定点数加减运算

+ 注意机器字长，若溢出则将溢出位丢弃。
+ 原码的加减，由加法器和减法器两个硬件来实现，因为最高位为符号位，所以不能直接进行加减，符号位要单独处理：
    + 原码的加法：
        + 正数+正数：绝对值做加法，结果为正数。
        + 负数+负数：绝对值做加法，结果为负数。
        + 正数+负数：绝对值大的减绝对值小的，符号同绝对值大的数。
    + 原码的减法，减数符号取反，转变为加法：
        + 正-负→正+正。
        + 负-正→负+负。
        + 正-正→正+负。
        + 负-负→负+正。
+ 补码的加减，由于减法器的硬件实现比较困难，所以原码的减法操作可以由补码来更简单实现，不用考虑符号位的问题，直接全部参与运算：
    + 参与运算的两个操作数均用补码表示。
    + 按二进制运算规则运算，逢二进一（与模二加减法不同需要进位）。
    + 符号位与数值位按同样规则一起参与运算，符号位运算产生的进位要丢掉，结果的符号位由运算得出。
    + 补码加减运算依据下面的公式进行。当参加运算的数是定点小数时，模$M=2$；当参加运算的数是定点整数时，模$M=2^{n+1}$。$[A+B]_\text{补}=[A]_\text{补}+[B]_\text{补}$（$\mod M$）；$[A-B]_\text{补}=[A]_\text{补}+[-B]_\text{补}$（$\mod M$）。
    + $\mod M$运算是为了将溢出位丢掉。也就是说，若做加法，则两数的补码直接相加；若做减法，则将被减数与减数的机器负数相加。
    + 补码运算的结果亦为补码。
+ 溢出判断，**由于使用补码进行加减操作都会变成加法，所以只用考虑加法溢出的处理。**
    + 小于最小值就是下溢。只有负数+负数才会下溢得到正数。如$-24-124=1110\,1000+1000\,0100=0110\,1100=108$。
    + 大于最大值就是上溢。只有正数+正数才会上溢得到负数。如$15+124=0000\,1111+0111\,1100=1000\,1011=-117$。
    + 对于小数，其绝对值小于等于$1$。
    + 方法一，采用一位符号位（模二补码），根据符号位判断：
        + 设$A$的符号为$A_s$，$B$的符号为$B_s$，运算结果的符号为$S_s$。
        + 则溢出逻辑表达式为$V=A_sB_s\overline{S_s}+ \overline{A_s}\overline{B_s}S_s$（即$V=A_s\&\&B_s\&\&!(S_s)\mid\mid!(A_s)\&\&!(B_s)\&\&S_s$，前面判断下+溢，后面判断上溢）。
        + 逻辑表达式的含义：
            + PS.符号位为0表示是正数,符号位为1表示是负数
            + 第一项 $A_sB_s\overline{S_s}$：表示当两个操作数 $A$ 和 $B$ 的符号位相同（都为正或都为负），而运算结果的符号位与操作数的符号位不同（异号），即产生了溢出。
            + 第二项 $\overline{A_s}\overline{B_s}S_s$：表示当两个操作数 $A$ 和 $B$ 的符号位不同（一个正一个负），而运算结果的符号位与操作数的符号位相同（同号），即产生了溢出。
        + 若$V=0$，表示无溢出，若$V=1$，表示有溢出。
        + 由于只有操作数同号才能溢出，即判断标准为，两个操作数是否同号，结果符号是否与原操作数相同，这两个条件必须同时满足。
        + 如$-24-124=108$产生了溢出，$A_s=1$、$B_s=1$、$S_s=0$，$V=A_sB_s\overline{S_s}+ \overline{A_s}\overline{B_s}S_s=1\,1\,1+0\,0\,0=1+0=1$，所以产生了溢出。
    + 方法二，采用一位符号位（模二补码），根据数据位进位$1$情况判断：
        + 符号位的进位$C_s=0$，最高数值位的进位$C_1=1$时产生了上溢。
        + 符号位的进位$C_s=1$，最高数值位的进位$C_1=0$时产生了下溢。
        + 原理同方法一类似，如果进位产生并符号与期待符号不同则发生溢出。
        + 如$-24-124=1110\,1000+1000\,0100=0110\,1100$中符号位都为$1$相加结果为$0$，所以符号位进位，$C_s=1$，而最高数值位为$1+0=1$，没有进位，所以$C_1=0$，所以就产生了下溢。
    + 方法三，采用双符号位（模四补码），正数符号为$00$，负数符号为$11$。
        + 若两个符号位不同，则表示溢出，第一个符号位表示应该得到的符号位，第二个符号位代表实际得到的符号位。
        + 如$-24-124=11,110\,1000+11,000\,0100=10,110\,1100=108$。下溢。
        + 如$15+124=00,000\,1111+00,111\,1100=01,000\,1011=-117$。上溢。
        + 实际存储时只存储一个符号位，运算时会复制一个符号位。
+ 符号扩展：防止溢出的一个方法就是将短数据扩展为长数据，把数据全部拓展为等长。（正数补码全部补$0$，负数补码高位补$1$低位补$0$）
    + 整数扩展，在原符号位和数值位中间添加新位，正数都填充$0$，对于负数：
        + 原码：扩展补$0$。
        + 反码：扩展补$1$。
        + 补码：扩展补$1$。
    + 小数扩展，在最后面添加新位，正数都填充$0$，对于负数：
        + 原码：扩展补$0$。
        + 反码：扩展补$1$。
        + 补码：扩展补$0$。



#### 定点数乘法运算

二进制乘法基本流程：将乘法变为加法和移位运算，将乘数一位位的向前移动并与被乘数相乘，由于是二进制所以只有$0$和$1$，遇到乘数当前位值为$1$就在原来的和上加上被乘数，并向前移动一位，如果是$0$就加上$0$继续移动一位，当乘数位数访问完成则乘法完成，所有的和相加成为最后的积。

##### 原码一位乘法

+ 一般使用原码一位乘法，即每次只乘一位的数据。
+ 在原码乘法时，可以先符号位单独处理，将两个符号进行异或操作，得到的结果就是最后的结果的符号。然后对数据的绝对值（去除符号位）进行一位位的乘法（位积）然后相加。
+ 由于运算时可能存在绝对值大于$1$但是不是溢出的情况，所以部分积和被乘数使用双符号位。
+ 在运算器的组成时出现一个表格，说明在进行乘运算时，$ACC$保存乘积高位，$MQ$保存乘数与乘积低位，$X$保存被乘数。
+ 原码一位乘法机器实现时就是按照这种方式计算：
    1. 字长若为$n+1$位，则$ACC$、$MQ$、$X$全部初始化为$n$位，将被乘数的绝对值放入$X$中，$MQ$放入乘数的绝对值，$ACC$初始化为全$0$。
    2. 将$MQ$的最右边的一位当做当前乘运算位，让其进行乘运算，运算规则是，若当前位是$1$，则$ACC$加上被乘数，即$ACC+=X$，若当前位是$0$，则$ACC$加上$0$（保持不变，跳过）。
    3. 将$ACC$和$MQ$的数据连接在一起，全部逻辑右移一位，$ACC$数据高位补$0$，$ACC$最后一个低位移到$MQ$的最高位。将$MQ$的最后一位抛弃。若是第i轮逻辑右移，则$MQ$的前$i$位是结果的后$i$个低位值。
    4. 从步骤二开始重复，字长若为$n+1$位，则重复$n$次，直到$MQ$的最后一位是符号位，则停止计算。此时$ACC$的全部和$MQ$的前$n$位都是结果。
    5. 定点小数的小数位隐藏在符号位后面第一位，定点正数的小数位隐藏在$MQ$符号位的前一位。
    6. 将两个符号位的异或结果赋值给积最高位。
+ 原码一位乘法逻辑运算：
    1. 初始化，左边为部分积，即计算的部分结果，最开始为全$0$，右边为乘数的绝对值，最后边全部为丢失位。
    2. 根据丢失位前一位的值来判断加上什么，若是$1$则加上被乘数的绝对值，若是$0$则加上被乘数等长的全$0$。
    3. 右移部分积一位，高位补$0$，丢失位多一位。
    4. 继续计算，直到乘数全部被移出。字长为$n+1$位则需要移位计算$n$次。丢失位前的就是全部部分积。
    5. 将两个符号位的异或结果赋值给积最高位。





##### 补码一位乘法

+ 对于补码的乘法运算的逻辑也跟原码的类似，补码的计算就是使用$Booth$算法实现。
+ 辅助位其实就是在$MQ$最后再加上一位，辅助位初始为$0$。每次右移会使$MQ$的最低位顶替原本的辅助位（事实上$MQ$共$n+2$位）。
+ 为了保证统一，所以$ACC$和$X$都会增加一位，变成$n+2$位，多出来的一位就可以实现双符号位补码运算，而$MQ$还是用原来的单符号位。
+ 为了加快运算会有辅助电路实现$(-x)$的补码的运算。
+ 最后一次不需要移位直接根据辅助位和$MQ$最后一位判断进行相加。从而让乘数的符号位也参数运算中来确定最后结果的符号。
+ 补码一位乘法逻辑运算：
    1. 初始化，左边为部分积，即计算的部分结果，最开始为全$0$，右边为乘数，然后是一个辅助位，最后边全部为丢失位。
    2. 根据辅助位$-MQ$最低位的差值来判断加上什么，若是$1$则加上被乘数的补码，若是$0$则加与被乘数等长的全$0$，若是$-1$则加上被乘数的负数的补码。
    3. 算术右移部分积一位，正数高位补$0$，负数高位补$1$，丢失位多一位。
    4. 继续计算，直到乘数全部被移出。字长为$n+1$位则需要移位计算$n$次。丢失位前的就是全部部分积。
    5. 最后一次不需要移位，再加一次。

$Booth$算法的移位法则，其中$y_n$为$MQ$最低位，$y_{n+1}$为辅助位：

| $y_n$（高位） | $y_{n+1}$（低位） |                 操作                 |
| :-----------: | :---------------: | :----------------------------------: |
|       0       |         0         |            部分积右移一位            |
|       0       |         1         | 部分积加$[X]_{\text{补}}$，右移一位  |
|       1       |         0         | 部分积加$[-X]_{\text{补}}$，右移一位 |
|       1       |         1         |            部分积右移一位            |

即辅助位减$MQ$最低位的值，若是$1$就加补码，若$0$则加$0$，若$-1$则加负数的补码。

## 浮点数

### 浮点数表示

#### 阶码与尾数

+ 指小数点的位置不固定，如使用科学计数法，如$9.694E2$。
+ 类似科学计数法，分为两个部分，阶码(一般记为$E$)和尾数(一般记为$M$)。其中阶码分为阶符和阶码数值,阶符和阶码数值反映数值大小、表示范围、小数点实际位置;尾数分为数符和尾数数值,数符代表浮点数的符号，尾数数值反映精度。
    + ![image-20230529154318976](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230529154318976.png)

+ 对于二进制的浮点数，阶码是常用补码或移码表示的定点整数，而尾数是常用原码或补码表示的定点小数。
+ $r$为阶码的底，即基数，一般为$2$,不过也可以使用$2^{n}$
+ 阶码$E$反映浮点数的**表示范围**及小数点的实际位置；
    + 阶码符号（exponent sign）：
        - 阶码符号表示阶码的正负号。它决定了浮点数的大小范围和取值方向。
        - 如果阶码符号为正，表示浮点数的阶码是正数；如果阶码符号为负，表示浮点数的阶码是负数。
    + 阶码数值（exponent value）：
        - 阶码数值是一个无符号整数，表示浮点数的阶码大小。
        - 阶码数值决定了浮点数在科学计数法中的指数部分的值，控制了浮点数的数量级。

+ 尾数$M$的数值部分的位数n反映浮点数的**精度**。
    + 数符（sign）：
        - 数符表示浮点数的正负号。它决定了浮点数的数值是正数还是负数。
        - 如果数符为正，表示浮点数是正数；如果数符为负，表示浮点数是负数。
    + 尾数数值（significand/mantissa）：
        - 尾数数值是一个带有符号位的小数或定点数，表示浮点数的小数部分或尾数部分。
        - 尾数数值决定了浮点数的精度和小数部分的值。

+ 其实$E\&M$就是分别的两个数,符号只是其本身的符号位

#### 尾数规格化

为了提高精度，充分利用**尾数有效位数必须进行规格化**，规定尾数必须是一个有效值。

+ **左规：算术左移n位，阶码真值减少n。**出现下溢需要左规，即若尾数的高位是无效值（即为$0$）则会丧失精度，所以我们需要尽可能将尾数多保存一些$1$，从而让最高位为$1$。所以需要让数值左移，让小数点右移，尾数算术左移$n$位，阶码减$n$，直到尾数最高位是有效值。可能会进行多次。
+ **右规：算术右移n位，阶码真值增加n。**出现上溢需要右规，规范要求小数点要在第一个非$0$的数据右边，如果小数点前有超过$1$个有效位，则需要将数值右移，小数点左移，尾数算术右移$n$位，阶码加$n$，直到小数点在尾数最高位的右边。只需要一次。

![image-20230528225320360](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230528225320360.png)

规格化浮点数的特点：

1. 用原码表示的尾数进行规格化，最高位数值一定为$1$：
    + 正数为$0.1xx\cdots x$的形式，其最大值表示为$0.11\cdots1$；最小值表示为$0.10\cdots0$。
    + 尾数的表示范围为$\dfrac{1}{2}\leqslant M\leqslant(1-2^{-n})$。
    + 负数为$1.1xx\cdots x$的形式，其最大值表示为$1.10\cdots0$;最小值表示为$1.11\cdots1$。
    + 尾数的表示范围为$-(1-2^{-n})\leqslant M\leqslant-\dfrac{1}{2}$。
    + **规格化格式：原码正数01，源码负数11**
2. 用补码表示的尾数进行规格化，符号位与最高位数值一定相反：
    + 正数为$0.1xx\cdots x$的形式，其最大值表示为$0.11\cdots1$；最小值表示为$0.10\cdots0$。跟原码一致。
    + 尾数的表示范围为$\dfrac{1}{2}\leqslant M\leqslant(1-2^{-n})$。
    + 负数为$1.0xx\cdots x$的形式，其最大值表示为$1.01\cdots1$；最小值表示为$1.00\cdots0$。（负数的补码$1.0xx\cdots x$取反后就是$1.1xx\cdots x$）
    + 尾数的表示范围为$-1\leqslant M\leqslant-(\dfrac{1}{2}+2^{-n})$。（补码中强制规定$1.00\cdots0$就代表$-1$）
    + **规格化格式：补码正数01，补码负数10**

当浮点数尾数的基数为$2$时，原码规格化数的尾数最高位一定是$1$，补码规格化数的尾数最高位一定与尾数符号位相反。

基数不同，浮点数的规格化形式也不同。当基数为$4$时，原码规格化形式的尾数正数最高两位不全为$0$，负数最高两位不全为$1$；当基数为$8$时，原码规格化形式的尾数正数最高$3$位不全为$0$，负数正数最高$3$位不全为$1$。

如若基数为$8$，则$0.000111$和$1.111010$都不是规格化数，而$1.101010$是规格化。

对于浮点数，上溢和下溢有正负之分：负上溢<负数区<负下溢<$0$<正下溢<正数区<正上溢。

#### 定点浮点区别

假设定点数和浮点数的字长相同。

+ 浮点数表示范围更大。
+ 浮点数精度降低。（由于只取出一部分数据，还有部分长度表示阶码等，所以用于表示尾数的字长减少）
+ 浮点数运算更复杂。（需要规格化，需要做尾数运算和阶码运算）
+ 浮点数只有规格化后才能判断是否溢出。



### IEEE 754标准

$IEEE\,754$标准就是浮点数标准，为了解决计算机中阶码、尾数使用什么码来表示，各取多少位的问题。

#### 移码定义

+ 移码的定义其实=真值+偏置值，一般取$2^{n-1}$，这时候移码才等于补码符号位取反，若移码采取其他方案则没有这个特点。
+ 在$IEEE\,754$标准中，规定移码的偏置值不再是$128$而是$127$，即$2^{n-1}-1$。所以这个标准下的移码与一般的移码不同。
+ 从而真值$-128$的移码为$-1000\,0000+0111\,1111=1111\,1111$，$-127$的移码为$0000\,0000$，$0$的移码为$0111\,1111$，$127$的移码为$1111\,1110$。

#### IEEE 754定义

+ 分为数符（表示数值正负号）、阶码（用移码表示）、尾数（用原码表示，且默认最高位为$1$，实际尾数都要在之前加$1$即实际尾数为$1.M$）。
    + ![image-20230529162847982](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230529162847982.png)

+ 标准中会将全$0$的$-127$（非规格化数）和全$1$的$-128$（无穷大）做特殊的用途，所以短浮点数的真值正常范围是$-126$到$127$。

|  英文类型   |  中文类型  | 数符位 | 阶码位 | 尾数位 | 总位数 | 十六进制偏置值 | 十进制偏置值 |
| :---------: | :--------: | :----: | :----: | :----: | :----: | :------------: | :----------: |
|    float    |  短浮点数  |   1    |   8    |   23   |   32   |      7FH       |     127      |
|   double    |  长浮点数  |   1    |   11   |   52   |   64   |      3FFH      |     1023     |
| long double | 临时浮点数 |   1    |   15   |   64   |   80   |     3FFFH      |    16383     |

+ 令数符为$S$，阶码为$E$，尾数为$M$。
+ 规格化的短浮点数$Float$的真值为$(-1)^S\times 1.M\times2^{E-127}$,共$1+8+23=32$位。
+ 规格化的长浮点数$Double$的真值为$(-1)^S\times 1.M\times2^{E-1023}$,共$1+11+52=64$位。
+ 短浮点数和长浮点数都隐含一位尾数最高位$1$，即$0.11$为$+1.11$，$1.11$为$-1.11$，而临时浮点数没有隐含位。



![image-20230528225855160](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230528225855160.png)

#### IEEE 754取值范围

|  格式  |            规格化的最小绝对值            |                      规格化的最大绝对值                      |
| :----: | :--------------------------------------: | :----------------------------------------------------------: |
| 单精度 |  $E=1$，$M=0$：$1.0×2^{1-127}=2^{-126}$  | $E=254$，$M=.11...1$：$1.11...1×2^{254-127}=2^{127}×(2-2^{23})$ |
| 双精度 | $E=1$，$M=0$：$1.0×2^{1-1023}=2^{-1022}$ | $E=2046$，$M=.11...1$：$1.11...1×2^{2046-1023}=2^{1023}×(2-2^{-52})$ |

![image-20230528225939326](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230528225939326.png)

+ 对于规格化短浮点数，只有$1\leqslant E\leqslant 254$正常区间时，$(-1)^S\times 1.M\times2^{E-127}$。
+ 阶码全0全1时的特殊用途
    + 当阶码$E$为全$0$，即应该为$-127D$，而尾数$M$不全为$0$时，表示**非规格化小数**$\pm(0.\textrm{M})_2\times2^{-126}$。（此时最高位就不默认为$1$了，阶码固定设置为$-126$）。
    + 当阶码$E$为全$0$，即应该为$-127D$，而尾数$M$全为$0$时，表示真值$\pm0$，正负由数符决定。
    + 当阶码$E$为全$1$，即应该为$-128D$，而尾数$M$全为$0$时，表示无穷大$\pm\infty$，正负由数符决定。
    + 当阶码$E$为全$1$，即应该为$-128D$，而尾数$M$不全为$0$时，表示非数值$NaN$（$Not\,a\,Number$）。如果非法操作如$\frac{0}{0}$等就会使用到。




#### 单精度浮点数与真值之间的转换

![image-20230528230030881](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230528230030881.png)

![image-20230528230050126](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230528230050126.png)

#### 尾数运算

由于阶码由原码转换为移码，尾数加减都需要进行原码运算，所以需要两种实现方式。

+ 转换为补码进行加减，再转回原码。
+ 直接用原码加减，符号和数值分开。

### 浮点数计算

#### 引例:科学计数法加减

1. 对阶：阶数小的向阶数更大的对齐。
    + 因为计算机内部，尾数是定点小数，小数点位置不会变，改变的只是数据的相对位置。
    + 若是阶数大的向阶数小的对齐，则阶数大的尾数值会变大，需要对尾数进行算术左移，若内存不够大很可能会引起最高有效位丢失。
    + 若是阶数小的向阶数大的对齐，则阶数小的尾数值会变小，需要对尾数进行算术右移，若内存不够大很可能会引起最后几位丢失，即精度下降，影响较小。
2. 尾数加减：阶数不变，对尾数进行相加减。
3. 规格化，将数据变为整数部分为$0$到$9$的数据：
    + 当尾数加减结果的第一位为$0$时需要左规，直到第一位不为$0$。
    + 当结果的整数部分大于等于$10$需要右规，直到整数部分只有一位。
4. 舍入：计算机中由于尾数的比特位有限，所以需要舍弃尾数的低位。只有浮点数才会舍入，定点数则没有这个概念。**对阶**和**右规格化**都会引起舍入。舍入方法有：
    + 直接去除。
    + 非$0$进$1$。
    + 四舍五入。
5. 判溢出：若运算后阶码超过规定范围则溢出。尾数的溢出未必会导致整体溢出，可以通过第三四步来修补，但是阶码溢出一定会整体溢出。

溢出的情况：

+ 右规和尾数舍入（如果是四舍五入可能导致尾数加一，尾数需要进位，阶码加一，导致阶码上溢）可能引起阶码上溢。
+ 左规可能引起阶码下溢。
+ 对阶不会导致溢出（因为是向大阶对齐，大阶一定不是溢出的）。

<!-- **例题** 计算$9.85211\times10^{12}+9.96007\times10^{10}$的值并保留四舍五入六位有效尾数。

第一步进行对阶，变成$9.85211\times10^{12}+0.0996007\times10^{12}$。

第二步进行相加得到$9.9517107\times10^{12}$。

第三步由于整数部分为9，所以不需要规格化。

第四步因为只能保留六位有效尾数，所以保留9.95171，因为后一位是0，所以不进位为最后答案。

第五步因为阶码无论是10或12都是两位，所以肯定没有溢出。 -->



#### 浮点数的加减运算

一般步骤

1. (转换格式化为浮点数)
    1. 一般格式为$2^{E}\times M$,$M$最高位可能是1可能是0,卷子上一般会给出浮点数格式,可能是双符号位格式(11表示负数,00表示正数)
    2. **此处阶码尾数均用补码表示**
2. 对阶
    1. 使两个数的阶码相等，小阶向大阶看齐，尾数每右移一位，阶码加1
3. 尾数加减
4. 规格化
5. 舍入
6. 判溢出





**【例题】:**

例：已知十进制数$X=-\frac{5}{256}$、$Y=+\frac{59}{1024}$,按机器补码浮点运算规则计算$X-Y$,结果用二进制表示，浮点数格式如下：阶符取2位，阶码取3位，数符取2位，尾数取9位。

**【解】:**

1. 转换格式化为浮点数

     

    $(5)_{10}=(101)_{2},\frac{1}{256}=2^{-8}$此处先不慌把-8转换

    $X=(-101)_{2}\times 2^{(-8)_{10}}=(-0.101)_{2}\times 2^{(-5)_{10}}$此处有进制混用,建议分开写

    对于阶码$E$,$(-5)_{10}=(1101)_{\text{原码}}=(11011)_{\text{双符号位补}},$

    对于尾数$M$,$(-0.101)_{2}=(1 101)_{\text{原码}}=(11.0110\,0000\,0)_{\text{双符号位补}}$

    则化为题目所给格式为$X:11.0110\,0000\,0;11 011,Y=00.1110\,1100\,0;11100$.

2. 对阶

    1. 使两个数的阶码相等，小阶向大阶看齐，尾数每右移一位，阶码加1

    2. 求阶差:$[\Delta E]_{\text{补}}=11011+00100=11111$,可知$[\Delta E]=-1$

        **此处是求XY两数阶数之差$X-Y$,由于计算机中计算减法是利用补码,所以此处是先将Y转换成对应负补码计算$X+Y$得到$11111^{补}$即为-1**

    3. 对阶:$X:11.0110\,0000\,0;11 011$转换为$X:11.1011\,0000\,0;11100$

        ****

3. 尾数加减

    1. $X-Y:10.1100\,0100\,0;11100$

4. 规格化

    1. $X-Y:10.1100\,0100\,0;11101$

5. 舍入

    1. 此处无舍入

6. 判溢出

    1. 常阶码，无溢出

结果即为$(-0.1001\,111)_{2}\times 2^{(-011)_{2}}$

![image-20230529201632972](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230529201632972.png)

#### 强制类型转换

|   类型    | 16位机器 | 32位机器 | 64位机器 |
| :-------: | :------: | :------: | :------: |
|   char    |    8     |    8     |    8     |
|   short   |    16    |    16    |    16    |
|    int    |    16    |    32    |    32    |
|   long    |    32    |    32    |    64    |
| long long |    64    |    64    |    64    |
|   float   |    16    |    32    |    32    |
|  double   |    64    |    64    |    64    |

无损转换：

+ $char$→$int$→$long$→$double$。
+ $float$→$double$。

此处默认$long$型为$32$位,64位$long$型向$double$转换会有精度损失

由于定点数和浮点数不同，浮点数使用阶码+尾数的存储方式存储，所以定点数数值精度看位长就可以了，而浮点数数值精度看尾数长度，按$IEEE\,754$标准有一个隐含的高位$1$，所以$double$尾数长度为$53$位。对于$32$位机器$long$是$32$位，所以转换到$double$的$53$位没有损失，而对于$64$位机器$long$是$64$位，$double$还是$53$位，这时候转换就会产生损失了。

$int$与$float$转换

+ $int$：表示整数，范围$[-2^{31},2^{31}-1]$，有效数字$32$位。
+ $float$：表示整数及小数，范围$\pm[2^{-126},2^{127}×(2-2^{-23})]$，有效数字$23+1=24$位。
+ $int$→$float$：可能损失精度。
+ $float$→>$int$：可能溢出及损失精度。

