# EX-第二章 数据的表示与运算总结

## 【导语】

### 【考纲内容】

1.   **数制与编码**
     1.   进位计数制及其相互转换
     2.   定点数的编码表示
2.   **运算方法和运算电路**
     1.   基本运算部件：加法器、算法逻辑单元 $ALU$
     2.   加/减运算：补码加/减运算器、标志位的生成
     3.   乘/除运算：乘/除法运算的基本原理、乘法运算和除法电路的基本结构
3.   **整数的表示和运算**
     1.   无符号整数的表示和运算
     2.   带符号整数的表示和运算
4.   **浮点数的表示和运算**
     1.   浮点数的表示：$IEEE\;\;754$ 标准、浮点数的加/减运算

### 【复习提示】

选择题：$unsigned、short、int、long、float、double$等在 C 语言中的表示、运算、溢出判断、隐式类型转换、强制类型转换、$IEEE 754$ 浮点数的表示，以及浮点数的运算。

## 考点总结

### 数制与编码

1.   ※使用二进制的原因：考过
     1. 可使用两个稳定状态的物理器件表示。
     2. $0$，$1$正好对应逻辑值假、真。方便实现逻辑运算。
     3. 可很方便地使用逻辑门电路实现算术运算（物理部件性质决定）。
2.   二进制与十六进制转换：十六进制用结束的$H$表示；二进制用结束的$B$表示。
     +   最好能够记下，方便考试转化：$AH=1010B,BH=1011B,CH=1100B,DH=1101B,EH=1110B,FH=1111B$。
3.   *$BCD(Binary-Coded\;Decimal)$码：即使用二进制编码的十进制。使用$4bit$来表示$0$到$9$这十个数，而$4bit$能表示十六个数，所以会冗余六个组合。
     1.   $8421$码：$8421$码是一种有权码。第$1$、$2$、$3$、$4$位分别对应$8$、$4$、$2$、$1$，使用常规的二进制来表示十进制，冗余最后六个。
     2.   余三码：在$8421$码的基础上全部加上三。余三码因为加上了三，所以每一位的权值映射关系就破坏了，所以这是一种无权码，不能分别对应$8$、$4$、$2$、$1$的值。
     3.   $2421$码：与$8421$码一样都是一种有权码，但是映射的方式不同，第$1$、$2$、$3$、$4$位分别对应$2$、$4$、$2$、$1$。
4.   字符与字符串：英文字符表示使用$ASCII$码：使用$7$位就可以表示$128$个字符，但是通常会高位补$0$凑足$1B$；其中$32$到$126$是可印刷字符，其他都是控制或通信字符。中文字符表示使用$GB\;2312$等：中文有两个字节。

### 定点数的编码

#### 定点数的编码表示

当机器字长为$n+1$位时

1.   原码：有正零和负零的表示。原码整数的表示范围是$[-(2^n-1)，2^n-1]$，原码小数的表示范围是$[-(1-2^{-n})，-2^{-n}]\cup[2^{-n}，1-2^{-n}]$。
2.   反码：不常用，整个408仅用于$CN$的$UDP$协议校验和中，$CO$中了解即可。有正零和负零的表示。反码整数的表示范围是$[-(2^n-1)，2^n-1]$，则反码小数的表示范围是$[-(1-2^{-n})，-2^{-n}]\cup[2^{-n}，1-2^{-n}]$。
3.   ※※※补码：只有正零的表示。补码整数的表示范围是$[-2^n，2^n-1]$，比原码多个$-2^n$；补码小数的表示范围是$[-1，1-2^{-n}]$。补码的整数和小数表示均比原码多个`-1`，即**均为把多出来的负零的表示对应到下限去了**。
     1.   **补码可以让减法操作转换为加法操作，减少硬件成本**。
     2.   $50$**年代开始成为整数标准**
     3.   补码的数值位越大，真值**绝对值**越小：故**补码的数值位越大，负数真值越大**，正数真值越小
4.   移码：一般是在补码的基础上只将符号位取反，即在真值上加上一个常数偏移量$2^n$，也可能加上不同的偏移量。只有一个零的表示。移码整数的表示范围是$[-2^n，2^n-1]$，**移码不能表示定点小数**。通常用于浮点数阶码。
     1.   移码全 $0$ 时，对应真值的最小值$-2^{n}$，移码全 $1$ 时，对应真值的最大值 $2^{n}-1$
     2.   移码保持了数据原有的大小顺序，移码大真值就大，移码小真值就小。补码的数值位越大，真值**绝对值**越小，移码又取反，相当于负负得正了。
5.   变形补码：又称**模 $4 $补码** 或 **双符号补码**。**符号位`01`表示正溢出，`10`表示负溢出，最高位表示正确符号位。**
     +   实际存储时只存储一个符号位，运算时会复制一个符号位。

#### 定点数的相互转换

1.   正数三码合一：正数的原码、反码和补码表示一致，**不需要进行转换**。
2.   负数原码转反码$and$负数反码转原码：符号位不变、数值位取反
3.   负数反码转补码：末位+1即可
4.   负数原码转补码$and$负数补码转原码：从右往左找到第一个1，这个1左边的所有“**数值位**”按位取反
5.   补码转反码：先转成原码再转成反码
6.   补码转移码：只将符号位取反即可
7.   三码转移码：先转成补码然后将符号位取反即可，注意正数三码合一不用转
8.   $[x]_补\to[-x]_补$：从右往左找到第一个1，这个1左边的**所有位（包括符号位）**按位取反

### $C$语言中的运算

1.   位运算
     1.   与：所有输入为真时，才会有输出真。
     2.   或：所有输入为假时，才会有输出假。
     3.   非：逆转输入的真假。
     4.   异或：输入相同时输出为假，否则为真。可以类比正负数乘法：正数（符号位）为`0`，负数（符号位）为`1`。
          1.   同号相乘得正：$1\oplus 1=0，0\oplus0=0 $
          2.   异号相乘得负：$1\oplus 0=1，0\oplus1=1 $
2.   逻辑运算：$C $语言中的逻辑运算操作符主要包括`&&`，`||`，`!`三种，逻辑运算和位运算的区别在它属于非数值运算，操作数只能是`0`和`1`两个值，所有非`0`值都被当作`1`处理。所以逻辑运算翻译成汇编程序时不会对应具体的运算指令，而会演变成相应的程序分支结构。
3.   移位运算：$C $语言中的移位运算操作符主要包括`<<`，`>>`两种，分别代表左移和右移。
     1.   左移运算操作符对应汇编指令中的**逻辑左移**：逻辑左移将高位移出，低位补零。左移运算可能会因为超出表示范围而发生溢出。
     2.   右移运算操作符根据操作数类型对应：有符号数：逻辑右移，将低位移出，高位补零；有符号数：算术右移，高位不是直接补零，而是填充原数据的符号位。

### 运算方法和运算电路

本位和数$ Sum $简写为$S$，进位$Carry$简写为$C$

1.   一位全加法器：$S=A\oplus B,C_{out}=A\times B$​。对于本位可以发现，**只要不一样就输出1一样就输出0**，符合**异或运算**的思想；对于进位C可以发现，**当且仅当输出均为1时才输出1**，符合**与运算**或相乘运算的思想

2.   一位半加法器：半加法器没有进位输入，只能计算一位二进制加法。
     $$
     S=A\oplus B\oplus C_{in},C_{out}=A\times B+(A\oplus B)\times C_{in}
     $$

3.   串行进位全加法器：将一位全加法器的$C_{in}，C_{out}$首尾相连即可得到。

     1.   在串行进位全加法器中，每个位的进位是依次计算的，需要等待前一位的进位计算完成后才能进行下一位的计算。
     2.   这种计算方式需要串行操作，即逐位地进行计算，因此速度较慢，且一位的错误输出可能会导致全部输出错误。

4.   并行进位加法器：对进位$C_{out}$逻辑表达式的逻辑展开式展开可以发现，每一位的运算结果几乎可以同时产生。故并行进位加法器中各级进位信号同时形成，**与位数无关**，又称为先行进位、同时进位。但随着加法器位数的增加，$C_{i}$的逻辑表达式会变得越来越长，这会使电路结构变得很复杂。**因此，当位数较多时采用全先行进位是不现实的。**

5.   带标志加法器：主要考查标志位的生成

#### ※※※标志位

只有进/借位标志位$CF$是“对于无符号数的整数运算有意义”。

1.   零标志位$ZF$（$Zero\;Flag$）：判断当前数字是否为全0值。**无论是有符号数还是无符号数，$ZF$都有意义**。
     +   将运算结果每个**数值位**逐个进行**或运算**，最后取反得到。
2.   符号标志位$SF$（$Symbol\;Flag$）：判断当前结果符号。**仅对于有符号整数运算有意义**。
     +   $SF=F_{i=max}$，其中$F_{i=max}$为运算结果的最高位。
3.   ※※溢出标志位$OF$（$Overflow\;Flag$）：表示带符号整数运算时结果发生溢出。**仅对于有符号整数运算有意义**。
     1.   采用一位符号位，根据数值位和符号位的进位情况判断溢出：$OF=C_0\oplus C_1$，其中
          1.   $C_0$表示运算时**符号位/最高位**是否产生进位，若符号位产生进位则为$1$，否则为$0$。
          2.   $C_1$表示运算时**最高数值位/次高位**是否产生进位，若最高数值位产生进位则为$1$，否则为$0$。
     2.   采用一位符号位，正正得负或负负得正则为溢出：$OF=A_SB_S\overline{S_S}+\overline{A_SB_S}S_S$。
          +   参与运算的$A$符号为$A_S$、$B$符号为$B_S$、运算结果符号为$S_S$。
     3.   采用双符号位，采用变形补码思想判断溢出：符号位`01`表示正溢出，`10`表示负溢出，最高位表示正确符号位。
          +   逻辑表达式为两个符号位进行或运算。
4.   进/借位标志位$CF$（$Carry\;Flag$）：表示无符号整数数加/减运算时的进位/借位（溢出）。**对于无符号数的整数运算有意义**。
     +   $CF=C_{out}\oplus Sub$，其中$Sub$为加减法控制信号，加法0减法1，$C_{out}$即为最高位产生的进位。

### 定点数的运算

只需要记补码整数的运算即可。

1.   移位运算：
     1.   算术移位：针对**有符号数**，符号位保持不变。对于补码的算术移位：**左移补0，右移补符号位**。算术移位的影响：
          1.   对于正数补码：左移时，高位丢1，结果出错；右移时，最低位丢1，影响精度。
          2.   对于负数补码：左移时，高位丢0，结果出错；右移时，低位丢1，影响精度。
     2.   逻辑移位：逻辑的移位可以视为对无符号数的算术移位。均补0.
          1.   逻辑右移：高位补$0$，低位舍弃。
          2.   逻辑左移：低位补$0$，高位舍弃。
     3.   循环移位：将移出的一位放到另一端的端点，类似队列。适合将数据的低字节数据和高字节数据互换。带$CF$就是大循环，不带$CF$的就是小循环。不论带不带$CF$进行循环移位，最高位的值都必定与$CF$的值相等。
          1.   循环右移：将最低位的一位移出放到最高位，其余右移一位。
          2.   循环左移：将最高位的一位移出放到最低位，其余左移一位。
          3.   带$CF$位的循环左移：需要加上进位位数值的循环左移。
          4.   带$CF$位的循环右移：需要加上进位位数值的循环右移。
2.   加减运算：注意机器字长，若溢出则将溢出位丢弃。溢出判断见上面溢出标志位$OF$处。
     1.   补码的加减：手算时可以先转换成真值计算或判断溢出。$[A-B]_\text{补}=[A]_\text{补}+[-B]_\text{补}$（$\mod M$）
     2.   ※※符号扩展：**补码加减只要是不等长的都要先符号扩展**，特别是算偏移量的时候。
          +   补码整数的符号扩展：在原符号位和数值位中间添加符号位。
3.   乘法运算：**手算强烈建议转换成真值计算**！！！使用$Booth$算法实现。补码一位乘法中，最多需要$n$次移位，$n+1$次加法运算。
     1.   实现$N$位（不包括符号位）补码一位乘时，乘积为$2N+1$位
          + 补码一位乘法运算过程中一共向右移位$N$次，加上原先的$N$位，一共是$2N$位数值位，因乘积结果需加上符号位一位。
     2.   $Booth$算法的移位法则，其中$y_n$为$MQ$最低位，$y_{n+1}$为辅助位：
          1.   $y_n=0,y_{n+1}=0$：部分积右移一位
          2.   $y_n=0,y_{n+1}=1$：部分积加$[X_{\text{补}}]$，右移一位
          3.   $y_n=1,y_{n+1}=0$：部分积加$[-X_{\text{补}}]$，右移一位
          4.   $y_n=1,y_{n+1}=1$：部分积右移一位
     3.   补码一位乘法逻辑运算：
          1. 初始化，左边为部分积，即计算的部分结果，最开始为全$0$，右边为乘数，然后是一个辅助位，最后边全部为丢失位。
          2. 根据辅助位减$MQ$最低位的差值来判断加上什么，若是$1$则加上被乘数的补码，若是$0$则加与被乘数等长的全$0$，若是$-1$则加上被乘数的负数的补码。
          3. 算术右移部分积一位，正数高位补$0$，负数高位补$1$，丢失位多一位。
          4. 继续计算，直到乘数全部被移出。字长为$n+1$位则需要移位计算$n$次。丢失位前的就是全部部分积。
          5. 最后一次不需要移位，再加一次。
     4.   溢出判断
          1.   若$n$位乘$n$位，若用$2n$位保存最终乘积，则不会溢出。
          2.   若$n$位乘$n$位，若用$2n$位保存中间结果，最后截取末尾位作为最终的乘积，则可能会溢出：
               1.   手算判溢出：带入十进制计算结果，判断该结果是否超出了当前类型所能表示的范围，若超出，则溢出。
               2.   $n$位乘$n$位无符号数乘法：用$2n$位保存中间结果，当且仅当 前$n$位 全$0$时才不溢出。
               3.   $n$位乘$n$位有符号补码乘法：用$2n$位保存中间结果。当且仅当 前$n+1$位 全$1$或全$0$时不溢出
4.   除法运算：**手算强烈建议转换成真值计算**！！！可以忽略小数点。机器字长为$n$位，则得到$n-1$位余数，在余数末尾补$0$。补码除法使用补码加减交替法：符号位参与运算，被除数、余数和除数采用双符号位，商采用单符号位。不会溢出：$408$大纲不会考定点小数和浮点数的乘除运算。
     1.   被除数和除数同号，则被除数减去除数，若异号则被除数加上除数。
     2.   余数和除数异号，商$0$，余数左移一位加上除数。
     3.   余数和除数同号，商$1$，余数左移一位减去除数;
     4.   重复$n$次，末位商恒置为$1$。处理简单，而且精度误差也不会超过$2^{-n}$。
5.   ※※定点数的强制类型转换
     1.   ※※无符号数与有符号数：不改变数据内容，只改变解释方式。**若转换前最高位为0，则转换前后相等**；若最高位为`1`，则转换前后会出现一个正数和一个负数，此时**正负数的绝对值相加等于当前类型的占用位数的理论最大值**
          + `unsigned short`类型占用`2B=16bit`，$2^{16}=65536$。
          + `unsigned int`类型占用`4B=32bit`，$2^{32}=4,294,967,296$。
     2.   长整数转短整数：高位截断，保留低位。
     3.   短整数转长整数：符号扩展。
6.   定点数数据存储与排列：数据最左边的高位就是最高有效字节$MSB$。数据最右边的低位就是最低有效字节$LSB$。
     1.   大端模式：将$MSB$存到最低地址，$LSB$存在最高地址。便于人类阅读。
     2.   小端模式：将$MSB$存到最高地址，$LSB$存在最低地址。便于机器读取。就是每个字节反过来，字节内不要反。
     3.   ※边界对齐：现代计算机通常是按字节编址即每个字节对应一个地址，也支持按字、按半字、按字节寻址。存储数据数据不满足对应计算机的编址单位时，会照样存储到一个编址单位，多余的空间用$0$填充。

### 浮点数

#### 浮点数表示

1.   浮点数分为两个部分，阶码（记为$E$）和尾数（记为$M$）。

     1.   阶码$E$反映浮点数的**表示范围**及小数点的实际位置。
     2.   尾数$M$反映浮点数的**精度**。

2.   尾数规格化：规定尾数必须是一个有效值。规格化使用的移位运算是算术移位。规格化浮点数的特点：

     1.   用原码表示的尾数进行规格化，**最高数值位**一定为$1$：**原码正数$01$，原码负数$11$**。
     2.   用**补码**表示的尾数进行规格化，符号位与最高数值位一定相反：补码正数$01$，补码负数$10$。

3.    $IEEE 754$标准：在$IEEE\;754$标准中，规定移码的偏置值不再是$128(2^n)$而是$127$，即$2^{n-1}-1$。所以这个标准下的移码与一般的移码不同。

4.   $IEEE 754$定义：分为数符（表示数值正负号）、阶码（用**上述移码**表示）、尾数（用**原码**表示，且默认最高位为$1$不进行存储，实际尾数都要在之前加$1$即实际尾数为$1.M$）。

5.   IEEE 754特殊用途浮点数：全$0$的$-127$（非规格化数）和全$1$的$-128$（无穷大）做特殊的用途，所以短浮点数的真值正常范围是$-126$到$127$。

     1.   $+\infty,-\infty$：阶码全为$1$，尾数全为$0$，正负由符号位决定。
     2.   $+0,-0$：阶码全为0，尾数全为$0$，正负由符号位决定。
     3.   非规格化数：阶码全为0，尾数非0。
     4.   非法操作/非数值$NaN$（$Not\;a\;Number$）：阶码全为$1$，尾数非$0$。

6.   IEEE 754浮点数表示范围：

     1.   规格化的短浮点数$Float$的真值为$(-1)^S\times 1.M\times2^{E-127}$，共$1+8+23=32$位。
     2.   规格化的长浮点数$Double$的真值为$(-1)^S\times 1.M\times2^{E-1023}$，共$1+11+52=64$位。

7.    单精度浮点数与真值之间的转换

![image-20231028164400629](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202310281644098.png)

#### 浮点数计算

1.   浮点数的加减运算：可能存在进制混用的情况，注意标记。
     1.   转换格式化为浮点数：**阶码尾数均用补码表示**
     2.   对阶：阶数小的向阶数更大的对齐。使用算术移位运算。
     3.   尾数加减：阶数不变，对尾数进行相加减。
     4.   规格化，将数据变为整数部分为$0$到$9$的数据
     5.   舍入：计算机中由于尾数的比特位有限，所以需要舍弃尾数的低位。只有浮点数才会舍入，定点数则没有这个概念。**对阶**和**右规格化**都会引起舍入。舍入方法有：直接去除、非$0$进$1$、四舍五入。
     6.   判溢出：若运算后阶码超过规定范围则溢出。尾数的溢出未必会导致整体溢出，可以通过第三四步来修补，但是阶码溢出一定会整体溢出。
2.   浮点数强制类型转换：`int`类型占用`4B=32bit`，`short`类型占用`2B=16bit`，`float`类型占用`4B=32bit`，`double`类型占用`8B=64bit`，`char`类型占用`1B=8bit`
     1.   无损转换：$char$→$int$→$long$→$double$。$float$→$double$。
     2.   有损转换：具体情况具体分析。
          1.   $float\to int$：可能会溢出（浮点数表示范围更大）及损失精度，$float$的小数部分会丢失，但是$float$是整数就是无损转换。
          2.   $int\to double$：可能会损失精度，产生的尾数若多于$23$位，多余的部分会丢失，但是不多于$23$位就是无损转换。