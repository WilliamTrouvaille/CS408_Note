# EX-第五章 树与二叉树考点总结

## 导读

### 【考纲内容】

1. 树的基本概念
2. 二叉树
    + 二叉树的定义及其主要特征
    + 二叉树的顺序存储结构和链式存储结构
    + 二叉树的遍历
    + 线索二叉树的基本概念和构造
3. 树、森林
    + 树的存储结构
    + 森林与二叉树的转换
    + 树和森林的遍历
4. 树与二叉树的应用
    + 哈夫曼$Huffman$树和哈夫曼编码
    + 并查集及其应用

### 【复习提示】

选择题：树和二叉树的性质、遍历操作、转换、存储结构和操作特性等，满二叉树、完全二叉树、线索二叉树、哈夫曼树的定义和性质

算法题：树遍历相关

## 选择题考点总结

### 树概述

1.   树：$n$​个结点的有限集（树是一种递归的数据结构，适合于表示具有层次的数据结构）。树作为一种逻辑结构，同时也是一种分层结构，具有以下两个特点
     1.   树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱。
     2.   树中所有结点都可以有零个或多个后继。 
2.   根结点：只有子结点没有父结点的结点。除了根结点外，树任何结点都有且仅有一个前驱。
3.   分支结点：有子结点也有父结点的结点。
4.   叶子结点：没有子结点只有父结点的结点。叶子结点度为$0$，常记为$n_0$。
5.   祖先：根结点到结点的路径上的任意结点都是该结点的祖先。
6.   子孙：子树上的所有结点。
7.   双亲：靠近根结点且最靠近该结点的结点。
8.   兄弟：有共同双亲结点的结点。
9.   堂兄弟：双亲结点在同一层的结点。
10.   空树：结点数$n=0$的数。
11.   子树：当$n>1$时，其余结点可分为$m$个互不相交的有限集合，每个集合本身又是一棵树，其就是根结点的子树。
12.   **结点的度**：一个结点的孩子（分支）个数。
13.   **树的度**：树中结点的最大度数。
14.   结点的层次（深度）：从上往下数，默认从$1$开始。根结点为第$1$层，它的子结点为第$2$层，以此类推。
15.   结点的高度：从下往上数。
16.   树的高度（深度）：树的高度（或深度）是树中结点的最大层数。
      + 结点的深度是从根结点开始**自顶向下**逐层累加的
      + 结点的高度是从叶结点开始**自底向上**逐层累加的
17.   两结点之间的路径：由两个结点之间所经过的结点序列构成。
18.   ※两结点之间的路径长度：路径上所经过的**边**的个数。
19.   树的路径长度：指树根到每个结点的路径长的总和，根到每个结点的路径长度的最大值是树的高。
20.   有序树：树各结点的子树从左至右有次序，不能互换。
21.   无序树：树各结点的子树从左至右无次序，可以互换。
22.   森林：$m(m\ge 0)$棵互不相交的树的集合。森林的概念与树的概念十分相近，因为只要把树的根结点删去就成了森林。反之，只要给m棵独立的树加上一个结点，并把这$m$棵树作为该结点的子树，则森林就变成了树。
23.   路径和路径长度：从树中的一个结点到另一个结点之间的分支构成这两个结点之间的路径，路径上的分支数目称作路径长度。
24.   结点的权$W$（$Weight$）：有某种现实含义的数值。

25.   结点的带权路径长度$L$（$Length$）：从根到该结点的路径长度（经过**边数**）与该结点权的乘积称为结点的带权路径长度。

26.   树的带权路径长度$WPL$：树中所有**叶子**的带权路径长度之和称为树的带权路径长度。
      1.   **等于树中所有非叶节点的权值之和**；
      2.   等于树中全部叶节点的带权路劲长度之和。


### 二叉树概述

1.   二叉树是$n$个结点构成**每个结点至多只有两棵子树**的有限集合。
     1.   即二叉树中不存在度大于$2$的结点。
     2.   二叉树与度为$2$的有序树的区别
          1.   度为$2$的树至少有$3$个结点，而二叉树可以为空。
          2.   度为$2$的有序树的孩子的左右次序是相对于另一孩子而言的，若某个结点只有一个孩子，则这个孩子就无须区分其左右次序，而二叉树无论其孩子数是否为$2$，均需确定其左右次序，即二叉树的结点次序不是相对于另一结点而言的，而是确定的。
2.   满二叉树：一棵高度为$h$，含有$2^h-1$个结点的二叉树。即树中的每层都含有最多的结点。
3.   二叉排序树：左子树上所有结点的关键字均小于根结点的关键字，右子树上所有结点的关键字均大于根结点的关键字，左右子树又各是一棵二叉排序树。
     +   **没有键值相等的节点**。
4.   平衡二叉树：树上任一结点的左子树和右子树的深度之差不超过$1$。平衡二叉树能有更高的搜索效率。

### 树的性质

#### 一般树性质

1.   ※※结点数$=$总度数$+1$。

     + 每个节点都会为树的总度数贡献一个度数，并且根节点没有父节点，所以需要额外加$ 1$

2.   度为$m$的树至少有$h+m-1$个结点。

3.   度为$m$的树以及$m$叉树的第$i(i\ge 1)$层至多有$m^{i-1}$个结点，例如完全二叉树。

4.   树的度为$m$代表至少一个结点度是为$m$，且一定是非空树，至少有$m+1$个结点。注意与$5.$区分。

5.   $m$叉树指所有结点的度都小于等于$m$，**可以是空树**。

6.   高度为$h$的$m$叉树至少有$h$个结点，此时为单支树。

7.   高度为$h$的$m$叉树至多有$\dfrac{m^h-1}{m-1}$​个结点。
     $$
     a+a \mathrm{q}+a q^{2}+\cdots+a q^{n-1}=\frac{a(1-q n)}{1-q}
     $$

8.   具有$n$个结点的$m$​叉树最小高度为
     $$
     \lceil\log_m(n(m-1)+1)\rceil
     $$

     + 若使高度最小应使**所有结点都有$m$个孩子**，所以$\dfrac{m^{h-1}-1}{m-1}<n\leqslant\dfrac{m^h-1}{m-1}$
         + $\dfrac{m^{h-1}-1}{m-1}$表示前$h-1$层最多有几个结点。
         + $\dfrac{m^h-1}{m-1}$表示前$h$层最多有几个结点。
     + 从而得到$h-1<\log_m(n(m-1)+1)\leqslant h$，即高度最小取值$h_{min}=\lceil\log_m(n(m-1)+1)\rceil$。

#### 一般二叉树性质

1.   设非空二叉树中度为$0$、$1$和$2$的结点个数分别为$n_0$，$n_1$、$n_2$，则$n_0=n_2+1$

     + 即叶子结点比二分结点（度为$2$的结点）多一个
     + 假设树中结点的总数为$n$，则$n=n_0+n_1+n_2$
     + 又根据树的结点$=$总度数$+1$得到$n=n_1+2n_2+0n_0+1$，联立得到结论
     + 拓展到任意一棵树，若结点数量为$n$，则边的数量为$n-1$
2.   二叉树的第$i$层至多有$2^{i-1}$个结点。
     + $m$叉树的第$i$层至多有$m^{i-1}$个结点。
3.   高度为$h(h\ge 1)$的二叉树至多有$2^h-1$个结点。

     + 高度为$h$的$m$叉树至多有$\dfrac{m^h-1}{m-1}$个结点。

#### 完全二叉树性质

1.   **完全二叉树的叶节点**可能在第$h$层和第$h-1$层。
2.   完全二叉树最多只有一个度为$1$的结点，且该结点只有左孩子而无右孩子。
3.   **度为$0$度为$2$的结点的个数和一定为奇数**。
4.   若完全二叉树有$2k$个结点，则必然$n_1=1$，$n_0=k$，$n_2=k-1$。
     + 即结点个数为$2k$的完全二叉树只有一个度为$1$的结点，叶子结点个数为$k$，二分结点个数为$k-1$。

5.   若完全二叉树有$2k-1$个结点，则必然$n_1=0$，$n_0=k$，$n_2=k-1$。
     + 即结点个数为$2k-1$的完全二叉树没有度为$1$的结点，叶子结点个数为$k$，二分结点个数为$k-1$。
6.   具有$n$个结点的完全二叉树的高度$h=\lceil\log_2(n+1)\rceil$或$h=\lfloor\log_2n\rfloor+1$

     1.   高为$h$的满二叉树共有$2^h一1$个结点，高为$h-1$的满二叉树共有$2^{h-1}-1$个结点
          + $2^{h-1}-1<n\leqslant2^h-1$

          + $h-1<\log_{2}{(n+1)}\le h$

          + $h=\lceil\log_{2}(n+1)\rceil$

     2.   高为$h-1$的满二叉树共有$2^{h-1}-1$个结点，高为$h$的完全二叉树至少$2^{h-1}$个结点至多$2^{h-1}$个结点
          +   $2^{h-1}< n\le2^h$
          +   $h-1<\log_{2}{n}\le h$
          +   $h=\lfloor\log_2n\rfloor+1$
7.   最多只有一个度为$1$的结点，即$n_1=0/1$，且该结点只有左孩子而无右孩子
8.   数组编号从下标$1$开始存储，（若从$0$开始则不满足），$i\leqslant\lfloor\dfrac{n}{2}\rfloor$为分支结点，$i>\lfloor\dfrac{n}{2}\rfloor$为叶子结点。
     + 按层序编号后，一旦出现某结点（编号为$i$）为叶结点或只有左孩子，则编号大于$i$的结点均为叶结点
9.   按层序从$1$开始编号，结点$i$的左孩子为$2i$，右孩子为$2i+1$，父结点如果有为$\lfloor\dfrac{i}{2}\rfloor$。
10.   若$n$为奇数，则每个分支结点都有左孩子和右孩子；若$n$为偶数，则编号最大的分支结点（编号为$\dfrac{n}{2}$）只有左孩子，没有右孩子，其余分支结点左、右孩子都有。

#### 二叉平衡树性质

$h$为平衡二叉树高度，$n_h$为构造此高度的平衡二叉树所需的最少结点数。

1.   平衡二叉树最多结点数$2^h-1$，即该二叉树为满二叉树。

2.   平衡二叉树最少结点数（所有非叶结点的平衡因子均为$1$的）的递推公式为
     $$
     n0=0,n1=1,n2=2,n_h=1+n_{h−1}+n_{h−2}
     $$
     此时所有非叶结点的平衡因子均为$1$。

     +   <span style="color:red">证明：</span>假设$T$为高度为$h$的平衡二叉树，其需要最少的结点数目为$F(h)$。
     +   又假设$TL$，$TR$为$T$的左右子树，因此$TL$，$TR$也为平衡二叉树。
     +   假设$FL$、$FR$为$TL$，$TR$的最少结点数，则$F(h)=FL+FR+1$。那么$FL$、$FR$到底等于多少呢？
     +   由于$TL$，$TR$与$T$一样是平衡二叉树，又由于我们知道$T$的最少结点数是$F(h)$，其中$h$为$T$的高度，因此如果我们知道$TL$，$TR$的高度就可以知道$FL$、$FR$的值了。
     +   由平衡二叉树的定义可以知道，$TL$和$TR$的高度要么相同，要么相差$1$，而当$TL$与$TR$高度相同（即都等于$h-1$）时，我们算出来的$F(h)$并不能保证最小，两边都是$h-1$明显比只有一边$h-2$的结点数更多。
     +   因此只有当$TL$与$TR$高度相差一，即一个高度为$h-1$，一个高度为$h-2$时，计算出来的$F(h)$才能最小。
     +   此时我们假设$TL$比$TR$高度要高$1$，即$TL$高度为$h-1$，$TR$高度为$h-2$，则有$F1=F(h-1)$，$F2=F(h-2)$。
     +   因此得到结论：$F(h)=F(h-1)+F(h-2)+1$。

#### 森林和一般树转换二叉树的对应关系

假设森林为$F$，树为$T$，转换而来的二叉树为$B$。其实$1.\&2.$都是一样的，都是非叶结点数加一。

1.   $T$有$n$个结点，叶子结点个数为$m$，则$B$中无右孩子的结点个数为$n-m+1$个。
     +   树转换为二叉树时，树的每个分支节结点的所有子结点的最右子结点无右孩子，根结点转换后也无右孩子。
     +   $n$个节点的树，有$n-1$个边。
     +   由于叶子节点个数为$x$，此树有$n-x$个非叶结点，每个非叶结点有且仅有一个长子，对应二叉树有$n-x$左向边。
     +   右向边$ = $总边数$ - $左向边$ = (n-1) - (n-x) = x-1$。
     +   总共有$n$个点，其中只有$x-1$个点有右孩子，剩下的$n-x+1$个点没有右孩子。
2.   $F$有$n$个非终端结点（**非叶结点**），则$B$中无右孩子的结点有$n+1$个。
     +   根据森林与二叉树转换规则“左孩子右兄弟”，$B$中右指针域为空代结点没有兄弟结点。
     +   森林中每棵树的根结点从第二个开始依次连接到前一棵树的根的右孩子，因此最后一棵树的根结点的右指针为空，这里有一个。
     +   另外，每个非终端结点即代表有孩子，其所有孩子结点不论有多少个兄弟，在转换之后，最后一个孩子的右指针一定为空，故树$B$中右指针域为空的结点有$n+1$个。
3.   $F$有$n$条边、$m$个结点，则$F$包含$T$的个数为$m-n$。
     +   若有$n$条边，则如果全部组成最小的树每个需要两个结点，总共需要$2n$个结点，组成$n$根树。
     +   假定$2n>m$，则还差$2n-m$个结点才能两两成树，所以少的这些结点不能单独成树，导致有$2n-m$个结点只能跟其他现成的树组成结点大于二的树。
     +   所以此时只能组成$n-(2n-m)=m-n$棵树。

#### 哈夫曼树的性质

1.   每个初始结点最终都会变成叶子结点，且权值越小到根结点的路径长度越长。
2.   哈夫曼树的结点总数为$2n-1$。
3.   构建哈夫曼树时，都是两个两个合在一起的，所以没有度为一的结点，即$n_1=0$。
4.   哈夫曼树不唯一，但是$WPL$必然最优。

#### 红黑树性质

0.   二叉排序树
     +   左子树结点值$\le$根结点值$\le$右子树结点值
     +   不存在两个结点具有相同的值
     +   红黑树是二叉排序树，不是平衡二叉树
     +   红黑树是自平衡排序树，不是平衡二叉树
1.   每个结点或是红色，或是黑色的。
2.   根结点是黑色的。
3.   叶结点都是黑色的，保证红黑树的内部结点左右孩子均非空。
     +   叶结点为$NULL$结点 
     +   和$n+1$个虚构的外部结点
4.   不存在两个相邻的红结点
     +   即红结点的父结点和孩子结点均是黑色的
     +   插入操作时一般只会破坏这个特性，只检查这个特性是否被破坏即可
5.   对每个结点，从该结点到任一叶结点的简单路径上，所含黑结点的数量相同。
     +   从某结点出发（不含该结点）到达任一空叶结点的路径上黑结点总数称为结点的黑高$bh$

---

1.   从根到叶结点的最长路径不大于最短路径的两倍。
     1.   由定义`5.`，当从根到任一叶结点的简单路径最短时，这条路径必然全由黑结点构成（即第二层的结点）。
     2.   由定义`4.`，当某条路径最长时，这条路径必然是由黑结点和红结点相间构成的，此时红结点和黑结点的数量相同（非第二层的其他所有结点）。

2.   有$n$个内部结点的红黑树的高度$h\leqslant2\log_2(n+1)$。
     + 若红黑树的总高度为$h$
     + 则根结点黑高$\geqslant\dfrac{h}{2}$，所以内部结点$n\geqslant2^{\frac{h}{2}-1}$（假设没有红结点）
     + 所以$h\leqslant2\log_2(n+1)$。

3.   红黑树查找、插入、删除的时间复杂度都是$O(\log_2n)$

     + 插入和删除
         + 由于红黑树的每次操作平均要旋转一次和变换颜色
         + 而普通二叉查找树如果平衡因子在指定范围内不会旋转
             + 如果要旋转则可能旋转多次
         + 所以红黑树比普通的二叉查找树效率要低一点，不过时间复杂度仍然是$O(\log_2n)$。
     + 普通查询
         + 没有使用到红黑树的性质，所以红黑树和二叉查找树的效率相同
         + 对于二叉平衡树而言，平衡树的效率更高。
     + 插入有序数据查询
         + 红黑树的查询效率就比二叉查找树要高了
         + 因为此时二叉查找树不是平衡树，它的时间复杂度$O(n)$。
             + 此时可能是单枝树

4.   根结点黑高为的红黑树，两部结点数（关键字）至少有$2^h-1$个

     +   内部结点数最少的情况为总共$h$层黑结点的满树形态

     +   若根结点黑高为$h$，内部结点数（关键字）最少有$2^h-1$个

     +   当根结点黑高为$h$时，只有在满树形态时红黑树树高才会是$h$,否则树高$H>h$

#### $B$树性质

1.   根结点的子树数$\in [2,m]$，关键字数$\in [1,m-1]$。

2. 其他结点的子树数$\in [\lceil\dfrac{m}{2}\rceil,m]$，关键字数$\in [\lceil\dfrac{m}{2}\rceil-1,m-1]$。

3. 任意结点的每棵子树都是绝对平衡的，即所有结点的平衡因子均等于$0$。

4. 每个结点中的关键字是有序的：子树$0<$关键字$1<$子树$1<$关键字$2<$子树$2<\cdots$

    + 非叶结点定义：$\{n,P_0,K_1,P_1,\cdots,K_n,P_n\}$。其中$K_i$为结点关键字，$K_1<K_2<\cdots<K_n$，$P_i$为指向子树根结点的指针。$P_{i-1}$所指子树所有结点的关键字均小于$K_i$，$P_i$所指子树的关键字均大于$K_i$。

5. 具有$n$个关键字的$m$阶$B$树，应有$n+1$个叶结点。

    + 叶结点即查询失败的结点，对于$n$个关键字查找则可能的失败范围有$n+1$种。

6. 有$n$个非叶结点的$m$阶$B$树中至少包含$(n-1)(\lceil\dfrac{m}{2}\rceil-1)+1$个关键字。

    + 除根结点外的$n-1$个$m$阶$B$树中的每个非叶结点最少有$\lceil\dfrac{m}{2}\rceil-1$。
    + 然后再加上根结点的一个，所以最少为$(n-1)(\lceil\dfrac{m}{2}\rceil-1)+1$个。

7.   有$n$个非叶结点的$m$阶$B$树中至少包含$(n-1)(\lceil\dfrac{m}{2}\rceil-1)+1$个关键字。

     +   除根结点外的$n-1$个$m$阶$B$树中的每个非叶结点最少有$\lceil\dfrac{m}{2}\rceil-1$，然后再加上根结点的一个，所以最少为$(n-1)(\lceil\dfrac{m}{2}\rceil-1)+1$个。

8.   最小高度：$h\geqslant\log_m(n+1)$

     + 让每个结点尽可能满
     + 有$m-1$个关键字，$m$个分叉
     + 则一共有$(m-1)(1+m+m^2+\cdots+m^{h-1})$个关键字
         + 其中由于每个结点都是满的，所以第一层有一个结点(根结点)，第二层有$m$个结点$,\cdots$
         + 即共有$(1+m+m^2+\cdots+m^{h-1})$个结点
         + 而$(m-1)$表示对于$m$阶$B$树每个结点至多包含$m-1$个关键字
     + 其中$n$小于等于这个值，从而求出$h\geqslant\log_m(n+1)$。

9.   最大高度：$h\leqslant\log_{\lceil\frac{m}{2}\rceil}\dfrac{n+1}{2}+1$

     1.   让各层分叉尽可能少，即根结点只有两个分叉，其他结点只有$\lceil\dfrac{m}{2}\rceil$个分叉

          所以第一层$1$个，第二层$2$个，第$h$层$2(\lceil\dfrac{m}{2}\rceil)^{h-2}$个结点，而$h+1$层的叶子结点有$2(\lceil\dfrac{m}{2}\rceil)^{h-1}$个，且$n$个关键字的$B$树必然有$n+1$个叶子结点

          从而$n+1\geqslant2(\lceil\dfrac{m}{2}\rceil)^{h-1}$，即$h\leqslant\log_{\lceil\frac{m}{2}\rceil}\dfrac{n+1}{2}+1$。

     2.   让各层关键字尽可能少，记$k=\lceil\dfrac{m}{2}\rceil$

          + 第一层最少结点数和最少关键字为$1$
          + 第二层最少结点数为$2$，最少关键字为$2(k-1)$
          + 第三层最少结点数为$2k$，最少关键字为$2k(k-1)$
          + 第$h$层最少结点数为$2k^{h-2}$，最少关键字为$2k^{h-2}(k-1)$

          从而$h$层的$m$阶$B$树至少包含关键字总数$1+2(k-1)(k^0+k^1+\cdots+k^{h-2})=1+2(k^{h-1}-1)$

          若关键字总数小于这个值，则高度一定小于$h$

          所以$n\geqslant 1+2(k^{h-1}-1)$，则$h\leqslant\log_{\lceil\frac{m}{2}\rceil}\dfrac{n+1}{2}+1$。

10.   对于高度为$h$的$m$阶$B$树最多有$$(m-1)(1+m+m^2+\cdots+m^{h-1})$$个结点。上面公式的逆运算。

11. 对于高度为$h$的$m$阶$B$树最少有$1+2(\lceil\dfrac{m}{2}\rceil^{h-1}-1)$个结点。上面公式的逆运算。

### 二叉树存储结构

1.   顺序存储：**完全二叉树**和**满二叉树**采用顺序存储比较合适，树中结点的序号可以唯一地反映结点之间的逻辑关系，这样既能最大可能地节省存储空间，又能利用数组元素的下标值确定结点在二叉树中的位置，以及结点之间的关系。****
     1.   ※**就算不是完全二叉树，也需要将包含节点的每一层都全部存储**。
          +   高度为$h$的二叉树需要$2^h-1$个存储单元。
          +   **所有**二叉树都需要$2^h-1$个存储单元。
     2.   会浪费较多内存，最坏情况下高度为$h$，且只有$h$个结点的单支树也需要$2^h-1$个存储单元。
2.   链式存储：顺序存储的空间利用率较低，**一般二叉树**通常都采用链式存储结构，用链表结点来存储一般二叉树中的每个结点。
     +   在含有$n$个结点的二叉链表中，含有$n+1$个空链域：含有$n$个结点的二叉链表中，链域一共有$2n$个（每个点有两个链域）。对于除了根结点以外的每个点都是有一个父亲结点，所以一共有$n-1$个指针指向某个结点，于是形成$n-1$个有内容的链域（减$1$即是根结点）所以一共有$2n-(n-1)=n+1$个链域没有指向任何东西。

### 二叉树遍历

1.   顺序遍历：若二叉树为空，则什么也不做。
     1.   先序遍历：**根**左右$NLR$。先序遍历第一个元素是根节点。
     2.   中序遍历：左**根**右$LNR$。中序遍历根节点左边元素是左分支，右边元素是右分支。
          +   **二叉搜索树中序遍历有序**。
     3.   后序遍历：左右**根**$LRN$。后序遍历最后一个元素是根节点。
2.   先序遍历和中序遍历的关系相当于以先序遍历为入栈队列，以中序遍历为出栈队列。同一先序遍历可能会有$\dfrac{1}{n + 1}C_{2n}^n$ 个（卡特兰数）合法的中序遍历。
3.   非递归方式
     1.   沿着根的左孩子结点依次入栈，直到左孩子为空。表示找到了最左边的可以输出的结点。
     2.   栈顶元素出栈并访问。
     3.   若栈顶元素的右孩子为空，则继续执行步骤二。
     4.   若栈顶元素的右孩子不为空，则对其右子树执行步骤一。
4.   层序遍历
     1.   初始化一个辅助队列。
     2.   根结点入队。
     3.   若队列非空，则队头结点出队，访问该结点，如果有并将其左右孩子入队。先左孩子后右孩子。
     4.   重复步骤三直至队列空。

### 线索二叉树

1.   线索二叉树：保存结点的前驱和后继，从而能减少重复遍历树。$n$个结点的二叉树，有$n+1$个空链域，可用来记录前驱、后继的信息。
     1.   指向前驱的就是**前驱**线索，由**左孩子**指针担当；指向**后继**的就是后继线索，由**右孩子**指针担当。
     2.   为了区分其左右孩子指针是指向什么，要在结点中新建两个$tag$位，如当$ltag=0$表示$lchild$指向的是左孩子结点，而为$1$表示其指向前驱。
2.   线索化构造：只需要在原来遍历算法的$$visit()$$函数中进行线索化即可。以中序线索二叉树的建立为例。
     1.   **先序线索二叉树不能查找前驱**，中序线索二叉树和后序线索二叉树可以查找前驱。
     2.   **后序线索二叉树不能查找后继**，中序线索二叉树和前序线索二叉树可以查找后继。
3.   中序线索二叉树的前驱后继
     1.   中序线索二叉树中找到结点$*P$的中序后继$next$：可以利用线索对二叉树实现非递归的中序遍历。

          + 若$p$右孩子指针指向后继：$p->rtag1$，则$next=p->rchild$。

          + 若$p$右孩子指针指向右子树根结点：$p->rtag0$，则后继$next=p$右子树中最左下结点。
     2.   中序线索二叉树中找到结点$*P$的中序前驱$pre$：可以利用线索对二叉树实现非递归的逆向中序遍历。

          + 若$p$左孩子指针指向前驱：$p->ltag1$，则$pre=p->lchild$。

          + 若$p$左孩子指针指向左子树根结点：$p->ltag0$，则前驱$pre=p$左子树中的最右下结点。

### 树与森林

1.   一般树的存储结构
     1.   双亲表示法：是一种顺序存储方式，一般采用一维数组，每个结点中保存指向双亲的伪指针。
          +   查找双亲方便，查找孩子不方便。适用于找双亲多，找孩子少的应用场景，例如并查集。
     2.   孩子表示法：是**顺序存储加链式存储**方法，顺序存储所有元素，添加一个$firstChild$域，指向第一个孩子结构体的指针。
          +   寻找孩子方便，寻找双亲不方便（需要遍历$n$个结点），适用于找孩子多，找双亲少的应用场景，例如服务流程树。
     3.   ※孩子兄弟表示法：是一种链式存储方式，定义了两个指针，分别指向第一个孩子与右兄弟，类似于二叉树，可以利用二叉树来实现对树的处理，也称为**二叉树表示法**。
          +   寻找孩子方便，寻找双亲不方便。
2.   森林与树的转换：树与森林的转换，树与二叉树的转换都可以使用孩子兄弟表示法来实现，左孩子右兄弟，如果是森林则认为其根结点为兄弟。

![image-20231108223317925](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202311082233068.png)

### 树的应用

1.   哈夫曼树：带权路径长度最短的二叉树，**不一定是完全二叉树**。**哈夫曼树不存在度为$1$的结点**。
     +   适合采用顺序结构：已知叶子结点数$n_0$，且$n_1=0$，则总结点数为$2n_2+1$（或$2n_0-1$），且哈夫曼树构造过程需要不停地修改指针，用链式存储的话很容易造成指针偏移。
2.   构造哈夫曼树：给定$n$个权值分别为$w_1, w_2\cdots w_n$的结点，则
     1.   将这$n$个结点分别作为$n$棵仅含一个结点的二叉树，构成森林$F$。
          +   这一步实际上就是把各个节点写在一堆。
     2.   构造一个新结点，从$F$中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和
          +   默认**树较深**的在右侧
     3.   从$F$中删除刚才选出的两棵树，同时将新得到的树加入$F$中。
     4.   重复步骤二和三，直至$F$中只剩下一棵树为止。
3.   哈夫曼编码：将编码使用次数作为权值构建哈夫曼树，然后根据左$0$右$1$的原则，按根到叶子结点的路径就变成了哈夫曼编码。哈夫曼编码是可变长度编码，即允许对不同字符用不等长的二进制表示，也是一个前缀编码，没有一个编码是另一个编码的前缀。
4.   并查集：将一个集合划分为互不相交的子集。
     1.   查找：查找两个元素是否属于同一个集合。需要通过向上递归的方式不断查找父结点直到找到根节点判断是否为同一个即可。
     2.   合并：只需将一个集合的根节点的父节点指向另一个集合的根节点即可。
     3.   路径压缩：在递归实现中，当递归地查找到根节点时，依次将路径上的每个节点的父节点更新为根节点。而在迭代实现中，通过循环迭代地查找根节点，并在查找过程中将路径上的每个节点的父节点直接指向根节点。通过路径压缩优化，**可以将查找操作的时间复杂度接近于常数级别**。
     4.   按秩合并：秩数组来记录每个根结点对应的树的深度（如果不是根结点，则秩数组中的元素大小表示的是以当前结点作为根结点的子树的深度）；一开始，把所有元素的秩值设为1，即自己就为一颗树，且深度为1；合并的时候，比较两个根结点，把秩值较小者合并到较大者中去。
          1.   根节点的存储方式采用了负数，并不是始终为$-1$。
          2.   根节点的绝对值表示这个集合的大小（包括根节点本身）。因此，当进行$Union$操作时，要考虑两个集合的大小，将节点数少的根节点合并到节点数多的根节点上，并更新节点数。