# 第二章 线性表

## 导读

### 【考纲内容】

1. 线性表的基本概念
2. 线性表的实现
    + 顺序存储
    + 链式存储
3. 线性表的应用

### 【知识导图】



### 【复习提示】

+ 线性表是算法题命题的重点。
+ 这类算法题实现起来比较容易且代码量较少，但是要求具有最优的性能（时间复杂度、空间复杂度），才能获得满分
+ 因此，应牢固掌握线性表的各种基本操作（基于两种存储结构），在平时的学习中多注重培养动手能力
+ 另外，需要提醒的是，算法最重要的是思想！考场上的时间紧迫，在试卷上不一定要求代码具有实际的可执行性，因此应尽力表达出算法的思想和步骤，而不必过于拘泥每个细节。注意算法题只能用`C++`语言实现。

## 基本概念

### 逻辑结构

是具有**相同**数据类型的$n$个数据元素的**有限序列**。$n$表示表长。

$L=(a_1,a_2,\cdots,a_i,\cdots,a_n)$，其中$i$表示元素在线性表中的位序，从一开始。

+ 存在唯一的第一个元素。
+ 存在唯一的最后一个元素。
+ 除第一个元素（表头元素）无直接前驱之外，每个元素均有且仅有一个直接前驱。
+ 除最后一个元素（表尾元素）无直接后继之外，每个元素均有且仅有一个直接后继。

> **注**
>
> “相同”表示每个数据元素所占空间一样大
>
> “有限序列”表示有次序

### 线性表的基本操作

+ `nitList(&L)`
    + 初始化表
    + 构造一个空的线性表`L`,分配内存空间。
+ `DestroyList(&L)`
    + 销毁操作
    + 销毁线性表，并释放线性表`L`所占用的内存空间。
+ `ListInsert(&L,i,e)`
    + 插入操作
    + 在表L中的第`i`个位置上插入指定元素`e`。
+ `ListDelete(&L,i,&e)`
    + 删除操作
    + 删除表`L`中第`i`个位置的元素，并用`e`返回删除元素的值
+ `LocateElem(L,e)`
    + 按值查找操作
    + 在表`L`中查找具有给定关键字值的元素。
+ `GetElem(L,i)`
    + 按位查我操作
    + 获取表`L`中第`i`个位置的元素的值。
+ `Length(L)`
    + 求表长
    + 返回线性表`L`的长度，即`L`中数据元素的个数。
+ `PrintList(L)`
    + 输出操作
    + 按前后顺序输出线性表`L`的所有元素值。
+ `Empty(L)`
    + 判空操作
    + 若`L`为空表，则返回`true`,否则返回`false`。



>+ 对数据的操作
>    + 创销、增删改查

### 物理结构

+ 顺序存储结构：顺序表。
+ 链式存储结构：链表。

## 顺序表

把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来实现。$i$是元素$a_i$在线性表中的位序。

### 顺序表特点

1. 随机访问，可以在$O(1)$时间内找到对应元素。
2. 存储密度高，只用存储数据。
3. 拓展容量不方便。
4. 插入删除操作不方便。
5. 表中元素的逻辑地址与物理地址顺序相同。

### 顺序表定义

使用$C$语言的结构体定义顺序表，使用`typedef`定义一个`ElemType`表示数据基本类型，并定义最大长度`MAXSIZE`：

```c
// 初始化最大长度
#define MAXSIZE 25
// 定义默认值
#define DEFAULTELEM 0
// 定义最大值
#define INFINITY 32767
// 定义默认数据类型
typedef char element_type;
```

可以使用**静态分配**空间：

![image-20230704224205453](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307042242503.png)

也可以使用动态分配空间，动态分配空间还是顺序的，只不过可以替换原来空间：

![image-20230704225442071](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307042254114.png)

其中长度是指有数据的长度，而最大容量是指已经分配给动态数组的长度，插入时要考虑这个长度，不能溢出。

>+  **malloc() 函数** 
>
>    1. 函数作用： `malloc()` 是C语言中的函数，用于在堆上分配指定大小的内存空间。它接收一个参数，表示所需内存的大小（以字节为单位），并返回指向该内存块的指针。
>
>
>    2. 函数实现： `malloc()` 函数的实现可以根据操作系统和编译器的不同而有所差异。通常情况下，它会在堆上查找足够大的连续内存块，然后将其分配给程序。如果找不到足够大的内存块，则返回一个空指针。
>
>
>    3. 函数使用方法：
>        - 首先，需要包含 `<stdlib.h>` 头文件，该头文件中包含了 `malloc()` 函数的声明。
>        - 使用 `malloc()` 函数时，需要指定所需内存的大小，并将返回的指针赋给一个指针变量。例如，可以使用以下语句分配一个大小为 `n` 字节的内存块：
>
>    ```c++
>    int* ptr = (int*)malloc(n);
>    ```
>    注意，在C++中使用 `malloc()` 时，**需要将返回的指针强制类型转换为适当的指针类型**。
>
>    + 在分配内存后，可以使用指针变量 `ptr` 来访问和操作所分配的内存块。例如，可以对分配的内存进行初始化、读取和写入操作。
>    + 最后，在不再需要分配的内存块时，应该使用 `free()` 函数释放内存，以避免内存泄漏。例如，可以使用以下语句释放之前分配的内存块：
>
>    ```c++
>    free(ptr);
>    ```
>    注意，与 `malloc()` 相对应，需要确保释放的是通过 `malloc()` 分配的内存块，否则可能会导致未定义的行为。
>    4. 返回值： `malloc()` 函数的返回值是一个指向分配内存块的指针。如果分配成功，则返回指向内存块的指针；如果分配失败（内存不足），则返回一个空指针（ `NULL` ）。
>
>
>    5. 注意事项：
>        - 使用 `malloc()` 分配的内存块不会自动初始化，所以在使用之前，需要手动进行初始化。
>        - 分配的内存块应该在使用完毕后及时释放，以免造成内存泄漏。
>        - 在C++中，更推荐使用 `new` 和 `delete` 运算符来动态分配和释放内存，因为它们提供了更好的类型安全性和异常处理机制。
>
>
>+  **new 和 malloc 的区别** 
>
>    1. 语法：
>        -  `malloc()` 是一个C语言函数，在C++中也可以使用，需要包含 `<cstdlib>` 头文件，并使用类型转换将返回的指针转换为适当的类型。
>        -  `new` 是一个C++运算符，不需要包含特定的头文件，并且返回的指针类型是自动推断的。
>
>    2. 内存分配和初始化：
>        -  `malloc()` 只负责分配指定大小的内存块，不会对分配的内存进行初始化，即内存的内容是未定义的。
>        -  `new` 在分配内存的同时，会调用构造函数对内存进行初始化。这对于对象的构造是非常重要的，确保对象的成员变量处于有效状态。
>
>    3. 内存大小：
>        -  `malloc()` 接收以字节为单位的内存大小作为参数。
>        -  `new` 接收对象类型作为参数，并根据类型自动计算所需的内存大小。
>
>    4. 错误处理：
>        -  `malloc()` 在内存不足时返回一个空指针（ `NULL` ），需要手动检查返回值来判断内存分配是否成功。
>        -  `new` 在内存不足时抛出 `std::bad_alloc` 异常，可以使用异常处理机制来捕获和处理异常。
>
>    5. 内存释放：
>        -  `malloc()` 分配的内存块需要使用 `free()` 函数手动释放。
>        -  `new` 分配的内存可以使用 `delete` 运算符来释放，对于数组形式的分配，使用 `delete[]` 。
>
>    6. 类型安全：
>        -  `malloc()` 返回的是 `void*` 类型的指针，需要手动转换为实际的指针类型，可能存在类型错误的风险。
>        -  `new` 返回的指针类型是自动推断的，不需要手动转换，并且在编译时进行类型检查，提供了更好的类型安全性。
>
>    总的来说， `malloc()` 是C语言提供的函数，适用于C++，但不支持类对象的构造和析构，而且需要手动管理内存的分配和释放。而 `new` 是C++提供的运算符，支持类对象的构造和析构，可以自动管理内存的分配和释放，并提供更好的类型安全性和异常处理机制。
>

### 顺序表操作

#### 顺序表初始化

+ 静态顺序表因为数组部分在创建时就已经设置好了，所以初始化就直接设置数据长度就可以了。
    + ![image-20230704224205453](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307042242503.png)
    + ![image-20230704224301457](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307042243497.png)
    + 顺序表的表长刚开始确定后就**无法更改**（存储空间是静态的）

+ 动态顺序表不仅需要设置数据长度与最大 长度，还得分配数组初始空间。
    + ![image-20230704225442071](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307042254114.png)
    + ![image-20230704231125072](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307042311115.png)

#### 顺序表增长数据空间长度

只有**动态顺序表**才能增加。

![image-20230704231140027](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307042311067.png)

#### 顺序表插入

使用静态定义

![image-20230704231922311](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307042319351.png)

倒序移动元素，最后将数据插入对应索引并长度加一。（这是一个较好的方式，因为如果插入的话其他元素会被挤住，倒序移动元素可以正好空出位置）

![image-20230704231956301](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307042319344.png)



+ 空间复杂度为$S(n)=O(1)$。

+ 时间复杂度

    + 最好时间复杂度O(1)$

        + 新元素插入到表尾，不需要移动元素
        + `i=n+1`,循环$0$次

    + 最坏时间复杂度$O(n)$

        + 新元素插入到表头，需要将原有的个元素全都向后移动
        + `i=1`,循环$n$次：

    + 平均时间复杂度$O(n)$

        + 假设$p_i$（$n_i=\dfrac{1}{n+1}$）是$i$位置上插入一个结点的概率，则在长度为$n$的线性表中插入一个结点时所需要移动结点的平均次数为

        + $\sum\limits_{i=1}^{n+1}p_i(n-i+1)=\sum\limits_{i=1}^{n+1}\dfrac{1}{n+1}(n-i+1)$

            $=\dfrac{1}{n+1}\sum\limits_{i=1}^{n+1}(n-i+1)=\dfrac{1}{n+1}\times\dfrac{n(n+1)}{2}=\dfrac{n}{2}$

        

#### 顺序表删除

使用静态定义

![image-20230704231922311](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307042319351.png)

正序移动元素并长度减一。

![image-20230704232414045](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307042324090.png)

+ 空间复杂度为$S(n)=O(1)$

+ 时间复杂度

    + 最好时间复杂度$O(1)$

        + 删除表尾元素，不需要移动其他元素
        + `i=n`,循环$0$次；

    + 最坏时间复杂度$O(n)$

        + 删除表头元素，需要将后续的$n-1$个元素全都向前移动
        + `i=1`,循环$n-1$次：

    + 平均时间复杂度$O(n)$

        + 假设$p_i$（$n_i=\dfrac{1}{n+1}$）是$i$位置上删除一个结点的概率，则在长度为$n$的线性表中插入一个结点时所需要移动结点的平均次数为

        + $\sum\limits_{i=1}^{n+1}p_i(n-i+1)=\sum\limits_{i=1}^{n+1}\dfrac{1}{n+1}(n-i+1)$

            $=\dfrac{1}{n+1}\sum\limits_{i=1}^{n+1}(n-i+1)=\dfrac{1}{n+1}\times\dfrac{n(n+1)}{2}=\dfrac{n}{2}$

#### 顺序表查找

使用动态定义

![image-20230704232842554](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307042328601.png)



+ 按位查找时间复杂度为$T(n)=O(1)$。
    + ![image-20230704232910427](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307042329466.png)
    + “随机存取”特性
        + 由于顺序表的各个数据元素在内存中连续存放，因此可以根据起始地址和数据元素大小立即找到第$i$个元素
+ 按值查找时间复杂度为$T(n)=O(n)$
    + ![image-20230704233030094](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202307042330135.png)
    + 一般都是找到第一个元素等于指定值的元素，返回其位序，如果没有找到就返回$-1$
    + 最好时间复杂度$O(1)$
        + 目标元素在表头,循环$1$次
    + 最坏时间复杂度$O(n)$
        + 目标元素在表尾,循环$n$次：
    + 平均时间复杂度$O(n)$
        + 假设目标元素出现在任何一个位置的概率相同，都是1
            目标元素在第1位，循环1次；在第2位，循环2次；：在第n位，循环n次

> 《数据结构》考研初试中，手写代码可以直接用$==$，无论$ElemType$是基本数据类型还是
> 结构类型