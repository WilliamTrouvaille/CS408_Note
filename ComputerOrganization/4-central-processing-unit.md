# 第五章 中央处理器$(CPU)$

## 导读

### 【考纲内容】

1. **CPU 的功能和基本结构**                                                       
2. **指令执行过程**
3. **数据通路的功能和基本结构**
4. **控制器的功能和工作原理**
5. **异常和中断机制**
    +   异常和中断的基本概念
    +   异常和中断的分类
    +   异常和中断的检测与响应
    
6. **指令流水线异常**
    + 指令流水线的基本概念
    + 指令流水线的基本实现
    + 结构冒险、数据冒险和控制冒险的处理
    + 超标量和动态流水线的基本概念

7. **多处理器基本概念**
    + $SISD$、$SIMD$、$MIMD$、向量处理器的基本概念
    + 硬件多线程的基本概念
    + 多核$(multi-core)$处理器的基本概念
    + 共享内存多处理器 $SMP$的基本概念

### 【知识导图】

![img](http://res.ptpress.cn/36AC35AB87F046638825B525E7461D78.png)

![img](http://res.ptpress.cn/AE377BFDA3CC41C58E31B10C083A6ACF.png)

![img](http://res.ptpress.cn/0ECBAB73C5B0462282B64370F38841D7.png)

![img](http://res.ptpress.cn/31B7D7A28541465F8ED83ED0BFD6D922.png)

![img](http://res.ptpress.cn/D27FEA23ED4E4E349133D0D1136B1B49.png)

![img](http://res.ptpress.cn/E7F58AB909C74113B87FDA486B3FE01D.png)

![img](http://res.ptpress.cn/B1E5799F550A46C7B10A6A8888E5FF31.png)

![image-20230603095230601](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603095230601.png)

![img](http://res.ptpress.cn/23C5A832CE9D497797DAE3E3A5EEAC23.png)

![img](http://res.ptpress.cn/27C7442F819549B5BE55A3427B590CAC.png)

![img](http://res.ptpress.cn/CC9FD1FC8E21462AB2DA312E22E7C149.png)

![img](http://res.ptpress.cn/DABCD40FB97049B9A69A3A3E2989570C.png)

![img](http://res.ptpress.cn/A49C1C1C425142009CE514B3DBD18DD9.png)

![img](http://res.ptpress.cn/897A9D9405864D7280040DECC2523212.png)

![img](http://res.ptpress.cn/F3D19288780642AF985FE0D671613D4A.png)

![img](http://res.ptpress.cn/B2FBB242C124458D87EA49977291E49D.png)

![img](http://res.ptpress.cn/967CF1FA3A71418482699C75341D3EDD.png)

![image-20230603095542154](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603095542154.png)



![img](http://res.ptpress.cn/292CC4CB6D0649C4998F669D2AAB1654.png)

### 【复习提示】

中央处理器是计算机的中心，也是本书的难点。其中，==数据通路的分析，指令执行阶段的节拍与控制信号的安排、流水线技术与性能分析易出综合题==。而关于==各种寄存器的特点、指令执行的各种周期与特点、控制器的相关概念、流水线的相关概念也极易出选择题==。

在学习本章时，请读者思考以下问题：

1) 指令和数据均存放在内存中，计算机如何从时间和空间上区分它们是指令还是数据?

2) 什么是指令周期、机器周期和时钟周期? 它们之间有何关系?

3) 什么是微指令? 它和第 4 章谈到的指令有什么关系?

4) 什么是指令流水线? 指令流水线相对于传统体系结构的优势是什么?

## $CPU$基本概念

![image-20230908204426892](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309082044118.png)

### CPU功能

#### CPU总功能

中央处理器$CPU$由**运算器**和**控制器**组成

+   其中控制器的功能是负责协调并控制计算机各部件执行程序的指令序列，包括==取指令、分析指令和执行指令==
+   ==运算器的功能是对数据进行加工==

![23SeptembeR_08-211809-1694179089-5b7df1d4-1baa-46bf-bdc9-ea7675f1458c](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309082118123.png)

CPU的具体功能包括：

1. 指令控制。
    + 完成取指令、分析指令和执行指令的操作，即程序的顺序控制。
2. 操作控制。
    + 一条指令的功能往往是由若干操作信号的组合来实现的
    + $CPU$管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作。
3. 时间控制。
    + 对各种操作加以时间上的控制。
    + 时间控制要为每条指令按时间顺序提供应有的控制信号。
4. 数据加工。
    + 对数据进行算术和逻辑运算。
5. 中断处理。
    + 对计算机运行过程中出现的异常情况和特殊请求进行处理。

#### 运算器结构和功能

![image-20230603112327224](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603112327224.png)

运算器接收从控制器送来的命令并执行相应的动作，对数据进行加工和处理。

运算器是计算机对数据进行加工处理的中心，它主要由算术逻辑单元$ALU$、暂存寄存器、累加寄存器$ACC$、 通用寄存器组、程序状态字寄存器$PSW$、移位器、计数器$CT$等组成

+   算术逻辑单元$ALU$。主要功能是进行算术/逻辑运算。
+   暂存寄存器$R$。==用于暂存从主存读来的数据，该数据不能存放在通用寄存器中==，否则会破坏其原有内容。
    +   ==暂存寄存器对应用程序员是透明的==。
    +   若两个操作数分别来自主存和$R_0$，最后结果存回$R_0$，那么从主存中取来的操作数直接放入暂存器，就不会破坏运算前$R_0$的内容。
+   累加寄存器$ACC$。它是一个通用寄存器，用于暂时存放$ALU$运算的结果信息，运算的结果信息，用于实现加法运算。
+   通用寄存器组$X$。如$AX、BX、CX、DX、SP$等，用于存放操作数（包括源操作数、目的操作数及中间结果）和各种地址信息等。
    +   $SP$是堆栈指针，用于指示栈顶的地址。
    +   ==内容可由程序员指定==
+   程序状态字寄存器$PSW$。保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息,
    +   如溢出标志（OF）、符号标志（SF）、零标志（ZF）、进位标志（CF）等。
    +   $PSW$中的这些位参与并决定微操作的形成。
    +   ==内容可由程序员指定==
+   移位器。对操作数或运算结果进行移位运算。
+   计数器$CT$。控制乘除运算的操作步数。
+   内部总线：
    + 专用数据通路方式：
        + 根据指令执行过程中的数据和地址的流动方向安排多条连接线路。
        + 寄存器有多少位就有多少根线连着$ALU$，寄存器将操作数的所有位并行的传输到$ALU$中
        + 如果直接用导线连接，相当于多个寄存器同时并且一直向$ALU$传输数据，解决方法：
            1. 使用多路选择器$MUX$根据控制信号选择一路输出解决方法。
            2. 使用三态门可以控制每一路是否输出，$1$允许，$0$不允许。
        + 性能较高，基本不存在数据冲突现象，但结构复杂，硬件量大，不易实现。
    + $CPU$内部单总线方式：
        + 将所有寄存器的输入端和输出端都连接到一条公共的通路上。
        + 结构简单，容易实现，但数据传输存在较多冲突的现象，性能较低。
        + 为了解决冲突用暂存寄存器解决。

>   标志位复习：
>
>   +   零标志位$ZF$（$Zero\;Flag$）
>
>       +   $ZF=1$表示结果为$0$。
>       +   ==无论是有符号数还是无符号数，$ZF$都有意义。==
>       +   通过加法电路和最后的取反操作实现。
>
>   +   溢出标志位$OF$（$Overflow\;Flag$）
>
>       +   $OF=1$表示溢出。
>       +   ==对于无符号整数运算，$OF$没有意义。==
>
>   +   符号标志位$SF$（$Symbol\;Flag$）
>
>       +   $SF=1$表示结果为负值。
>
>       + 当产生溢出时，符号标志位置出错。
>           $$
>           SF=F_{i=max}
>           $$
>
>           +   $F_{i=max}$即为运算结果的最高位
>
>       + ==对于无符号整数运算，$SF$没有意义==。
>
>   +   进/借位标志位$CF$（$Carry\;Flag$）
>
>       +   $CF=1$表示无符号数加法溢出/减法借位。
>           $$
>           CF=C_{out}\oplus Sub
>           $$
>
>           +   $Sub$即为加减法控制信号，加法0减法1
>           +   $C_{out}$即为最高位产生的进位
>
>       + ==对于有符号数的整数运算，$CF$没有意义。==

#### 控制器结构和功能

控制器的基本功能是执行指令，每条指令的执行一组微操作实现的。 

$PC$(取指令)$\to$$IR$(分析指令)$\to$$CU$(执行指令)

![image-20230603112149297](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603112149297.png)

控制器有硬布线控制器和微程序控制器两种类型

控制器由程序计数器$PC$、指令寄存器$IR$、指令译码器、存储器地址寄存器$MAR$、 存储器数据寄存器$MDR$、时序系统和微操作信号发生器等组成。

+   程序计数器$PC(Program\;Counter)$。用于==指出欲执行指令在主存中的存放地址==。$CPU$根据$PC$的内容去主存中取指令。
    +   因程序中指令（通常）是顺序执行的，所以==$PC$有自增功能==。
        +   执行转移指令时，
        +   需要判别转移是否成功，若成功则$PC$修改为转移指令的目标地址，否则下一条指令的地址仍然为PC自增后的地址
    +   ==内容可由程序员指定==
    +   ==$PC$的位数取决于存储器的容量/字数==
        +   程序计数器的内容为指令在主存中的地址，所以程序计数器的位数与存储器地址的位数相等，而存储器地址取决于存储器的容量
        +   $2^n=$主存空间$\div$字长
+   指令寄存器$IR(Instruction\;Register)$。用于保存当前正在执行的那条指令。
    +   指令寄存器$IR$中存放当前执行的指令，不需要用户的任何干预，==所以对用户是透明的==
    +   ==$IR$的位数取决于机器字长==
        +   指令寄存器中保存当前正在执行的指令，所以其位数取决于指令字长。
+   指令译码器$ID(Instruction\;Decoder)$。==仅对**操作码**字段进行译码==，向控制器提供特定的操作信号。
+   存储器地址寄存器$MAR$。用于存放要访问的主存单元的地址。
    +   $PC$与$MAR$的位数一样
+   存储器数据寄存器$MDR$。用于存放向主存写入的信息或从主存读出的信息。
+   时序系统$TG(Timing\;Generator)$。用于产生各种时序信号，它们都由统一时钟$CLOCK$分频得到。
+   微操作信号发生器。==根据$IR$的内容（指令）、$PSW$的内容（状态信息）及时序信号，产生控制整个计算机系统所需的各种控制信号，其结构有组合逻辑型和存储逻辑型两种==。

协调并控制计算机各部件执行程序的指令序列，基本功能包括取指令、分析指令、执行指令：

1. 取指令：
    + 自动形成指令地址。
    + 自动发出取指令的命令。
    + $(PC)+$`'1'`$\rightarrow PC$。
2. 分析指令：
    + 操作码译码（对操作码分析本条指令要完成什么操作）。
    + 产生操作数的有效地址。
3. 执行指令：
    + 根据分析指令得到的“操作命令”和“操作数地址”。
    + 形成操作信号控制序列，控制运算器、存储器以及$I/O$设备完成相应的操作。
4. 中断处理：
    + 管理总线及输入输出。
    + 处理异常情况（如掉电）。
    + 特殊请求（如打印机请求打印一行字符）。

>   数据/指令流入流出
>
>   + 控制器部件向系统中的部件提供它们运行所需要的控制信号。
>   + 控制器部件从数据总线接收指令信息。
>   + 控制器部件从运算器部件接收指令转移地址。
>   + 控制器部件送出指令地址到地址总线。

## 指令执行

![image-20230908204513556](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309082045784.png)

### 指令周期

![image-20230603113042749](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603113042749.png)

四种周期，前三种周期从大到小：

+ 指令周期：$CPU$从主存中每取出并执行一条指令所需的全部时间，==指令周期可变==。
    + 通常包含一个取指周期（取指、分析）和执行周期。
+ 机器周期：通过一次总线事务访问一次主存或 $I/O$的时间定为一个机器周期。所以机器周期往往与访存周期相等。
    + 是$CPU$进行一次操作的时间。
    + 由于$CPU$内部操作的速度较快，而$CPU$访问一次存储器的时间较长，因此==机器周期通常由存取周期来确定，往往是通过一次总线事务访问一次主存或$I/O$的时间==
    + ==机器周期可变==。
+ 时钟周期：通常称为节拍或$T$周期，它是$CPU$操作的最基本单位，==时钟周期不变==。
    + 也称为节拍、$T$周期或$CPU$时钟周期
    + ==是$CPU$操作的最基本单位==
+ 存取周期：指存储器进行两次独立的存储器操作（连续两次读或写操作）所需的最小间隔时间。存取周期往往为固定值。

![image-20230908220650071](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309082206180.png)


+ 每个指令周期内机器周期数可以不等，每个机器周期内的节拍数也可以不等。

    + 空指令$NOP$：指令周期=取值周期

    + 加法指令$ADD$：指令周期=取值周期+执行周期

    + 乘法指令$MUL$：指令周期=取值周期+执行周期(较长)

    + 具有间接寻址的指令：指令周期=取值周期+间址周期+执行周期

    + 带有中断周期的指令：指令周期=取值周期+间址周期+执行周期+中断周期

        + 当CPU采用中断方式实现主机和I/O设备的信息交换时，==$CPU$在每条指令执行结束前，都要发中断查询信号==，若有中断请求，则CPU进入中断响应阶段，又称**中断周期**
        + 上述==4个工作周期都有CPU访存操作，只是访存的目的不同==。
            + 取指周期是为了取指令，间址周期是为了取有效地址，执行周期是为了取操作数，中断周期是为了保存程序断点。

        ![image-20230603113844682](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603113844682.png)

+ 为了区别不同的工作周期，$CPU$内设了四个标志触发器，以`1`为有效：
  
    + 取指令$FE$：取指周期。
        + 信号控制为`1->FE`
    + 取地址$IND$：间址周期。
        + 信号控制为`1->IND`
    + 存取操作数或结果$EX$：执行周期。
        + 信号控制为`1->EX`
    + 存程序断点$INT$：中断周期。
        + 信号控制为`1->INF`
    
+ 指令周期流程：
  
    1. 进入取指周期。
    2. 判断是否有间址。
        +   若有则进入间址周期，结束后进入执行周期。
        +   若无则直接进入执行周期。
    3. 判断是否有中断。
        +   若有则进入中断周期，结束后进入下一条指令的指令周期。
        +   若无则直接进入下一条指令的指令周期。

![image-20230603144007541](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603144007541.png)

>   +   **字长/机器字长**：在通常所说的“某16位或32位机器”中，16、32指的是字长，也称机器字长。
>       +   所谓字长，通常是指CPU内部用于整数运算的数据通路的宽度，
>       +   因此字长等于CPU内部用于整数运算的运算器位数和通用寄存器宽度，它反映了计算机处理信息的能力。
>   +   **存储字长**：一个存储单元存储的二进制代码的长度。
>       +   早期的存储字长一般与指令字长、字长相等，因此访问一次主存便可取出一条指令或一个数据。
>       +   随着计算机的发展，指令字长、字长都可变，但==必须都是字节的整数倍==。
>   +   **指令字长**：一个指令字中包含的二进制代码的位数。
>       +   指令字长一般是存储字长的整数倍，这是为了硬件设计方便，而不是必然的关系。
>           +   若指令字长等于存储字长的$n$倍，则需要$n$个访存周期来取出一条指令
>           +   若指令字长等于存储字长，则取指周期等于机器周期。
>       +   ==实际上指令字长取决于操作码长度、地址码长度和地址码个数==。
>           +   与机器字长没有必然的联系
>           +   但为了硬件设计方便，指令字长一般取字节或存储字长的整数倍
>
>   ---
>
>   指令和数据都存于存储器中，$CPU$如何区分它们？ 
>
>   +   ==$CPU$可根据指令周期的不同阶段判断从存储器取出的二进制代码是指令还是数据==
>       +   通常完成一条指令可分为取指阶段和执行阶段。
>           +   在取指阶段通过访问存储器可将指令取出
>           +   在执行阶段通过访问存储器可以将操作数取出。

### 指令周期的数据流

**数据流**是根据指令要求依次访问的**数据序列**。而且==对于不同的指令，它们的数据流往往也是不同的==。

#### 取指周期

取指周期的任务是==根据$PC$内容（无论是普通指令还是转移指令）从内存中取出指令代码/指令字并放入$IR$中==。

$PC$中存放的是指令的地址，根据此地址从内存单元中取出的是指令，并放在指令寄存器$IR$中，==取指令的同时，PC内容`+1`==。 取指周期的数据流向如下：

1.   $PC\stackrel{(1)}{\longrightarrow}MAR\stackrel{(2)}{\longrightarrow}$地址总线$\stackrel{(3)}{\longrightarrow}$主存

     1.   当前指令地址送至存储器地址寄存器，记做：$(PC)\rightarrow MAR$。
     2.   $MAR$将地址码发送到地址总线。
     3.   地址总线将地址发送给存储器，等待使用地址。

2.   $CU$发出读命令$\stackrel{(4)}{\longrightarrow}$控制总线$\stackrel{(5)}{\longrightarrow}$主存。

     4.   $CU$发出控制读信号给控制总线。
     5.   控制总线将控制读的信号发送给存储器。启动存储器做读操作，这是是**读信号**，记做：$1\rightarrow R$。
          + $R$(头上没有横杠)表示高电平激活，这里$1$表示高电平

3.   主存$\stackrel{(6)}{\longrightarrow}$数据总线$\stackrel{(7)}{\longrightarrow}MDR\stackrel{(8)}{\longrightarrow}IR$ （存放指令）。

     6.   存储器根据**地址总线**传来的地址信息和**控制总线**传来的控制读信息来进行读操作，从中读出数据，并将地址所指的数据发送给数据总线。
     7.   数据总线将数据送入$MDR$，记做：$M(MAR)\rightarrow MDR$。
          + $M(MAR)$指主存$(Memory)$中$MAR$存储地址所指的数据

     8.   将$MDR$中数据（此时是指令内容）**复制**送入$IR$，记做：$(MDR)\rightarrow IR$。

4.   $CU$发出控制信号$\stackrel{(9)}{\longrightarrow}PC$内容`+1`

     9.   $CU$发出控制信号，控制$PC$形成下一条指令地址，默认是加一，记做：$(PC)+1\rightarrow PC$。

![image-20230908222402565](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309082224660.png)

>   <span style="color:orange">注意：</span>取指操作是控制器固化的自动执行的操作。
>
>   即使是空操作指令，在取指操作后，PC也会自动加1，“空操作指令的指令周期中任何寄存器的内容都不会被改变”错误

#### 间址周期

根据间接地址==取操作数有效地址==。

以**一次间址**为例（见图5.5），将指令中的地址码送到$MAR$并送至地址总线，此后$CU$向存储器发读命令，以获取有效地址并存至$MDR$。 

间址周期的数据流向如下：

1.   $Ad(IR){\tiny \mathbb{OR}}   MDR\stackrel{(1)}{\longrightarrow}MAR\stackrel{(2)}{\longrightarrow}$地址总线$\stackrel{(3)}{\longrightarrow}$主存。

     1.   $IR$将指令的地址码送入$MAR$，记做：$Ad(IR)\rightarrow MAR {\tiny \mathbb{OR}}  Ad(MDR)\rightarrow MAR$。
          + 由于取指周期$(MDR)\rightarrow IR$时，$MDR$是复制一份地址码送入$IR$的，此时$MDR$中还留有地址码
     2.   $MAD$将地址码发送到地址总线。
     3.   地址总线将地址发送给存储器，等待使用地址。

2.   $CU$发出读命令$\stackrel{(4)}{\longrightarrow}$控制总线$\stackrel{(5)}{\longrightarrow}$主存。

     4.   $CU$发出控制读信号给控制总线。
     5.   控制总线将控制读信息发送到存储器中，启动主存做**读操作**，记做：$1\rightarrow R$。

3.   主存$\stackrel{(6)}{\longrightarrow}$数据总线$\stackrel{(7)}{\longrightarrow}MDR$ （存放有效地址）$\underline{\stackrel{(8)}{\longrightarrow}Ad(IR)} $

     6.   存储器根据地址总线传来的地址信息和控制总线传来的控制读信息来进行读操作，从中读出数据，并将地址所指的数据发送给数据总线。

     7.   数据总线将数据送入$MDR$，记做：$M(MAR)\rightarrow MDR$

          +   ==此时$MDR$保存的是操作数的地址而不是操作数本身==。

     8.   将有效地址送至指令的地址码字段，记做：$MDR\rightarrow Ad(IR)$。

          + ==这一步只有部分$CPU$会有==

          + 这一步会将有效地址覆盖于原指令的间接地址

![image-20230908223618547](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309082236654.png)

#### 执行周期

执行周期的任务是根据$IR$中的指令字的操作码和操作数通过$ALU$操作产生执行结果。不同指令的执行周期操作不同，因此没有统一的数据流向。

这里$MDR$访存取数得到操作数，此时$MDR$中的内容才是操作数。

#### 中断周期

中断周期的任务是==处理中断请求==。

+ 中断：暂停当前任务去完成其他任务。为了能够恢复当前任务，需要**保存断点**。
+ 一般使用**堆栈**来保存断点，这里用$SP$表示栈顶地址，假设$SP$指向栈顶元素，进栈操作是先修改指针，后存入数据。

中断周期的数据流向如下：

1.   $CU$控制将$SP$减1，然后$SP\stackrel{(1)}{\longrightarrow}MAR\stackrel{(2)}{\longrightarrow}$地址总线$\stackrel{(3)}{\longrightarrow}$主存。

     1.   $CU$控制将**$SP$减$1$**，即将一个空元素进栈然后对其操作，并修改后的地址送入$MAR$，记做：$(SP)-1\rightarrow SP$，$(SP)\rightarrow MAR$。本质上是将断点存入某个存储单元，假设其地址为$a$，故可记做：$a\rightarrow MAR$。
          + <span style="color:orange">注意：</span>==中断周期中的进栈操作是将$SP$减$1$==，这和传统意义上的进栈操作相反，原因是==计算机的堆栈中从高向低地址增加==，所以进栈操作是减$1$而不是加$1$。
     2.   $MAR$将地址码发送到地址总线。
     3.   地址总线将地址发送给存储器，等待使用地址。

2.   $CU$发出写命令$\stackrel{(4)}{\longrightarrow}$控制总线$\stackrel{(5)}{\longrightarrow}$主存。

     4.   $CU$发出控制写信号给控制总线。

     5.   控制总线将控制写信息发送到存储器中，启动主存做**写操作**，记做：$1\rightarrow W$。

3.   $PC\stackrel{(6)}{\longrightarrow}MDR\stackrel{(7)}{\longrightarrow}$数据总线$\stackrel{(8)}{\longrightarrow}$主存（程序断点存入主存）。

     6.   将断点（$PC$内容）送入$MDR$，记做：$(PC)\rightarrow MDR$。

     7.   将$MDR$内容传入数据总线。
     8.   数据总结将内容发送存储器，存储器将内容写入其中，记为$(MDR)\rightarrow M$。

4.   $CU $（中断服务程序的入口地址）$\stackrel{(9)}{\longrightarrow}PC$

     9.   $CU$控制将中断服务程序的入口地更新（由向量地址形成部件产生）送入$PC$：向量地址$\rightarrow PC$。

![image-20230908225046909](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309082250007.png)

### 指令执行方案

一个指令周期通常要包括多个时间段（执行步骤），每个步骤完成指令的一部分功能，几个依次执行的步骤完成这条指令的全部功能。

1. 单指令周期：
    + 对所有指令都选用相同的执行时间来完成。
        + ==每条指令都在一个时钟周期内完成==
    + 指令之间==串行执行==，即下一条指令只能在前一条指令执行结束后才能启动
        + 指令周期取决于执行时间最长的指令的执行时间。
    + 执行周期内控制信号不变。
    + 缺点：对于那些本来可以在更短时间内完成的指令，要使用这个较长的周期来完成，==会降低整个系统的运行速度==。
    + 优点：实施简单，只用程序计数器$PC$就能实现。
2. 多指令周期：
    + 对不同类型的指令选用不同的执行步骤来完成。
    + 指令之间==串行执行==，即下一条指令只能在前一条指令执行结束后才能启动
    + 但可选用不同个数的时钟周期来完成不同指令的执行过程，指令需要几个周期就为其分配几个周期，==不再要求所有指令占用相同的执行时间==。
    + 缺点：需要更复杂的硬件设计。
    + 优点：系统运行速度更高，效率更高。
3. 流水线方案：
    + 指令之间可以并行执行的方案，称为流水线方案，其追求的目标是力争在每个时钟脉冲周期完成一条指令的执行过程（只在理想情况下才能达到该效果）。
    + 在每一个时钟周期启动一条指令，尽量让多条指令同时运行，但各自处在不同的执行步骤中。

## 数据通路

![image-20230908204549642](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309082045373.png)

### 数据通路的功能和基本结构

+ **数据通路**就是数据在功能部件之间传送的路径。
    + 包括数据通路上流经的部件，如$ALU$、Cache、MMU、通用寄存器、状态寄存器、异常和中断处理逻辑等都是指令执行过程中数据流经的部件，都属于数据通路的一部分。
    + 数据通路描述了信息从什么地方开始，中间经过哪个寄存器或多路开关，最后传送到哪个寄存器，这些都需要加以控制
+ 数据通路由控制部件控制，控制部件根据每条指令功能的不同生成对数据通路的控制信号。 
+ 数据通路的功能是实现$CPU$内部的运算器与寄存器及寄存器之间的数据交换。
+ 数据通路的基本结构：
    + $CPU$内部单总线方式：将所有寄存器的输入端和输出端都连接到一条公共通路上
        + $ALU$工作时需要配合暂存寄存器
        + 结构比较简单，但数据传输存在较多的冲突现象，性能较低。
        + 一个时钟内只允许一次操作。
        + 连接各部件的总线只有一条时，称为单总线结构
    + $CPU$内部多总线方式：将所有寄存器的输入端和输出端都连接到多条公共通路上
        + 相比之下单总线中一个时钟内只允许传一个数据，因而指令执行效率很低
        + 因此采用多总线方式，==同时在多个总线上传送不同的数据，提高效率==
    + 专用数据通路方式：根据指令执行过程中的数据和地址的流动方向安排连接线路，避免使用共享的总线
        + 性能较高，但硬件量大，基本不存在数据冲突现象。
        + 也叫“不采用CPU内部总线方式”

图5.7所示为CPU内部总线的数据通路和控制信号。

+   ==**控制信号**是CU根据指令操作码发出的信号==
    +   对于==单周期处理器==来说，每条指令的执行只有一个时钟周期，而==在一个时钟周期内控制信号并不会变化==
    +   若是==多周期处理器==，则指令的执行需要多个时钟周期，在==每个时钟周期控制器会发出不同信号==

+   规定各部件用大写字母表示，字母加“in”表示该部件的允许输入控制信号，字母加“out”表示该部件的允许输出控制信号。
+   ==内部总线是指同一部件==（如CPU内部连接各寄存器及运算部件）==之间的总线==，==系统总线是指同一台计算机系统的各部件==（如CPU、内存和各类I/O接口）==之间互相连接的总线==

![image-20230909094120186](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309090941295.png)

1. 寄存器之间的数据传送

    +   寄存器之间的数据传送可通过CPU内部总线完成

    +   在图5.7中，某寄存器AX的输出和输入分别由$AX_ {out}$和$AX_{in}$控制。

    +   现以PC寄存器为例，把PC内容送至MAR，实现传送操作的流程及控制信号为
        $$
        (PC) \to MAR
        $$
        $PC_{out}$ 和 $MAR_{in} $有效，$ PC $内容$\to MAR$

2.   主存与CPU之间的数据传送

     +   主存与CPU之间的数据传送也要借助CPU内部总线完成。

     +   现以CPU从主存读取指令为例说明数据在数据通路中的传送过程，实现传送操作的流程及控制信号为
         1.   $(PC)\to MAR$，$PC_{out}$和$MAR_{in}$有效，现行指令地址$\to MAR$
         2.   $1\to R$，$CU$发读命令
         3.   $MEM(MAR)\to MDR$，$MDR_{in}$有效
         4.   $(MDR) \to IR$，$MDR_{out}$和$IR_{in}$有效，现行指令$\to IR$

3.   执行算术或逻辑运算

     +   执行算术或逻辑操作时，由于==ALU本身是没有内部存储功能的组合电路==，因此如要执行加法运算，==相加的两个数必须在ALU的两个输入端同时有效==。

     +   图5.7中的暂存器Y即用于该目的。 

     +   先将一个操作数经CPU内部总线送入暂存器Y保存，Y的内容在ALU的左输入端始终有效，再将另一个操作数经总线直接送到ALU的右输入端。

     +   这样两个操作数都送入了 ALU，运算结果暂存在暂存器Z中。

     +   执行算术或逻辑运算的流程及控制信号为
         1.   $(MDR) \to MAR$，$MDR_{out}$和$MAR_{in}$有效，操作数有效地址$\to MAR$
         2.   $1\to R $，$CU$发读命令
         3.   $MEM(MAR)\to MDR$ ，操作数从存储器 $MDR$
         4.   $(MDR)\to Y$ ，$MDR_{out}$和有效，操作数$\to Y$
         5.   $(ACC) + (Y)\to Z $，$ACC_{out}$和$ALU_{in}$有效，$CU$向$ALU$发加命令，结果$\to Z$
         6.   $(Z)\to ACC $，$Z_{out}$和$ACC_{in}$有效，结果$\to ACC$

![23SeptembeR_09-093807-1694223487-c31549e9-992b-498c-a959-7b744b740edf](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309090940889.png)

>   需注意题上箭头是左箭头还是右箭头，尽量按题上的箭头指

### CPU内部单总线方式

+ $CPU$内部单总线方式：将所有寄存器的输入端和输出端都连接到一条公共通路上
    + $ALU$工作时需要配合暂存寄存器
    + 结构比较简单，但数据传输存在较多的冲突现象，性能较低。
    + 一个时钟内只允许一次操作。
    + 连接各部件的总线只有一条时，称为单总线结构

+   对于$ALU$这种是一个组合逻辑电路的部件，其运算过程中必须保持两个输入端的内容不变。
    +   如果使用内部单总线方式，因此为了得到两个不同的操作数，==$ALU$的一个输入端与总线相连，另一个输入端需通过一个寄存器与总线相连==，第一个传入值的输入端需要用寄存器保存数据等待第二个数的输入，避免数据发生变化。
    +   此外，==$ALU$的唯一的输出端也不能直接与内部总线相连==，否则其输出又会通过总线反馈到输入端，影响运算结果
    +   ==因此输出端需通过一个暂存器（用来暂存结果的寄存器）或三态门（控制与总线的打开与关闭）与总线相连==。
        +   三态门，用于控制移位器与总线之间数据通路的连接与断开
    +   答题的标准答案（为什么输入输出端分别设置一个暂存器）：
        +   因为在单总线结构中，每一时刻总线上只有一个数据有效，而ALU有两个输入端和一个输出端。
        +   因此，当ALU运算时，需要先用暂存器Y缓存其中一个输入端的数据，再通过总线传送另一个输入端的数据。
        +   与此同时，ALU的输出端产生运算结果，但由于总线正被占用，因此需要暂存器Z，以缓存ALU的输出端数据

<span style="color:orange">注意：</span>**哪些控制信号有效是关键得分点一定要写上**

![image-20230603154752818](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603154752818.png)

1. 寄存器之间数据传送，比如把$PC$内容送至$MAR$，实现传送操作的流程及控制信号为：
    1. $(PC)\rightarrow Bus$：$PC_{out}$有效，$PC$内容送总线。
    2. $Bus\rightarrow MAR$：$MAR_{in}$有效，总线内容送$MAR$。
2. **主存与$CPU$之间的数据传送**，比如$CPU$从主存读取指令，实现传送操作的流程及控制信号为：
    1. $(PC)\rightarrow Bus\rightarrow MAR$：$PC_{out}$和$IMAR_{in}$有效，现行指令地址$\rightarrow MAR$。
    2. $1\rightarrow R$：$CU$通过控制总线发出**读命令**。
    3. $MEM(MAR)\rightarrow MDR$：$MDR_{in}E$有效，根据$MAR$地址取值送到$MDR$。
        + 此时$MDR_{in}$也常写成$MDR_{in}E$，因为$MDR_{in}$指的$CPU$内部总线的控制信号，而此时主存送数据到$MDR$时使用的是外部总线，一般使用的不是$MDR_{in}$的控制信号
    4. $MDR\rightarrow Bus\rightarrow IR$：$MDR_{out}$和$IR_{in}$有效，现行指令$\rightarrow IR$。
3. **执行算术或逻辑运算**，比如一条加法指令，微操作序列及控制信号为：
    1. $Ad(IR)\rightarrow Bus\rightarrow MAR$：$MDR_{out}$和$IMAR_{in}$有效。
    2. $1\rightarrow R$：$CU$发读命令。
    3. $MEM(MAR)\rightarrow$外部数据总线$\rightarrow MDR$：$MDR_{in}E$有效。
        + 同上，使用的是外部数据总线
    4. $MDR\rightarrow Bus\rightarrow Y$：$MDR_{out}$和$Y_{in}$有效，操作数$\rightarrow Y$。
    5. $(ACC)+(Y)\rightarrow Z$：$ACCout$和$ALUin$有效，$CU$向$ALU$发送加命令。
        + $(ACC)+(Y)$这一步是在$ALU$中计算，计算结果放入寄存器$Z$中
        + ==寄存器$Y$和$ALU$之间有一根专用数据通路，不会走数据总线==
    6. $Z\rightarrow ACC$：$Z_{out}$和$ACC_{in}$有效，结果$\rightarrow ACC$。

---

**【例题】：**

设有如图所示的单总线结构，分析指令$ADD\; (R_0)，R_1$的指令流程和控制信号

![image-20230603154837161](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603154837161.png)

**【解析】：$ADD\; (R_0)，R_1$**中

+ $(R_0)$部分是目的操作数，由于有括号则可知需先将$R_0$中数据取出得到主存中存放有效数的地址，然后根据地址去主存中取得有效数
+ $R_1$部分是源操作数，直接取得有效数即可
+ $ADD\;d\;s$指$d+s$的结果存放到$d$(所指地址的)中，则完整功能为$((R_0))+(R_1)\rightarrow(R_0)$，其中包括取指周期，间址周期，执行周期

**【解】：**

完整功能为$((R_0))+(R_1)\rightarrow(R_0)$，其中包括取指周期，间址周期，执行周期

**取址周期：**公共操作

| 时序 | 微操作                                    | 有效控制信号              |
| ---- | ----------------------------------------- | ------------------------- |
| 1    | $(PC) \rightarrow MAR$                    | $PC_{out}，MAR_{in}$      |
| 2    | $M(MAR)→MDR$<br />$(PC) +1\rightarrow PC$ | $MemR，MARout，MAR_{in}E$ |
| 3    | $(MDR) \rightarrow IR$                    | $MDR_{out}，IR_{in}$      |
| 4    | 指令译码                                  | /                         |

**间址周期：**完成取数操作，被加数在主存中，加数已经放在寄存器$R_1$中

| 时序 | 微操作                   | 有效控制信号              |
| ---- | ------------------------ | ------------------------- |
| 1    | $(R_0)  \rightarrow MAR$ | $R_0out，MAR_{in}$        |
| 2    | $M(MAR)→MDR$             | $MemR，MARout，MAR_{in}E$ |
| 3    | $(MDR)  \rightarrow Y$   | $MDR_{out}，Y_{in}$       |

**执行周期：**完成取数操作，被加数在主存中，加数己经放在寄存器$R_1$中。

| 时序 | 微操作                       | 有效控制信号                              |
| ---- | ---------------------------- | ----------------------------------------- |
| 1    | $(R_1)  + (Y) \rightarrow Z$ | $R_1out，ALUin，CU$向$ALU$发$ADD$控制信号 |
| 2    | $(Z)→MDR$                    | $Zout，MDR_{in}$                          |
| 3    | $(MDR)  \rightarrow M(MAR)$  | $MemW，MDR_{out}E，MARout$                |

### CPU内部多总线方式

+ 使用多根总线连接部件的输入和输出。
+ 效率相对于单总线而言得到了提升。

### 专用数据通路方式

+ 对于各种部件使用专用的通路进行连接。专用通路就是将总线分散到各个地方。
+ 连接多，实现困难。
+ 专用数据通路是指针对特定的操作或指令进行优化设计的数据通路，以提高指令执行的效率和速度。

专用数据通路方式的主要特点是针对特定的操作或指令进行优化，通过直接连接相应的功能单元，减少数据传输的路径和延迟，从而提高数据的传输速度和系统的整体性能。

以下是几种常见的专用数据通路方式：

1. **乘法器和除法器数据通路**：对于乘法和除法操作，通常会采用专门的乘法器和除法器单元。这些单元与其他功能单元（如寄存器、ALU等）直接连接，形成专用的数据通路，以提高乘除操作的速度和效率。
2. **浮点数数据通路**：针对浮点数运算，通常会设计专用的浮点数单元和浮点数数据通路。这些单元包括浮点加减器、浮点乘除器等，与其他功能单元相连接，形成专门用于浮点数运算的数据通路。
3. **向量处理器数据通路**：在一些特定的应用中，需要进行大规模的向量计算，如图形处理、科学计算等。为了提高向量操作的效率，可以设计专门的向量处理器单元和数据通路，以支持并行的向量操作。
4. **高速缓存数据通路**：高速缓存是用于加速存储器访问的重要组件。在CPU中，高速缓存通常与其他功能单元直接相连，形成专用的数据通路，以实现快速的缓存访问和数据交换。

![image-20230603161842951](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603161842951.png)

---

**【例题】：**

下图是一个简化的 $CPU $与主存连接结构示意图 ( 图中省略了所有的多路选择器 )，其中有一个累加寄存器 ($ACC $)、一个状态数据寄存器和其他 4 个寄存器： 主存地址寄存器($MAR $)、主存数据寄存器 ($MDR $)、程序寄存器 ($PC $) 和指令寄存器 ($IR $)，各部件及其之间的连线表示数据通路，箭头表示信息传递方向。

![image-20230603162149568](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603162149568.png)

要求：

1) 请写出图中 a、b、c、d 四个寄存器的名称

2) 简述图中取指令的数据通路

3) 简述数据在运算器和主存之间进行存/取访问的数据通路
    + 假设地址已在$MAR $中


4) 简述完成指令$LDA\;X$ 的数据通路
    + $X $为主存地址，$LDA $的功能为$(X) \rightarrow ACC $
5) 简述完成指令 $ADD\;Y$ 的数据通路
      +  $Y$立为主存地址，$ADD $的功能为$(ACC) + (Y) \rightarrow ACC $
6) 简述完成指令 $STA\;Z $的数据通路
      +  $Z $为主存地址，$STA $的功能为$(ACC) \rightarrow Z $


**【解】：**

1.  请写出图中 a、b、c、d 四个寄存器的名称
    1. $d$能自动$“+1”$，是$PC$
    2. $PC$内容是地址，需要送给$MAR$，则$c$是$MAR$
    3. $b$与微操作信号发生器相连，是$IR$
    4. 与主存相连的寄存器是$MAR$和$MDR$，$c$是$MAR$，则$a$是$MDR$

2. 简述图中取指令的数据通路
    + $(PC) \rightarrow MAR$
    + $M(MAR) \rightarrow MDR$
        + $1 \rightarrow R$
    + $(MDR)  \rightarrow IR$
    + $OP(IR) \rightarrow $微操作发生器
    + $(PC)+1 \rightarrow PC$
3. 简述数据在运算器和主存之间进行存/取访问的数据通路
   
    ![image-20230603164301374](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603164301374.png)
    
    + 取：
        + $M(MAR) \rightarrow MDR$
            + $1 \rightarrow R$
        + $(MDR) \rightarrow ALU  \rightarrow  ACC$
    + 存：
        + $(ACC) \rightarrow MDR$
        + $(MDR) \rightarrow M(MAR)$
            + $1 \rightarrow W$
    
4. 简述完成指令$LDA\;X$ 的数据通路
    + $X  \rightarrow MAR$
    + $M(MAR) \rightarrow MDR$
        + $1 \rightarrow R$
    + $(MDR) \rightarrow ALU  \rightarrow  ACC$

5. 简述完成指令 $ADD\;Y$ 的数据通路
    + $Y  \rightarrow MAR$
    + $M(MAR) \rightarrow MDR$
        + $1 \rightarrow R$
    + $(MDR) \rightarrow ALU，(ACC)  \rightarrow  ALU$
    + $ALU \rightarrow ACC$

6. 简述完成指令 $STA\;Z $的数据通路
    + $Z  \rightarrow MAR$
    + $(ACC)  \rightarrow  MDR$
    + $(MDR) \rightarrow M(MAR)$

## 控制器的工作原理和功能

![1](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309082047831.png)

$CU$的设计包括硬布线和微程序两种，==微程序比较重要，硬布线了解即可==。

+   CPU控制器/控制部件主要由三个部件组成：指令寄存器、程序计数器和操作控制器
+   一台数字计算机基本上可以划分为两大部分：控制部件和执行部件
    +   控制器就是控制部件，
    +   而运算器、存储器、外围设备相对控制器来说就是执行部件

### 控制器的结构和功能

![image-20230909214730476](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309092147666.png)

从图5.8可以看到计算机硬件系统的五大功能部件及其连接关系。它们通过数据总线、地址总线和控制总线连接在一起，其中点画线框内的是控制器部件。 其主要连接关系简要如下：

1.   运算器部件通过**数据总线**与内存储器、输入设备和输出设备传送数据。
2.   输入设备和输出设备通过**接口电路**与总线相连接。
3.   内存储器、输入设备和输出设备==从**地址总线**接地址信息，从**控制总线**得到控制信号， 通过**数据总线**与其他部件传送数据==。
4.   控制器部件==从**数据总线**接收指令信息，从运算器部件接收指令转移地址，送出指令地址到地址总线==，还要向系统中的部件提供它们运行所需要的控制信号。

控制器是计算机系统的指挥中心，控制器的主要功能有：

1.   从主存中取出一条指令，并指出下一条指令在主存中的位置。
2.   对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作。
3.   指挥并控制CPU、主存、输入和输出设备之间的数据流动方向。 

根据控制器产生微操作控制信号的方式的不同，控制器可分为硬布线控制器和微程序控制器，两类控制器中的$PC$和$IR$是相同的，但确定和表示指令执行步骤的办法以及给出控制各部件运行所需要的控制信号的方案是不同的。

>   ![image-20230525163828848](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230525163828848.png)
>
>   +   控制单元$CU(Control\,Unit)$：分析指令，给出控制信号
>
>   +   指令寄存器$IR(Instruction\,Register)$：存放当前执行的指令
>
>   +   程序计数器$PC(Program\,Counter)$：存放下一条指令地址，有自动加1功能
>
>   $PC$(取指令)$\to$$IR$(分析指令)$\to$$CU$(执行指令)

### 硬布线控制器

微操作控制信号由组合逻辑电路根据当前的指令码、状态和时序，即时产生。

它由复杂的组合逻辑门电路和一些触发器构成，因此又称组合逻辑控制器

#### 硬布线控制单元图

为了简化控制单元$CU$的逻辑，将指令的操作码译码和节拍发生器从$CU$分离出来，便可得到简化的控制单元图，如图5.9所示。

![image-20230909220136550](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309092201657.png)

$CU$的输入信号来源如下，前两者是主要因素：

1. 经指令译码器译码产生的指令信息。
    +   指令寄存器：$OP(IR)\rightarrow CU$，控制信号的产生与操作码有关
    +   现行指令的==操作码==决定了不同指令在执行周期所需完成的不同操作，因此指令的操作码字段是控制单元的输入信号，它与时钟配合产生不同的控制信号。
2. 时序系统产生的机器周期信号和节拍信号
    +   为了使控制单元按一定的先后顺序、一定的节奏发出各个控制信号，控制单元必须受时钟控制，即==一个时钟脉冲使控制单元发送一个操作命令，或发送一组需要同时执行的操作命令==。
    +   $FE、IND、EX、INT$
        +   事实上==这四个触发器集成在$CU$内部==
3. 来自执行单元的反馈信息即标志。
    +   控制单元有时需依赖CPU当前所处的状态产生控制信号，如BAN指令，控制单元要根据上条指令的结果是否为负来产生不同的控制信号。 
    +   可能来自运算器的$PSW$、$ACC$的符号位等
    +   也可能来自$I/O$设备、主存

---

![image-20230603210419448](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603210419448.png)

输入：

1. 指令寄存器：$OP(IR)\rightarrow CU$，控制信号的产生与操作码有关。
2. 时钟：一个时钟脉冲发一个操作命令或一组需要同时执行的操作命令。
3. 标志：如条件转移指令，根据相应的标志位决定下一步操作。
4. 外来信号：如中断请求信号$INTR$、总线请求信号$HRQ$，$DMA$请求。

输出：

1. $CPU$内部的控制信号：寄存器之间的数据传输、$PC$的修改、控制$ALU$进行相应的运算。
2. 到控制总线的控制信号：
    + 到存储器：访存控制信号$MREQ$、读命令$RD$、写命令$WR$。
    + 到$I/O$设备：访问$I/O$设备的控制信号$I/O$。
    + 中断响应信号$INTA$。
    + 总线响应信号$HLDA$。

#### CPU的控制方式

==控制单元$CU$控制一条指令执行的过程，实质上是依次执行一个确定的微操作序列的过程==。由于不同指令所对应的微操作数及复杂程度不同，因此每条指令和每个微操作所需的执行时间也不同。主要有以下3种控制方式。

1. 同步控制方式。所谓同步控制方式，是指系统有一个统一的时钟，所有的控制信号均来自这个统一的时钟信号。

      +   通常以最长的微操作序列和最烦琐的微操作作为标准，采取完全统一的、具有相同时间间隔和相同数目的节拍作为机器周期来运行不同的指令。
      +   同步控制方式的优点是控制电路简单，缺点是运行速度慢。
2) 异步控制方式。异步控制方式不存在基准时标信号，各部件按自身固有的速度工作，通过应答方式进行联络。 
      +   异步控制方式的优点是运行速度快，缺点是控制电路比较复杂。
3) 联合控制方式。联合控制方式是介于同步、异步之间的一种折中。
      +   这种方式对各种不同的指令的微操作实行大部分采用同步控制、小部分采用异步控制的办

#### 硬布线控制器的时序系统及微操作

1.   时钟周期。用时钟信号控制节拍发生器，可以产生节拍，每个节拍的宽度正好对应一个时钟周期。
     +   ==在每个节拍内机器可完成一个或几个需同时执行的操作==。
2.   机器周期。机器周期可视为所有指令执行过程中的一个基准时间。
     +   不同指令的操作不同， 指令周期也不同。
     +   访问一次存储器的时间是固定的，因此通常以存取周期作为基准时间， 即内存中读取一个指令字的最短时间作为机器周期。
     +   在==存储字长等于指令字长的前提下，取指周期也可视为机器周期==。 
     +    在一个机器周期里可完成若干微操作，每个微操作都需一定的时间，可用时钟信号来控制产生每个微操作命令。
3.   指令周期。见指令周期
4.   微操作命令分析。控制单元具有发出各种操作命令（控制信号）序列的功能。
     +   这些命令与指令有关，而且必须按一定次序发出，才能使机器有序地工作。 

各个子周期的微操作命令分析如下

1. 取址$FE$：无论是什么指令，取指周期都需有下列微操作命令

    1. $PC\rightarrow MAR$：将$PC$地址交给$MAR$。
    2. $(PC)+1\rightarrow PC$：$PC$自加$1$。因为操作完就可以更新，所以在`1.`后面即可了。
    3. $1\rightarrow R$：主存发出读命令。==只需要存储器空闲就能发出==。
    4. $M(MAR)\rightarrow MDR$：将地址指向指令交给$MDR$。==要$MAR$准备好，在`1.`的后面==。
    5. $MDR\rightarrow IR$：将指令交给$IR$。把$MDR$有指令，在`3.`后面。
    6. $OP(IR)\rightarrow ID$：编译指令。$IR$中要有指令，在`4.`后面。
    7. 指令译码

2. 间址$IND$：间址周期完成取操作数地址的任务，有指令都一样

    1. $Ad(IR)\rightarrow MAR$：获取$IR$指令中的地址交给$MAR$。
    2. $1\rightarrow R$：主存发出读命令。
    3. $M(MAR)\rightarrow MDR$：取出对应的值放到$MDR$中。
    4. $MDR\rightarrow Ad(IR)$：将$MDR$的地址值放入$IR$的指令中。

3. 执行$EX$

    >   详见下节指令类别

4. 中断$INT$

    1. $a\rightarrow MAR$：将$a$保存到$MAR$中。
    2. $1\rightarrow W$：主存发出写命令。存储器空闲就可以。
    3. $0\rightarrow EINT$：硬件关中断。安排在第一个周期就可以。
    4. $(PC)\rightarrow MDR$：将当前程序计数器保存的位置暂存到$MDR$，等待后期恢复。内部数据通路空闲就可以。
    5. $MDR\rightarrow M(MAR)$：将$MDR$的数据保存到$a$这个地址。在$4$之后。
    6. 向量地址$\rightarrow PC$：将$PC$送到中断服务地址。只用$PC$改好就可以，在$4$之后。

#### 指令类别

1. 非访存指令：

    1. $CLA$（$clear$）：$ACC$清零。
        +   $0\to ACC$
    2. $COM$（$complement$）：$ACC$取反。
        +   $\overline{ACC}\to ACC$
    3. $SHR$（$shift$）：算术右移。
        +   $L(ACC)\to R(ACC)$
        +   $ACC_0\to ACC_0$
    4. $CSL$（$cyclic\;shift$）：循环左移。
        +   $R(ACC)\to L(ACC)$
        +   $ACC_0\to ACC_n$
    5. $STP$（$stop$）：停机。
        +   $0\to G$
2. 访存指令：

    1. $ADD$：加法指令，隐含$ACC$。
        1. $Ad(IR) \to MAR, 1\to R$
        2. $M (MAR) \to MDR$
        3. $(ACC) + (MDR)\to ACC$
    2. $STA$：存数指令，隐含$ACC$。
        1. $Ad(IR) \to MAR, 1\to W$
        2. $(ACC) \to MDR$
        3. $(MDR) \to M(MAR)$
    3. $LDA$：取数指令，把$X$所指内容取到$ACC$，隐含$ACC$。
        1. $Ad(IR) \to MAR, 1\to R$
        2. $M (MAR) \to MDR$
        3. $(MDR) \to ACC$
3. 转移指令：

    1. $JMP$（$jump$）：无条件转移。
        +   $Ad(IR) \to PC$
    2. $BAN$（$branch\;ACC\;Negative$）：条件转移，当$ACC$为负时转移到$X$
        +   $A_{0} \cdot A d(I R)+\overline{A_{0}} \cdot(P C) \rightarrow P C$

#### 设计步骤

1. 列出微操作命令的操作时间表。

    +   先根据微操作节拍安排，列出微操作命令的操作时间表。 
    +   操作时间表中包括各个机器周期、节拍下的每条指令完成的微操作控制信号。
    +   表5.1列出了 `CLA`、`COM`、`SHR`等10条机器指令微操作命令的操作时间表。
        +   表中FE、IND和EX为CPU工作周期标志，$T_0\sim T_2$为节拍，`I`为间址标志
            +   在取指周期的$T_2$时刻，若测得$I=1$,则IND触发器置“1”，标志进入间址周期
            +   若`I = 0`，则EX触发器置“1”，标志进入执行周期。
        +   同理，在间址周期的写时刻
            +   若测得`IND = 0` (表示一次间接寻址)，则EX触发器置“1”，进入执行周期
            +   若测得`IND = 1 `(表示多次间接寻址)，则继续间接寻址。
        +   在==执行周期的$T_2$时刻，CPU要向所有中断源发中断查询信号，若检测到有中断请求并满足响应条件，则INT触发器置“1”，标志进入中断周期==。
        +   表中未列出INT触发器置“1”的操作和中断周期的微操作。
        +   表中第一行对应10条指令的操作码，代表不同的指令。
        +   若某指令有表中所列出的微操作命令，其对应的单元格内为1。

    ![image-20230909223027344](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309092230594.png)

2. 进行微操作信号综合，写出微操作指令的逻辑表达式。

    +   在列出微操作时间表后，即可对它们进行综合分析、归类，根据微操作时间表可写出各微操作控制信号的逻辑表达式并进行适当的简化。

    +   表达式一般包括下列因素： 

        +   微操作控制信号=机器周期$\and$节拍$\and$脉冲$\and$操作码$\and$机器状态条件

    +   根据表5.1便可列出每个微操作命令的初始逻辑表达式，经化简、整理可获得能用现有门电路实现的微操作命令逻辑表达式

    +   例如，根据表5.1可写出$M(MAR)\to MDR$微操作命令的逻辑表达式： 
        $$
        \begin{array}{l}
        \mathrm{M}(\mathrm{MAR}) \rightarrow \mathrm{MDR} \\
        \quad=\mathrm{FE} \cdot T_{1}+\mathrm{IND} \cdot \mathrm{T}_{1}(\mathrm{ADD}+\mathrm{STA}+\mathrm{LDA}+\mathrm{JMP}+\mathrm{BAN})+\mathrm{EX} \cdot T_{1}(\mathrm{ADD}+\mathrm{LDA}) \\
        \quad=T_{1}\{\mathrm{FE}+\mathrm{IND}(\mathrm{ADD}+\mathrm{STA}+\mathrm{LDA}+\mathrm{JMP}+\mathrm{BAN})+\mathrm{EX}(\mathrm{ADD}+\mathrm{LDA})\}
        \end{array}
        $$

3. 画出微操作命令的逻辑图。

    +   根据逻辑表达式可画出对应每个微操作信号的逻辑电路图， 并用逻辑门电路实现
    +    例如，$M(MAR)\to MDR$的逻辑表达式所对应的逻辑图如图5.10所示，图中未考虑门的扇入系数

![image-20230909224148524](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309092241677.png)

>   安排微操作时序的原则：
>
>   1. 微操作的先后顺序不得随意更改
>   2. 被控对象不同的微操作尽量安排在一个节拍内完成
>   3. 占用时间较短的微操作尽量安排在一个节拍内完成并允许有先后顺序

#### 硬布线控制器的特点

- 指令越多，设计和实现就越复杂，因此==一般用于精简指令集系统$RISC$==
- 如果扩充一条新的指令，则控制器的设计就需要大改，因此扩充指令较困难。
- 由于使用纯硬件实现控制，因此执行速度很快。微操作控制信号由组合逻辑电路即时产生。

### 微程序控制器

事先把微操作控制信号存储控制存储器中，将每一条机器指令编写成一个微程序，这些微程序可以存到一个控制存储器中，用寻址用户程序机器指令的办法来寻址每个微程序中的微指令。==目前，大多数计算机都采用微程序设计技术==。 

+ 在微程序控制器中，控制部件向执行部件发出的控制信号称为微命令。
+ 微命令执行的操作称为微操作。
+ 微指令则是若干微命令的集合。
+ 若干微指令的有序集合称为微程序。

#### 微程序控制的基本概念

![image-20230603213035541](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603213035541.png)

+ 相关概念
    + **微指令（Microinstruction）**：微指令是微程序的最小执行单位，是对硬件层面的微操作进行编码的指令，它包含了对CPU中各个部件的控制信号、操作码和地址等信息。
    
        + 微指令是若干微命令的集合。
            + ==每条微指令对应着一个或多个微操作==。
        + 一条微指令通常至少包含两大部分信息： 
            1.   操作控制字段，又称微操作码字段，用于产生某一步操作所需的各种操作控制信号。 
            2.   顺序控制字段，又称微地址码字段，用于控制产生下一条要执行的微指令地址。 
        + ==**微周期**通常指从控制存储器中读取一条微指令并执行相应的微操作所需的时间，通常为一个时钟周期==
    
    + **指令（Instruction）**：指令是在机器语言中表示一条操作的基本单位。它是对特定操作的功能描述，由操作码和操作数组成。在微程序控制器中，指令被解码后会生成对应的一系列微指令。
    
    + **微操作（Microoperation）**：一条机器指令可以分解成一个微操作序列，微操作是对硬件中的某个具体操作进行编码的指令，它是微指令的基本执行单位。
    
        + 例如，将数据从寄存器加载到ALU、将运算结果存储到寄存器等都可以视为一个微操作。
        + 完成一条机器指令分为多个微操作命令，微操作命令即微命令，是微操作的控制信号，==微操作是微命令的执行过程==。
    
    + **微命令**：在微程序控制的计算机中，==将控制部件向执行部件发出的各种控制命令称为**微命令**==，它==是构成控制序列的最小单位==
    
        + 例如，打开或关闭某个控制门的电位信号、某个寄存器的打入脉冲等。
        + ==微命令和微操作是一一对应的==
        + 微命令有相容性和互斥性之分。
            + 相容性微命令是指那些可以同时产生、共同完成某一些微操作的微命令
            + 而互斥性微命令是指在机器中不允许同时出现的微命令
            + 相容和互斥都是相对的，一个微命令可以和一些微命令相容，和另一些微命令互斥。
            + 对于==相容性的微命令可以合并为一条微指令==，而==互斥性微命令只能单独为一条微指令==。
    
        >   在组合逻辑控制器中也存在微命令与微操作这两个概念，它们并非只是微程序控制器的专有概念。
    
    + **主存储器/主存**$Mem$：用于存放程序和数据，==在CPU外部==，用$RAM$实现
    
    + **控制存储器**$CM$：$CM$用于存放微程序，==在CPU内部==，用$ROM$实现。
    
        + $ROM$非易失性，数据不会丢失即微程序由厂商设计且出厂前就会把微指令写好
        + 决定了$CPU$对指令集的支持和执行效率
        + 通过适当设计微指令和微程序，可以实现复杂的指令集和灵活的指令执行
        + $CM$的访问速度和容量对$CPU$性能和指令执行速度也有重要影响。
    
    + **微程序（Microprogram）**：微程序是一系列微指令的集合，用于实现特定的指令集和操作序列。
    
        + 它是对指令执行过程进行细化和抽象的一种表示方式。
        + ==微程序通常以存储器的形式存在，存储着每条指令对应的微指令序列==。
        + 一个微程序的周期对应一个指令周期
    
    + **程序**：程序是指令的有序集合，用于完成特定的功能
    
+ 寄存器：

    + 地址译码器$MAR$：将地址码转换微存储单元控制信号。

    + 指令寄存器$IR$：用于存放从主存中读出的指令

    + 微地址寄存器$CMAR$(别名$\mu PC$)：接收微地址形成部件送来的微地址，为在**控制存储器**$CM$中读取微指令作准备。
        + ==决定的是微指令执行顺序，无法决定指令执行顺序==

    + 微指令寄存器$CMDR$(别名$\mu IR$)：用于存放从**控制存储器**$CM$中取出的微指令，它的位数同微指令字长相等。

    + 微地址形成部件：产生初始微地址和后继微地址，以保证微指令的连续执行。

    + 顺序逻辑单元：为了保证指令联系执行，控制形成下一条微指令，拥有一个时钟信号$CLK$和一个标志位用于标识接下来是顺序执行还是条件/无条件跳转。

+ 假设微指令的一个二进制位对应一个微操作命令，所有的微命令都合并为微指令，微指令再合并为一个微程序保存到$ROM$中，从而每一条机器指令对应一条微程序。

+ 每条指令取指周期的操作是相同的，所以将取指令操作的微命令统一编成一个微程序，而每条机器指令所对应的具体操作再单独编写一个对应的微程序。

+ ==执行公用的取指微程序从主存中取出机器指令后，由机器指令的操作码字段指出各个微程序的入口地址（初始微地址）==。

+ 微程序和程序是两个不同的概念。

    + 微程序是由微指令组成的，用于描述机器指令。
    + 微程序实际上是机器指令的实时解释器，是由计算机设计者事先编制好并存放在控制存储器中的，一般不提供给用户。
    + 对于程序员来说，计算机系统中微程序的结构和功能是透明的，无须知道。
    + 而程序最终由机器指令组成，是由软件设计人员事先编制好并存放在主存或辅存中的。 

+ 微指令基本格式：
    + 操作控制：微操作码：产生控制信号。

    + 顺序控制：微地址码：产生下一条指令地址。

        ![image-20230603213222529](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603213222529.png)

#### 微程序控制器组成和工作过程

在控制单元$CU$内部：

图5.11所示为一个微程序控制器的基本结构，主要画出了微程序控制器比组合逻辑控制器多出的部件，包括： 

1.   控制存储器$CM$。它是微程序控制器的核心部件，用于存放各指令对应的微程序，控制存储器可用只读存储器ROM构成。 
2.   微指令寄存器$CMDR(\mu IR)$。用于存放从**控制存储器**$CM$中取出的微指令，==位数同微指令字长相等==。
3.   微地址形成部件。用于产生初始微地址和后继微地址，以保证微指令的连续执行。 
4.   微地址寄存器$CMAR(\mu PC)$。接收微地址形成部件送来的微地址，为在**控制存储器**$CM$中读取微指令作准备

![image-20230603214556204](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603214556204.png)


微程序控制器的工作过程实际上就是在微程序控制器的控制下计算机执行机器指令的过程， 这个过程可以描述如下：

1. 执行取微指令公共操作。
    +   在机器开始运行时，自动将取指微程序的入口地址送入**微地址寄存器**$CMAR(\mu PC)$，并从**控制存储器**$CM$中读出相应的微指令送入**微指令寄存器**$CMDR(\mu IR)$
    +   取指微程序的入口地址一般为**控制存储器**$CM$的0号单元，当取指微程序执行完后，从主存中取出的机器指令就已存入指令寄存器中。 
2. 由机器指令的操作码字段通过微地址形成部件产生该机器指令所对应的微程序的入口地址，并送入**微地址寄存器**$CMAR(\mu PC)$
3. 从**控制存储器**$CM$中逐条取出对应的微指令并执行。 
4. 执行完对应于一条机器指令的一个微程序后，又回到取指微程序的入口地址，继续第`1.`步，以完成取下一条机器指令的公共操作。

微程序和机器指令的个数对应关系：

+ 通常，一条机器指令对应一个微程序。
    + 物理上，取指址周期、执行周期看起来像是两个微程序，但逻辑上应该把它们看作一个整体。
    + 由于任何机器指令的取指令操作都是相同的，因此可将取指令操作的微命令统一编成一个微程序，这个微程序只负责将指令从主存单元中取出并送至指令寄存器
    + 因此，`一条指令对应一个微程序`的说法是正确的
    
+ 取指周期微程序默认是公共的（即单独拿出来公用），故==如果某指令系统中有$n$条机器指令，则**控制存储器**$CM$中**微程序段**的个数至少是$n+1$个（加一个取指的公共微程序）==。
    + 也可以说**微程序**的个数至少是$n$个

+ 间址周期微程序和中断周期微程序不一定是公共的。
    + 若公共的，如果这台计算机指令系统中有$n$条机器指令，则**控制存储器**$CM$中**微程序**的个数是$n+3$个
    + 若题目中没有提到间址，就不考虑间址，所以是$n+2$个。


#### 微指令编码

微指令的编码方式又称为微指令的控制方式，它是指如何对微指令的控制字段进行编码，以形成控制信号。编码的目标是在保证速度的情况下，尽量缩短微指令字长。

1. 直接编码（直接控制）方式：

    + 在微指令的操作控制字段中，每一位二进制位代表一个微操作命令。

    + 设计微指令时，选用或不选用某个微命令，只要将表示该微命令的对应位设置成1或0即可

        + 某位为`1`表示该控制信号有效，为`1`的指令同时执行
        + 若`0`则代表此时该位指向的命令不运行。

    + 优点：简单、直观，执行速度快，操作并行性好。

    + 缺点：微指令字长过长，$n$个微命令就要求微指令的操作字段有$n$位，造成控存容量极大。

        ![image-20230603220208151](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603220208151.png)

2. 字段直接编码方式：

    + 将微指令的控制字段分成若干“段”，每段经译码后发出控制信号。

    + 把==互斥性微命令组合在同一字段中==，把==相容性微命令组合在不同字段中==

    + 每个字段独立编码，每种编码代表一个微命令且各字段编码含义单独定义，与其他字段无关

    + 微命令字段分段的原则：

        1. 因为每组译码后可以通过每位$1\&0$的不同来让每组中的操作互斥，而不同组则很难完成互斥，所以**互斥性微命令分在同一段内**，因为命令在不同的组可以同时执行，所以**相容性微命令分在不同段内**。
            +   例如$001\&011$是相容性微命令，可以并行发出
            +   $001\&100$是互斥性微命令，不可以并行发出
        2. 每个小段中包含的信息位不能太多，否则将增加译码线路的复杂性和译码时间。
        3. 一般每个小段还要留出一个状态，表示本字段不发出任何微命令。
            +   因此，当某字段的长度为$3$位时，最多只能表示$2^3-1=7$个互斥的微命令
            +   通常用$000$表示不操作。

    + 优点：可以缩短微指令字长。

    + 缺点：要通过译码电路后再发出微命令，因此比直接编码方式慢。

        ![image-20230909233544584](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309092335691.png)

3. 字段间接编码方式：

    + 一个字段的某些微命令需由另一个字段中的某些微命令来解释(两层译码)
    + 由于不是靠字段直接译码发出的微命令，故称为字段间接编码，又称隐式编码。
    + 优点：可进一步缩短微指令字长。
    + 缺点：运行速度更慢；削弱了微指令的并行控制能力，故通常作为字段直接编码方式的辅助手段。

#### 微指令地址形成方式

1. 直接由微指令的**下地址字段**指出：微指令格式中设置一个下地址字段，由微指令的下地址字段直接指出后继微指令的地址，这种方式又称为**断定方式**。
2. 根据机器指令的**操作码**形成：当机器指令取至指令寄存器后，微指令的地址由操作码经微地址形成部件形成。
3. **增量计数器法**：$(CMAR)+1 \rightarrow CMAR$，适用于指令**连续存放**的情况。
4. 分支转移：指令分为三个字段：
    1. 操作控制字段：指明操作控制类型。
    2. 转移方式：指明判别条件。
    3. 转移地址：指明转移成功后的去向。
5. 通过测试网络：一个测试网络产生。

![image-20230603221103255](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603221103255.png)

6. 由硬件产生微程序入口地址：
    + 第一条微指令地址：专门硬件产生。
    + 中断周期：硬件产生中断周期微程序首地址。

#### 微指令的格式

1. 水平型微指令：
    + 一次能定义并执行多个并行操作。
    
    + 从编码方式看，直接编码、字段直接编码、字段间接编码和混合编码都属于水平型微指令
    
    + 指令字中的一位对应一个控制信号，有输出时为1，否则为0
    
    + 基本格式是：操作控制+判别测试+后继地址。
    
    + 优点：微程序短，执行速度快。
    
    + 缺点：操作控制字段比较长导致微指令长，编写微程序较麻烦。
    
        ![image-20230909233950020](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309092339126.png)
    
2. 垂直型微指令：
    + 类似机器指令操作码的方式，由微操作码字段规定指令的功能，一条指令对应一个操作。
    
    + 采用微操作码编译法，由微操作码规定微指令的功能
    
    + 一条垂直型微指令只能定义并执行一种基本操作
    
    + 基本格式：微操作码+目的地址+源地址。
    
    + 优点：微操作码短导致微指令短、简单、规整，便于编写微程序。
    
    + 缺点：微程序长，执行速度慢，工作效率低。
    
        ![image-20230909234036307](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309092340407.png)
    
3. 混合型微指令：
    + 在垂直型的基础上增加一些不太复杂的并行操作。
    + 微指令较短，仍便于编写。
    + 微程序也不长，执行速度加快。

水平型微指令和垂直型微指令的比较如下： 

1.   水平型微指令并行操作能力强、效率高、灵活性强；垂直型微指令则较差。 
2.   水平型微指令执行一条指令的时间短；垂直型微指令执行的时间长。 
3.   由水平型微指令解释指令的微程序，具有微指令字较长但微程序短的特点；垂直型微指令则与之相反，其微指令字较短而微程序长。 
4.   水平型微指令用户难以掌握，而垂直型微指令与指令比较相似，相对容易掌握。

水平型微指令的求法。

+ 操作控制：
    + 若是直接编码方式，则微命令数就是操作控制字段位数。
    + 若是字段直接编码方式，则会分$n$个组，每组$n_i$种状态，则总位数就是（全$0$空出）
        $$
        \sum\limits_{i=1}^n\log_2(n_i+1)
        $$
        如$2，3，4$，则一共需要$2+2+3=7$位。
+ 判别测试：
    + 直接编码方式，有几个外部条件，就取几位。
    + 如果是字段直接编码，有$N$个外部条件就有$n$位
        $$
        2^n\geqslant N+1
        $$
        加$1$是因为还有**无条件转移**的情况。
+ 后继地址：
    + 求出前面两项后，直接根据微指令字长减去。
    + 根据$CM$的容量的前一项确认，$2^N\times M$容量就是$N$位。
    
+ 操作控制+判别测试+后继地址即可

#### 微程序控制单元设计

设计步骤：

1. 分析每个阶段的微操作序列。
2. 写出对应机器指令的微操作命令及节拍安排：
    1. 写出每个周期所需要的微操作（参照硬布线）。
    2. 补充微程序控制器特有的微操作：
        + 取指周期：$Ad(CMDR)\rightarrow CMAR$；$OP(IR)\rightarrow CMAR$。
        + 执行周期：$Ad(CMDR)\rightarrow CMAR$。
3. 确定微指令格式：
    + 根据微操作个数决定采用何种编码方式，以确定微指令的操作控制字段的位数。
    + 由微指令数确定微指令的顺序控制字段的位数。
    + 最后按操作控制字段位数和顺序控制字段位数就可确定微指令字长。
4. 编写微指令码点：根据操作控制字段每一位代表的微操作命令，编写每一条微指令的码点。

| 节拍安排 | 取指周期-硬布线控制器的节拍安排 | 取指周期-微程序控制器的节拍安排 |
| :------: | :-----------------------------: | :-----------------------------: |
|    T0    |             PC→MAR              |             PC→MAR              |
|    T0    |               1→R               |               1→R               |
|    T1    |           M(MAR)→MDR            |           M(MAR)→MDR            |
|    T1    |            (PC)+1→PC            |            (PC)+1→PC            |
|    T2    |             MDR→IR              |             MDR→IR              |
|    T2    |            OP(IR)→ID            |      OP(IR)→微地址形成部件      |

根据读出转入微指令的过程，变为：

| 节拍安排 | 取指周期-硬布线控制器的节拍安排 | 取指周期-微程序控制器的节拍安排 |
| :------: | :-----------------------------: | :-----------------------------: |
|    T0    |             PC→MAR              |             PC→MAR              |
|    T0    |               1→R               |               1→R               |
|    T1    |           M(MAR)→MDR            |          Ad(CMDR)→CMAR          |
|    T1    |            (PC)+1→PC            |                                 |
|    T2    |             MDR→IR              |           M(MAR)→MDR            |
|    T2    |            OP(IR)→ID            |            (PC)+1→PC            |
|    T3    |                                 |          Ad(CMDR)→CMAR          |
|    T4    |                                 |             MDR→IR              |
|    T4    |                                 |      OP(IR)→微地址形成部件      |

#### 微程序设计分类

+ 静态微程序设计：无需改变，采用$ROM$。
+ 动态微程序设计动态通过改变微指令和微程序改变机器指令，有利于仿真，采用$EPROM$。
+ 毫微程序设计：微程序设计用微程序解种机器指令，毫微程序设计用毫微程序解释微程序。

### 硬布线与微程序

+   硬布线控制器的特点。硬布线控制器的优点是由于控制器的速度取决于电路延迟，所以速度快；缺点是由于将控制部件视为专门产生固定时序控制信号的逻辑电路，所以把用最少元件和取得最高速度作为设计目标，一旦设计完成，就不可能通过其他额外修改添加新功能。

+   微程序控制器的特点。微程序控制器的优点是同组合逻辑控制器相比，微程序控制器具有规整性、灵活性、可维护性等一系列优点；缺点是由于微程序控制器采用了存储程序原理，所以每条指令都要从控制存储器中取一次，影响速度

| 对比项目\类别 |                         微程序控制器                         |                         硬布线控制器                         |
| :-----------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   工作原理    | 微操作控制信号以微程序的形式存放在控制存储器中，执行指令时读出即可 | 微操作控制信号由组合逻辑电路根据当前的指令码、状态和时序，即时产生 |
|   执行速度    |                    慢（从CM中读取微指令）                    |                              快                              |
|    规整性     |                            较规整                            |                         烦琐、不规整                         |
|   应用场合    |                           CISC CPU                           |                           RISC CPU                           |
|   易扩充性    |                          易扩充修改                          |                             困难                             |



## 异常和中断

![image-20230908204920928](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309082049701.png)

### 异常和中断的基本概念

+   内中断（**异常**、例外、陷入）信号来自$CPU$内部，与当前执行的命令有关，必须立刻处理，且对于无法恢复故障的需要终止进程.
    + 三种分类
        + 陷阱、自陷$Trap$：是一种事先安排的"异常"事件，用于在用户态下调用操作系统内核程序，此时会执行一条特殊的指令一一陷入指令，如条件陷阱指令引起的**访管中断**.

        + 故障$Fault$：通常是由指令执行引起的异常，如非法操作码、缺页故障、除数为零、运算溢出等.
        + 终止$Abort$：是指出现了使得$CPU$无法继续执行的硬件故障，如控制器出错、存储器校验错等.
    + ==无法被屏蔽==
    + 异常由指令在执行种产生，而中断不与指令相关，也不阻止指令的完成。
    + 异常的检测由$CPU$完成，不需要外部信号通知。中断必须$CPU$通过总线获取中断源标记信息才能知道中断的类型。
    + 异常是不可屏蔽的中断，而通过$INTR$信号线发出的中断是可屏蔽的中断。
+   外中断（**中断**）是来自$CPU$外部的设备向CPU发出的中断请求，通常用于信息的输入和输出，==与当前执行的命令无关==.
    + **可屏蔽中断**($INTR$)是指通过$INTR$线发出的中断请求，通过改变屏蔽字可以实现多重中断，从而使得中断处理更加灵活.
    + **非屏蔽中断 ($NMI$)**是指通过$NMI$线发出的中断请求，通常是紧急的硬件故障，如电源掉电等.
    + 常见外中断：
        + 外设请求：如$I/O$操作完成时发出的中断信号.
        + 时钟中断：时间片已到.
        + 人工干预.
+   异常和中断处理过程的大致描述如下：
    +   当CPU在执行用户程序的第i条指令时检测到一个异常事件，或者在执行第$i$条指令后发现一个中断请求信号，则CPU打断当前用户程序， 然后转到相应的异常或中断处理程序去执行。
    +   若异常或中断处理程序能够解决相应的问题， 则在异常或中断处理程序的最后，CPU通过执行异常或中断返回指令，==回到被打断的用户程序的第$i$条指令或第$i+1$条指令继续执行==
    +   若异常或中断处理程序发现是==不可恢复的致命错误==，则==终止用户程序==。
    +   ==通常情况下，对异常和中断的具体处理过程由操作系统（和驱动程序）完成==
    +   异常和中断的处理过程基本是相同的，这也是有些教材将两者统称为中断的原因。

### 异常和中断的分类

#### 异常/内中断的分类

+   异常是由CPU内部产生的意外事件，分为**硬故障中断**和**程序性异常**。
    +   硬故障中断是由硬连线出现异常引起的，如存储器校验错、总线错误等。
    +   程序性异常也称软件中断，是指在CPU内部因执行指令而引起的异常事件。
        +   如==整除0==、溢出、==断点==、单步跟踪、非法指令、栈溢出、==地址越界==、==缺页==等。
    +   按异常发生原因和返回方式的不同，可分为故障、自陷和终止
+   故障$Fault$：==属于程序性异常/软件中断==
    +   指在引起故障的指令启动后、执行结束前被检测到的异常事件。
    +   例如，指令译码时，出现“非法操作码”；取数据时，发生“缺段”或“缺页”；执行整数除法指令时，发现“除数为0”等。 
    +   对于“缺段”“缺页”等异常事件，经处理后，可将所需的段或页面从磁盘调入主存，回到发生故障的指令继续执行，==断点为当前发生故障的指令==
    +   对于“非法操作码”“除数为0”等，因为无法通过异常处理程序恢复故障，因此不能回到原断点执行，必须终止进程的执行
+   自陷$Trap$：==属于程序性异常/软件中断==
    +   自陷也称陷阱或陷入，它是预先安排的一种“异常”事件，就像预先设定的“陷阱” 一样。 
    +   通常的做法是：
        +   事先在程序中用一条特殊指令或通过某种方式设定特殊控制标志来人为设置一个“陷阱”
        +   当执行到被设置了 “陷阱”的指令时，CPU在执行完自陷指令后，自动根据不同“陷阱”类型进行相应的处理
        +   然后==返回到自陷指令的下一条指令==执行
        +   注意，当==自陷指令是转移指令时==， ==并不是返回到下一条指令执行，而是返回到转移目标指令执行==。 
    +   在x86机器中，==用于程序调试“断点设置”和单步跟踪的功能就是通过陷阱机制实现的==。
    +   此外，系统调用指令、条件自陷指令（如MIPS中的teq、teqi、tne> tnei等）等都属于陷阱指令， 执行到这些指令时，==无条件或有条件地自动调出操作系统**内核程序**进行执行==。 
+   终止$Abort$：和外中断都==属于硬件中断==
    +   如果在执行指令的过程中发生了使计算机无法继续执行的硬件故障，如控制器出错、存储器校验错等，那么程序将无法继续执行，只能终止
    +   此时，调出中断服务程序来重启系统。
    +   这种异常与故障和自陷不同，不是由特定指令产生的，而是随机发生的。 

#### 中断/外中断的分类

+   中断是指来自CPU外部、与CPU执行指令无关的事件引起的中断，包括I/O设备发出的I/O中断（如键盘输入、打印机缺纸等），或发生某种特殊事件（如用户按Esc键、定时器计数时间到）等。
+   外部I/O设备通过特定的中断请求信号线向CPU提出中断请求，==CPU每执行完一条指令就检查中断请求信号线==，如果检测到中断请求，则进入中断响应周期。 

中断可分为可屏蔽中断和不可屏蔽中断

+   可屏蔽中断：指通过可屏蔽中断请求线INTR向CPU发出的中断请求
    +   CPU可以通过在中断控制器中设置相应的屏蔽字来屏蔽它或不屏蔽它，被屏蔽的中断请求将不被送到CPU
+   不可屏蔽中断：指通过专门的不可屏蔽中断请求线NMI向CPU发出的中断请求，通常是非常紧急的硬件故障，如电源掉电等
    +   这类中断请求信号不可被屏蔽，以让CPU快速处理这类紧急事件。 

中断和异常在本质上是一样的，但它们之间有以下两个重要的不同点：

1.   “缺页”或“溢出”等异常事件是==由特定指令在执行过程中产生的==，而中断==不和任何指令相关联，也不阻止任何指令的完成==。
2.   异常的检测由CPU自身完成，不必通过外部的某个信号通知CPU。对于==中断，CPU必须通过**中断请求线**获取中断源的信息==，才能知道哪个设备发生了何种中断

### 异常和中断响应过程

+   从CPU检测到异常或中断事件，到调出相应的处理程序，整个过程称为异常和中断的响应

CPU对异常和中断响应的过程可分为：关中断、保存断点和程序状态、识别异常和中断并转到相应的处理程序。

1.   关中断
     +   通常通过设置“中断允许”($IF$)触发器来实现
     +   若IF置为1，则为开中断，表示==允许响应中断==
     +    若IF置为0，则表示关中断，表示不允许响应中断。
2.   保存断点和程序状态
     +   为了能在异常和中断处理后正确返回到被中断的程序继续执行，必须将程序的断点(返回地址)送到栈或特定寄存器中。
     +   ==通常保存在栈中，这是为了支持异常或中断的嵌套==。 
     +   异常和中断处理后可能还要回到被中断的程序继续执行，被中断时的**程序状态字寄存器**$PSWR$的内容也需要保存在栈或特定寄存器中，在异常和中断返回时恢复到**程序状态字寄存器**$PSWR$中
3.   识别异常和中断并转到相应的处理程序
     +   异常和中断源的识别有软件识别和硬件识别两种方式。
     +   异常和中断源的识别方式不同，==异常大多采用软件识别方式==，而==中断可以采用软件识别方式或硬件识别方式==。 
     +   **软件识别方式**是指CPU设置一个异常状态寄存器，用于记录异常原因。操作系统使用一个统一的异常或中断查询程序，按优先级顺序查询异常状态寄存器，以检测异常和中断类型，先查询到的先被处理，然后转到内核中相应的处理程序。 
     +   **硬件识别方式**又称**向量中断**，异常或中断处理程序的首地址称为中断向量，所有中断向量都存放在中断向量表中。
         +   每个异常或中断都被指定一个中断类型号。
         +   在中断向量表中，类型号和中断向量一一对应，因而可以根据类型号快速找到对应的处理程序。 

整个响应过程是不可被打断的。中断响应过程结束后，CPU就从PC中取出==中断服务程序的第一条指令==开始执行，直至中断返回，这部分任务是由CPU通过执行中断服务程序完成的，==整个中断处理过程是由软/硬件协同实现的==

## 指令流水线

![1](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309082046037.png)

### 流水线基本概念

可从两方面提高处理机的并行性：

1.   时间上的并行技术，将一个任务分解为几个不同的子阶段，每个阶段在不同的功能部件上并行执行，以便在同一时刻能够同时执行多个任务，进而提升系统性能，这种方法被称为**流水线技术**。
2.   空间上的并行技术，在一个处理机内设置多个执行相同任务的功能部件，并让这些功能部件并行工作，这样的处理机被称为**超标量处理机**

超标量流水线是指在一个时钟周期内一条流水线可执行一条以上的指令

$m$段流水线和$m$个并行部件的吞吐能力等同

#### 指令流水线定义

假设一条指令的执行过程分为如下5个阶段（也称功能段或流水段）：

1.   取指$IF$：从指令存储器或Cache中取指令。
2.   译码/读寄存器$ID$：操作控制器对指令进行译码，同时从寄存器堆中取操作数。
3.   执行/计算地址$EX$：执行运算操作或计算地址。
4.   访存$MEM$：对存储器进行读写操作。
5.   写回$$WB$$：将指令执行结果写回寄存器堆。

把$k+1$条指令的**取指阶段**提前到第$k$条指令的**译码阶段**，从而将第$k+1$条指令的译码阶段与第$k$条指令的执行阶段同时进行，如图5.16所示

![image-20230910111951960](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309101119083.png)

理想情况下，每个时钟周期都有一条指令==进入流水线，每个时钟周期都有一条指令完成，每条指令的时钟周期数$CPI$都为1==。

流水线设计的原则是，指令流水段个数以最复杂指令所用的功能段个数为准，流水段的长度以最复杂的操作所花的时间为准

>   假设某条指令的5个阶段所花的时间分别如下。①取指:200ps； ②译码：100ps；③执行：150ps；④访存：200ps；⑤写回：100ps,该指令的总执行时间为750ps。 
>
>   按照流水线设计原则，每个流水段的长度为200ps，所以每条指令的执行时间为Ins，反而比串行执行时增加了 250pso假设某程序中有N条指令，单周期处理机所用的时间为Nx750ps，而流水线处理机所用的时间为（N+4）x200ps。

流水线方式==并不能缩短单条指令的执行时间==， 但对于整个程序来说，==执行效率得到了大幅增高==

为了利于实现指令流水线，指令集应具有如下特征：

1.   ==指令长度应尽量一致==，有利于简化取指令和指令译码操作。否则，取指令所花时间长短不一，使取指部件极其复杂，且也不利于指令译码。
2.   指令格式应尽量规整，尽量保证==源寄存器的位置相同==，有利于在指令未知时就可取寄存器操作数，否则须译码后才能确定指令中各寄存器编号的位置
3.   让$Load/Store$指令唯一访问存储器。
4.   数据和指令在存储器种对齐存放。

#### 流水线表示

通常使用时空图直观描述流水线的执行情况

![image-20230910112448657](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309101124788.png)

只有大量连续任务不断输入流水线，才能充分发挥流水线的性能，而==指令的执行正好是连续不断的，非常适合采用流水线技术==。对于其他部件级流水线，如浮点运算流水线，同样也仅适合于提升浮点运算密集型应用的性能，对于单个运算是无法提升性能的

### 流水线的基本实现

#### 流水线的数据通路

+   一个5段流水线数据通路如图5.19所示。
+   假如各部件实际耗时：$100ns$、$80ns$、$70ns$、$50ns$、$50ns$，为方便流水线的设计，将每个阶段的耗时取成一样，以**最长耗时**为准。即此处应将机器周期设置为$100ns$。
    +   若有寄存器延时还应该加上寄存器延时

+   其中，==不包括控制部件==：
    +   IF段包括程序计数器（PC）、指令存储器、 下条指令地址的计算逻辑
    +   ID段包括操作控制器、取操作数逻辑、立即数符号扩展模块
    +   EX段主要包括算术逻辑单元（ALU）、分支地址计算模块
    +   MEM段主要包括数据存储器读写模块
    +   WB段主要包括寄存器写入控制模块。
+   每个流水段后面都需要增加一个流水寄存器，或称为**锁存器**，用于锁存本段处理完成的数据和控制信号，以保证本段的执行结果能在下个时钟周期给下一流水段使用，图中增加了4个流水寄存器，并根据其所连接的功能段来命名。
+   各种寄存器和数据存储器均采用统一时钟CLK进行同步，每来一个时钟，就会有一条新的指令进入流水线IF段，同时流水寄存器会锁存前段加工处理完成的数据和控制信号，为下一段的功能部件提供数据输入。

![image-20230910113921940](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309101139161.png)

+   $CISC $中$ID$中数据来源于寄存器
+   $ID$中读和$WB$中写可能存在冲突

#### 流水线的控制信号

+   在某一时刻，每个流水段执行不同指令的某个阶段，每个流水段还需要正在执行指令的对应功能段的控制信号
+   图5.19中的控制信号(虚线表示)如表5.3所示。控制信号的来源并不一致，如IF段的分支转跳信号BranchTaken来源于EX段，ID段的RegWrite信号来源于WB段，其他控制信号通过控制器产生，由ID段负责译码生成控制信号，并分别在随后的各个时钟周期内使用。

![image-20230910114425684](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309101144857.png)

+   每个流水寄存器中保存的信息包括：
    1.   后面流水段需要用到的==所有数据信息==
         +   包括PC+ 4、指令、立即数、目的寄存器、ALU运算结果、标志信息等
         +   它们是前面阶段在数据通路中执行的结果；
    2.   前面传递过来的后面各流水段要用到的==所有控制信号==

### 流水线的冒险和处理

在指令流水线中，可能会遇到一些情况使得流水线无法正确执行后续指令而==引起流水线阻塞或停顿==，这种现象称为**流水线冒险**。根据导致冒险的原因不同主要有3种：结构冒险（资源冲突）、 数据冒险（数据冲突）和控制冒险（控制冲突）。

#### 结构冒险（资源冲突）—互斥问题

![image-20230603224708919](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603224708919.png)

+ 由于多条指令在==同一时刻争用同一资源==而形成的冲突称为**结构冒险**。

    + 也称为**资源冲突**，即由硬件资源竞争造成的冲突

+ 解决办法：
    1. 前一指令访存时，使后一条相关指令（以及其后续指令）暂停一个时钟周期。

    2. 单独设置数据存储器和指令存储器，使取数和取指令操作各自在不同的存储器中进行。 

        +   事实上，==现代计算机都引入了 Cache机制==，而L1 Cache通常采用==数据Cache和指令Cache分离==的方式，因而也就==避免了资源冲突的发生==

        ![image-20230603224807896](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603224807896.png)

#### 数据冒险（数据冲突）—同步问题

+   数据的基本操作：读、写。
+   数据冒险指在一个程序中，存在必须等前一条指令执行完才能执行后一条指令的情况，则这两条指令即为数据冒险。
    +   上一个指令想要写的存储器会被下一条指令读就有可能发生数据冒险


![image-20230603224851784](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603224851784.png)

+ 冲突的基本类型：
    + 写后读$RAW$：没有写完就读取，按序发射，按序完成只会出现写后读的错误。
    + 读后写$WAR$：乱序发射，优化手段导致指令顺序不符合编写程序时预想的逻辑顺序。
    + 写后写$WAW$：存在多个功能部件时，后一条指令先于前一条指令完成。

+ 解决办法：
    1. 把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行。

        +   可分为**硬件阻塞**$stall$和软件插入**空指令**$NOP$两种方法。

        + ==每个**空指令**$NOP$也有完整的五个阶段==

            ![image-20230603225205192](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603225205192.png)

    2. 数据旁路技术：计算得到结果后不写回，直接当作输入使用。

        +   ==硬件措施==

        ![image-20230603225324884](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603225324884.png)
    
    3. 编译优化：通过编译器调整指令顺序来解决数据相关。
        + 后续指令不依赖之前的计算结果时提前执行

#### 控制冒险（控制冲突）

![image-20230603225534316](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603225534316.png)

+ 指令通常是顺序执行的，但是在遇到改变指令执行顺序的情况，例如执行转移、调用或返回等指令时，会改变PC值造成断流，从而引起**控制冒险**
+ 主要针对转移指令。
+ 解决办法：
    1. 分支预测，尽早判别转移是否发生，尽早生成转移目标地址。
        1. 简单预测：永远猜$True$或$False$
        2. 动态预测：根据历史情况动态调整，有较高的预测准确率
    2. 预取转移成功和不成功两个控制流方向上的目标指令。
    3. 加快和提前形成条件码。
    4. 提高转移方向的猜准率。

>   Cache缺失的处理过程也会引起流水线阻塞。在不过多增加硬件成本的情况下，如何尽可能地提高指令流水线的运行效率是选用指令流水线技术必须解决的关键问题

#### 流水线阻塞

真题中常出现流水线的阻塞现象

1.   若上一条指令的WB写回的寄存器与本指令对应的寄存器相同，会发生资源冲突。这时有3个时钟周期的阻塞，使本指令ID应在上一条WB后，如下图所示

     ![image-20230910213933096](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309102139314.png)

     第三条指令$I_3$由于$I_1$与$I_2$和$I_3$都存在数据相关，需等到$I_1$和$I_2$将结果写回寄存器后，$I_3$才能读寄存器内容，所以阻塞了 3个时钟周期

     第四条指令$I_4$由于其前一条指令$I_3$在ID段被阻塞，所以$I_4$的IF段被阻塞。

2.   跳转指令（JMP） （bra）：由于流水线默认直接提取下一条指令，若指令为JMP或JC （根据情况预判跳转结果），在没有分支预测的情况下，默认有3个时钟周期的阻塞使本指令ID应在上一条WB后。

     +   bne表示条件跳转（branch not equal）指令。 

### 流水线的性能指标

1. 吞吐率：

    + 指在单位时间内流水线所完成的任务数量，或是输出结果的数量。

    + 设任务数为$n$，处理完成$n$个任务所用的总时间为$T_k$，则计算流水线吞吐率$TP$​的最基本的公式为
        $$
        TP=\dfrac{n}{T_k}
        $$

    + 在最理想情况下（取一个机器周期=一个时钟周期）：

        + 令每个指令分为$k$个阶段，每个阶段所需时间为$\Delta t$（==一般等于一个时钟周期==），则
            $$
            T_k=(k+n-1)\Delta t\\
            TP=\dfrac{n}{(k+n-1)\Delta t}
            $$

            + 当连续输入的任务$n\to \infty$时，得最大吞吐率为$TP_{max}=\frac{1}{\Delta t}$

    + 第一个指令执行阶段称为装入时间，最后一个指令执行的阶段称为排空时间。

        ![image-20230603222647289](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603222647289.png)

2. 加速比：

    + 完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比。

    + 在最理想情况下：

        + 设$T_0$表示不使用流水线时的执行时间，即顺序执行所用的时间，$T_k$表示使用流水线时的执行时间，则计算流水线加速比$S$​的基本公式为
            $$
            S=\dfrac{T_0}{T_k}
            $$

        + 单独完成一个任务需要$k\Delta t$，则顺序完成时间$T_0=nk\Delta t$​，则
            $$
            T_k=(k+n-1)\Delta t\\
            S=\dfrac{n\cdot k\cdot \Delta t}{(k+n-1)\Delta t}=\dfrac{k\cdot n}{k+n-1}
            $$

            + 当连续输入的任务$n\to \infty$时，得最大加速比为$S_{max}=k$

    ![image-20230603222919889](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603222919889.png)

3. 效率*：

    + 流水线的设备利用率称为流水线的效率。

    + 在时空图上，流水线的效率定义为完成$n$个任务占用的时空区有效面积与$n$个任务所用的时间与k个流水段所围成的时空区总面积之比。（时空图中用到的类平行四边形面积除以围成矩形的面积）。

    + 流水线效率$E$​的基本公式为
        $$
        E=\dfrac{T_0}{k\cdot T_k}=\dfrac{n}{k+n-1}
        $$

        + 当连续输入的任务$n\to \infty$时，得最大效率为$E_{max}=1$

        ![image-20230603223135052](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603223135052.png)

### 流水线分类

+ 根据流水线使用的级别的不同：
    + **部件功能级流水线**就是将复杂的算术逻辑运算组成流水线工作方式。例如，可将浮点加法操作分成求阶差、对阶、尾数相加以及结果规格化等4个子过程。
    + **处理机级流水线**是把一条指令解释过程分成多个子过程，如前面提到的取指、译码、执行、访存及写回$5$个子过程。
    + **处理机间流水线**是一种流水线，其中每一个处理机完成某一专门任务，各个处理机所得到的结果需存放在与下一个处理机所共享的存储器中。
+ 按流水线可以完成的功能：
    + **单功能流水线**指只能实现一种固定的专门功能的流水线。
    + **多功能流水线**指通过各段间的不同连接方式可以同时或不同时地实现多种功能的流水线。
+ 按同一时间内各段之间的连接方式：
    + **静态流水线**指在同一时间内，流水线的各段只能按同一种功能的连接方式工作。
    + **动态流水线**指在同一时间内，当某些段正在实现某种运算时，另一些段却正在进行另一种运算。这样对提高流水线的效率很有好处，但会使流水线控制变得很复杂。
+ 按流水线的各个功能段之间是否有反馈信息：
    + **线性流水线**中，从输入到输出，每个功能段只允许经过一次，不存在反馈回路。
    + **非线性流水线**存在反馈回路，从输入到输出过程中，某些功能段将数次通过流水线，这种流水线适合进行线性递归的运算。

### 高级流水线技术

有两种增加指令级并行的策略：

1. **超标量流水线技术/动态多发射技术**：

    + 每个时钟周期内可并发多条独立指令。

    + 以并行操作方式将两条或多条指令编译并执行，为此需配置多个功能部件

    + 不能调整指令的执行顺序。

    + 在==简单的==超标量CPU中，指令是==按顺序发射执行==的

    + 为了更好地==提高并行性能==，多数超标量CPU都结合动态流水线调度技术，通过动态分支预测等手段，==指令不按顺序执行==，这种执行方式称为**乱序执行**。

        ![image-20230603230212709](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603230212709.png)

2. 超长指令字技术/静态多发射技术：

    + 由**编译程序**挖掘出指令间**潜在**的并行性，将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字(可达几百位)。

    + 需要采用多个处理部件更大的$Cache$。

        ![image-20230603230302644](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603230302644.png)

3. 超流水技术：

    + 流水线功能段划分得越多，时钟周期就越短，指令吞吐率也就越高

    + 超流水线技术通过==提高流水线主频==的方式来提升流水线性能

    + 但是，流水线级数越多，用于流水寄存器的开销就越大，因而==流水线级数是有限制的==，并不是越多越好。

    + 在一个时钟周期内再分段。

    + 在一个时钟周期内单个功能部件使用多次。

    + 不能调整指令的执行顺序，靠编译来优化。

        ![image-20230603230251081](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603230251081.png)

## 多处理器

![image-20230908204937142](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202309082049189.png)

### 指令数据流结构

基于指令流的数量和数据流的数量，Flynn分类法将计算机体系结构分为SISD、SIMD、MISD和MIMD四类。

==常规的单处理器属于SISD，而常规的多处理器属于MIMD==

#### 单指令流单数据流SISD结构

+ 单指令流和单数据流系统，即传统冯·诺依曼体系结构。
+ 只有一个处理器和存储器，在一段时间内一次性只执行一条指令。
+ 使用流水线技术，所以设置多个功能部件，采用多模块交叉组织存储器。

#### 单指令流多数据流SIMD结构

+ 一个指令流同时对多个数据进行处理，一般称为数据级并行技术。
+ 有一个指令控制部件和多个处理单元。
+ 每个处理单元虽然执行的都是同一条指令，但是==每个单元都有自己的地址寄存器==，这样每个单元就都有不同的数据地址。
    + 因此，==不同处理单元执行的同一条指令所处理的数据是不同的==

+ 一个顺序应用程序被编译后，可能按SISD组织并运行于串行硬件上，也可能按SIMD组织并运行于并行硬件上。
+ 适合循环结构，不适合选择结构。
    + 使用`for`循环处理数组时最有效
        + 一条分别对16对数据进行运算的SIMD指令如果在16个ALU中同时运算，则只需要一次运算时间就能完成运算

    + 在使用`case`或`switch`语句时效率最低

+ 包括阵列处理器和向量处理器系统。
    + 向量处理器系统是一种实现了直接操作一维数组（向量）指令集的$CPU$，而串行处理器只能处理单一数据集。
    + 其基本理念是将从存储器中收集的一组数据按顺序放到一组向量寄存器中，然后以流水化的方式对它们依次操作，最后将结果写回寄存器。
    + 向量处理器在特定工作环境中极大地提升了性能，尤其是在数值模拟或者相似的领域中。


#### 多指令流单数据流MISD

同时执行多条指令，处理同一个数据，这种计算机实际上不存在。

==多指令流必定多数据流==

#### 多指令流多数据流MIMD

+ 多条指令分别处理多个不同的数据，是一种并行程度更高的线程级并行或线程级以上并行计算模式。
+ 包括多处理器和多计算机系统。
+ 多计算机系统中的每个计算机节点都具有各自的私有存储器，并且具有独立的主存地址空间，不能通过存取指令来访问不同节点的私有存储器，而要通过消息传递进行数据传送，也称消息传递$MIMD$。
+ 多处理器系统是共享存储多处理器$SMP$系统的简称，它具有共享的单一地址空间，通过存取指令来访问系统中的所有存储器，也称共享存储$MIMD$。

### 硬件多线程

为减少线程切换的开销，产生硬件多线程。在支持便件多线程的$CPU$中，必须为每个线程提供单独的通用寄存器组、单独的程序计数器等，线程的切换只需激活选中的寄存器，从而省略了与存储器数据交换的环节，大大减少了线程切换的开销。

#### 细粒度多线程

多个线程之间轮流交叉执行指令，多个线程之间的指令是不相关的，可以乱序并行执行。

在这种方式下，处理器能在每个时钟周期切换线程。

| 时钟 | 当前执行指令所属线程 |
| :--: | :------------------: |
|  1   |          A           |
|  2   |          B           |
|  3   |          A           |
|  4   |          C           |
|  5   |          B           |

#### 粗粒度多线程

仅在一个线程出现了较大开销的阻塞时，才切换线程，如$Cache$缺失。

在这种方式下，当发生流水线阻塞时，必须清除被阻塞的流水线，新线程的指令开始执行前需要重载流水线，因此，线程切换的开销比细粒度多线程更大。

| 时钟 | 当前执行指令所属线程 |
| :--: | :------------------: |
|  1   |          A           |
|  2   |          A           |
|  3   |          B           |
|  4   |          B           |
|  5   |          C           |

#### 同时多线程

+   同时多线程$SMT$是上述两种多线程技术的变体。它在实现指令级并行的同时，实现线程级并行，也就是说，它在同一个时钟周期中，发射多个不同线程中的多条指令执行。
+   Intel处理器中的超线程$HT(Hyper\;Threading)$就是同时多线程$SMT$，即在一个单处理器或单个核中设置了两套线程状态部件，共享高速缓存和功能部件
    +   超线程技术是在一个CPU中，提供两套线程处理单元，让单个处理器实现线程级并行
    +   虽然采用超线程技术能够同时执行两个线程，但是当两个线程同时需要某个资源时，其中一个线程必须暂时挂起，直到这些资源空闲后才能继续运行，因此，超线程的性能并不等于两个CPU的性能。
    +   而且，超线程技术的CPU需要芯片组、操作系统（如Windows 98不支持超线程技术）和应用软件的支持，才能发挥该项技术的优势。
    +   双核技术是指将两个一样的CPU集成到一个封装内（或者直接将两个CPU做成一个芯片），而超线程技术在CPU内部仅复制必要的线程资源来让两个线程同时运行，能并行执行两个线程，模拟实体双核心。

| 时钟 | 当前执行指令所属线程 |
| :--: | :------------------: |
|  1   |          AB          |
|  2   |          AC          |
|  3   |          BC          |

### 多核处理器

+ 多核处理器是指将多个处理单元集成到单个$CPU$中，每个处理单元称为一个核，可以同时执行多个运算。
+ 每个核可以有自己的$Cache$，也可以共享同一个$Cache$。
+ 所有核一般都是对称的，并且共享主存储器，因此多核属于共享存储的对称多处理器。
+ 在多核计算机系统中，如要充分发挥硬件的性能，必须采用多线程/多进程执行，使得==每个核在同一时刻都有线程在执行==。
    + 与单核上的多线程不同，多核上的多个线程是在物理上并行执行的，是真正意义上的并行执行，==在同一时刻有多个线程在并行执行==。
    + 而单核上的多线程是一种多线程交错执行，实际上在同一时刻只有一个线程在执行


### 共享内存多处理器

具有共享的单一物理地址空间的多处理器被称为共享内存多处理器$SMP$。

处理器==通过存储器中的共享变量互相通信==，所有处理器都能==通过存取指今访向任何存储器==的位置。

注意，即使这些系统共享同一个物理地址空间，它们仍然可在自己的虚拟地址空间中单独地运行程序。

单一地址空间的多处理器有两种类型：

+ 统一存储访问$UMA$多处理器
    + 每个处理器对所有存储单元的访问时间是大致相同的
        + 即==访问时间与哪个处理器提出访存请求及访问哪个字无关==。
    + 根据处理器与共享存储器之间的连接方式，分为基于总线、基于交叉开关网络和基于多级交换网络连接等几种处理器。
    + 需要解决$Cache$一致性问题。
    + 早期计算机，内存控制器没有整合进CPU，访存操作需要经过北桥芯片（集成了内存控制器，并与内存相连），CPU通过前端总线和北桥芯片相连
+ 非统一存储访问$NUMA$多处理器
    + 某些访存请求要比其他的快，具体取决于哪个处理器提出了访问请求以及访问哪个字，这是由于主存被分割并分配给了同一机器上的不同处理器或内存控制器。
    + 处理器中不带高速缓存时，被称为$NC-NUMA$，处理器中带有一致性高速缓存时，被称为$CC-NUMA$。
    + 内存控制器被集成到CPU内部，每个CPU都有独立的内存控制器
    + 每个CPU都独立连接到一部分内存，CPU直连的这部分内存被称为**本地内存**
    + 在NUMA架构下，内存的访问出现了本地和远程的区别，访问本地内存明显要快于访问远程内存
    + 拓展性更强。
