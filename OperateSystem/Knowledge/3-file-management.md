# 第四章 文件管理

## 导读

### 【考纲内容】

1. 文件
    + 文件的基本概念
    + 文件元数据和索引结点($inode$)
    + 文件的操作
        + 建立
        + 删除
        + 打开
        + 关闭
        + 读
        + 写
    + 文件的保护
    + 文件的逻辑结构
    + 文件的物理结构
2. 目录
    + 目录的基本概念
    + 树形目录
    + 目录的操作
    + 硬链接和软链接
3. 文件系统
    + 文件系统的全局结构($layout$)
    + 文件系统在外存中的结构，文件系统在内存中的结构
    + 外存空闲空间管理办法
    + 虚拟文件系统
    + 文件系统挂载（$mounting$)

### 【知识导图】

### 【复习提示】

+ 本章内容较为具体，要注意对概念的理解。重点掌握文件系统的结构及其实现、文件分配和
    空闲空间管理等。要掌握文件系统的文件控制块、物理分配方法、索引结构、树形目录结构、文件共享原理、文件系统的布局、虚拟文件系统原理等。这些都是统考真题易考查的内容。

## 文件系统

文件系统不仅管理普通文件，对于$UNIX$系统所有设备都被视为特殊文件。

### 文件系统基础

![image-20230626222700660](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262227751.png)

#### 文件基本属性

操作系统通过文件控制块$FCB$来保护文件元数据：

+ 文件名
    + 由创建文件的用户决定文件名，主要是为了方便用户找到文件
    + 同一目录下不允许有重名文件。

+ 标识符
    + 一个系统内的各文件标识符唯一，对用户来说毫无可读性
    + 因此标识符只是操作系统用于区分各个文件的一种内部名称。

+ 类型
    + 指明文件的类型。

+ 位置
    + 文件存放的路径（让用户使用）
    + 在外存中的地址（操作系统使用，对用户不可见）。

+ 大小
    + 指明文件大小。

+ 创建时间。
+ 上次修改时间。
+ 文件所有者信息。
+ 保护信息
    + 对文件进行保护的访问控制信息。


#### 文件组织形式

+ 无结构文件（如文本文件)
    + 由一些二进制或字符流组成，又称“流式文件”
+ 有结构文件（如数据库表）
    + 目录也是一种特殊的有结构文件
    + 由一组相似的记录组成，又称“记录式文件”
    + 记录是一组相关数据项的集合
    + 数据项是文件系统中最基本的数据单位
    + 有结构文件中，各个记录间应该如何组织的问题,顺序存放$OR$索引表
        + 这是后文“文件的逻辑结构”重点要探讨的问题

#### 文件存放在外存的形式

+ 与内存一样，外存也是由一个个存储单元组成的，每个存储单元可以存储一定量的数据（如$1B$)。
    + 每个存储单元对应一个物理地址
+ 类似于内存分为一个个“内存块”，外存会分为一个个“块/磁盘块/物理块”
    + 每个磁盘块的大小是相等的，每块一般包含$2$的整数幂个地址
    + 同样类似的是，文件的逻辑地址也可以分为（逻辑块号，块内地址），操作系统同样需要将逻辑地址转换为外存的物理地址（物理块号，块内地址）的形式
    + 块内地址的位数取决于磁盘块的大小
+ 后文“文件的物理结构”重点要探讨的问题
    + 文件数据放在连续的几个磁盘块中
    + 文件数据放在离散的几个磁盘块中

#### 文件基本概念

用户输入输出以文件为基本单位。

+ 数据项
    + 最低级数据组织形式
        + 基本数据项
            + 用于描述一个对象的某种属性的一个值，是数据中可命名的最小逻辑数据单位，即原子数据。
        + 组合数据项
            + 多个基本数据项构成。
+ 记录：一组相关数据项的集合，用于表述一个对象在某方面的属性。
+ 文件：一组有意义的信息/数据的集合。
+ 操作系统以“块”为单位为文件分配存储空间，外存中的数据读入内存同样以块为单位。



#### 文件控制块

![image-20230626231528261](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262315381.png)

+ 目录本身就是一种有结构文件，由一条条记录组成
    + 每条记录对应一个在该放在该目录下的文件。
    + ![image-20230626225353206](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262253274.png)

+ 目录文件中的一条记录就是一个**文件控制块**（$FCB$）
    + $FCB$的有序集合就是文件目录，一个$FCB$就是一个文件目录项
    + ![image-20230626225547911](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262255984.png)

+ $FCB$中包含了
    + 文件的基本信息
        + 文件名、物理地址、逻辑结构、物理结构等

    + 存取控制信息
        + 是否可读/可写、禁止访问的用户名单等

    + 使用信息
        + 如文件的建立时间、修改时间等

    + 最重要最基本的就是文件名和文件存放物理地址。

+ $FCB$实现了文件名与文件之间的映射，使得用户（用户程序）可以实现按名存取。
+ 需要对目录进行的操作
    + 搜索
        + 当用户要使用一个文件时，系统要根据文件名搜索目录，找到该文件对应的目录项

    + 创建文件
        + 创建一个新文件时，需要在其所属的目录中增加一个目录项

    + 删除文件
        + 当删除一个文件时，需要在目录中删除相应的目录项

    + 显示目录
        + 用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性

    + 修改目录
        + 某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项
        + 如：文件重命名


#### 索引结点

+ 其实在查找各级目录的过程中只需要用到“文件名”这个信息，只有文件名匹配时，才需要读出文件的其他信息
    + 因此可以考虑让目录表“瘦身”来提升效率。

+ 所以目录只包含文件名与索引结点指针，除了文件名之外的文件描述信息都存放在索引结点之中
    + 索引结点是对$FCB$的改进。
    + ![image-20230626231131920](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262311980.png)

+ 假设一个$FCB$是$64B$，磁盘块的大小为$1KB$，则每个盘块中只能存放$16$个$FCB$
    + 若一个文件目录中共有$640$个目录项，则共需要占用$640\div16=40$个盘块
    + 因此按照某文件名检索该目录，使用折半查找平均需要查询$320$个目录项，平均需要启动磁盘$20$次
        + 每次磁盘$I/O$读入一块

+ 若使用索引结点机制，文件名占$14B$，索引结点指针站$2B$，则每个盘块可存放$64$个目录项，那么按文件名检索目录平均只需要读入$320\div64=5$个磁盘块
    + 显然，这将大大提升文件检索速度。


+ 当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件。
    + 存放在**外存**中的索引结点称为“磁盘索引结点”
    + 当索引结点放入**内存**后称为“内存索引结点”
    + 相比之下内存索引结点中需要增加一些信息，比如：文件是否被修改、此时有几个进程正在访问该文件等。

+ “磁盘索引结点”：存放在外存中的索引结点，每个文件有一个唯一的磁盘索引结点。
    + 文件主标识符。
    + 文件类型。
    + 文件存取权限。
    + 文件物理地址。
    + 文件长度。
    + 文件链接计数。
    + 文件存取时间。
+ “内存索引结点”：存放在内存中的索引结点，文件打开后将磁盘索引结点复制到内存中。
    + 相比之下内存索引结点中需要增加一些信息：
    + 索引结点编号。
    + 状态。
    + 访问计数。
    + 逻辑设备号。
    + 链接指针。

### 文件逻辑结构

![image-20230626225052485](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262250534.png)

+ 所谓的“逻辑结构”，就是指在用户看来，文件内部的数据应该是如何组织起来的。而“物理结构”指的是在操作系统看来，文件的数据是如何存放在外存中的。
+ 类似于数据结构的“逻辑结构”和“物理结构”。
    + 如“线性表”就是一种逻辑结构，在用户角度看来，线性表就是一组有先后关系的元素序列，
+ 而“线性表”这种逻辑结构可以用不同的物理结构实现
    + 如：顺序表/链表。顺序表的各个元素在逻辑上相邻，在物理上也相邻
    + 而链表的各个元素在物理上可以是不相邻的
    + 因此，顺序表可以实现“随机访问”，而“链表”无法实现随机访问。
+ 可见，算法的具体实现与逻辑结构、物理结构都有关
    + 文件也一样，文件操作的具体实现与文件的逻辑结构、物理结构都有关

#### 文件分类及逻辑结构

分为无结构文件与有结构文件。

+ 无结构文件（如文本文件）：
    + 由一些二进制或字符流组成，又称“流式文件”。
    + 以$Byte$为单位。
    + 只能通过穷举进行搜索。
    + 管理简单，适用于字符流的无结构方式，如源程序文件、目标代码文件等。
    + 例如$Windows$操作系统中的`. txt` 文件
+ 有结构文件（如数据库表）
    + 由一组相似的记录组成
        + 每条记录又若干个数据项组成，数据项又包含多个属性，是文件系统中最基本的数据单位

    + 又称“记录式文件”
    + 每条记录有一个数据项可作为关键字（如$ID$）。
    + 可以根据各条记录的长度（占用的存储空间）是否相等，可分为**定长记录**和可变长记录两种。
    + ![image-20230626223426807](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262234877.png)


有结构文件的逻辑结构：

+ 顺序文件。
+ 索引文件。
+ 索引顺序文件。
+ 散列文件。

#### 顺序文件

文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的。各个记录在物理上可以顺序存储或链式存储。

根据关键字与顺序之间的关系：

+ 串结构(链式存储)
    + 记录之间的顺序与关键字无关
    + 一般按记录存入时间决定记录的顺序
    + ![image-20230626223518827](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262235869.png)

+ 顺序结构(顺序存储)
    + 记录之间的顺序按关键字顺序排列。
    + ![image-20230626223510675](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262235713.png)


如何访存顺序文件：

+ 链式存储
    + 无论是定长/可变长记录，都**无法实现随机存取**，**每次只能从第一记录开始依次往后查找**。

+ 顺序存储：
    + 可变长记录
        + **无法实现随机存取**
        + 每次只能从第一个记录开始依次往后查找。因为需要显式地给出记录长度
        + ![image-20230626223751118](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262237163.png)
    + 定长记录：
        + **可实现随机存取**。记录长度为$L$，则第$i$个记录存放的相对位置是$i\times L$。
        + 若采用串结构，只能从头开始查找，无法快速找到某关键字对应的记录。
        + 若采用顺序结构，可以快速找到某关键字对应的记录（如折半查找）
        + ![image-20230626223851744](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262238793.png)
        + **【注意】：**
            + 一般来说，考斌题目中所说的“顺序文件”指的是**物理上顺序存储的顺序文件**

+ 可见，顺序文件的缺点是**增加/删除一个记录比较困难**
    + 如果是串结构则相对简单一点
+ 顺序文件插入删除文件比较麻烦。一般实际实现时会隔一个时间段集中将修改写入到文件中。

#### 索引文件

+ 为了解决顺序文件查找速度慢问题，建立一张索引表存放每个文件所存放的块盘地址，以加快文件检索速度
    + 每条记录对应一个索引项。
    + ![image-20230626224218240](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262242286.png)

+ 记录可以离散存放，而索引表必须连续存放。
+ 索引表包含索引号，长度，指针三个部分
    + 其本身是定长长度的顺序文件，所以可以快速找到索引，通过指针随机访问。

+ 可将关键字作为索引号内容，若按关键字顺序排列，则还可以支持按照关键字折半查找。
+ 每当要增加/删除一个记录时，需要对索引表进行修改。
+ 由于索引文件有很快的检索速度，因此**主要用于对信息处理的及时性要求比较高的场合**。
+ 可以使用不同的数据项对一组数据建立多个索引表。
+ 索引表其实是索引顺序结构的。
+ 对于$N$条记录的顺序文件，查找关键字记录需要$N/2$次，在索引顺序文件中，将其分为$\sqrt{N}$组，每组$\sqrt{N}$条记录，所以索引表查找需要$\dfrac{\sqrt{N}}{2}$次，主文件顺序查找也需要$\dfrac{\sqrt{N}}{2}$次，所以一共需要查找$\sqrt{N}$次。

#### 索引顺序文件

类似于字典。

+ 因为每个记录对应一个索引表项，因此索引表可能会很大
    + 同时若数据长度本身远小于索引表项长度，则空间利用率会很低。

+ 索引顺序文件是索引文件和顺序文件思想的结合
    + 索引顺序文件中，同样会为文件建立一张索引表，但不同的是并不是每个记录对应一个索引表项，而是一组记录对应一个索引表项
    + ![image-20230626224506881](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262245941.png)

+ 每个分组就是一个顺序文件（组间有序），分组内的记录不需要按关键字排序（组内无序）。
+ 索引项页不需要按关键字顺序排列，从而能便利插入删除。
+ 索引顺序文件的索引表其实是**定长记录**的**串结构**的**顺序文件**。
+ 检索效率分析
    + ![image-20230626224935856](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262249900.png)

+ 为了进一步提高索引效率，可以建立多级索引表。
    + ![image-20230626225030820](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262250876.png)


#### 散列文件

也称为直接文件。给定记录的键值或通过散列函数转换的键值直接决定记录的物理地址。这种映射结构不同于顺序文件或索引文件，没有顺序的特性。

散列文件有很高的存取速度，但是会引起冲突，即不同关键字的散列函数值相同。

### 文件物理结构

![image-20230627000929742](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306270009818.png)

![image-20230626231857349](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262318396.png)

+ 文件物理结构即文件分配方式，是对非空间磁盘块的管理。
    + 连续分配
    + 链接分配
        + 隐式链接
        + 显式链接
    + 索引分配
+ 文件物理结构即文件数据应该怎样存放在外存中

#### 文件块与磁盘块

+ 类似于内存分页，磁盘中的存储单元也会被分为一个个“块/磁盘块/物理块”
    + 很多操作系统中，磁盘块的大小与内存块、内存页面的大小相同。
        + 便于数据交换

+ 内存与磁盘之间的数据交换（即读/写操作、磁盘$I/O$)都是以“块”为单位进行的
    + 即每次读入一块，或每次写出一块。

+ 在内存管理中，进程的逻辑地址空间被分为一个一个页面
    + 同样的，在外存管理中，为了方便对文件数据的管理，文件的逻辑地址空间也被分为了一个一个的文件“块”
    + 于是文件的逻辑地址也可以表示为（逻辑块号，块内地址）的形式。

+ 用户通过逻辑地址来操作自己的文件，操作系统要负责实现从逻辑地址到物理地址的映射，即文件的物理结构或文件分配方式。
    + 文件分配方式/文件的物理结构的核心问题
        + 怎么把文件逻辑块号映射为物理块号


#### 记录成组分解技术

+ 由于磁盘块的大小是预先划分好的，大小固定
+ 而逻辑记录的大小是用户文件性质决定的，不一定和块大小一致
+ 如果逻辑记录比物理块小得多时，可以把多个逻辑记录存放在一个块中，这就是记录的成组，
+ 用户使用时再把读取的一块信息中分离出所需的记录，这就是记录的分解。

#### 连续分配

+ 连续分配方式要求每个文件在磁盘上占有一组连续的块。
+ （逻辑块号，块内地址）→（物理块号，块内地址）
    + 只需转换块号就行，块内地址保持不变。

+ 文件目录中记录存放的起始块号和长度（总共占用几个块）。
+ ![image-20230626232531792](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262325846.png)
+ 用户给出要访问的逻辑块号，操作系统找到该文件对应的目录项（$FCB$）
    + 物理块号=起始块号＋逻辑块号。

+ 优点：
    + 可以直接算出逻辑块号对应的物理块号，因此连续分配支持顺序访问和直接访问
        + 直接访问=随机访问
    + 连续分配的文件在顺序读写时速度最快。
        + 读取某个磁盘块时，需要移动磁头。访问的两个磁盘块相隔越远，移动磁头所需时间就越长。
        + 连续分配的文件相邻,磁头移动距离最短
+ 缺点：
    + 不便于拓展。
        + ![image-20230626232837902](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262328956.png)
    + 存储空间利用率低，产生难以利用的**磁盘碎片**
        + 可以利用紧凑处理碎片,但是需要耗费巨大的时间代价
        + ![image-20230626232905051](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262329103.png)

#### 链接分配

+ 采取离散分配的方式，可以为文件分配离散的磁盘块
    + 分为隐式链接和显式链接两种。
    + 考试题目中遇到未指明隐式/显式的“链接分配”，默认指的是隐式链接的链接分配

+ 隐式链接：
    + ![image-20230626233036804](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262330872.png)
    + 类似链表。
    + $FCB$目录中记录了文件存放的起始块号和结束块号，当然也可以增加一个字段来表示文件的长度。
    + 除了文件的最后个磁盘块之外，每个磁盘块中都会保存指向下一个盘块的指针，这些指针对用户是透明的。
    + 读入$i$号逻辑块，总共需要$i+1$次磁盘$I/O$操作
        + 从目录项中找到起始块号（即$0$号块）
        + 将$0$号逻辑块读入内存，由此知道$1$号逻辑块存放的物理块号
        + 于是读入$1$号逻辑块，再找到$2$号逻辑块的存放位置
        + 以此类推。

    + 优点：
        + 方便文件拓展。
            + 若需要拓展文件，则可以随便找一个空闲磁盘块，挂到文件的磁盘块链尾，并修改文件的$FCB$
        + 不会有硬盘碎片。
    + 缺点：
        + 只支持顺序访问，不支持随机访问，查找效率低。
        + 指向下一个盘块的指针也需要耗费少量的存储空间。
        + 存储稳定性不足，若是中间毁坏后面的数据也会丢失。

+ 显式链接：
    + ![image-20230626233424662](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262334718.png)
    + 类似静态链表。
    + 把用于链接文件各物理块的指针显式地存放在一张表中。即文件分配表（$FAT$，$File\,Allocation\,Table$）
        + $FAT$包含物理块号和下一块指针两项。
    + $FCB$目录中只需记录文件的起始块号。
    + 一个**磁盘**仅设置一张$FAT$。开机时，将$FAT$读入内存，并常驻内存。所以地址转换不需要读取内存，从而效率更高。
    + $FAT$的各个表项在物理上连续存储，且每一个表项长度相同，因此“物理块号”字段可以是隐含的。
    + 地址转换
        + 目录项中找到起始块号，若$i>0$，则查询内存中的文件分配表$FAT$，往后找到$i$号逻辑块对应的物理块号
        + 逻辑块号转换成物理块号的过程不需要**读磁盘**操作。
    + 优点：
        + 很方便文件拓展。
        + 不会有外部碎片问题，外存利用率高。
        + 支持顺序访问也支持随机访问。
            + 访问$i$号数据块时并不需要访问之前的$0\sim i-1$号数据块
        + 相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。
    + 缺点：文件分配表的需要占用一定的存储空间。

#### 索引分配

![image-20230627000724673](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306270007740.png)

+ 允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表
    + ![image-20230626235343848](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262353904.png)

    + 索引表中记录了文件的各个逻辑块对应的物理块
        + 索引表的功能类似于内存管理中的页表
            + 建立逻辑页面到物理页之间的映射关系

    + 索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块。

+ 索引表包含逻辑块号和物理块号两项
    + 逻辑块号可以是隐含的。

+ 每一个文件都有一个索引表。
+ 地址转换
    + 从目录项中可知索引表存放位置，将索引表从外存读入内存，并查找索引表即可只$i$号逻辑块在外存中的存放位置。

+ 优点：
    + 很方便文件拓展，不会有碎片问题，外存利用率高。
    + 支持随机访问。
+ 缺点
    + 文件索引表的需要占用一定的存储空间。


索引块必须不能太大，但是索引块太小就无法支持大文件，解决方案：

+ 链接方案：
    + 分配多个索引块并链接起来。
    + 文件$FCB$中只需要记录第一个索引块的块号。
    + 缺点：查找效率低。
+ 多层索引：
    + 建立类似多级页表的多层索引，使上层索引块指向下一层的索引块。
    + $FCB$中只需要记录顶层索引块就可以了。
    + 若采用多层索引，则各层索引表大小不能超过一个磁盘块。理由同多级页表。
    + 采用$K$层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要$K+1$次读磁盘操作。
    + 缺点：即使是小文件页需要$K+1$次读磁盘操作。
+ 混合索引：
    + 多种索引分配方式的结合
        + 一个文件的顶级索引表中
        + 既包含直接地址索引（直接指向数据块）
        + 又包含一级间接索引（指向单层索引表）
        + 还包含两级间接索引（指向两层索引表）
    + ![image-20230627000523511](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306270005569.png)
    + 优点：对于小文件，只需较少的读磁盘次数就可以访问目标数据块。
        + 一般计算机中小文件更多

如一共十三个地址项，前十个为直接地址，后面三个为一级间址、二级间址、三级间址。每个盘块的大小为$4KB$，索引块大小为$4B$。

所以文件不大于$4\times10=40KB$时可以直接读出。一个一级间址块中能包含$4KB\div4B=1K=2^{10}$个索引，所以能索引出$2^{10}\times4KB=4MB$的空间。同理，若文件长度大于$4MB+40KB$时可以使用二级间址块，索引出$4GB$的空间，三级间址能索引出$4TB$的空间。

|  &nbsp;  |   访问第n条记录    |                             优点                             |                             缺点                             |
| :------: | :----------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 连续分配 |   需访问磁盘1次    | 顺序存取时速度快，文件定长时可根据文件起始地址及记录长度进行随机访问 | 文件存储要求连续的存储空间，会产生碎片，不利于文件的动态扩充 |
| 链接分配 |   需访问磁盘n次    |  可解决外存的碎片问题，提高外存空问的利用率，动态增长较方便  | 只能按照文件的指针链顺序访问，查找效率低，指针信息存放消耗外存空间 |
| 索引分配 | m级需访问磁盘m+1次 |                  可以随机访问，文件易于增删                  | 索引表增加存储空间的开销，索引表的查找策略对文件系统效率影响较大 |

### 文件操作

#### 文件基本操作

+ 创建$create$。
    1. 文件系统为文件找到空间。
    2. 在目录中为新文件创建条目，记录文件名称、位置和其他信息。
+ 删除$delete$：找到对应目录项，使其为空，并回收该文件所占存储空间。
+ 截断：允许文件所有属性不变，删除文件内容，即设置长度归零并释放空间。
+ 读文件$read$：执行一个系统调用，指明文件名和位置。系统维护一个读位置的指针，读时就更新读指针。需要的参数：
    1. 文件描述符。
    2. 缓冲区首址。
    3. 传输字节数。
+ 写文件$write$：执行一个系统调用，指明文件名和内容。系统通过文件名搜索位置。系统需要为文件维护一个写位置的指针，当写时就更新写指针。
+ 文件重定位（文件寻址）：按条件搜索目录，将当前文件位置设置为给定值，不读写。

#### 文件打开

+ 开文件操作是将该文件的$FCB$存入内存的活跃文件目录表。
+ 在很多操作系统中，在对文件进行操作之前，要求用户先使用$open$系统调用“打开文件”，需要提供的几个主要参数：
    1. 文件存放路径。
    2. 文件名。
    3. 要对文件的操作类型（如：$r$只读；$rw$读写等）。
+ 操作系统在处理$open$系统调用：
    1. 将文件名传递给逻辑文件系统。
    2. 搜索系统打开文件表。
    3. 如果已打开，则在进程打开文件表种创建新目录指向系统打开文件表对应条目。
    4. 如果未打开，根据文件名搜索目录结构，并检查该用户是否有指定的操作权限。（部分文件目录会缓存到内存中以加快检索）
    5. 找到文件后将目录项$FCB$复制到系统打开文件表（活跃文件目录表）中。
    6. 进程打开文件表中创建一个条目，然后通过指针将系统打开文件表条目和其他域相联。
    7. 返回一个指向进程打开文件表条目的指针，通过指针操作文件。
    8. 打开文件后内核不能通过文件名访问文件，只能通过文件描述符（文件句柄）访问。
+ 打开文件表分为两种：
    1. 系统打开文件表，只有一张，包括编号、文件名、外存地址、打开计数器（多少个进程打开了次文件）等。
    2. 每一个进程的打开文件表，包括编号、文件名、读写指针、访问权限、系统表索引号等。
+ 打开文件时并不会把文件数据直接读入内存，而是提供索引号。“索引号”也称“文件描述符”或“文件句柄”。

每个打开文件都有如下关联信息：

+ 文件指针。系统跟踪上次的读写位置作为当前文件位置的指针，这种指针对打开文件的某个进程来说是唯一的，因此必须与磁盘文件属性分开保存。
+ 文件打开计数。文件关闭时，操作系统必须重用其打开文件表条目，否则表内空间会不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件。计数器跟踪打开和关闭的数量，计数为$0$时，系统关闭文件，删除该条目。
+ 文件磁盘位置。绝大多数文件操作都要求系统修改文件数据。该信息保存在内存中，以免为每个操作都从磁盘中读取。
+ 访问权限。每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等）。该信息保存在进程的打开文件表中，以便操作系统能够允许或拒绝之后的$I/O$请求。
+ 系统范围的打开文件表，包括每个打开文件的$FCB$复制和其他信息。
+ 单个进程的打开文件表，包括一个指向系统范围内已打开文件表中合适条目和其他信息的指针。

#### 文件关闭

+ 用户使用$close$系统调用“打开文件”，需要提供的几个主要参数：
    1. 文件存放路径。
    2. 文件名。
+ 操作系统在处理$close$系统调用时，主要做了几件事：
    1. 将进程的打开文件表相应表项删除。
    2. 回收分配给该文件的内存空间等资源。
    3. 系统打开文件表的打开计数器$count$减$1$，若$count=0$，则删除对应表项。

### 文件保护

口令保护和加密保护是为了防止用户文件被他人存取，而访问控制用于控制用户对文件的访问方式。

#### 口令保护

+ 为文件设置一个“口令”，用户请求访问该文件时必须提供“口令”。
+ 口令一般存放在文件对应的$FCB$或索引结点中。用户访问文件前需要先输入“口令”，操作系统会将用户提供的口令与$FCB$中存储的口令进行对比，如果正确，则允许该用户访问文件。
+ 优点：保存口令的空间开销不多，验证口令的时间开销也很小。
+ 缺点：正确的“口令”存放在系统内部，不够安全。

#### 加密保护

+ 使用某个“密码”对文件进行加密，在访问文件时需要提供正确的“密码”才能对文件进行正确的解密。
+ 系统并不保存原始数据，而是加密过的数据。
+ 加密方式有异或加密等。
+ 优点：保密性强，不需要在系统中存储“密码”。
+ 缺点：编码/译码，或者说加密/解密要花费一定时间。

#### 访问控制

+ 在每个文件的$FCB$（或索引结点）中增加一个访问控制列表（$AccessControl\,List$，$ACL$），该表中记录了各个用户可以对该文件执行哪些操作。
+ 访问类型包括：
    + 读：从文件中读数据。
    + 写：向文件中写数据。
    + 执行：将文件装入内存并执行。
    + 添加：将新信息添加到文件结尾部。
    + 删除：删除文件，释放空间。
    + 列表清单：列出文件名和文件属性。
+ 优点：可以使用复杂的访问方法。
+ 缺点：长度无法余集且可能导致复杂的空间管理。
+ 有的计算机可能会有很多个用户，因此访问控制列表可能会很大，可以用精简的访问列表解决这个问题。
+ 精简的访问列表：以“组”为单位，标记各“组”用户可以对文件执行哪些操作。当某用户想要访问文件时，系统会检查该用户所属的分组是否有相应的访问权限。所以系统也需要管理分组的信息。
+ 用户类型：
    + 拥有者：创建文件用户。
    + 组：一组需要共享文件且拥有类似访问的用户。
    + 其他：系统内其他所有用户。
+ 若想要让某个用户能够获取某种权限，需要把该用户放入有该权限的分组即可。
+ 如果对某个目录进行了访问权限的控制，那也要对目录下的所有文件进行相同的访问权限控制。

#### Linux文件权限

命令格式`chmod 权限 文件名`。

一共九位，从左至右分为三组，$1-3$位数字代表文件所有者的权限，$4-6$位数字代表同组用户的权限，$7-9$数字代表其他用户的权限。每一组的第一位表示可读，第二位表示可写，第三位表示可执行。

如$755$，第一组的$7=4+2+1$表示所有者可读可写可执行，$5=4+0+1$表示同组用户和其他用户可读可执行但是不可写。

## 目录系统

### 目录结构

#### 单级目录结构

+ 早期操作系统并不支持多级目录，**整个系统中只建立一张目录表**，每个文件占一个目录项。

    + 实现了“按名存取”，但是不允许文件重名。
    + 在创建一个文件时，需要先检查目录表中有没有重名文件，确定不重名后才能允许建立文件，并将新文件对应的目录项插入目录表中。
    + 不适用于多用户操作系统。

#### 两级目录结构

分为主文件目录（$MFD$，$Master\,File\,Directory$）和用户文件目录（$UFD$，$User\,Flie\,Directory$）：

+ 主文件目录记录用户名及相应用户文件目录的存放位置。
+ 用户文件目录由该用户的文件$FCB$组成。
+ 允许不同用户的文件重名。文件名虽然相同，但是对应的其实是不同的文件。
+ 两级目录结构允许不同用户的文件重名，也可以在目录上实现实现访问限制
    + 检查此时登录的用户名是否匹配
+ 两级目录结构依然缺乏灵活性，用户不能对自己的文件进行分类。

#### 多级目录结构

即树形目录结构：

+ 不同目录下的文件可以重名。
+ 用户（或用户进程）要访问某个文件时要用文件路径名标识文件，文件路径名是个字符串。各级目录之间用`/`隔开。
+ 从根目录出发的路径称为绝对路径。
+ 很多时候，用户会连续访问同一目录内的多个文件，显然，每次都从根目录开始查找，是很低效的
    + 因此可以设置一个“当前目录”出发的相对路径。
+ 树形目录结构可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。
+ 但是，树形结构**不便于实现文件的共享**，且查找文件需要逐级访问影响速度
    + 为此，提出了“无环图目录结构”。

#### 无环图目录结构

+ 在树形目录结构的基础上，增加一些**指向同一节点的有向边**，使整个目录成为一个有向无环图
    + 可以更方便地实现多个用户间的文件共享。
    +   ![image-20230626230932887](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202306262309958.png)
+ 可以用不同的文件名指向同一个文件，甚至可以指向同一个目录（共享同一目录下的所有内容）。
+ 需要为每个共享结点设置一个共享计数器，用于记录此时有多少个地方在共享该结点
    + 用户提出删除结点的请求时，只是删除该用户的$FCB$、并使共享计数器减$1$，并不会直接删除共享结点。
    + 当且仅当共享计数器计数为$0$时才真正删除节点

+ 共享文件不同于复制文件。在共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化。
+ 实现了文件共享，但是使得文件管理更复杂。

### 目录操作

#### 目录基本操作

+ 搜索：首先要找到对应目录项。
+ 创建文件。
+ 删除文件。
+ 创建目录。
+ 删除目录：包括不删除非空目录和可删除非空目录两种。
+ 移动目录。
+ 显示目录。
+ 修改目录。

#### 目录实现

+ 线性列表。
+ 哈希表。

### 文件目录共享

多个用户共享同一个文件或目录，意味着系统中只有“一份”文件数据。并且只要某个用户修改了该文件的数据，其他用户也可以看到文件数据的变化。

文件共享方式分为：

+ 基于索引结点的共享方式：硬链接。
+ 基于符号链的共享方式：软链接。

索引结点中设置一个链接计数变量$count$，用于表示链接到本索引结点上的用户目录项数。

#### 硬链接

+ 在文件目录中提到，索引结点，是一种文件目录瘦身策略。由于检索文件时只需用到文件名，因此可以将除了文件名之外的其他信息放到索引结点中。这样目录项就只需要包含文件名、索引结点指针。
+ 不同目录下对于同一个文件的索引结点的命名可以是不同的。

创建硬链接时：

+ 创建硬链接时$count+1$。

删除文件时：

+ 则只是要把用户目录中与该文件对应的目录项删除，且索引结点的$count$值减$1$。
+ 若$count>0$，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空。
+ 若$count=0$，则系统需要删除文件。

#### 软链接

+ 软链接就是共享时建立一个$Link$类型的文件，文件记录了要共享的文件的存放路径或任意一条硬链接路径，类似$Windows$系统的快捷方式。
+ 文件拥有者才拥有指向其索引结点的指针，而共享该文件的其他用户只有该文件的路径名。
+ 当访问共享文件时，先判断这个文件属于$Link$类型文件，然后根据其中记录的路径层层查找路径找到索引结点。

创建软链接时：

+ $count$直接复制。
+ 计算$count$值时忽略所有软链接。

若决定“删除”该文件：

+ 由于删除操作对软链接不可见，所以$count$值不变。
+ 当以后通过符号链接再次访问时发现文件不存在再直接删除软链接。

优点：

+ 网络共享只用提供文件所在机器的网络地址和文件路径。
+ 若共享文件被删除了，则软链接失效。删除软链接则无影响。

缺点：

+ 当共享文件删除，而其他用户新建一个相同路径的文件则原链接指向的是新文件而不是原文件。
+ 因为软链接访问共享文件时需要查询多层目录，所以有多层$I/O$操作，从而软链接访问速度慢于硬链接。

硬链接和软链接都是静态共享方式，都存在一个共同的问题，每个共享文件都有几个文件名，从而每增加一条文件名，当遍历整个文件系统时会多次遍历到该共享文件。

多个进程同时对同一个文件操作称为动态共享。
