# 第一章 计算机系统概述

## 【考纲内容】

### 【考纲内容】

1. **计箅机系统层次结构**

    - 计算机系统的基本组成
    - 计算机硬件的基本组成
    - 计算机软件和硬件的关系
    - 计算机系统的工作原理：“存储程序”方式、高级语言程序与机器语言程序的转换程序和指令的执行过程

2. **计算机性能指标**

    - 吞吐量、响应时间、$CPU$时钟周期、主频、$CPI$、$CPU$执行时间

    + $MIPS$、$MFLOPS$、$GFLOPS$、$TFLOPS$、$PFLOPS$、$EFLOPS$、$ZFLOPS$


### 【知识导图】

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/DFB631B62B5746AE93BDE69E9C818ACE.png)

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/0BDB891F8C034AED8807FDEDAFB6FEA2.png)

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/1000BF9CB68B4FCEAAD5CE99DB22B6B4.png)

### 【复习提示】

本章是组成原理的概述，考查时易针对有关概念或性能指标出选择题，也可能综合后续章节的内容出有关性能分析的综合题。掌握本章的基本概念，是学好后续章节的基础。部分知识点在初学时理解不深刻也无须担忧， 相信随着后续章节的学习，一定会有更为深入的理解

学习本章时，请读者思考以下问题;         .

1) 计算机由哪几部分组成? 以哪部分为中心? .

2) 主频高的 $CPU $一定比主频低的$CPU $快吗? 为什么?

3) 翻译程序、汇编程序、编译程序、解释程序有什么差别? 各自的特性是什么?

4) 不同级别的语言编写的程序有什么区别? 哪种语言编写的程序能被硬件直接执行?



## *计算机发展历程

| 发展阶段 |   时间    |         逻辑元件         | 速度（次/秒） |      内存      |              外存              |
| :------: | :-------: | :----------------------: | :-----------: | :------------: | :----------------------------: |
|  第一代  | 1946-1957 |          电子管          |   几千-几方   | 汞延迟线、磁鼓 |         穿孔卡片、纸带         |
|  第二代  | 1958-1964 |          晶体管          |  几万-几干万  |   磁芯存储器   |              磁带              |
|  第三代  | 1964-1971 |     中小规模集成电路     | 几十万-几百万 |  半导体存储器  |           磁带、磁盘           |
|  第四代  | 1972-现在 | 大规模、超大规模集成电路 |  上千万-万亿  |  半导体存储器  | 磁盘、磁带、光盘、半导体存储器 |

+ 第一代使用纸带磁带编程。
+ 第二代出现了面向过程的程序设计语言$FORTRAN$，有了操作系统雏形。
+ 第三代主要用于科学计算等专业用途，高级语言快速发展，开始有了分时系统。
+ 第四代开始出现$CPU$、$PC$，如$Windows$、$MacOS$等。



## 计算机系统层次结构

### 计算机系统的组成

计算机系统 = 硬件系统 + 软件系统

软件= 程序+数据+文档

计算机软件=应用软件+系统软件

**计算机系统性能的好坏，很大程度上是由软件的效率和作用来表征的**，而软件性能的发挥又离不开硬件的支持。

#### 冯诺依曼结构

1. 计算机由五大部件组成：
    + 输入设备：将信息转换成机器能识别的形式。
    + 存储器：存放数据和程序。
    + 运算器：算术运算和逻辑运算。
    + 控制器：协调其他部件与解析存储器中的程序或指令。
    + 输出设备：将结果转换为人类熟悉的形式。
2. 指令和数据以同等地位存于存储器，可按地址寻访。
3. 指令和数据用二进制表示。
4. 指令由操作码（指令序列号，用来表示处理的指令）和地址码（操作数据存储的地址）组成。
5. 存储程序：指将指令以二进制代码的形式事先输入计算机的主存储器，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。
6. **以运算器为中心**：输入/输出设备与存储器之间的数据传送通过运算器完成。

现代计算机:以存储器为中心

$CPU(Central\,Processing\,Unit)$=运算器+控制器

![image-20230525162924076](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230525162924076.png)

#### 计算机的功能部件

##### 主存储器$(Main\,Memory,MM)$

![image-20230525163152049](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230525163152049.png)

$MAR$对应$Address $地址寄存器

$MDR$对应$Data $数据寄存器

![image-20230531150315847](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230531150315847.png)

$MAR$位数反映存储单元的个数

$MDR$位数$=$存储字长

例：

$MAR=4$位→总共有$24$个存储单元

$MDR=16$位→每个存储单元可存放$16bit$,

$1$个字($word$)$=16bit$



##### 运算器$(Arithmetic\,Logic\,Unit,ALU)$

![image-20230525163515957](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230525163515957.png)

**运算器：**用于实现算术运算（加减乘除）、**逻辑运算**（与或非）

$ACC(Accumulator)$:累加器，用于存放操作数，或运算结果。

$MQ(Multiplier-Quotient\,Register)$:乘商寄存器，在乘、除运算时，用于存放操作数或运算结果。

$X$(此字母没有专指的缩写含义，可以用作任一部件名):通用的操作数寄存器，用于存放操作数

$ALU(Arithmetic\,Logic\,Unit)$:算术逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算



以下内容详见第二章2.5.3 原码乘法

进行乘法操作$(a*b)$时,$MQ$存放乘数,$X$存放被乘数,$ALU$计算后把乘积放入$ACC$中

如果数据较大会将部分积存储在$MQ$中,在乘法的每个时钟周期中，$ALU$会将当前乘法结果累加到$MQ$中。

$ALU$还可以使用$ACC$来保存中间积的高位，以便在乘法的不同阶段进行溢出处理。

##### 控制器$(Controller,CU)$

![image-20230525163828848](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230525163828848.png)

控制单元$CU(Control\,Unit)$：分析指令，给出控制信号

指令寄存器$IR(Instruction\,Register)$：存放当前执行的指令

程序计数器$PC(Program\,Counter)$：存放下一条指令地址，有自动加1功能



$PC$(取指令)$\to$$IR$(分析指令)$\to$$CU$(执行指令)



##### 计算机执行指令的工作过程

对于C语言代码

```C
int a=2,b=3,c=1,y=0;
void main(){
    y=a*b+c;
}
```

主存中编译出来的机器语言如下:

![image-20230527210627384](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230527210627384.png)

**(MAR),(PC)指该寄存器中的内容 PC是一种特殊的寄存器**

**M指Memory存储器,这里是主存储器,M(MAR)指主存MAR指向地址所对应的内容**

**(PC)→MAR指PC里面的内容放到MAR里面**

**OP是操作码,AD是地址码**

以第一步操作为例:

初始状态：(PC)=0,指向第一条指令的存储地址

#1:(PC)→MAR,导致(MAR)=0

#3:M(MAR)→MDR,导致(MDR)=**000001** 0000000101

#4:(MDR)→1R,导致(IR)=**000001** 0000000101

#5:OP(IR)→CU,指令的操作码送到CU,CU分析后得知，这是“取数”指令

#6:AdIR)→MAR,指令的地址码送到MAR,导致(MAR)=5

#8:M(MAR)→MDR,导致(MDR)=0000000000000010=2

#9:(MDR)→ACC,导致(ACC)=0000000000000010=2

**取指令(#1~#4)**

**分析指令(#5)**

**执行取数指令(#6~#9)**



![image-20230527211541526](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230527211541526.png)

上一条指令取指后PC自动+1，(PC)=1:执行后，(ACC)=2

#1:(PC)→MAR,导致(MAR)=1

#3:M(MAR)-→MDR,导致(MDR)=**000100** 0000000110

#4:(MDR)→1R,导致(IR)=**000100** 0000000110

#5:OP(IR)→CU,指令的操作码送到CU,CU分析后得知，

#6:Ad(IR)→MAR,指令的地址码送到MAR,导致(MAR)=6

#8:M(MAR)→MDR,导致(MDR)=0000000000000011=3

#9:(MDR)→MQ,导致(MQ)=0000000000000011=3

#10:(ACC)→X,导致(X)=2

#11:(MQ)*(X)→ACC,由ALU实现乘法运算，导致(ACC)=6,



**取指令(#1~#4)**

**分析指令(#5)**

**执行取数指令(#6~#11)**



### 计算机软件

#### **程序设计语言**

+ 机器语言：唯一可以被计算机识别和执行的语言。
+ 汇编语言：必须经过汇编程序的翻译。
+ 高级语言：转换为汇编程序或直接翻译为机器语言。
    + 解释型语言：采用边解释边执行的方法。不生成目标程序，如$Python$。（每次执行都要翻译）
    + 编译型语言：必须先将源程序翻译成目标程序才能运行，如$C$语言等。（只需翻译一次）
    + $Java$既不属于传统的编译型语言，也不属于解释型语言。Java事先编译成“.class”字节码文件，然后再利用$JVM$虚拟机进行解释执行的，所以$Java$即可以说成编译型，也可以说成解释型。




#### **翻译程序**

汇编程序(汇编器):将汇编语言程序翻译成机器语言程序。

解释程序(解释器):将源程序中的语句按执行顺序逐条翻译成机器指令并执行。

编译程序(编译器):将高级语言翻译成汇编语言或机器语言程序。（只需翻译一次）

#### 软硬件逻辑等价性

硬件实现的往往是最基本的算术和逻辑运算功能，而其他功能大多通过软件的扩充得以实现。对某一功能来说，既可以由硬件实现，又可以由软件实现，从用户的角度来看，它们在功能上是等价的。这一等价性被称为软、硬件逻辑功能的等价性。例如，浮点数运算既可以用专门的浮点运算器硬件实现，又可以通过一段子程序实现，这两种方法在功能上完全等效，不同的只是执行时间的长短而已，显然**硬件实现的性能要优于软件实现的性能**。

### 计算机系统层次结构



![image-20230521155703897](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230521155703897.png)

- 高级语言层：面向用户，必须用编译程序（编译器或解释器）翻译成汇编语言程序。

- 汇编语言层：不能直接运行汇编语言，必须用汇编程序（汇编器）翻译成机器语言程序，所以是虚拟的。汇编语言与机器语言一一对应。

- 操作系统机器层：由操作系统程序实现，向上提供“广义指令”即系统调用。也称为混合层。

    ---

- 传统机器层（指令集架构层，$ISA$）：执行二进制机器指令，微程序解释机器执行微指令。

- 微指令层：由硬件直接执行微指令。只有微程序设计的计算机系统才有这一层。

- 逻辑门层：最底层的硬件系统。



## 计算机性能指标和评价

### 基本性能指标

#### 字长

字长是指计算机进行一次整数运算（即定点整数运算）所能处理的二进制数据的位数。

字长一般与计算机内部**寄存器**、**运算器**，**数据总线**的位宽相等。

**注**：

**字、字长、机器字长、指令宇长、存储字长的区别和联系是什么？**

在通常所说的“某16位或32位机器”中，16、32指的是字长，也称机器字长。所谓字长，通常是指CPU内部用于整数运算的数据通路的宽度，因此字长等于CPU内部用于整数运算的运算器位数和通用寄存器宽度，它反映了计算机处理信息的能力。字和字长的概念不同。字用来表示被处理信息的单位，用来度量数据类型的宽度，如x86机器中将一个字定义为16位。

指令字长：一个指令字中包含的二进制代码的位数。

存储字长：一个存储单元存储的二进制代码的长度。

它们都必须是字节的整数倍。

指令字长一般取存储字长的整数倍，若指令字长等于存储字长的2倍，则需要2个访存周期来取出一条指令：若指令字长等于存储字长，则取指周期等于机器周期。

早期的存储字长一般与指令字长、字长相等，因此访问一次主存便可取出一条指令或一个数据。随着计算机的发展，指令字长、字长都可变，但必须都是字节的整数倍。



#### 数据通路带宽

数据通路带宽是指数据总线一次所能并行传送信息的位数。这里所说的数据通路宽度是指外部数据总线的宽度，它与$CPU$内部的数据总线宽度·（内部寄存器的大小）有可能不同。

**注：各个子系统通过数据总线连接形成的数据传送路径称为数据通路。**



#### 主存客量

主存容量是指主存储器所能存储信息的最大容量，通常以字节来衡量，也可用字数×字长（如$512K×16位$)来表示存储容量。其中，$MAR$的位数反映了存储单元的个数，$MDR$的位数反映了存储单元的字长。例如，$MAR$为16位，表示$2^{16}$=$65536$，即此存储体内有$65536$个存储单元（可称为$64K$内存，$1K=1024$),若$MDR$为32位，表示存储容量为$64K×32$位。

增加主存容量可以减少程序运行期间访问辅存的次数，有利于提高程序的运行速度，也有利于计算机性能的提高。

**注：$MAR$是地址寄存器（用来储存地址），$MDR$是数据寄存器（用来储存数据）。**

### 与时间有关的性能指标

**程序执行时间(响应时间)=硬盘访问时间+内存访问时间+$I/O$操作时间+操作系统开销时间+$CPU$执行时间**



#### 时钟周期$T$与主频$f$

$CPU$主频$f$ :$CPU$内数字脉冲信号振荡的频率。单位为赫兹。

$CPU$主频（时钟主频）=$\frac{1}{\text{CPU时钟周期}}$。

即
$$
f=\frac{1}{T}
$$
$CPU$时钟周期$T$ ：单位为纳秒或微秒。在一个时钟周期内，$CPU$仅完成**一个最基本的动作**。



**最基本的动作$\ne $一条指令**

**最基本的动作$\ne $一条指令**

**最基本的动作$\ne $一条指令**

下文全是针对**指令**而言



#### 执行指令均所需时钟周期数$CPI$

$CPI$（$Clock\,cycle\,Per\,Instruction$）：执行一条指令所需的时钟周期数。

也称节拍周期或$T$周期

$CPI$即可表示每条指令执行所需要的时钟周期数，也可指一类指令或一段程序中所有指令所需时钟周期数的平均值。

计算公式：
$$
CPI=\frac{m}{IC}
$$
其中，程序中**包含的总指令条数用$IC$表示**，程序执行所需**时钟周期数为$m$，机器周期为$T$，频率为$f$**。

若能知道某程序中每类指令的使用频率（用$P_i$表示），每类指令的$CPI$(用$CPI_i$表示)，每类指令的条数（用$IC_i$表示)，则程序的$CPI$可表示为：
$$
\mathrm{CPI}=\sum_{i=1}^{n}\left(\mathrm{CPI}_{i} \times P_{i}\right)=\sum_{i=1}^{n}\left(\mathrm{CPI}_{i} \times \frac{\mathrm{IC}_{i}}{\mathrm{IC}}\right)
$$



#### $CPU$时间$T_{\text {cpu}}$

即执行程序一共需要多少时间
$$
T_{\text {cpu}}=m \times T
$$
考虑$CPI$后，
$$
T_{\text {cpu}}=\mathrm{CPI} \times \mathrm{IC} \times T=\frac{\mathrm{CPI} \times \mathrm{IC}}{f}
$$

#### 每时钟周期执行指令条数$IPC$

$IPC(Instructions\, Per\, Cycle)$是指每个时钟周期$CPU$能执行的指令条数，是$CPI$的倒数，
于指令流水线技术以及多核技术的发展，目前$IPC$的值已经可以大于$1$，反过来$CPI$的值也可
小于$1$。

即
$$
IPC=\frac{1}{CPI}
$$


#### 每秒执行(百万)指令条数$(M)IPS$



$IPS(Instructions\,Per\,Second)$,即每秒执行多少条指令。
$$
IPS=\frac{IC}{T_{\text {cpu}}}
$$
$MIPS(Million\,Instructions\,Per\,Second)$,即每秒执行多少百万条指令。
$$
MIPS=\frac{IC}{T_{\text {cpu}}\times 10^{6}}
$$
$MIPS$对不同机器进行性能比较是有缺陷的，因为不同机器的指令集不同，指令的功能也就
不同，比如在机器$M1$上某条指令的功能也许在机器$M2$上要用多条指令来完成：不同机器的$CPI$
和时钟周期也不同，因而同一条指令在不同机器上所用的时间也不同。



**注：**在描述存储容量、文件大小等时，$K、M、G、T$通常用$2$的幂次表示，如$1Kb=2^{10}b$;在
描达速率、频率等时，$k、M、G、T$通常用$10$的幂次表示，如$1kb/s=10^{3}b/s$。通常前者用大写的
$K$,后者用小写的$k$,但其他前缀均为大写，表示的含义取决于所用的场景。





#### 系统整体的性能指标

##### 数据通路带宽

数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）

##### 吞吐量

指系统在单位时间内处理请求的数量。

它取决于信息能多快地输入内存，CPU能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备。这些步骤中的每一步都关系到主存，因此，系统吞吐量主要取决于主存的存取周期。

##### 响应时间

指从用户向计算机发送一个请求，到系统对该请求做出响应并获得它所需
要的结果的等待时间。



### QA常见问题

问：主频高的CPU一定比主频低的CPU快吗？
	不一定，如两个CPU,A的主频为2GHz,平均CPI=10;B的主频1GHz,平均CPI=1



问：若A、B两个CPU的平均CPI相同，那么A一定更快吗？

也不一定，还要看指令系统，如A不支持乘法指令，只能用多次加法实现乘法；而B支持乘法指令。



问：基准程序执行得越快说明机器性能越好吗？

基准程序中的语可存在频度差异，运行结果也不能宪全说明问题

# 第二章 数据的表示与运算

## 【考纲内容】

1. 数制与编码
    - 进位计数制及其相互转换，定点数的编码表示
2. 运算方法和运算电路
    - 基本运算部件，加法器，算法逻辑单元 ($ALU$)
    - 加/减运算:补码加/减运算器，标志位的生成
    - 乘/除运算: 乘/除法运算的基本原理，乘法运算和除法电路的基本结构
3. 整数的表示和运算
    - 无符号整数的表示和运算，带符号整数的表示和运算
4. 浮点数的表示和运算
    - 浮点数的表示: $IEEE\,\,754$ 标准，浮点数的加/诚运算



### 知识导图

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/1BB3CFD0434748BB836E32A0B3C9A2E4.png)

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/D5B4D246B03D49C2B456C4CDC6A20E10.png)



![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/AA80B3FA8E8343B6A5DFA11B4B2E77D3.png)

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/8E87101F98DC42F8B63EA88BF26C77DE.png)

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/09BAE5B9728D419392B24B896330DFA5.png)

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/4FB6EB9E4A474460B1CC4DEA66B7C706.png)

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/F2DB54B4C1734300AE96BAC9217E0AE7.png)

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/BE01B0C824104573BB78BA5750676E25.png)

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/1483AFEC982C44F18D77B0A7CB6DCD52.png)

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/0A5B68E7070446DFBAFACD39FB7C4E8B.png)

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/15D2891365BE4C9481C7C8DE3CFB7724.png)



## 定点数

### 数据表示的作用

数据表示的作用是将**数据按照某种方式组织起来，以便计算机硬件能直接识别和使用。**

在设计和选择计算机内的数据表示方式时，一般需要综合考虑以下几方面的因素。

1. 数据的类型: 满足应用对数据类型的要求，一般要支持数值数据和非数值数据，前者
    如小数、整数、实数等，后者如 ASCII 码和汉字等。
2. 表示的范围和精度: 满足应用对数据范围和精确度的要求，这要通过选择适当的数据
    类型与字长来实现。
3. 存储和处理的代价: 应尽量使设计出的数据格式易于表示、存储和处理; 易于设计处
    理数据的硬件，如运算器设计等赶要综合考虑性能需求和硬件开销。

4. 软件的可移植性: 从保护用户软件投资的角度看，应使设计的数据格式在满足应用需
    求的前提下，符合相应的规范，方便软件在不同计算机之间的移植。

二进制由于数码最少、容易与简单的物理状态对应、算术逻辑运算电路更容易实现等优势成为现代计算机中数据表示的不二之选，采用二进制可以表示任何数据信息。

### 定点数表示

**书写时用“+”和“-”来表示数据的书写格式称为真值。**

由符号和数值一起编码表示的二进制数称为机器数或机器码。

常用的定点数机器码有原码、反码、补码和移码等，不同的机器码具有不同的特点。

![image-20230522170034441](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230522170034441.png)



#### 原码

- **正数符号位用$0$表示, 负数符号位用 $1$ 表示，数值位保持不变。**
- **对于数据$0$，原码有$+0$和$-0$两个编码。**

+ 若机器字长$n+1$位，则原码整数的表示范围是$[-(2^n-1),2^n-1]$。
+ 若机器字长$n+1$位，则原码小数的表示范围是$[-(1-2^{-n}),-2^{-n}]\cup[2^{-n},1-2^{-n}]$。

定点小数的原码公式

![image-20230522161021822](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230522161021822.png)

定点整数的原码公式

![image-20230522161026922](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230522161026922.png)



原码的加减法运算复杂，**符号位不能直接参与运算**。加法运算需要”同号求和，异号求差”, 减法运算需要“异号求和, 同号求差”, 求差时还需要先比较大小，然后用大数减去小数，最后结果的符号选择也相对复杂。

显然，利用原码作为机器数在实现加减法运算方面是不方便的，**原码在计算机中目前仅仅用于表示浮点数的尾码。**

#### 反码

反码又称 1 的补码，其符号位和原码相同，**真值为正数时，反码和原码相同；真值为负数时，反码数值位为真值数值位取反。**

- **同样反码也存在$+0$和$-0$两个 $0$。**

+ 范围表示没有变化与原码一致,如下

+ 若机器字长$n+1$位，则反码整数的表示范围是$[-(2^n-1),2^n-1]$。
+ 若机器字长$n+1$位，则反码小数的表示范围是$[-(1-2^{-n}),-2^{-n}]\cup[2^{-n},1-2^{-n}]$。

定点小数的反码公式

![image-20230522160957632](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230522160957632.png)

定点整数的反码公式

![image-20230522161043531](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230522161043531.png)

反码的加减运算较原码略简单，其符号位可以直接参与运算，加法运算直接将反码相加即可，但最高位进位要从运算结果最低位相加 ( 循环进位 ) 。减法运算只需要将被减数的反码加上被减数负数的反码即可，同样也要采用循环进位的运算方法。

但尽管如此，现代计算机中并没有采用反码进行数据表示和运算，这是因为人们找到了更好的编码一一补码。



#### 补码

+ 补码：若符号位为$0$，则反码与原码相同，若符号位为$1$，则数值位全部取反再加一，即反码加一。
+ 补码表示时真值$0$只有一种形式$0000\,0000$。
+ 多出来的一种形式$1000\,0000$表示整数的$-2^7$和小数的$-1$。
+ 若机器字长$n+1$位，则补码整数的表示范围是$[-2^n,2^n-1]$。（比原码多个$-128$）
+ 若机器字长$n+1$位，则补码小数的表示范围是$[-1,1-2^{-n}]$。（比原码多个$-1$）
+ 负数补码转回原码：尾数取反，末位加一；或是负数补码中，最右边的$1$以及右边不变，最右边的$1$的左边取反。
+ 数值的补码求其负数的补码：全部位包括符号位取反，末位加一。
+ 对一个整数的补码再求补码，等于该整数自身。
+ 补码算术移位：将补码的符号位与数值位一起右移一位并保持原符号位的值不变，表示除二。

定点小数的补码公式

![image-20230522161507622](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230522161507622.png)

定点整数的补码公式

![image-20230522161521871](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230522161521871.png)

##### 变形补码

变形补码，又称模 $4 $补码 或 双符号补码，采用两个二进制位来表示数据的符号，其余与补码相同。

**符号位为 $00 $ 时表示正数，符号位为 $11$ 时表示负数。**对定点小数而言，采用变形补码后，其模为 4。

因此，变形补码也称为“模 $4 $补码”。对定点整数而言，采用变形补码后，其模为$2^{n+2}$ (为数值位的位数 ) 。

用于完成算术运算的$ALU$部件中。

定点小数变形补码

![image-20230522162614722](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230522162614722.png)

定点整数变形补码

![image-20230522162626352](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230522162626352.png)



##### 补码作用

+ 原码在计算时由于首位表示的是符号，所以需要考虑将加减运算转换的问题，而减法实现起来比较困难，就考虑是否可以将减法通过加法来实现。
+ 由于计算机码操作若最高位进一就被舍弃，则天然是进行模运算，所以可以通过数学模运算来实现机器码的运算。
+ 带余除法：设$x,m\in Z$，$m>0$则存在唯一决定的整数$q$和$r$，使得$x=q\cdot m+r\,,0\leqslant r<m$。
+ 若两个数绝对值之和为模，则互为补数。即模-数的绝对值=数的补数（正数）。从而数加上数的补数就得到了模。
+ 补码就是正数不变，负数取模的结果。如$-66=-0100\,0010$，而$(1000\,0000-0100\,0010)\mod(1111\,1111)=1011\,1110$，也就是其补码。
+ 从而就可以用补数的加法（**被减数转为其负数的补码**）替代原码转换的加减法。
+ 所以**补码可以让减法操作转换为加法操作，减少硬件成本**。

#### 移码

+ 一般是在补码的基础上只将符号位取反，即在真值上加上一个常数偏移量$2^n$。也可能加上不同的偏移量。
+ 移码只能用于表示整数，而不能表示定点小数。一般用来表示浮点数的阶码。
+ 若机器字长$n+1$位，则移码整数的表示范围是$[-2^n,2^n-1]$。
+ 若机器字长$n+1$位，则移码小数的表示范围是$[-1,1-2^{-n}]$。
+ 只有一个零的表示$10\cdots0$。
+ 移码全 $0$ 时，对应真值的最小值$-2^{n}$，移码全 $1$ 时，对应真值的最大值 $2^{n}-1$
+ 移码保持了数据原有的大小顺序，移码大真值就大，移码小真值就小。

#### 对照表、对照数轴

|  机器数   | 无符号数 | 原码 | 反码 | 补码 | 移码 |
| :-------: | :------: | :--: | :--: | :--: | :--: |
| 0000 0000 |    0     |  +0  |  +0  |  0   | -128 |
| 0000 0001 |    1     |  +1  |  +1  |  +1  | -127 |
|    ...    |          |      |      |      |      |
| 0111 1101 |   125    | +125 | +125 | +125 |  -3  |
| 0111 1110 |   126    | +126 | +126 | +126 |  -2  |
| 0111 1111 |   127    | +127 | +127 | +127 |  -1  |
| 1000 0000 |   128    |  -0  | -127 | -128 |  0   |
| 1000 0001 |   129    |  -1  | -126 | -127 |  1   |
| 1000 0010 |   130    |  -2  | -125 | -126 |  2   |
|    ...    |          |      |      |      |      |
| 1111 1101 |   253    | -125 |  -2  |  -3  | 125  |
| 1111 1110 |   254    | -126 |  -1  |  -2  | 126  |
| 1111 1111 |   255    | -127 |  -0  |  -1  | 127  |

![image-20230522165301372](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230522165301372.png)

#### 相互转换







原码转补码:

符号位不动,在右起第一个1的左边画一条竖线,竖线右边的数字不动,左边的数据位(即**除了符号位以外**的所有数字全部取反)



#### 总结

1. 原码、补码、反码的符号位相同，正数的机器码相同。

2. 原码、反码的表示在数轴上对称，二者都存在$+0$ 和$-0$ 两个零。

3. 补码、移码的表示在数轴上不对称，零的表示唯一，它们比原码、反码多表示一个数。

4. 整数的补码、移码的符号位相反，数值位相同。

5. 负数的反码、补码末位相差 $1$。

6. 原码很容易判断大小。而**负数的反码、补码**很难直接判断大小，可采用如下规则**快速判**
    **断**：**对于负数，数值部分越大，绝对值越小，真值越大（更靠近 $0$）。**





### 计算机中的运算

#### C语言中的位运算

C 语言中的位运算操作符主要包括“&”，“|”，“~“，”^” 4种,分别对应逻辑与、或、非、异或操作。这些位运算操作符会在编译器的作用下被翻译成与之对应的汇编指令，如 x86 中的逻辑与指令 and 、逻辑或指令 or、逻辑非指令 not、逻辑异或指令 xor.


| A    | B    | A AND B与 | A OR B或 | NOT A非 | A XOR B异或 |
| :--- | :--- | :-------- | :------- | :------ | :---------- |
| 0    | 0    | 0         | 0        | 1       | 0           |
| 0    | 1    | 0         | 1        | 1       | 1           |
| 1    | 0    | 0         | 1        | 0       | 1           |
| 1    | 1    | 1         | 1        | 0       | 0           |

与：所有输入为真时，才会有输出真。

或：所有输入为假时，才会有输出假。

非：逆转输入的真假。

 异或：输入相同时输出为假，否则为真。



#### C语言中的逻辑运算

C 语言中的逻辑运算操作符主要包括“&&”，“||”，“!”3 种，逻辑运算和位运算的区别在它属于非数值运算，操作数只能是“0”和“1”两个值,所有非“0”值都被当作“1”处理。

所以逻辑运算翻译成汇编程序时不会对应具体的运算指令，而会演变成相应的程序分支结构。



#### C语言中的移位运算

C 语言中的移位运算操作符主要包括“<<”，“>>”两种，分别代表左移和右移。

左移运算操作符对应汇编指令中的逻辑左移，而右移运算操作符则根据操作数是无符号还是有符号类型分别对应汇编指令中的逻辑右移和算术右移指令。

逻辑左移将高位移出，低位补零; 逻辑右移则是将低位移出，高位补零; 算术右移的高位不是直接补零，而是填充原数据的符号位。

**每左移一位，数据就扩大一倍; 每右移一位，数据就缩小一半。**所以高级语言中 $2x$ 、$4x$、$x/8$、$x/16$ 这样的运算在编译时都会转换成对应的汇编移位指令实现，而不是转换成运算时间较长的乘除法指令。

**需要注意的是，左移运算可能会因为超出表示范围而发生溢出。**



#### C语言中的算术运算

C 语言中的算术运算操作符主要包括“+”，“-”，“*”，“/”4 种，分别对应算术运算中的加、减、乘、除。

对于定点数的加减运算，由于有符号数采用补码表示，符号位也可以参与运算，因此编译程序通常直接转换成汇编语言中的 add、sub 指令，并不区分符号数据类型。定点数的乘除运算则会根据操作数符号类型进行不同的转换，而所有浮点数的算术运算都会被编译成汇编浮点算术运算指令。



### 运算方法和运算电路

#### 基本运算部件

在计算机中，运算器由算术逻辑单元$ (Arithmetic\,Logic\,Unit,ALU)$、移位器、状态寄存器和通用寄存器组等组成。运算器的基本功能包括加、减、乘、除四则运算，与、或、非、异或等逻辑运算，以及移位、求补等操作。ALU 的核心部件是加法器。

##### 一位全加法器

注：参考资料[【硬件科普】带你认识CPU第02期——CPU是怎么计算加法的（上）_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1aQ4y1v7QP/?spm_id_from=333.337.search-card.all.click&vd_source=58d3a366b06c1c094d0731d6732f7441)

###### 基本概念 本位和数和进位

本位和数 Sum 简写为S

进位 Carry 简写为C

![image-20230523154300713](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230523154300713.png)



###### 运算思路

![image-20230527214738312](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230527214738312.png)

对于本位可以发现,**只要不一样就输出1一样就输出0**,符合异或运算的思想

对于进位C可以发现,当且仅当AB均为1时才输出1,符合与运算或相乘的思想

即$S=A\oplus B,C_{out}=A\times B$



###### 一位半加法器

半加法器没有进位输入,只能计算一位二进制加法

![image-20230527215240654](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230527215240654.png)

###### 一位全加法器

计算多位加法可需要将进位$C_{out}$作为下一个加法器的$C_{in}$参与运算

由加法表可知

对于本位S来说,$S=A\oplus B\oplus C_{in}$即可

对于进位$C_{out}$来说,$A,B,C_{in}$中至少要有两个1

![image-20230527220236696](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230527220236696.png)

计算时考虑AB相同和AB不同的情况

AB相同时相乘(进行与运算),均为0则输出为0($A,B,C_{in}$中已经有两个0了,进位$C_{out}$一定是0),均为1则输出为1($A,B,C_{in}$中已经有两个1了,进位$C_{out}$一定是1)

AB不同时,进行异或运算结果一定是1(此时$AB$中只要有一个1,只需要判断$C_{in}$即可),此时与$C_{in}$相乘判断$C_{in}$是0还是1

![image-20230527220143755](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230527220143755.png)

而AB相同与AB不同两种情况互斥可以相加(进行与运算),得到最终逻辑表达式

$C_{out}=A\times B+(A\oplus B)\times C_{in}$



即全加法器逻辑表达式为:
$$
S=A\oplus B\oplus C_{in}\\
C_{out}=A\times B+(A\oplus B)\times C_{in}
$$

#### 串行进位全加法器

将以上一位全加法器的$C_{in},C_{out}$首尾相连即可得到

![image-20230527221104467](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230527221104467.png)

在串行进位全加法器中，每个位的进位是依次计算的，需要等待前一位的进位计算完成后才能进行下一位的计算。

这种计算方式需要串行操作，即逐位地进行计算，因此速度较慢,且一位的错误输出可能会导致全部输出错误。



#### 并行进位加法器

考虑进位$C_{out}$逻辑表达式$C_{out}=A\times B+(A\oplus B)\times C_{in}$

可以写成
$$
C_{i}=A_{i}\times B_{i}+(A_{i}\oplus B_{i})\times (A_{i-1}\times B_{i-1}+(A_{i-1}\oplus B_{i-1})\times C_{i-2})
$$
…

继续对$C_{i-2}$展开可以一直展开到$C_0$

则**第$i$位向更高位的进位$C_{i}$可根据被加数、加数的第1~i位，再结和$C_{0}$即可确定**

记$G_{i}=A_{i}\times B_{i} \quad P_{i}=A_{i} \oplus B_{i}$

则上式可以化为

$C_{i}=A_{i}\times B_{i}+\left(A_{i} \oplus B_{i}\right) C_{i-1}=G_{i}+P_{i} C_{i-1}$
$$
\begin{aligned}
&C_{1}= G_{1}+P_{1}C_{0}  \\
&C_{2}= G_{2}+P_{2}C_{1}=G_{2}+P_{2}G_{1}+P_{2}P_{1}C_{0}  \\
&C_{3}= G_{3}+P_{3}C_{2}=G_{3}+P_{3}G_{2}+P_{3}P_{2}C_{1}+P_{3}P_{2}P_{1}C_{1}\\
&C_{4}= G_{4}+P_{4}C_{3}=G_{4}+P_{4}G_{3}+P_{4}P_{3}G_{2}+P_{4}P_{3}P_{2}G_{1}+P_{4}P_{3}P_{2}P_{2}P_{2}P_{1}  \\
...
\end{aligned}
$$
其中每一位的$A_{i}, B_{i}$都预先知道,则$G_{i},P_{i}$可以通过简单的运算得知

则每一位的运算结果几乎可以同时产生

**并行进位的并行加法器：各级进位信号同时形成，又称为先行进位、同时进位**



这种进位方式是快速的，与位数无关。

但随着加法器位数的增加，$C_{i}$的逻辑表达式会变得越来越长，这会使电路结构变得很复杂。**因此，当位数较多时采用全先行进位是不现实的。**



更多位数的加法器可通过将$CLA$部件或全先行进位加法器串接起来实现。 

例如，对于 16 位加法器，可以分成4组，组内为 4 位先行进位，组间串行进位。为了进一步提高运算速度，也可以采用组内和组间都并行的进位方式。因为两级先行进位加法器组内和组间都采用先行进位方式，其延迟和加法器的位数没有关系。所以，通常采用两级或多级先行进位加法器。



#### 带标志加法器

##### 补码计算器

![image-20230528161717724](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230528161717724.png)

计算减法$(A-B)$时,先将减数全部按位取反并末位加1,得到$[-B]_{\text{补}}$即$B$的相反数的补码,此时计算$A+[-B]_{\text{补}}$即可 

加法时不必改变,按位相加即可

![image-20230528170248482](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230528170248482.png)

- 当$Sub$信号为$0$时识别为加法,直接输出加数$B$,$C_{in}$此时为0

- 当$Sub$信号为$1$时识别为减法,先在非门中按位取反再输出加数$B$,且此时$C_{in}$此时为1

**但此时无法检测溢出,检测溢出可以使用标志位**



本电路也可以实现无符号数的运算(逻辑表达式相同),且无需考虑溢出

##### 带标志加法器

###### 标志位

![image-20230528171805353](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230528171805353.png)

###### 溢出标志位

即$OF$（$Overflow\,Flag$）。表示带符号整数运算时结果发生溢出。

+ $OF=1$表示溢出。
+ 对于无符号整数运算，$OF$没有意义。

对于有符号数的溢出判断方式有：

1. 采用一位符号位：思想为：正正得负或负负得正则为溢出，其他情况无溢出。
    + 设$A$符号为$A_S$、$B$符号为$B_S$、运算结果符号为$S_S$。
    + 溢出逻辑表达式为$V=A_SB_S\overline{S_S}+\overline{A_SB_S}S_S$。
2. 采用双符号位：$s1$、$s2$表示运算结果的两个符号位：
    + $s1s2=00$：表示正数，无溢出。
    + $s1s2=01$：表示结果正溢出 ，即正正得负，且$s2$表示当前运算符号为负，$s1$表示原本正确的符号应该为正。
    + $s1s2=10$：表示结果负溢出 ，即负负得正，且$s2$表示当前运算符号为正，$s1$表示原本正确的符号应该为负。
    + $s1s2=11$：表示结果为负数，无溢出
3. 采用一位符号位，根据数据位和符号位的进位情况判断溢出：
    + $C0$：表示运算时符号位(最高位)是否产生进位，若符号位产生进位则为$1$，否则为$0$。
    + $C1$：表示运算时最高数值位(次高位)是否产生进位，若最高数值位产生进位则为$1$，否则为$0$。
    + $V=C0\oplus C1$：若$V=0$表示无溢出；$V=1$表示有溢出。



###### 符号标志位

即$SF$（$Symbol\,Flag$）。判断当前结果符号。

+ $SF=1$表示结果为负值。
+ 当产生溢出时，符号标志位置出错。
+ $SF=F_{i=max}$,$F_{i=max}$即为运算结果的最高位
+ 对于无符号整数运算，$SF$没有意义。



###### 零标志位

即$ZF$（$Zero\,Flag$）。判断当前数字是否为全0值。

+ $ZF=1$表示结果为$0$。
+ **无论是有符号数还是无符号数，$ZF$都有意义。**
+ 通过加法电路和最后的取反操作实现。



###### 进/借位标志位

即$CF$（$Carry\,Flag$）。表示无符号整数数加/减运算时的进位/借位（溢出）。

+ $CF=1$表示无符号数加法溢出/减法借位。
+ $CF=C_{out}\oplus Sub,Sub$即为加减法控制信号,加法0减法1;$C_{out}$即为最高位产生的进位
+ **对于有符号数的整数运算，$CF$没有意义。**



### 定点数运算

#### 定点数移位运算

首先明确一件事情

在不产生溢出的情况下,左移相当于原数乘二

在不考虑因移出而舍弃的末位尾数的情况下,右移相当于原数除以二

+ 算术移位：针对**有符号数**，符号位保持不变，通过改变各个数码位和小数点的相对位置，从而改变各数码位的位权。可用移位运算实现乘法、除法。
    + 原码的算数移位——仅对数值位进行移位：
        + 若右移高位补$0$，低位舍弃，右移代表除$2$，若移出的是$0$则刚好整除，若移出的是$1$则会整除余$1$丢失精度。
        + 若左移低位补$0$，高位舍弃，左移代表乘$2$，若移出的是$0$则刚好乘$2$，若移出的是$1$，则会溢出严重误差。
    + 反码的算术移位——正数的反码与原码相同，所以正数的处理跟原码一样。而对于负数而言，反码的$1$等于原码的$0$，反码的$0$等于原码的$1$：
        + 若右移低位补$1$，高位舍弃。
        + 若左移高位补$1$，低位舍弃。
    + 补码的算术移位——正数的补码与原码相同，所以正数的处理跟原码一样。由于负数补码=反码末位加一，导致反码最右边几个连续的$1$都因进位而变为$0$，直到进位碰到第一个$0$为止。所以得到规律：
        + 负数补码中，最右边的$1$及其右边同原码一样。最右边的$1$的左边同反码一样。
        + 右移同反码，高位补$1$，低位舍弃。
        + 左移同原码，低位补$0$，高位舍弃。
+ 逻辑移位，逻辑的移位可以视为对无符号数的算术移位：
    + 逻辑右移：高位补$0$，低位舍弃。
    + 逻辑左移：低位补$0$，高位舍弃。
+ 循环移位，将移出的一位放到另一端的端点，类似队列：
    + 进位位$CF$：保存计算是否进位。$1$代表产生进位，$0$代表未产生进位。
    + 带$CF$就是大循环，不带$CF$的就是小循环。不论带不带$CF$进行循环移位，最高位的值都必定与$CF$的值相等。
    + 循环右移：将最低位的一位移出放到最高位，其余右移一位。
    + 循环左移：将最高位的一位移出放到最低位，其余左移一位。
    + 带进位位的循环左移：需要加上进位位数值的循环左移。
    + 带进位位的循环右移：需要加上进位位数值的循环右移。
    + 适合将数据的低字节数据和高字节数据互换。



#### 定点数加减运算

+ 注意机器字长，若溢出则将溢出位丢弃。
+ 原码的加减，由加法器和减法器两个硬件来实现，因为最高位为符号位，所以不能直接进行加减，符号位要单独处理：
    + 原码的加法：
        + 正数+正数：绝对值做加法，结果为正数。
        + 负数+负数：绝对值做加法，结果为负数。
        + 正数+负数：绝对值大的减绝对值小的，符号同绝对值大的数。
    + 原码的减法，减数符号取反，转变为加法：
        + 正-负→正+正。
        + 负-正→负+负。
        + 正-正→正+负。
        + 负-负→负+正。
+ 补码的加减，由于减法器的硬件实现比较困难，所以原码的减法操作可以由补码来更简单实现，不用考虑符号位的问题，直接全部参与运算：
    + 参与运算的两个操作数均用补码表示。
    + 按二进制运算规则运算，逢二进一（与模二加减法不同需要进位）。
    + 符号位与数值位按同样规则一起参与运算，符号位运算产生的进位要丢掉，结果的符号位由运算得出。
    + 补码加减运算依据下面的公式进行。当参加运算的数是定点小数时，模$M=2$；当参加运算的数是定点整数时，模$M=2^{n+1}$。$[A+B]_\text{补}=[A]_\text{补}+[B]_\text{补}$（$\mod M$）；$[A-B]_\text{补}=[A]_\text{补}+[-B]_\text{补}$（$\mod M$）。
    + $\mod M$运算是为了将溢出位丢掉。也就是说，若做加法，则两数的补码直接相加；若做减法，则将被减数与减数的机器负数相加。
    + 补码运算的结果亦为补码。
+ 溢出判断，**由于使用补码进行加减操作都会变成加法，所以只用考虑加法溢出的处理。**
    + 小于最小值就是下溢。只有负数+负数才会下溢得到正数。如$-24-124=1110\,1000+1000\,0100=0110\,1100=108$。
    + 大于最大值就是上溢。只有正数+正数才会上溢得到负数。如$15+124=0000\,1111+0111\,1100=1000\,1011=-117$。
    + 对于小数，其绝对值小于等于$1$。
    + 方法一，采用一位符号位（模二补码），根据符号位判断：
        + 设$A$的符号为$A_s$，$B$的符号为$B_s$，运算结果的符号为$S_s$。
        + 则溢出逻辑表达式为$V=A_sB_s\overline{S_s}+ \overline{A_s}\overline{B_s}S_s$（即$V=A_s\&\&B_s\&\&!(S_s)\mid\mid!(A_s)\&\&!(B_s)\&\&S_s$，前面判断下+溢，后面判断上溢）。
        + 逻辑表达式的含义：
            + PS.符号位为0表示是正数,符号位为1表示是负数
            + 第一项 $A_sB_s\overline{S_s}$：表示当两个操作数 $A$ 和 $B$ 的符号位相同（都为正或都为负），而运算结果的符号位与操作数的符号位不同（异号），即产生了溢出。
            + 第二项 $\overline{A_s}\overline{B_s}S_s$：表示当两个操作数 $A$ 和 $B$ 的符号位不同（一个正一个负），而运算结果的符号位与操作数的符号位相同（同号），即产生了溢出。
        + 若$V=0$，表示无溢出，若$V=1$，表示有溢出。
        + 由于只有操作数同号才能溢出，即判断标准为，两个操作数是否同号，结果符号是否与原操作数相同，这两个条件必须同时满足。
        + 如$-24-124=108$产生了溢出，$A_s=1$、$B_s=1$、$S_s=0$，$V=A_sB_s\overline{S_s}+ \overline{A_s}\overline{B_s}S_s=1\,1\,1+0\,0\,0=1+0=1$，所以产生了溢出。
    + 方法二，采用一位符号位（模二补码），根据数据位进位$1$情况判断：
        + 符号位的进位$C_s=0$，最高数值位的进位$C_1=1$时产生了上溢。
        + 符号位的进位$C_s=1$，最高数值位的进位$C_1=0$时产生了下溢。
        + 原理同方法一类似，如果进位产生并符号与期待符号不同则发生溢出。
        + 如$-24-124=1110\,1000+1000\,0100=0110\,1100$中符号位都为$1$相加结果为$0$，所以符号位进位，$C_s=1$，而最高数值位为$1+0=1$，没有进位，所以$C_1=0$，所以就产生了下溢。
    + 方法三，采用双符号位（模四补码），正数符号为$00$，负数符号为$11$。
        + 若两个符号位不同，则表示溢出，第一个符号位表示应该得到的符号位，第二个符号位代表实际得到的符号位。
        + 如$-24-124=11,110\,1000+11,000\,0100=10,110\,1100=108$。下溢。
        + 如$15+124=00,000\,1111+00,111\,1100=01,000\,1011=-117$。上溢。
        + 实际存储时只存储一个符号位，运算时会复制一个符号位。
+ 符号扩展：防止溢出的一个方法就是将短数据扩展为长数据，把数据全部拓展为等长。（正数补码全部补$0$，负数补码高位补$1$低位补$0$）
    + 整数扩展，在原符号位和数值位中间添加新位，正数都填充$0$，对于负数：
        + 原码：扩展补$0$。
        + 反码：扩展补$1$。
        + 补码：扩展补$1$。
    + 小数扩展，在最后面添加新位，正数都填充$0$，对于负数：
        + 原码：扩展补$0$。
        + 反码：扩展补$1$。
        + 补码：扩展补$0$。



#### 定点数乘法运算

二进制乘法基本流程：将乘法变为加法和移位运算，将乘数一位位的向前移动并与被乘数相乘，由于是二进制所以只有$0$和$1$，遇到乘数当前位值为$1$就在原来的和上加上被乘数，并向前移动一位，如果是$0$就加上$0$继续移动一位，当乘数位数访问完成则乘法完成，所有的和相加成为最后的积。

##### 原码一位乘法

+ 一般使用原码一位乘法，即每次只乘一位的数据。
+ 在原码乘法时，可以先符号位单独处理，将两个符号进行异或操作，得到的结果就是最后的结果的符号。然后对数据的绝对值（去除符号位）进行一位位的乘法（位积）然后相加。
+ 由于运算时可能存在绝对值大于$1$但是不是溢出的情况，所以部分积和被乘数使用双符号位。
+ 在运算器的组成时出现一个表格，说明在进行乘运算时，$ACC$保存乘积高位，$MQ$保存乘数与乘积低位，$X$保存被乘数。
+ 原码一位乘法机器实现时就是按照这种方式计算：
    1. 字长若为$n+1$位，则$ACC$、$MQ$、$X$全部初始化为$n$位，将被乘数的绝对值放入$X$中，$MQ$放入乘数的绝对值，$ACC$初始化为全$0$。
    2. 将$MQ$的最右边的一位当做当前乘运算位，让其进行乘运算，运算规则是，若当前位是$1$，则$ACC$加上被乘数，即$ACC+=X$，若当前位是$0$，则$ACC$加上$0$（保持不变，跳过）。
    3. 将$ACC$和$MQ$的数据连接在一起，全部逻辑右移一位，$ACC$数据高位补$0$，$ACC$最后一个低位移到$MQ$的最高位。将$MQ$的最后一位抛弃。若是第i轮逻辑右移，则$MQ$的前$i$位是结果的后$i$个低位值。
    4. 从步骤二开始重复，字长若为$n+1$位，则重复$n$次，直到$MQ$的最后一位是符号位，则停止计算。此时$ACC$的全部和$MQ$的前$n$位都是结果。
    5. 定点小数的小数位隐藏在符号位后面第一位，定点正数的小数位隐藏在$MQ$符号位的前一位。
    6. 将两个符号位的异或结果赋值给积最高位。
+ 原码一位乘法逻辑运算：
    1. 初始化，左边为部分积，即计算的部分结果，最开始为全$0$，右边为乘数的绝对值，最后边全部为丢失位。
    2. 根据丢失位前一位的值来判断加上什么，若是$1$则加上被乘数的绝对值，若是$0$则加上被乘数等长的全$0$。
    3. 右移部分积一位，高位补$0$，丢失位多一位。
    4. 继续计算，直到乘数全部被移出。字长为$n+1$位则需要移位计算$n$次。丢失位前的就是全部部分积。
    5. 将两个符号位的异或结果赋值给积最高位。





##### 补码一位乘法

+ 对于补码的乘法运算的逻辑也跟原码的类似，补码的计算就是使用$Booth$算法实现。
+ 辅助位其实就是在$MQ$最后再加上一位，辅助位初始为$0$。每次右移会使$MQ$的最低位顶替原本的辅助位（事实上$MQ$共$n+2$位）。
+ 为了保证统一，所以$ACC$和$X$都会增加一位，变成$n+2$位，多出来的一位就可以实现双符号位补码运算，而$MQ$还是用原来的单符号位。
+ 为了加快运算会有辅助电路实现$(-x)$的补码的运算。
+ 最后一次不需要移位直接根据辅助位和$MQ$最后一位判断进行相加。从而让乘数的符号位也参数运算中来确定最后结果的符号。
+ 补码一位乘法逻辑运算：
    1. 初始化，左边为部分积，即计算的部分结果，最开始为全$0$，右边为乘数，然后是一个辅助位，最后边全部为丢失位。
    2. 根据辅助位$-MQ$最低位的差值来判断加上什么，若是$1$则加上被乘数的补码，若是$0$则加与被乘数等长的全$0$，若是$-1$则加上被乘数的负数的补码。
    3. 算术右移部分积一位，正数高位补$0$，负数高位补$1$，丢失位多一位。
    4. 继续计算，直到乘数全部被移出。字长为$n+1$位则需要移位计算$n$次。丢失位前的就是全部部分积。
    5. 最后一次不需要移位，再加一次。

$Booth$算法的移位法则，其中$y_n$为$MQ$最低位，$y_{n+1}$为辅助位：

| $y_n$（高位） | $y_{n+1}$（低位） |                 操作                 |
| :-----------: | :---------------: | :----------------------------------: |
|       0       |         0         |            部分积右移一位            |
|       0       |         1         | 部分积加$[X]_{\text{补}}$，右移一位  |
|       1       |         0         | 部分积加$[-X]_{\text{补}}$，右移一位 |
|       1       |         1         |            部分积右移一位            |

即辅助位减$MQ$最低位的值，若是$1$就加补码，若$0$则加$0$，若$-1$则加负数的补码。

## 浮点数

### 浮点数表示

#### 阶码与尾数

+ 指小数点的位置不固定，如使用科学计数法，如$9.694E2$。
+ 类似科学计数法，分为两个部分，阶码(一般记为$E$)和尾数(一般记为$M$)。其中阶码分为阶符和阶码数值,阶符和阶码数值反映数值大小、表示范围、小数点实际位置;尾数分为数符和尾数数值,数符代表浮点数的符号，尾数数值反映精度。
    + ![image-20230529154318976](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230529154318976.png)

+ 对于二进制的浮点数，阶码是常用补码或移码表示的定点整数，而尾数是常用原码或补码表示的定点小数。
+ $r$为阶码的底，即基数，一般为$2$,不过也可以使用$2^{n}$
+ 阶码$E$反映浮点数的**表示范围**及小数点的实际位置；
    + 阶码符号（exponent sign）：
        - 阶码符号表示阶码的正负号。它决定了浮点数的大小范围和取值方向。
        - 如果阶码符号为正，表示浮点数的阶码是正数；如果阶码符号为负，表示浮点数的阶码是负数。
    + 阶码数值（exponent value）：
        - 阶码数值是一个无符号整数，表示浮点数的阶码大小。
        - 阶码数值决定了浮点数在科学计数法中的指数部分的值，控制了浮点数的数量级。

+ 尾数$M$的数值部分的位数n反映浮点数的**精度**。
    + 数符（sign）：
        - 数符表示浮点数的正负号。它决定了浮点数的数值是正数还是负数。
        - 如果数符为正，表示浮点数是正数；如果数符为负，表示浮点数是负数。
    + 尾数数值（significand/mantissa）：
        - 尾数数值是一个带有符号位的小数或定点数，表示浮点数的小数部分或尾数部分。
        - 尾数数值决定了浮点数的精度和小数部分的值。

+ 其实$E\&M$就是分别的两个数,符号只是其本身的符号位

#### 尾数规格化

为了提高精度，充分利用**尾数有效位数必须进行规格化**，规定尾数必须是一个有效值。

+ **左规：算术左移n位，阶码真值减少n。**出现下溢需要左规，即若尾数的高位是无效值（即为$0$）则会丧失精度，所以我们需要尽可能将尾数多保存一些$1$，从而让最高位为$1$。所以需要让数值左移，让小数点右移，尾数算术左移$n$位，阶码减$n$，直到尾数最高位是有效值。可能会进行多次。
+ **右规：算术右移n位，阶码真值增加n。**出现上溢需要右规，规范要求小数点要在第一个非$0$的数据右边，如果小数点前有超过$1$个有效位，则需要将数值右移，小数点左移，尾数算术右移$n$位，阶码加$n$，直到小数点在尾数最高位的右边。只需要一次。

![image-20230528225320360](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230528225320360.png)

规格化浮点数的特点：

1. 用原码表示的尾数进行规格化，最高位数值一定为$1$：
    + 正数为$0.1xx\cdots x$的形式，其最大值表示为$0.11\cdots1$；最小值表示为$0.10\cdots0$。
    + 尾数的表示范围为$\dfrac{1}{2}\leqslant M\leqslant(1-2^{-n})$。
    + 负数为$1.1xx\cdots x$的形式，其最大值表示为$1.10\cdots0$;最小值表示为$1.11\cdots1$。
    + 尾数的表示范围为$-(1-2^{-n})\leqslant M\leqslant-\dfrac{1}{2}$。
    + **规格化格式：原码正数01，源码负数11**
2. 用补码表示的尾数进行规格化，符号位与最高位数值一定相反：
    + 正数为$0.1xx\cdots x$的形式，其最大值表示为$0.11\cdots1$；最小值表示为$0.10\cdots0$。跟原码一致。
    + 尾数的表示范围为$\dfrac{1}{2}\leqslant M\leqslant(1-2^{-n})$。
    + 负数为$1.0xx\cdots x$的形式，其最大值表示为$1.01\cdots1$；最小值表示为$1.00\cdots0$。（负数的补码$1.0xx\cdots x$取反后就是$1.1xx\cdots x$）
    + 尾数的表示范围为$-1\leqslant M\leqslant-(\dfrac{1}{2}+2^{-n})$。（补码中强制规定$1.00\cdots0$就代表$-1$）
    + **规格化格式：补码正数01，补码负数10**

当浮点数尾数的基数为$2$时，原码规格化数的尾数最高位一定是$1$，补码规格化数的尾数最高位一定与尾数符号位相反。

基数不同，浮点数的规格化形式也不同。当基数为$4$时，原码规格化形式的尾数正数最高两位不全为$0$，负数最高两位不全为$1$；当基数为$8$时，原码规格化形式的尾数正数最高$3$位不全为$0$，负数正数最高$3$位不全为$1$。

如若基数为$8$，则$0.000111$和$1.111010$都不是规格化数，而$1.101010$是规格化。

对于浮点数，上溢和下溢有正负之分：负上溢<负数区<负下溢<$0$<正下溢<正数区<正上溢。

#### 定点浮点区别

假设定点数和浮点数的字长相同。

+ 浮点数表示范围更大。
+ 浮点数精度降低。（由于只取出一部分数据，还有部分长度表示阶码等，所以用于表示尾数的字长减少）
+ 浮点数运算更复杂。（需要规格化，需要做尾数运算和阶码运算）
+ 浮点数只有规格化后才能判断是否溢出。



### IEEE 754标准

$IEEE\,754$标准就是浮点数标准，为了解决计算机中阶码、尾数使用什么码来表示，各取多少位的问题。

#### 移码定义

+ 移码的定义其实=真值+偏置值，一般取$2^{n-1}$，这时候移码才等于补码符号位取反，若移码采取其他方案则没有这个特点。
+ 在$IEEE\,754$标准中，规定移码的偏置值不再是$128$而是$127$，即$2^{n-1}-1$。所以这个标准下的移码与一般的移码不同。
+ 从而真值$-128$的移码为$-1000\,0000+0111\,1111=1111\,1111$，$-127$的移码为$0000\,0000$，$0$的移码为$0111\,1111$，$127$的移码为$1111\,1110$。

#### IEEE 754定义

+ 分为数符（表示数值正负号）、阶码（用移码表示）、尾数（用原码表示，且默认最高位为$1$，实际尾数都要在之前加$1$即实际尾数为$1.M$）。
    + ![image-20230529162847982](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230529162847982.png)

+ 标准中会将全$0$的$-127$（非规格化数）和全$1$的$-128$（无穷大）做特殊的用途，所以短浮点数的真值正常范围是$-126$到$127$。

|  英文类型   |  中文类型  | 数符位 | 阶码位 | 尾数位 | 总位数 | 十六进制偏置值 | 十进制偏置值 |
| :---------: | :--------: | :----: | :----: | :----: | :----: | :------------: | :----------: |
|    float    |  短浮点数  |   1    |   8    |   23   |   32   |      7FH       |     127      |
|   double    |  长浮点数  |   1    |   11   |   52   |   64   |      3FFH      |     1023     |
| long double | 临时浮点数 |   1    |   15   |   64   |   80   |     3FFFH      |    16383     |

+ 令数符为$S$，阶码为$E$，尾数为$M$。
+ 规格化的短浮点数$Float$的真值为$(-1)^S\times 1.M\times2^{E-127}$,共$1+8+23=32$位。
+ 规格化的长浮点数$Double$的真值为$(-1)^S\times 1.M\times2^{E-1023}$,共$1+11+52=64$位。
+ 短浮点数和长浮点数都隐含一位尾数最高位$1$，即$0.11$为$+1.11$，$1.11$为$-1.11$，而临时浮点数没有隐含位。



![image-20230528225855160](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230528225855160.png)

#### IEEE 754取值范围

|  格式  |            规格化的最小绝对值            |                      规格化的最大绝对值                      |
| :----: | :--------------------------------------: | :----------------------------------------------------------: |
| 单精度 |  $E=1$，$M=0$：$1.0×2^{1-127}=2^{-126}$  | $E=254$，$M=.11...1$：$1.11...1×2^{254-127}=2^{127}×(2-2^{23})$ |
| 双精度 | $E=1$，$M=0$：$1.0×2^{1-1023}=2^{-1022}$ | $E=2046$，$M=.11...1$：$1.11...1×2^{2046-1023}=2^{1023}×(2-2^{-52})$ |

![image-20230528225939326](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230528225939326.png)

+ 对于规格化短浮点数，只有$1\leqslant E\leqslant 254$正常区间时，$(-1)^S\times 1.M\times2^{E-127}$。
+ 阶码全0全1时的特殊用途
    + 当阶码$E$为全$0$，即应该为$-127D$，而尾数$M$不全为$0$时，表示**非规格化小数**$\pm(0.\textrm{M})_2\times2^{-126}$。（此时最高位就不默认为$1$了，阶码固定设置为$-126$）。
    + 当阶码$E$为全$0$，即应该为$-127D$，而尾数$M$全为$0$时，表示真值$\pm0$，正负由数符决定。
    + 当阶码$E$为全$1$，即应该为$-128D$，而尾数$M$全为$0$时，表示无穷大$\pm\infty$，正负由数符决定。
    + 当阶码$E$为全$1$，即应该为$-128D$，而尾数$M$不全为$0$时，表示非数值$NaN$（$Not\,a\,Number$）。如果非法操作如$\frac{0}{0}$等就会使用到。




#### 单精度浮点数与真值之间的转换

![image-20230528230030881](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230528230030881.png)

![image-20230528230050126](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230528230050126.png)

#### 尾数运算

由于阶码由原码转换为移码，尾数加减都需要进行原码运算，所以需要两种实现方式。

+ 转换为补码进行加减，再转回原码。
+ 直接用原码加减，符号和数值分开。

### 浮点数计算

#### 引例:科学计数法加减

1. 对阶：阶数小的向阶数更大的对齐。
    + 因为计算机内部，尾数是定点小数，小数点位置不会变，改变的只是数据的相对位置。
    + 若是阶数大的向阶数小的对齐，则阶数大的尾数值会变大，需要对尾数进行算术左移，若内存不够大很可能会引起最高有效位丢失。
    + 若是阶数小的向阶数大的对齐，则阶数小的尾数值会变小，需要对尾数进行算术右移，若内存不够大很可能会引起最后几位丢失，即精度下降，影响较小。
2. 尾数加减：阶数不变，对尾数进行相加减。
3. 规格化，将数据变为整数部分为$0$到$9$的数据：
    + 当尾数加减结果的第一位为$0$时需要左规，直到第一位不为$0$。
    + 当结果的整数部分大于等于$10$需要右规，直到整数部分只有一位。
4. 舍入：计算机中由于尾数的比特位有限，所以需要舍弃尾数的低位。只有浮点数才会舍入，定点数则没有这个概念。**对阶**和**右规格化**都会引起舍入。舍入方法有：
    + 直接去除。
    + 非$0$进$1$。
    + 四舍五入。
5. 判溢出：若运算后阶码超过规定范围则溢出。尾数的溢出未必会导致整体溢出，可以通过第三四步来修补，但是阶码溢出一定会整体溢出。

溢出的情况：

+ 右规和尾数舍入（如果是四舍五入可能导致尾数加一，尾数需要进位，阶码加一，导致阶码上溢）可能引起阶码上溢。
+ 左规可能引起阶码下溢。
+ 对阶不会导致溢出（因为是向大阶对齐，大阶一定不是溢出的）。

<!-- **例题** 计算$9.85211\times10^{12}+9.96007\times10^{10}$的值并保留四舍五入六位有效尾数。

第一步进行对阶，变成$9.85211\times10^{12}+0.0996007\times10^{12}$。

第二步进行相加得到$9.9517107\times10^{12}$。

第三步由于整数部分为9，所以不需要规格化。

第四步因为只能保留六位有效尾数，所以保留9.95171，因为后一位是0，所以不进位为最后答案。

第五步因为阶码无论是10或12都是两位，所以肯定没有溢出。 -->



#### 浮点数的加减运算

一般步骤

1. (转换格式化为浮点数)
    1. 一般格式为$2^{E}\times M$,$M$最高位可能是1可能是0,卷子上一般会给出浮点数格式,可能是双符号位格式(11表示负数,00表示正数)
    2. **此处阶码尾数均用补码表示**
2. 对阶
    1. 使两个数的阶码相等，小阶向大阶看齐，尾数每右移一位，阶码加1
3. 尾数加减
4. 规格化
5. 舍入
6. 判溢出





**【例题】:**

例：已知十进制数$X=-\frac{5}{256}$、$Y=+\frac{59}{1024}$,按机器补码浮点运算规则计算$X-Y$,结果用二进制表示，浮点数格式如下：阶符取2位，阶码取3位，数符取2位，尾数取9位。

**【解】:**

1. 转换格式化为浮点数

    

    $(5)_{10}=(101)_{2},\frac{1}{256}=2^{-8}$此处先不慌把-8转换

    $X=(-101)_{2}\times 2^{(-8)_{10}}=(-0.101)_{2}\times 2^{(-5)_{10}}$此处有进制混用,建议分开写

    对于阶码$E$,$(-5)_{10}=(1101)_{\text{原码}}=(11011)_{\text{双符号位补}},$

    对于尾数$M$,$(-0.101)_{2}=(1 101)_{\text{原码}}=(11.0110\,0000\,0)_{\text{双符号位补}}$

    则化为题目所给格式为$X:11.0110\,0000\,0;11 011,Y=00.1110\,1100\,0;11100$.

2. 对阶

    1. 使两个数的阶码相等，小阶向大阶看齐，尾数每右移一位，阶码加1

    2. 求阶差:$[\Delta E]_{\text{补}}=11011+00100=11111$,可知$[\Delta E]=-1$

        **此处是求XY两数阶数之差$X-Y$,由于计算机中计算减法是利用补码,所以此处是先将Y转换成对应负补码计算$X+Y$得到$11111^{补}$即为-1**

    3. 对阶:$X:11.0110\,0000\,0;11 011$转换为$X:11.1011\,0000\,0;11100$

        ****

3. 尾数加减

    1. $X-Y:10.1100\,0100\,0;11100$

4. 规格化

    1. $X-Y:10.1100\,0100\,0;11101$

5. 舍入

    1. 此处无舍入

6. 判溢出

    1. 常阶码，无溢出

结果即为$(-0.1001\,111)_{2}\times 2^{(-011)_{2}}$

![image-20230529201632972](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230529201632972.png)

#### 强制类型转换

|   类型    | 16位机器 | 32位机器 | 64位机器 |
| :-------: | :------: | :------: | :------: |
|   char    |    8     |    8     |    8     |
|   short   |    16    |    16    |    16    |
|    int    |    16    |    32    |    32    |
|   long    |    32    |    32    |    64    |
| long long |    64    |    64    |    64    |
|   float   |    16    |    32    |    32    |
|  double   |    64    |    64    |    64    |

无损转换：

+ $char$→$int$→$long$→$double$。
+ $float$→$double$。

此处默认$long$型为$32$位,64位$long$型向$double$转换会有精度损失

由于定点数和浮点数不同，浮点数使用阶码+尾数的存储方式存储，所以定点数数值精度看位长就可以了，而浮点数数值精度看尾数长度，按$IEEE\,754$标准有一个隐含的高位$1$，所以$double$尾数长度为$53$位。对于$32$位机器$long$是$32$位，所以转换到$double$的$53$位没有损失，而对于$64$位机器$long$是$64$位，$double$还是$53$位，这时候转换就会产生损失了。

$int$与$float$转换

+ $int$：表示整数，范围$[-2^{31},2^{31}-1]$，有效数字$32$位。
+ $float$：表示整数及小数，范围$\pm[2^{-126},2^{127}×(2-2^{-23})]$，有效数字$23+1=24$位。
+ $int$→$float$：可能损失精度。
+ $float$→>$int$：可能溢出及损失精度。





# 第三章 存储系统

## 【考纲内容】

1. 存储器的分类
2. 层次化存储器的基本结构
3. 半导体随机存取存储器
    1. $SRAM$、$DRAM$、$Flash$存储器
4. 主存硅器
    1. $DRAM$芯片和内存条、多模块存储器、主存和 $CPU$之间的连接
5. 外部存储器
    1. 磁盘存储器、固态硬盘($SSD$)
6. 高速缓冲存储器
    1. $Cache $的基本原理;$Cache $和主存之间的映射方式
    2. $Cache $中主存块的替换算法; $Cache $写策略
7. 虚拟存储器
    1. 虚拟存储器的基本概念
    2. 页式虚拟存储器:基本原理、页表、地址转换、$TLB $(快表)
    3. 段式虚拟存储器的基本原理;段页式虚拟存储器的基本原理

### 知识导图

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/672FB81A53104DD5A97665FF62EFF7DB.png)

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/38C568CC236147D58434E3F19E736C23.png)

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/B5A436D1D5A44E8BA040A1327886A3E3.png)

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/A3F555F82C9B4FBCABE43FDEC9208472.png)

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/B62FEAA02C6248DEA9776FB3786C261B.png)

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/F97108E05F724CA28FB4E3B7EB34026B.png)

























![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/A3F1E19083EF42A2828EDBBFC1D3B6D1.png)

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/24615E5383D14DC39D5F6C66E12B895D.png)

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/B5A2938961C048A68859D0634F7A5FE4.png)

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/B28B6811A1104FE5BFE21B79F0242B34.png)

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/24898425462440FBB9D9C234BE1C05B3.png)

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/E28034CF80874956BC3BCEE9987E86FA.png)

![img](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/CF749DF9747048A9A2AE955907DDFC24.png)



## 存储器概念

### 存储器的分类

#### 按作用分类

+ 主存储器：主存或内存。
    + 存放计算机运行间的程序和数据。
    + $CPU$、$Cache$，能直接访问。
    + 容量小、速度快、价格高。
+ 辅助存储器：辅存或外存。
    + 存放暂时不用的或永久的数据。
    + 不能与$CPU$直接交换信息。
    + 容量大、速度慢、成本低。
+ 高速缓冲存储器$Cache$。
    + 存放正在执行的程序和数据。
    + 在$CPU$中。
    + 容量小、速度快、价格高。

#### 按存取方式分类

+ 随机存取：**与存储单元的物理位置无关**
    + $RAM(Random\,Access\,Memory)$：随机存取存储器：
        + $DRAM$：动态。
        + $SRAM$：静态。
    + $ROM(Read-Only\,Memory)$：只读存储器。
    + $CAM(Content-Addressable\,Memory)$:相联存储器
+ 串行访问：**读写某个存储单元所需时间与存储单元的物理位置有关**
    + 直接存取$DAM$：磁盘。
    + 顺序存取$SAM$：磁带。

#### 按存储介质分类

+ 磁表面存储器：
    + 磁盘。
    + 磁带。
+ 磁芯存储器。
    + $MOS$型存储器。
    + 双极型存储器。
+ 光存储器：光盘。
+ 半导体存储器。

#### 按信息的可更改性分类

- 读写存储器$(Read/Write\,Memory)$:即可读也可写
    - 如：磁盘、内存、Cache
- 只读存储器$(Read\,Only\,Memory,ROM)$:只能读不能写(事实上很多ROM也可以多次读写,只是比较麻烦)
    - 如：实体音乐专辑通常采用CD-ROM,实体电影采用蓝光光碟，BIOS通常写在ROM中



#### 按信息可保存性分类

+ 断电后信息是否消失：
    + 易失性：$RAM(Cache,主存)$。
    + 非易失性：磁带、$ROM$。
+ 破坏性，存取是否影响存储内存：
    + 破坏性读出：$DRAM$。
    + 非破坏性读出。

### 存储器性能指标

1. 存储容量：存储字数×字长（如$1M\times8$位）。

2. 单位成本：每位价格=总成本÷总容量。

3. 存储速度：数据传输率=数据的宽度÷存储周期：

    ![image-20230531144914508](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230531144914508.png)

    + 存储周期=存取时间+恢复时间。
    + 存取时间（$T_a$）：存取时间是指从启动一次存储器操作到完成该操作所经历平均的时间，分为读出时间和写入时间。
    + 存取周期（$T_m$）：存取周期又称为读写周期或访问周期。它是指存储器进行一次完整的读写操作所需的金部时间，即连续两次独立地访问存储器操作（读或写操作）之间所需的最小时间间隔。
    + 主存带宽（$B_m$）：主存带宽又称数据传输率，表示每秒从主存进出信息的最大数量，单位为字/秒、字节/秒（$B/s$）或位/秒（$b/s$）。

### 存储器层次化结构

![image-20230531153244212](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230531153244212.png)

![image-20230531153635799](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230531153635799.png)

![image-20230531153409405](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230531153409405.png)

+ $CPU$。
+ $Cache$：为了解决$CPU$的高速与主存之间的低速速度不匹配的问题，由硬件自动完成。
+ 主存。
+ 辅存：为了解决主存容量不足的问题，由硬件和操作系统共同完成。
+ 虚拟存储系统。



## 主存储器

### 主存储器的基本组成

#### 基本半导体元器件的原理

+ 存储元：由电路控制的单个存储部件。
    + ![image-20230531151020133](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230531151020133.png)
    + 规定电容保存电荷时表示二进制的1,反之为0
    + 当MOS管接通时,在末端检测到电流即表示存储元存储的数据为1,反之为0
+ 存储单元：由同一个电路控制的一组同时读写的存储部件集合，一般为一行存储元，一行存储元的个数就代表一次存储的字长。
    + ![image-20230531154319195](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230531154319195.png)
    + 对红线通上高电压,监测绿线是否有电流则可以判断存储的数据
    + 每一行存储元组成一个存储字,一个存储字的位数等于数据总线宽度等于计算机位数(64位计算机数据总线宽度为64位)
+ 存储体：由多个存储单元构成的，多个电路控制的存储集合。
+ 存储字：存储单元通电后由电信号表示可以读写的一个存储单元信息集合。存储字的位数就是存储字长，单位是$bit$。

#### 存储芯片的基本原理

![image-20230531155044312](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230531155044312.png)

$n$位地址对应$2^n$个存储单元和译码器输出线

当电流稳定下来后,译码器会根据$MAR$所给地址的字选线(此处为0号字选线)通上高压电流,$MDR$会在数据线(位线)处读出数据![image-20230531155714441](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230531155714441.png)

存储体总容量=存储单元个数$\times$存储字长

此处等于$2^3 \times 8bit =8 \times 1 Byte=8B$



![image-20230531160212237](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230531160212237.png)

+ 控制电路

    + 对于$MAR$端和译码器端:电流可能不稳定,当电流稳定下来才打开译码器开关让电流输入译码器

    + 对于$MDR$端:当电流稳定下来后才控制$MDR$输出数据给数据总线

+ 片选线:是整个存储芯片的开关,用来确定哪一个存储芯片被选中，可用于容量扩充

    + 一个存储器可能由多个存储矩阵组成,由片选线控制哪个存储矩阵工作

    + $\overline{CS}$：芯片选择信号，选择指定芯片，低电平有效。
    + $\overline{CE}$：芯片使能信号，打开指定芯片进行存储，低电平有效。

+ 读写控制线:见图,字面意思

    + 如果是一根就用$\overline{WE}$表示，低电平写，高电平读。如果是$WE$则反之。
    + 如果是两根，则$\overline{OE}$低电平表示允许读，$\overline{WE}$低电平表示允许写。如果是$OE$和$WE$则反之。

+ 存储矩阵：由大量相同位存储单元阵列。

+ 译码驱动：将来自地址总线的地址信号翻译成对应存储单元的选通信号，该信号在读写电路的配合下未完成对被选中的单元的读写操作。

    + 译码器：将$MAR$输入的地址进行译码，选择选中的存储单元地址。
    + 驱动器：根据译码器提供的地址，通过驱动器获取对应存储单元。

总体结构如下图

![image-20230531160920612](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230531160920612.png)

![image-20230531154008906](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230531154008906.png)

存储芯片通常描述:

![image-20230531161352914](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230531161352914.png)

### 随机存储器$(Random\,Access\,Memory,RAM)$

RAM芯片一一易失性，断电后数据消失

#### $DRAM$和$SRAM$的区别

$DRAM(Dynamic\,Random\,Access\,Memory)$:动态随机存储器(动态$RAM$)

$SRAM(Static\,Random \,Access\,Memory)$:静态随机存储器(静态$RAM$)

* $DRAM$主要用于主存,$SRAM$主要用于$Cache$
* **核心区别:存储单元不一样.**$DRAM$使用**栅极电容**(见3.1)存储信息,$SRAM$主使用**双稳态触发器**(6个$MOS$管)存储信息



| 类型                  | DRAM                                                         | SRAM                                                       |
| --------------------- | ------------------------------------------------------------ | ---------------------------------------------------------- |
| 存储信息              | 栅极电容，充电是1，否则为0                                   | 双稳态触发器，分为0态和1态                                 |
| 破坏性读出            | 是；读需要连接电容，检测电流变化，电流随着电路连通而溜走；写需要给电容充放电 | 非；读只用查看触发器状态；写只用改变触发器状态             |
| 需要刷新              | 需要，因为电容上的电荷只能维持$2ms$,刷新由存储器独立完成不需要$CPU$控制 | 不需要，一直供电能保持两种稳定的状态                       |
| 易失/非易失性存储器？ | 易失(断电后信息消失),$RAM$芯片都是易失性                     | 易失(断电后信息消失),$RAM$芯片都是易失性                   |
| 送行列地址            | 分两次送，行地址和列地址分开，所以地址线可以复用，**线路引脚数减少一半**，需要一根行通选线和一根列通选线 | 同时送，因为地址分为行地址和列地址一同发送，需要一根片选线 |
| 运行速度              | 慢                                                           | 快                                                         |
| 集成度                | 高，1个或3个逻辑元件构成                                     | 低，6个逻辑元件构成                                        |
| 发热量                | 小                                                           | 大                                                         |
| 存储成本              | 低，常用于主存(现在的主存通常采用$SDRAM$芯片)                | 高，常用于$Cache$                                          |

<span style="color:orange">注意：</span>$SRAM$不地址复用，而$DRAM$地址复用。（地址线只有原来的一半）

#### 存储器芯片结构

+ 存储体：由行选择线$X$和列选择线$Y$选择访问单元。
+ 地址译码器：将地址转换为译码输出线上的高电平，以便驱动对应读写电路。
+ $I/O$控制电路：控制选中单元读出写入，并放大信息。
+ 片选控制信号：产生片选控制。
+ 读/写控制信号：输入读或写命令。

#### DRAM的刷新

+ 刷新周期：一般为$2ms$。
+ 刷新单元数：以行为单元，每次刷新一行存储单元。
    + 如果译码器有$n$位，则可以寻址$2^n$个，也就需要$2^n$与存储单元连接的线路，很难实现。
    + 将地址拆分为行列地址（$DRAM$行、列地址等长）。
    + $SRAM$需要$2^n$条线路，而$DRAM$需要$2^{\frac{n}{2}+1}$根线。
+ 刷新方式：硬件支持，读出一行的信息后重新写入整个行，占用一个读/写周期。
+ 刷新时刻：假设$DRAM$内部结构排列为$128\times128$的形式，读写周期为$0.5\mu s$，所以$2ms$一共$4000$个周期（注意针对刷新问题，读写时间不是重点，即无论是否读写或者读写多少行，都要在固定时间进行刷新所有行）：
    + 集中刷新：
        + 有一段时间专门刷新，但是这时候就无法访问存储器，称为访存死区。该段时间为死时间。
        + 因为有$128$行，刷新需要$128$个周期的时间。所以一共需要专门刷新$128\times0.5=64\mu s$，则前面正常读写时间为$2000-64=1936\mu s$，读写需要$3872$个周期。
        + 读写时间不受刷新工作的影响，但是存在死区。
    + 分散刷新：
        + 每读取完一行数据就刷新一次。
        + 如在每存取周期$1\mu s$中前$0.5$用于读写，后$0.5$用于刷新该行。
        + 没有死区，但是加长了系统存取周期，降低整机速度。
    + 异步刷新：
        + 隔一段时间刷新一次，一次要刷新所有的行，而如果将刷新设置在不需要访存的译码时间可以加大利用效率。
        + 将刷新周期除以行数，得到两次刷新操作之间的时间间隔$t$，利用逻辑电路每$t$时间产生一次刷新请求。
        + 因为每隔$2ms$要刷新$128$行即$128$次，所以平均每个时间周期为$\frac{2ms}{128}=15.6\mu s$，$15.6\mu s$中要读写数据并刷新一次即一行，所以每$15.6\mu s$中有$0.5\mu s$的死时间，其中前$15.6-0.5=15.1\mu s$用来读写。

#### RAM的读写周期

+ 读周期：
  + 从给出有效地址开始，到读出所选中单元的内容并在外部数据总线上稳定地出现所需的时间，称为读出时间（$t_A$）。从数据稳定到数据有效之间存在一个时间缝隙，因为数据线上的信号速度是不一样的，所以需要这个缓冲。
  + 地址片选信号$\overline{CS}$必须保持到数据开始稳定输出，$t_{CO}$为片选的保持时间，即发出片选信号的从地址有效到地址失效的时间，在读周期中$\overline{WE}$为高电平。
  + 读周期与读出时间是两个不同的概念，读周期时间（$t_{RC}$）表示存储芯片进行两次连续读操做时必须间隔的时间，因为里面存在要等待数据稳定才能开始读的等待时间等其他时间，所以必然大于等于读出时间。

![download](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/download.png)

+ 写周期：
  + 要实现写操作，要求片选信号$\overline{CS}$和写命令信号$\overline{WE}$必须都为低电平。
  + 为使数据总线上的信息能够可靠地写入存储器，要求$\overline{CS}$信号与$\overline{WE}$信号相“与”的宽度至少为$t_{WC}$。
  + 为了保证在地址变化期间不会发生错误写入而破坏存储器的内容，$\overline{WE}$信号在地址变化期间必须为高电平。
  + 为了保证有效数据的可靠写入，地址有效的时间至少应为$t_{WC}=t_{AW}+t_W+t_{WR}$。其中$t_{AW}$和$t_{WR}$为写入前和写入后必须的间隔时间，$t_W$为写入的时间。
  + 为了保证在$\overline{WE}$和$\overline{CS}$变为无效前能把数据可靠地写入，要求写入的数据必须在$t_{DW}$以前在数据总线上已经稳定。

![download](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/download.png)

### $ROM$

只读存储器$ROM$即使断电也能保存数据，主存不能直接与$CPU$相连，所以一定会出现$ROM$来完成这个工作。

$ROM$写入速度不如$RAM$，所以一般还是用来保存信息而不用于大量的写。

#### $ROM$的分类

+ 掩模式只读存储器（$MROM$）：存储内容由半导体制造厂按用户提出的要求在芯片的生产过程中直接写入，无法修改。
+ 一次可编程只读存储器（$PROM$）：存储内容由用户用专门的设备（编程器）一次性写入，之后无法修改。
+ 可擦除可编程只读存储器（$EPROM$）：先全部擦除数据然后编程。修改次数有限，写入时间长：
  + 紫外线擦除（$UVEPROM$）。
  + 电擦除（$EEPROM$）。
+ 闪速存储器（$Flash\,Memory$）：如$U$盘，写入速度快。
+ 固态硬盘（$Solid\,State\,Drives$）：控制单元+$FLASH$芯片。

### 只读存储器$(Read-Only\,Memory,ROM)$

ROM芯片一一非易失性，断电后数据不会丢失

#### $ROM$的种类

+ $MROM (Mask\,Read-Only\,Memory)$ 一一掩模式只读存储器
    + 厂家按照客户需求，在芯片生产过程中直接写入信息，之后任何人**不可重写,只能读出**
    + 可靠性高、灵活性差、生产周期长、只适合批量定制


+ $PROM (Programmable\,Read-Only\,Memory)$ 一一可编程只赌存储器
    + 用户可用专门的PROM写入器写入信息，写一次之后就不可更改
+ $EPROM (Erasable\,Programmable\,Read-Only\,Memory)$ 一一可擦除可编程只读存储器
    + 允许用户写入信息，之后用某种方法擦除数据，**可进行多次重写**
    + $UVEPROM (Ultraviolet\,Rays,紫外线)$ 一一用紫外线照射8~20分钟，**擦除所有信息,无法特定擦除**
    + $EEPROM$(也常记为$E^2PROM$，第一个$E$是$Electrically$)一一可用“电擦除”的方式，擦除特定的字
+ $Flash Memory$ 一一闪速存储器(**注:U盘、SD卡就是闪存**)
    + 在$EEPROM $基础上发展而来， 断电后也能保存信息,且**可进行多次楷书擦除重写**
    + 注意: 由于闪存需要先擦除再写入，因此闪存的写速度比读速度要慢
    + 每个存储元只需单个$MOS$管，位密度比$RAM$高
    
+ $SSD (Solid \,State \,Drives)$ 一一 固态硬盘
    + 由控制单元+存储单元($Flash $芯片)构成，与闪速存储器的核心区别在于控制单元不一样，但存储介质都类似，**可进行多次快速擦除重写**。$SSD$速度快、功耗低、价格高。目前个人电脑上常用$SSD$取代传统的机械硬盘
    + 手机辅存也使用$Flash $芯片，但相比SSD使用的芯片集成度高、功耗低、价格贵;对于手机RAM一般指内存,ROM一般指辅存

### 多模块存储器





## 主存储器与$CPU$的连接

对$CPU$来讲，系统中所有物理存储器中的存储单元都处在一个统一的逻辑存储器中，这个逻辑存储器的容量大小受到$CPU$寻址能力的限制。如果一个$CPU$的地址总线宽度为$10$，则该$CPU$可以寻址的存储单元为$2^{10}=1024$个，这$1024$个可寻到的存储单元就构成了这个$CPU$的内存地址空间，也叫做逻辑存储器。

所以对于$CPU$而言，它有一个固定的内存地址大小，对应的地址就是个逻辑地址，所以$CPU$读入的数据有限，一次性处理的能力有限；而内存（如内存条）可以扩充，其实际地址就是物理地址，由操作系统给$CPU$的逻辑地址映射物理地址，还包括替换算法等一系列处理方案。

为了获取更多的容量，所以需要对主存容量进行扩展。

### 连接原理

$CPU$与内存通过总线连接。

+ $MDR$和$MAR$虽然为寄存器，但是现在一般集成在$CPU$上。
+ 数据总线直接连接在$MDR$上，可以写入也可以读出，是一个双向的。
+ 地址总线直接连接在$MAR$上，将$CPU$的地址要求交给主存，是一个单向的。其位数决定可寻址最大内存空间。
+ 控制总线向主存发送控制类型，如读写要求，是一个单向的。



### 主存容量扩展

为了获取更多的容量，所以需要对主存容量进行扩展。

#### 位扩展法

![image-20230531215407055](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230531215407055.png)

* 对于以上的存储器可以看到是$8K\times 1$位的
    * 地址线的连接:对于$8K$,$8K=2^{13}$,则需要13根地址线进行传输(此处为$A_0\sim A_{12}$),直接对应连接即可
    * $WE(Write\,Enable$,写使能信号$)$的连接:WE头上没有横线,表示高电平使能写,直接对应连接即可
    * 数据总线的连接:这里的存储器只有一位,$D_0$对应连接即可
    * CS片选信号:CS头上没有横线,表示高电平有效,这里直接接高电压即可

![image-20230531215642206](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230531215642206.png)

8片$8K\times 1$位组合成一块$8K\times 8$位的存储器



**【注意】：**

+ $CPU$的数据线数与存储芯片位数不一定相等，用多个存储器件对数据位数进行扩展（一次性输入输出数据数量）。
+ 地址总线和片选线都是并联的，数据总线连接在每一块芯片上。
+ 因为需要拓展位，所以一次性需要处理所有芯片的数据，从而需要对芯片同时进行片选线同步信号，所以所有芯片的$\overline{CS}$都可以连接在一起。
+ 每个芯片各输入输出一部分数据。

#### 字扩展法

![image-20230531220749895](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230531220749895.png)

+ 增加存储器中字的数量（数据的地址大小即能保存的数据的数量），而位数不变，字扩展将芯片的地址线、数据线、读写控制线相应并联，与位扩展法连接方式一样。
+ 但是如果每个芯片同时输入输出输数据则$CPU$无法区分到底是哪个芯片存储的数据，所以不能再将片选线连在一起同时控制。
+ 需要用片选信号区分个芯片地址范围，即将每个芯片的片选线依次连接在$CPU$的地址线接口上，因为不能同时工作，所以片选线信号$CS$或$\overline{CS}$不会同时为$1$或$0$，而片选线的信号连接在$CPU$的地址线接口上就相当于将片选线的信号也作为芯片存储地址。
+ 如一个$CPU$一共有$16$个地址线接口$A_0$到$A_{15}$与$8$个数据接口$D_0$到$D_7$以及一个读写控制线$\overline{WE}$，现在有两个$8K\times8$位的存储芯片，首先按位扩展时将两个芯片的地址线$A_0$到$A_{12}$全部串联接到$CPU$的$A_0$到$A_{12}$接口上，芯片读写线$WE$串联接到$CPU$的$WE$接口上，数据线$D_0$到$D_7$借到$CPU$数据接口$D_0$到$D_7$上。如果这时$CPU$发出地址信号$0\,0000\,0000\,0000$，就无法识别这个地址是第一块还是第二位芯片的第一位。此时$CPU$的$A_{13}$到$A_{15}$三个接口还是空的，将芯片1的选片线$CS$接到$CPU$的$A_{13}$上，芯片2的选片线$CS$接到$CPU$的$A_{14}$上，此时$CPU$的地址信号会变成15位。因为$CS$指高电平$1$有效，$A_{13}$为$1$代表选择芯片1，$A_{14}$为$1$代表选择芯片$2$，所以$010\,0000\,0000\,0000$代表选择芯片$1$，$100\,0000\,0000\,0000$带包选择芯片$2$。若高位为$110$或$000$则冲突而浪费位数。  
+ 每个芯片各存储一部分数据。

#### 字位同时扩展法

即增加存储字的数量又增加存储字长。各芯片连接地址线的方式相同，但是连接数据线的方式不同，需要通过片选信号$\overline{CS}$或采用译码器设计连接到对应芯片。![image-20230531221233861](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230531221233861.png)

+ 字扩展法针对数据总线($D_0\sim D_7$)
+ 位拓展法针对多出来的地址总线($A_{14},A_{15}$)

### 存储芯片片选

+ 线选法：
    + 当某地址线信息为“$0$”时，就选中与之对应的存储芯片，只能一位有效。
    + 优点：不需要地址译码器，线路简单。
    + 缺点：地址空间不连续，选片的地址线必须分时为低电平（否则不能工作)，不能充分利用系统的存储器空间，造成地址资源浪费。
+ 译码片选法：
    + 由于译码器可以将$n$位映射到$2^n$位，所以通过地址译码芯片产生片选信号。如线选法如果三位编码只能选择三个芯片，而译码片选法三位编码可以选择八个芯片，即三位二进制编码。
    + 优点：地址空间可连续，可以增加逻辑设计。
    + 缺点：电路逻辑复杂。

### 双端口$RAM$和多模块存储器

由于$CPU$与主存相连，而$CPU$速度增长是指数级别的，而主存容量增长是线性的，所以双方速度不匹配，所以需要更快的访问速度。一方面可以更高性能存储器，一方面使用高速缓冲存储器。

存取周期由存取时间和恢复时间构成，所以缩短存取周期的方法一种是空间上并行（双端口存储器技术），一种是时间上并行（多模块存储器技术）。

#### 双端口RAM

左右有两个独立的端口，所以有两对独立的数据线、地址线、控制线可以同时对主存进行操作，如果不是一个位置不会发生异常。

两个端口对同一主存操作有以下$4$种情况：

1. 两个端口不同时对同一地址单元存取数据。
2. 两个端口同时对同一地址单元读出数据。
3. 两个端口同时对同一地址单元写入数据。应产生写入错误
4. 两个端口同时对同一地址单元，一个写入数据，另一个读出数据。应产生读出错误。

所以只用设置一个“忙”的标志位，若$CPU$发现该端口为忙，则等待一段时间再进行访问。



#### 多模块存储器

##### 单体多字存储器

由于$CPU$的速度远快于主存，所以同时从主存中拿出多个指令就能让$CPU$等待$I/O$时间变短，从而提高效率，单体多字存储器以此而实现。

普通存储器是每行为一个存储单元，而对于单体多字存储器来说，每个存储单元存储$m$个字，若总线宽度也为$m$个字，则一次并行就能读出$m$个字。但是只有数据和指令是连续存放在内存的才能这样操作，转移指令无效。

##### 多体并行存储器

每个模块都有相同的容量和存取速度，以及独立的读写控制电路、地址寄存器和数据寄存器。地址分为体号和体内地址两个部分。

对读取数据进行优化。（不是对传输数据）

+ 高位交叉编址的多体存储器：
    + 高位是体号，低位是体内地址。
    + 按列，模块里先编址，一个个模块进行分配。只是相当于扩容而已，对于速度没有改变。
    + 若连续取$n$个存储字，每次访问需要$T$的时间，则耗时$nT$。
    + ![image-20230601093956529](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230601093956529.png)
    + 如图,可以理解成多根内存条,高位(体号)表示访问内存条编号，低位是体内地址
    + ![image-20230601095142536](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230601095142536.png)
    + 对于连续访问连续地址时,只能一个个访问周期依次访问
    
+ 低位交叉编址的多体存储器：
    + 低位是体号，高位是体内地址。
    
    + 按行，每一个单元先编址，一行行进行分配。
    
    + 由于每个存储体都是独立的，所以可以间隔一小段时间就能进行另一个的存储单元的访存而不用等待上一个单元的阶数。这就要求其模块数必须到达一个值，从而保证能流水线运行而不会卡住。
    
    + 设模块字长等于数据总线宽度，模块存取一个字的存取周期为$T$，**总线传送周期(存取时间)**为$r$，所以存储器交叉模块数应该大于等于$m=T/r$。这个值被称为交叉存取度。
    
    + ![image-20230601095845355](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230601095845355.png)
    
    + 从而启动该模块后能保证经过$m\times r$的时间后再次使用该模块时上次存取操作已经完成。
    
    + ![image-20230601095531755](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230601095531755.png)
    
    + 若连续取$n$个存储字，每次访问需要$T$的时间，启动间隔为$\tau$，则耗时$T+(n-1)\tau$。
        <!-- + 存储周期=总线周期×模块数。 -->
    
    + ![image-20230601094034088](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230601094034088.png)
    
    + 如图,可以理解成多根内存条,低位(体号)表示访问内存条编号，高位是体内地址
    
        

如高位交叉编址，体号+体内地址：

|  M0  |  M1  |  M2  |  M3  |
| :--: | :--: | :--: | :--: |
| 0000 | 0100 | 1000 | 1100 |
| 0001 | 0101 | 1001 | 1101 |
| 0010 | 0110 | 1010 | 1110 |
| 0011 | 0111 | 1011 | 1111 |

这时按顺序访问就是竖着的。

低位交叉编址，体内地址+体号：

|  M0  |  M1  |  M2  |  M3  |
| :--: | :--: | :--: | :--: |
| 0000 | 0001 | 0010 | 0011 |
| 0100 | 0101 | 0110 | 0111 |
| 1000 | 1001 | 1010 | 1011 |
| 1100 | 1101 | 1110 | 1111 |

此时顺序访问就是横着的，多个存储体可以共同输入输出数据，可以流水线操作。

对于交叉存储器的存取速度：

+ 模块数为$m$，存储周期为$T$，字长为$W$，数据总线宽度为$W$，总线传输周期为$r$，连续存取$n$个字，求交叉存储器的带宽。（有$m$个存储体，存储周期为$T$，字长为$W$，每隔$r$时间启动下一个存储体，连续存取$n$个字，求交叉存储器的存取速率。）
+ 连续存取$n$个字耗时为$T+(n-1)r$，但是需要$m\geqslant\dfrac{T}{r}$。因为如果模块数过少，则轮流到某一个存储体时这个存储体上一次的处理还没有完成就无法继续工作了。
+ 所以带宽是$\dfrac{n\times W}{T+(n-1)r}$。
+ 当$n$无限大时，带宽趋近于$\dfrac{W}{r}$，而单个存储体的带宽为$\dfrac{W}{T}$。

多端口存储器是对同一个存储体使用多套读写电路实现的，扩大存储容量的难度显然比多体结构的存储器要大，而且不能对多端口存储器的同一个存储单元同时执行多个写入操作，而多体结构的存储器则允许在同一个存储周期对几个存储体执行写入操作。

## 外部存储器

### 磁盘存储器

计算机的外存储器又称为辅助存储器，目前主要使用磁表面存储器。

所谓“磁表面存储”，是指把某些磁性材料薄薄地涂在金属铝或塑料表面上作为载磁体来存储信息。磁盘存储器、磁带存储器和磁鼓存储器均属于磁表面存储器。

![image-20230601102102925](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230601102102925.png)

磁表面存储器的优点：

- 存储容量大，位价格低；
- 记录介质可以重复使用：
- 记录信息可以长期保存而不丢失，甚至可以脱机存档：
- 非破坏性读出，读出时不需要再生。

磁表面存储器的鲮点：

- 存取速度慢；
- 机械结构复杂：
- 对工作环境要求较高。

#### 磁盘存储器

磁盘主要看操作系统,操作系统讲的更详细

##### 磁盘设备的组成

+ 硬盘存储器的组成。硬盘存储器由**磁盘驱动器、磁盘控制器和盘片**组成。
    + 磁盘驱动器。核心部件**是磁头组件**和**盘片组件**，温彻斯特盘是一种可移动磁头固定盘片的硬盘存储器。
    + 磁盘控制器。硬盘存储器和主机的接口，主流的标准有 $IDE$、$SCSI$、$SATA $等。
+ 存储区域。一块硬盘含有若干记录面，每个记录面划分为若干磁道，而每条磁道又划分为若干扇区，扇区(也称块)是磁盘读写的最小单位,即磁盘按块存取。
    + 磁头数($Heads$):-即记录面数，表示硬盘共有多少个磁头，磁头用于读取/写入盘片上记录面的信息，一个记录面对应一个磁头。
    + 柱面数$(Cylinders)$: 表示硬盘每面盘片上有多少条磁道。在一个盘组中，不同记录面的相同编号(位置)的诸磁道构成一个圆柱面。
    + 扇区数$(Sectors)$: 表示每条磁道上有多少个扇区。

##### 磁盘的性能指标

+ 记录密度。 记录密度是指盘片单位面积上记录的二进制信息量，通常以道密度、位密度和面密度表示。道密度是沿磁盘半径方向单位长度上的磁道数，位密度是磁道单位长度上能记录的二进制代码位数，面密度是位密度和道密度的乘积。
+ 磁盘的容量。磁盘容量有非格式化容量和格式化容量之分。非格式化容量是指磁记录表面可利用的磁化单元总数，它由道密度和位密度计算而来，格式化容量是指按照某种特定的记录格式所能存储信息的总量。格式化后的容量比非格式化容量要小。
+ 平均存取时间。平均存取时间由**寻道时间**(磁头移动到目的磁道的时间)、**旋转延迟时间**(磁头定位到要读写扇区的时间) 和**传输时间**(传输数据所花费的时间) 三部分构成。由于寻道和找扇区的距离远近不一，故寻道时间和旋转延迟时间通常取平均值。
+ 数据传输率。磁盘存储器在单位时间内向主机传送数据的字节数，称为数据传率。
    + 假设磁盘转数为$r$转/秒，每条磁道容量为$W$字节，则数据传输率为$D_r=rN$

##### 磁盘地址

![image-20230601142601900](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230601142601900.png)



##### 磁盘工作过程

硬盘的主要操作是寻址、读盘、写盘。 每个操作都对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字。

硬盘属于机械式部件，其读写操作是串行的，不可能在同一时刻既读又写，也不可能在同一时刻读两组数据或写两组数据。

![image-20230601142744200](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230601142744200.png)



#### 磁盘阵列

$RAID $(独立冗余磁盘阵列) 是指将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理内上分割交叉存储、并行访问，具有更好的存储性能、可靠性和安全性。

$RAID $的分级如下所示。在 $RAID1\sim RAID5$ 几种方案中，无论何时有磁盘损坏，都可随时拔出受损的磁盘再插入好的磁盘，而数据不会损坏，提升了系统的可靠性。

* $RAID0$: 无冗余和无校验的磁盘阵列。
    * ![image-20230601143149962](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230601143149962.png)
    * 无容错能力
* $RAID1$: 镜像磁盘阵列。
    * ![image-20230601143248539](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230601143248539.png)
    * 有容错能力,但成本翻倍
* $RAID2$: 采用纠错的海明码的磁盘阵列。
    * ![image-20230601143417512](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230601143417512.png)
* $RAID3$: 位交叉奇偶校验的磁盘阵列。
* $RAID4$: 块交叉奇偶校验的磁盘阵列。
* $RAID5$: 无独立校验的奇偶校验磁盘阵列。



### 固态硬盘$SSD$

![image-20230601143941680](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230601143941680.png)

![image-20230601144217002](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230601144217002.png)

## 高速缓冲存储器$Cache$

### 高速缓冲存储器基本概念

#### 局部性原理

+ 时间局部性：程序所访问的数据在相邻时间也可能访问到。
+ 空间局部性：程序所访问的数据的周围数据也可能访问到。

#### 高速缓冲存储器地址

+ 主存储器的地址包括主存块号和块内地址，而$Cache$的地址包含缓冲块号和块内地址，两个块内地址都是一样长的且完全相同的。
    + ![image-20230601162351734](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230601162351734.png)

+ $Cache$块又称为$Cache$行。长度为块长或$Cache$行长。
+ $Cache$还有一个标记，用来说明$Cache$块与主存块的关系，等于此块在主存中的块号。
+ $Cache$与主存之间以块为单位进行数据交换

#### 工作流程

先访问$Cache$未命中再访问主存型的计算机:

1. $CPU$发出访问地址，从地址总线传输到$Cache$。
2. 通过$Cache$主存地址映射变换结构，将主存地址转换为$Cache$地址，在$Cache$中寻址对应数据。
3. 如果命中就访问$Cache$并取出指令通过数据总线返回$CPU$。
4. 如果不命中，就直接访问主存，取出信息通过数据总线返回$CPU$，并把这个信息存储在$Cache$中。
5. 需要检测$Cache$是否已满，如果不满就直接将新的主存块调入$Cache$进行存储。
6. 若已经满了则通过$Cache$替换结构，执行替换算法腾出空位再调入。

其中$CPU$和$Cache$之间数据交换以**字**为单位，而$Cache$和内存之间数据交换以**块**为单位。

注意: 某些计算机中也采用同时访问 $Cache $和主存的方式, 若 $Cache $命中, 则主存访问终止;否则访问主存并替换 $Cache$。

#### 命中与未命中

+ 命中：主存块调入缓存，主存块与缓存块建立了对应关系，用标记记录与某缓存块建立了对应关系的主存块号。
+ 未命中：主存块未调入缓存，主存块与缓存块未建立对应关系。
+ 命中率：$CPU$欲访问的信息在$Cache$中的比率，设一个程序执行期间，$Cache$的总命中次数为$N_c$，访问主存的总次数为$N_m$，则命中率$H=\dfrac{N_c}{N_c+N_m}$。
+ 命中率与$Cache$的容量与块长有关。一般每块可取$4$到$8$个字，块长取一个存取周期内从主存调出的信息长度。
+ 平均访问时间为$t$,$t_c$为访问一次$Cache$所需时间,$t_m$为访问一次主存所需时间:
    + 若先访问$Cache$未命中再访问主存,则$t=Ht_c+(1-H)(t_c+t_m)$
    + 若同时访问$Cache$和主存则$t=Ht_c+(1-H)t_m$

+ 访问效率=$Cache$访存时间÷平均访存时间。
+ 相联存储器：并行比较标记，若有标记与当前将要访问的地址的标记相同，且有效位为1（表示当前存储单元存储数据），则命中；若标记不同，则直接替换。

#### 高速缓冲存储器的效率

+ 效率$e$与命中率有关，$e=$访问$Cache$的时间/平均访问时间$\times100\%$。
+ 假如$Cache$和主存是同时被访问的，设$Cache$命中率为$h$，访问$Cache$的时间为$t_c$，访问主存的时间为$t_m$，则$e=\dfrac{t_c}{h\times t_c+(1-h)\times t_m}\times100\%$。当$h=0$时最小为$\dfrac{t_c}{t_m}$，当$h=1$时最大为$1$。





### 地址映射

即将主存块调入(复制而非剪切)$Cache$时应该将其放在哪里。

地址以字节为单位。

默认都需要一位有效位,有效位指当前块的地址有效 。

<span style="color:orange">注意：</span>$Cache$字块标记是指$Cache$有多少行，而不是有多少容量。

![image-20230601163558303](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230601163558303.png)

![image-20230601160138498](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230601160138498.png)

#### 全相联映射

存储方式：

+ 随机选择空位:空位随意放。
+ **更改标记有效位和标记位**:此时不知道$Cache$里的每一个存储单元存的是主存的哪一块数据，所以还需要将主存的主存块号保存到标记项中。
    + 存储因为是乱序存放，所以一定要把整个主存块号都放入标记项中。


地址组成：

+ 地址=主存字块标记+字块内地址。

附加位：

+ 因为无法查看$Cache$里面每个存储块是否有数据，所以还需要一个有效位来表示里面是否有数据，将有效位放入标记项中。

特点：

+ 优点：冲突概率低；空间利用率高，命中率高。
+ 缺点：标记比较速度慢，实现成本高（相联存储器）。

#### 直接映射

存储方式：

+ 对号入座，每一个主存块只能存放在唯一一个地方。
+ 将主存储体按$Cache$存储体的长度划分为多个区，主存的每个区只能放在$Cache$的指定区域中。类似于模运算，将主存长度对$Cache$长度取模，地址相同余数的内存块放在同一个$Cache$块中。

地址组成：

+ 地址=主存字块标记+$Cache$字块标记+字块内地址。
    + ![image-20230601164955609](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230601164955609.png)

+ $Cache$地址=$Cache$字块标记+字块内地址。
+ 主存字块标记为主存容量除以$Cache$容量，表示要用多少位来区分主存地址。
+ $Cache$字块标记，即$Cache$行号的位数为$Cache$的块数的二对数。
+ 字块内地址就是块内地址，位数为每块容量的二对数。

附加位：

+ 这种映射方式需要一位有效位标识是否有数据存储。
+ 若发生冲突，不需要替换算法直接替换出去。所以不需要替换位。
+ 但是与全相连映射不同的是，因为直接映射是根据模运算来存储的，所以行与行之间是顺序的关系，所以主存块号不需要全部存入标记项，把能区分相同模结果的地址前一部分位的数据存入即可。

特点：

+ 优点：节省掉$Cache$字块标记，有效位存储的地址减少，实现难度降低。
+ 缺点：空间利用率降低。

如$Cache$一共八行，则主存按八为一个周期存储，则如$Cache$的$0$号地址中一定存入主存块地址模八后余$0$的主存块，即地址都为为$xx\cdots000$，同理$1$号地址存的都是$xx\cdots001$，所以可以保存主存地址减三的前面位数就足够了。这里的$000$和$001$等类似于$Cache$的组号。若$Cache$的行数为$2^n$，主存块号地址为$c$位，则标记项只用保存$c-n$位就可以了。

#### 组相联映射

存储方式：

+ 按号分组，组内随意放，结合了上面二者的优点。
+ 标记项也需要存入能区分数据块的部分地址。
+ 将$Cache$的块分为几个组，主存不再按照$Cache$的行数进行模运算分组存入，而用$Cache$组的个数进行模运算，虽然这样能节省的位数变少，但是这样主存的某一块就可以在每一组内随机选一个存储，而不用只能存储在一个块内浪费其他块的空间。
+ 每组有$r$个行，则称为$r$路组相联。

地址组成：

+ 地址=主存字块标记+$Cache$组号+字块内地址（$Cache$每行长度）。
    + ![image-20230601165202006](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230601165202006.png)

+ 一般物理地址的中间部分直接映射为组号。
+ 当$Cache$组地址位数长度变为表示$Cache$行数的二进制位，那么组号和行号一样就变成了直接映射，若组地址位数为$1$全部为一个组，则$Cache$不分组都随机存储即变成了全相连映射。

附加位：

+ 需要有效位。

#### 标记整列

称为地址映射表，即标记项总体长度，即总$Cache$行数$\times$标记项的长度。

标记项的长度=标记位长度+其他位长度（如有效位、替换控制位、一致控制位即脏位）。

+ 有效位默认是一位。
+ 替换控制位主要用于组相联映射方式，其他两种方式基本上没有这个。多少路组相联的二对数对应多少位替换控制位。如两路组相联对应标记项的一位替换控制位，物理地址的$Cache$组标记为三位对应八组，则一共有十六行$Cache$行。
+ 脏位默认是一位。如果是写回法和写分配法则需要，全写法和非写分配法则不需要。

标记位长度=主存地址长度（即主存总容量位数而不是$Cache$容量长度）-其他地址长度（块内地址，即$Cache$行的数量的对数；组地址，即多少个组的对数）。

标记的主要计算在于主存块标记长度，即标记位长度，为什么是这个长度？为什么要如此计算？

我们要将主存的内容放到高速缓冲存储器中，所以我们要根据主存的地址找到$Cache$的地址，并能通过$Cache$的地址找到主存的地址。由于$Cache$的数量远小于主存的数量，所以我们使用不同的方式将主存映射到$Cache$中。我们通过替换映射算法能得到一部分主存和$Cache$的映射规则，但是这种规则只能得到不完整的地址信息，那么其他相关地址信息就是通过标记项来给出，通过标记项和$Cache$位置信息就能完整映射$Cache$到每一个主存地址。

因为是主存地址映射，所以我们自然要映射到每一个主存地址，所以主存地址长度是我们的目标，通过地址信息加和得到所有主存地址。由于主存与$Cache$之间的数据交换单位为块，所以只要给定一个$Cache$块在主存中的首地址，那么一个块内的其他数据的地址也是可以推算的，所以这部分的信息可以在地址总线传输过来的块内偏移量中得到，标记位中就可以不要这个信息，所以主存地址长度减去块内地址长度。通过映射方式不同，我们可以得到每一块或每一组$Cache$与主存之间的映射关系，确定映射关系后，地址总线传输块号或者组号，所以这部分内容也是可以减去的，即主存地址长度再减去块号长度或块组号长度。最后的位数就是标记长度，通过标记位能与块号/组号+偏移地址得到主存地址。

如某计算机的主存地址大小为$256MB$，按字节编址，有$8$个$Cache$行，行长$64B$，使用直接映射方式，求标记项长度。首先主存地址大小为$256MB=2^{28}B$，则主存地址总长度为$28$位；然后行长$64B=2^6B$，则块内偏移地址长度为$6$位，所以$28-6=22$，使用直接映射方式，一共$8$行，所以行号位长度为$3$位，所以$22-3=19$，标记位一共$19$位。

### 替换算法

即$Cache$中存储满了如何处理。对于直接映射法来说，固定替换出前一个数据存入此时的数据，所以替换算法只针对全相联映射和组相联映射。

![image-20230601161801818](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230601161801818.png)

#### 随机算法

即$RAND$算法：随机地确定替换的$Cache$块。它的实现比较简单，但没有依据程序访问的局部性原理，故可能命中率较低。但是这种方式基本上不会使用。

#### 先进先出算法

即$FIFO$算法：选择最早调入的行进行替换。它比较容易实现，可以使用堆栈，但也没有依据程序访问的局部性原理，可能会把一些需要经常使用的程序块（如循环程序）也作为最早进入$Cache$的块替换掉。

会出现抖动现象：频繁的换入换出现象（刚被替换的块很快又被换出)

#### 近期最少使用算法

即$LRU$算法：依据程序访问的局部性原理选择近期内长久未访问过的存储行作为替换的行，平均命中率要比$FIFO$要高，是堆栈类算法。是一种局部性策略。

$LRU$算法对每行设置一个计数器，$Cache$每命中一次，命中行计数器清$0$，而其他各行计数器均加$1$，需要替换时比较各特定行的计数值，将计数值最大的行换出。

若被频繁访问的主存块数量>$Cache$行的数量，则有可能发生“抖动”

![image-20230601161325604](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230601161325604.png)

#### 最不经常使用算法

即$LFU$算法：将一段时间内被访问次数最少的存储行换出。每行也设置一个计数器，新行建立后从$0$开始计数，每访问一次，被访问的行计数器加$1$，需要替换时比较各特定行的计数值，将计数值最小的行换出。是一种全局性策略。

但是这种策略是无法实现的，因为计算机不可能全局考虑后面会出现什么，而只会考虑局部。

![image-20230601161747424](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230601161747424.png)

### 写策略

即$Cache$中内容修改后如何让主存于$Cache$修改的保持一致。分为当前命中和当前不命中的情况：

+ 命中：全写法、写回法。
+ 不命中：写分配法、非写分配法。

标记项结构：有效位+脏位+替换控制位+标记位。

#### 写回法

也称为$write-back$：当$CPU$对$Cache$写命中时，只修改$Cache$的内容，而不立即写入主存，只有当此块被换出时才写回主存（全部改完了再写回主存）。

**减少了访存次数，但存在数据不一致的隐患。**

需要在信息位中使用一个类似于有效位的$1/0$表示位，名为**脏位**，$0$代表未修改，$1$代表修改。



#### 全写法

也称为写直通法或$write-through$：当$CPU$对$Cache$写命中时，必须把数据同时写入$Cache$和主存。

由于写$Cache$要远快于写主存，所以一般使用写缓冲（$Write\,Buffer$）暂存写入的数据，但是如果写的速度过快可能会出现溢出。

##### 写缓冲

![image-20230601214539333](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230601214539333.png)

写缓冲本质是$SRAM$实现的先进先出队列,写速度比向主存的写操作块

$CPU$对$Cache$中某地址进行写操作并且命中时

1. 写操作：当处理器执行写操作时，数据被写入$Cache$，并同时被写入写缓冲。
2. 提交到主存储器：写缓冲将数据提交到主存储器的过程通常是异步的，不需要等待主存储器的响应。这意味着处理器可以继续执行后续指令而不需要等待写操作的完成。
3. 主存储器的更新：后续，写缓冲中的数据将被异步地写入主存储器。写缓冲可以利用主存储器的高带宽和并行性，将多个写操作合并成一个更大的写操作，从而提高数据传输的效率。
4. 数据一致性：在全写法中，写缓冲确保数据被及时写入主存储器，从而保证了数据的一致性。这意味着其他处理器或外部设备可以立即访问更新后的数据，而不需要等待主存储器的访问延迟。

#### 写分配法

也称为$write-allocate$：把主存中的块调入$Cache$，在$Cache$中修改。一般搭配写回法使用，即写完$Cache$之后再把$Cache$的值覆盖在主存的数据上，所以也需要设置一个脏位。



#### 非写分配法

也称为$not-write-allocate$：只写入主存，不调入$Cache$。一般搭配全写法使用。

#### 多级Cache

使用两级$Cache$，在与$CPU$直接连接的第一层$Cache$使用全写法，在与主存直接连接的第二层$Cache$使用写回法。

+ 离CPU越近的速度越快，容量越小

+ 离CPU越远的速度越慢，容量越大

## 虚拟存储器

$Cache$为了解决主存和$CPU$之间的问题，而虚拟存储器为了解决主存和辅存之间的问题。虚拟存储器包括主存和辅存，将主存和辅存联合在一起统一编址。

+ 是一个逻辑模型。
+ 用户给出一个地址，叫做虚地址或逻辑地址，虚拟存储器要给出该地址对应的数据。
+ 有辅助硬件将虚地址映射到主存中某个单元，主存单元地址称为实地址或物理地址。虚地址远大于实地址。
+ 基于局部性原理：在程序执行过程中，程序对主存的访问是不均匀的。
+ 由操作系统和一部分硬件完成地址映射。

具体内存参考操作系统，主要考页式存储，段式非常少。

对于虚拟存储器的三个地址空间：

+ 实地址=主存页号+页内字地址。
+ 虚地址=虚存页号+页内字地址。
+ 辅存地址=磁盘号+盘面号+磁道号+扇区号。

<!-- <span style="color:orange">注意：</span>这里地址空间基本上都是用字地址的，即以机器字长为单位进行编址，这是因为虚拟存储器面向程序员，所以以逻辑的每一个字为单位；而上一讲的高速缓冲存储器面向的机器本身，所以经常以字节为单位进行编址。 -->

<span style="color:orange">注意：</span>虚拟系统中，找到的地址后，进行地址映射是靠操作系统完成，在操作系统的书中会更详细讲到。

### 页式虚拟寄存器

+ 虚拟空间与主存空间都被划分成同样大小的页，主存的页称为实页，虚存的页称为虚页。
+ 虚页地址分为虚页号和页内地址，实页地址分为实页号和页内地址，在虚页转换为实页时，页内地址是相同的，唯一要考虑的是虚页号如何转换为实页号。
+ 做法就是将这种映射关系存在一张表中，这张表就是页表。页表存储的是实页号和装入位，用来标识虚拟地址是否装入主存地址。页表长期存储在主存中。
+ 首先页内基表寄存器保存着页表起始地址，和虚页号进行计算就得到了页表项的地址，就可以找到页表项，把页表项中的实页地址取出并进行拼接就得到了页内地址。
+ 若在$Cache$中存有则访问$Cache$，若没有再访问主存。
+ 页表包括有效位（装入位）、脏位、引用位、物理页或磁盘地址。
+ 优点：长度固定，页表简单，调入方便。
+ 缺点：程序不可能总是页面的整数倍，所以最后一页的部分空间会浪费；页不是逻辑独立的实体，所以保护、处理、共享不便。

对于页表的大小选择需要适度。页面若很小，虚拟存储器中包含的页面数就会过多，使得页表的体积过大，导致页表本身占据的存储空间过大，同一个程序需要调用更多页表，使操作速度变慢；当页面很大时，虚拟存储器中的页面数会变少，由于主存的容量比虚拟存储器的容量小，主存中的页面数会更少，每次页面装入的时间会变长，每当需要装入新的页面时，速度会变慢。

### 段式虚拟寄存器

+ 段式虚拟存储器中的段是按程序的逻辑结构划分的，各个段的长度因程序而异。
+ 虚拟地址分为两部分：段号和段内地址。
+ 段表：每一行记录了与某个段对应的段号、装入位、段起点和段长等信息。
+ 由于段的长度可变，所以段表中要给出各段的起始地址与段的长度。
+ 段表的段首址加上虚拟地址的段内地址就得到了物理地址。
+ 优点：按逻辑划分，所以利于编译、管理、修改、保护、共享。
+ 缺点：段长度可变，所以分配空间不便，容易造成碎片问题。

### 段页式寄存器

+ 把程序按逻辑结构分段，每段再划分为固定大小的页，主存空间也划分为大小相等的页。
+ 程序对主存的调入、调出仍以**页**为基本传送单位。每个程序对应一个段表，每段对应一个页表。
+ 所以段长必须是页长的整数倍，段首址必须是某页的页首址。
+ 虚拟地址：段号+段内页号+页内地址。
+ $CPU$根据虚地址访存时，首先根据段号得到段表地址；然后从段表中取出该段的页表起始地址，与虚地址段内页号合成，得到页表地址；最后从页表中取出实页地址，与页内地址拼接形成主存实地址。



### 快表

#### 快表原理

+ 页表、段表存放在主存中，收到虚拟地址后要先访问主存，查询页表、段表，进行虚实地址转换。放在主存中的页表称为慢表（$Page$）。
+ 提高变换速度→用高速缓冲存储器$Cache$存放常用的页表项→快表（$TLB$）。
+ $TLB$是$Page$的副本（快表是慢表的副本），而$Cache$为主存的副本。
+ 慢表在主存中。快表是一个特殊的单独的$Cache$。
+ 使用相联存储器，所以查找速度更快。也可以使用$SRAM$。（$DRAM$必须不断刷新不适合$TLB$和$Cache$）
+ 快表地址计算与之前的地址计算类似，使用全相联或组相联的模式，若使用组相联也需要留出组号。

#### 快表映射

快表映射一般次啊用全相联或组相联映射。映射方式与$Cache$映射类似。

+ 每个$TLB$项由页表表项内容加上一个$TLB$标记字段组成，$TLB$标记用来表示该表项取自页表中哪个虚页号对应的页表项。
+ $TLB$标记的内容在全相联方式下就是该页表项对应的虚页号。
+ $TLB$标记的内容在组相联方式下则是对应虚页号的高位部分，而虚页号的低位部分用于选择$TLB$组的组索引（组号）。

#### 快表与Cache

![download3](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/download3.png)

先虚拟存储再高速缓存，先主存再$Cache$。

| 序号 | TLB  | Page | Cache | 访存次数 | 访磁次数 |                 说明                 |
| :--: | :--: | :--: | :---: | :------: | :------: | :----------------------------------: |
|  1   | 命中 | 命中 | 命中  |    0     |    0     |   TLB命中则Page一定命中，Cache未知   |
|  2   | 命中 | 命中 | 缺失  |    1     |    0     |   TLB命中则Page一定命中，Cache未知   |
|  3   | 缺失 | 命中 | 命中  |    1     |    0     |   TLB缺失而Page可能命中，Cache未知   |
|  4   | 缺失 | 命中 | 缺失  |    2     |    0     |   TLB缺失而Page可能命中，Cache未知   |
|  5   | 缺失 | 缺失 | 缺失  |    2+    |    1+    | TLB缺失而Page也缺失，则Cache一定缺失 |

+ $Cache$缺失：硬件完成。
+ $TLB$缺失：硬件或软件。
+ $Page$缺失：软件完成（操作系统的缺页异常处理程序）。

### 虚拟存储器与Cache

1. $Cache$主要解决系统速度，而虚拟存储器却是为了解决主存容量。
2. $Cache$全由硬件实现，是硬件存储器，对所有程序员透明；而虚拟存储器由$OS$和硬件共同实现，是逻辑上的存储器，对系统程序员不透明，但对应用程序员透明。
3. 对于不命中性能影响，因为$CPU$的速度约为$Cache$的$10$倍，主存的速度为硬盘的$100$倍以上，因此虚拟存储器系统不命中时对系统性能影响更大。
4. $CPU$与$Cache$和主存都建立了直接访问的通路，而辅存与$CPU$没有直接通路。也就是说在$Cache$不命中时主存能和$CPU$直接通信，同时将数据调入$Cache$；而虚拟存储器系统不命中时，只能先由硬盘调入主存，而不能直接和$CPU$通信。

所以高速缓冲存储器连接主存实地址与$Cache$地址，虚拟存储连接主存实地址和虚拟存储逻辑地址，快表连接虚拟存储逻辑地址与快表地址。







1. # 第四章 指令系统

    ## 【考纲内容】

    1. **指令格式的基本概念**
    2. **指令格式**
    3. **寻址方式**
    4. **数据的对齐和大/小端存放方式**
    5. **$CISC $和 $RISC $的基本概念**
    6. **高级语言程序与机器级代码之间的对应**
        + 编译器、汇编器与链接器的基本概念
        + 选择结构语句的机器级表示
        + 循环结构语名的机器级表示
        + 过程(函数)调用对应的机器级表示

    

    ### 知识导图

    ![img](http://res.ptpress.cn/9A4870B28DC14677AABDD5B607B425F0.png)

    ![img](http://res.ptpress.cn/3A921A9F5F3D460289828430ECE67F8B.png)

    ![img](http://res.ptpress.cn/5C96AB60C31147D4ABF49B2E86D05989.png)

    ![image-20230603093752238](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603093752238.png)

    ## 【复习提示】

     指令系统是表征一台计算机性能的重要因素。应掌握各种寻址方式的特点及有效地址的计算，相对寻址的计算，CISC 与 RISC 的特点与区别。2022 年大纲新增的机器级表示，在 2017年和2019年的真题中考查过。本章内容既可能出选择题也可能结合其他章节出油管指令的综合题。指令格式、机器指令和指令寻址方式与 CPU 指令执行过程部分紧密相关，需引起重视。

    在学习本章时， 请读者思考以下问题;

    1. 什么是指令? 什么是指令系统? 为什么要引入指令系统?
    2. 指令分为哪些部分? 每部分有什么用处?

    3) 对于一个指令系统来说，寻址方式多和少有什么影响?

    ## 指令格式

    指如何使用二进制代码表示指令。

    操作码+寻址特征码（有多少种寻址方式）+地址码。

    ### 指令定义

    + 指令（又称机器指令）：是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。
    + 指令系统是计算机软硬件的界面。指令系统指的是计算机执行的机器指令的集合；这里要注意的是微指令是微程序级命令，属于硬件范畴；伪指令是由若干的机器指令组成的指令序列，属于软件范畴；然而机器指令介于两者之间，处于软硬件的交界面；而机器指令集又称为指令系统；所以回答是指令系统。
    + 一台计算机的所有指令的集合构成该机的指令系统，也称为**指令集**。**一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令。**
    + 一条指令通常要包括操作码字段（$OP$）和地址码字段（$A$）两部分。
    + 操作码指出该指令要执行什么操作，地址码指出指令要操作的数据的地址。
    + 指令地址由$PC$给出。
    + 定长指令字结构：所有指令长度相等。执行速度块，控制简单。
    + 变长指令字结构：指令长度随指令功能而异。

    ### 地址码

    + 一条指令的执行分为三步，如果是两个操作数则四次访存：
        1. 取指令。
        2. 取两个操作数。
        3. 放回结果。
    + 访存是指访问内存，$ACC$在运算器中，访问$ACC$不是访问内存。如果数据在$Cache$中则不用访存。

    指令类型：

    + 四地址指令：操作码+操作数$A_1$地址+操作数$A_2$地址+结果地址$A_3$+下指令地址$A_4$。
        + $(A_1)OP(A_2)\rightarrow A_3$。
    + 三地址指令：操作码+操作数$A_1$地址+操作数$A_2$地址+结果地址$A_3$。
        + 下一条指令的寻址靠程序计数器$PC$完成。
        + 一共访存四次。
        + $(A_1)OP(A_2)\rightarrow A_3$。
    + 二地址指令：操作码+操作数$A_1$地址+操作数$A_2$地址。
        + 将结果存到操作数$A_1$地址或操作数$A_2$地址中。取指令，取数$A_1$和$A_2$，存放到$A_1$或$A_2$。一共访存四次。$(A_1)OP(A_2)\rightarrow A_1$。
        + 若使用累加器$ACC$暂存结果则只用访存三次，取指令，取数$A_1$和$A_2$，暂存到$ACC$。$(A_1)OP(A_2)\rightarrow ACC$。
    + 一地址指令（单地址指令）：操作码+操作数地址：
        + 只需要一个操作数的指令操作，如加一、减一、取反、求补等。取出指令、取出数、操作、放回，只需要三次访存。$OP(A)\rightarrow A$。
        + 隐含约定的目的地址的双操作数指令，如目的地址为累加器$ACC$的地址。取指令和取数，只需要两次访存。$(ACC)OP(A)\rightarrow ACC$。
    + 零地址指令：只有操作码：
        + 不需要操作数。如空操作、停机、关中断等。
        + 堆栈计算机，两个操作数隐含存放在栈顶和次栈顶，计算结果压回栈顶。
    + 用硬件资源减少地址码字段的优势：
        + 扩大指令寻址范围。
        + 缩短指令字长。
        + 减少访存次数。

    ### 指令字长

    + 固定：指令字长=存储字长。
    + 可变：按字节的倍数变化。
    + 指令字长取决于：
        1. 操作码长度。
        2. 操作数地址长度。
        3. 操作数地址个数。

    

    机器字长：$CPU$进行一次整数运算所能处理的二进制数据的位数（通常和$ALU$直接相关）

    存储字长：一个存储单元中的二进制代码位数（通常和$MDR$位数相同）

    ### 操作码

    #### 定长操作码

    + 指令字的最高位部分分配固定的若干位表示操作码。
    + 若有$n$位操作码，则有$2^n$条指令。
    + 优点：能简化计算机硬件设计，提高指令译码和识别速度。
    + 缺点：指令数量增加时会占用更多固定位，留给表示操作数地址的位数有限。
    + 一般这种操作码用于指令字长较长的情况。
    + 控制器的译码电路设计简单，但灵活性较低

    #### 可变长操作码

    + 控制器的译码电路设计复杂，但灵活性较高

    ##### 拓展操作码

    定长指令字结构+可变长操作码

    + 拓展操作码是可变长操作码实现的一种，让操作码长度随地址码减少而增加。
    + 操作码的位数至少为当种指令总条数的二对数。如指令总长度为$32$位，二地址指令有$27$条，则二地址指令的操作码至少有$27=2^4+11=5$位，否则不能操作这么多地址。
        + ![image-20230601224859074](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230601224859074.png)
        + 在设计扩展操作码指令格式时，必须注意以下两点：
            + **不允迕短码是长码的前缀**，即短操作码不能与长操作码的前面部分的代码相同。
            + 各指令的操作码一定不能重复。
        + 通常情况下，对使用频率较高的指令，分配较短的操作码；对使用频率较低的指令，分配较长的操作码，从而尽可能减少指令译码和分析的时间。
    + 优点：在指令字长有限的前提下能保持比较丰富的指令种类。
    + 缺点：增加了指令译码和分析的难度，使控制器的设计复杂化。

    ![image-20230601225659206](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230601225659206.png)

    + 假设指令字长为$16$位，前$4$位为基本操作码字段$OP$，另有$3$个$4$位长的地址字段$A_1$、$A_2$和$A_3$。$4$位基本操作码若全部用于三地址指令，则有$16$条。
    + 但至少须将当前位的$1111$留作扩展操作码之用，即三地址指今为$15$条($0000\sim 1110$)。所以目前就留下来了前$4$位操作数为$1111$的指令，这是只有四位操作码。
    + 然后将留下来的指令的操作码位拓展为八位，将$A_1$的位也用作操作码，即将$1111\,0000\,A_1\,A_2 \sim 1111\,1011\,A_1\,A_2$(这里的$A_1\,A_2$表示二地址指令中的操作数1和操作数2,下同)作为二地址指令，二地址指令为$12$条。同样将$1111\,11**$的指令作为下一个拓展操作码备用。
    + 同样将留下来的指令的操作码拓展为十二位，将$A_1A_2$的位用作操作码，即将$1111\,1100\,0000\,A_1 \sim 1111\,1111\,1101\,A_1$作为一地址指令，一地址指令为$62$条。同样将$1111\,1111\,111*$的指令作为下一个拓展操作码备用。
    + 最后将操作码拓展为十六位，将$A_1A_2A_3$全部作为操作码，即将$1111\,1111\,1110\,0000$到$1111\,1111\,1111\,1111$作为零地址指令，零地址指令为$32$条。

    假设地址长度为$n$，上一层留出$m$种状态，则下一层可以拓展出$m\times2^n$种状态。所以也可以形成任意种不同拓展方法。

    ### 操作类型

    1. 数据传输：
        1. $MOV$：寄存器之间的传送。
        2. $LOAD$：把存储器的数据放到$CPU$寄存器中。
        3. $STORE$：把$CPU$寄存器的数据放到存储器中。
    2. 算术逻辑：
        1. 算术：加$ADD$、减$SUB$、比较$CMP$、乘$MUL$、除$DIV$、自加一$INC$、自减一$DEC$、求补、浮点运算、十进制运算。
        2. 逻辑：与$AND$、或$OR$、非$NOT$、异或$XOR$、位操作、位测试、位清除、位求反。
    3. 移位操作：
        1. 算术移位。
        2. 逻辑移位。
        3. 循环移位（带进位和不带进位）。
    4. 转移操作：调用指令必须保存下一条指令的地址，当子程序结束时要返回主程序继续执行，而转移指令不用返回执行。
        1. 无条件转移：$JMP$。将地址码送入$PC$。
        2. 条件转移：$BRANCH$，如$JZ$：结果为$0$；$JO$：结果溢出；$JC$：结果进位。
        3. 调用$CALL$和返回$RET$。
        4. 陷阱$TRAP$和陷阱指令。（意外事故的中断）
    5. 输入输出操作。

    

    ## 指令寻址方式

    指令地址码不代表真实地址，这只是个形式地址$A$，只有结合寻址方式寻址才能得到真实地址$EA$。如$EA=(A)$指有效地址是形式地址$A$中保存的数值。

    目的是：缩短指令字长、扩大寻址空间、提高编程灵活性。

    寻址方式包括指令寻址和数据寻址。

    ### 操作数类型与存放方式

    #### 操作数类型

    + 地址：无符号整数。
    + 数字：定点数、浮点数、十进制数。
    + 字符：$ASCII$。
    + 逻辑数：逻辑运算。

    #### 存放方式

    + 若一个操作数有多个内存地址对应，则存放地址为：
        + 大端方式：指令中给出的地址是操作数最高有效字节（$MSB$）所在的地址。字地址为高字节地址。如$012345$。
        + 小端方式：指令中给出的地址是操作数最低有效字节（$LSB$）所在的地址。字地址为低字节地址。如$452301$。
    + 按字节地址寻址：给出个字节地址，可以取出长度为一个字节的数据。
    + 按字地址寻址：给出个字地址，可以取出长度为一个字的数据。
    + 按字节编址：每个字节存储单元都有一个地址编号。每个字中最小的字节地址就是字地址。
    + 按字编址：每个字存储单元都有一个地址编号。但是按字编址就无法直接取出字节地址。所以一般只按字节编址。
    + 三个字长：
        1. 机器字长：$CPU$一次能处理的二进制数据的位数。一般等于内部寄存器的位数。
        2. 指令字长：一个指令字中包含二进制代码的位数。若是单字长指令则指令字长等于机器字长，若是半字长指令等则不相等。
        3. 存储字长：一个存储单元存储二进制代码的长度。
    + 从任意位置开始存储：
        + 优点：不浪费存储资源。
        + 缺点：除了访问一个字节之外，访阿其它任何类型的数据，都可能花费两个存储周期的时间。读写控制比较复杂。
    + 从一个存储字的起始位置开始访问，其余位置置空或填充：
        + 优点：无论访问何种类型的数据，在一个周期内均可完成，读写控制简单。
        + 缺点：浪费了宝贵的存储资源。
    + 边界对准方式，从地址的整数倍位置开始访问：
        + 由于不同的机器数据字长不同，每台机器处理的数据字长也不统一，为了便于硬件实现，通常要求多字节的数据在存储器的存放方式能满足“边界对准”的要求。
        + 数据存放的起始地址是数据长度（按照编址单位进行计算）的整数倍。
        + 本方案是前两个方案的折衷，在一个周期内可以完成存储访问，空间浪费也不太严重。

    ### 指令寻址

    $(PC)+"1"\to PC$

    用于确定要执行的下一条指令的地址。始终由程序计数器$PC$给出。

    + 顺序寻址：由$PC$自动加上某个数寻址下一个要操作的指令，<span style="color:orange">注意：</span>不是单纯加一,**加上的是当前取出的指令字长**。如果是按字编址就是直接加一，如果是按字节编址则是加一个指令字长。
    + 跳跃寻址：由转移指令指出。如执行到操作码为$JMP$，则跳跃到保存的地址码所指向的指令地址进行执行。跳跃地址分为绝对地址（标记符直接得到）和相对地址（相对当前地址的偏移量）。跳跃的结构是当前指令**修改$PC$值**，所以下一条指令仍通过$PC$给出。可实现程序的条件或无条件转移。<span style="color:orange">注意：</span>程序跳跃后，按新的指令地址开始顺序执行。因此，程序计数器的内容也必须相应改变，以便及时跟踪新的指令地址。

    ### 数据寻址

    + 用于确定本条指令的数据地址。
    + 具体的数据寻址分为：
        + 主存寻址：数据都存储在主存中
            + 直接寻址。
                + 直接寻址相对于立即寻址，缩短了指令长度。
            + 间接寻址。
                + 间接寻址扩大了寻址范围，便于编制程序，易于完成子程序返回。
            + 隐含寻址。
            + 立即寻址。
                + 立即寻址操作数获取便捷，通常用于给寄存器赋初值。
        + 寄存器寻址：数据都存储在寄存器中
            + 寄存器寻址。
                + 寄存器寻址的指令字较短，指令执行速度较快。
            + 寄存器间接寻址。
                + 寄存器间接寻址扩大了寻址范围。
        + 偏移寻址：都需要加一个偏移量
            + 基址寻址。
                + 基址寻址扩大了操作数寻址范围，适用于多道程序设计，常用于为程序或数据分配存储空间。
                + 以程序的起始存放地址作为“起点”
            + 变址寻址。
                + 变址寻址主要用于处理数组问题，适合编制循环程序。
                + 程序员自己决定从哪里作为“起点”
            + 相对寻址。
                + 相对寻址用于控制程序的执行顺序、转移等。
                + 以程序计数器PC所指地址作为“起点”
        + 堆栈寻址。
    + 此时指令就需要由：操作码$OP$+寻址特征（寻址方式）+形式地址$A$组成。形式地址不再是实际的地址，而是指令字中的地址。
    + 有效地址(真实地址)$(Effctive\,Address,EA)$就是通过寻址特征和形式地址$A$进行运算得到的。
    + 无论是有多少个地址，都必须给出成对的寻址特征和形式地址$A$。
    + 主存地址不能为负。
    + 基址寻址和变址寻址的区别：
        + 两种方式有效地址的形成都是寄存器内容＋偏移地址。
        + 在基址寻址中，程序员操作的是偏移地址，基址寄存器的内容由操作系统控制，在执行过程中是动态调整的。偏移量较短。
        + 在变址寻址中，程序员操作的是变址寄存器，偏移地址是固定不变的。偏移量较大。

    由于访存慢于访问寄存器，所以寄存器访问快于直接访问。

    如果采用变长指令码格式，由于要表示一定范围的立即数，立即数的指令通常需要较多的二进制位，取指时，可能需要不止一次的读内存来完成取指，因此采用变长指令码格式的时候，寄存器寻址方式的执行速度更快。但是如果采用定长指令码格式，那就是立即寻址更快了。

    ![image-20230602170354206](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230602170354206.png)

    #### 直接寻址

    + 指令字中的形式地址$A$就是操作数的真实地址$EA$，即$EA=A$。
    + 直接寻址的指令执行：
        1. 取指令，访存$1$次。
        2. 执行指令，取操作数，访存$1$次。
        3. 暂不考虑如何存结果。
        4. 共访存$2$次。
    + 优点：简单，指令执行阶段仅访问一次主存，不需专门计算操作数的地址。
    + 缺点：
        + 形式地址$A$的位数决定了该指令操作数的寻址范围。
        + 操作数的地址不易修改。

    #### 间接寻址

    + 指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址所在的存储单元的地址，也就是操作数地址的地址，即$EA=(A)$。
    + 间接寻址的指令执行：
        1. 取指令，访存$1$次。
        2. 执行指令，取操作数地址，取操作数，访存$2$次。
        3. 暂不考虑如何存结果。
        4. 共访存$3$次。
    + 若间址次数为$n$，则访问时间为$n+2$。
    + 优点：
        + 可扩大寻址范围（有效地址$EA$的位数大于形式地址$A$的位数）。
        + 便于编制程序（用间接寻址可以方便地完成子程序返回）。
    + 缺点：指令在执行阶段要多次访存（一次间址需两次访存，多次寻址需根据存储字的最高位确定几次访存）。由于访问速度过慢，所以一般都不使用。

    + 

    #### 隐含寻址

    + 不是明显地给出操作数的地址，而是在指令中隐含着操作数的地址。
    + 如单地址指令，隐含约定另一个操作数的目的地址为累加器$ACC$的地址。
    + 优点：有利于缩短指令字长。
    + 缺点：需增加存储操作数或隐含地址的硬件。

    #### 立即寻址

    + 形式地址指出的不是数据地址，而是数据本身，称为立即数，采用**补码**形式存储。
    + 地址形式为：操作码$OP+\#+$立即数。$\#$即表示立即寻址特征。
    + 立即寻址的指令执行：
        1. 取指令，访存$1$次。
        2. 执行指令，直接取指令操作数，访存$0$次。
        3. 暂不考虑如何存结果。
        4. 共访存$1$次。
    + 优点：指令执行阶段不访问主存，指令执行**时间最短**。
    + 缺点：
        + 形式地址$A$的位数限制了立即数的范围。
        + 如$A$的位数为$n$，且立即数采用补码时，可表示的数据范围为$[-2^{n-1},2^{n-1}-1]$。

    #### 寄存器寻址

    + 在指令字中直接给出操作数所在的寄存器编号，即$EA=R_i$，其操作数在由$R_i$所指的寄存器内。
    + 类似于直接寻址，只是数据在主存中变为在寄存器中。寄存器编号就是形式地址。
    + 寄存器寻址的指令执行：
        1. 取指令，访存$1$次。
        2. 执行指令，由于操作数在寄存器中，寄存器集成在$CPU$中，所以不需要访问主存，访存$0$次。
        3. 暂不考虑如何存结果。
        4. 共访存$1$次。
    + 优点：
        + 指令在执行阶段不访问主存，只访问寄存器，指令字短且执行速度快。
        + 支持向量/矩阵运算。
    + 缺点：
        + 寄存器价格昂贵。
        + 计算机中寄存器个数有限。

    #### 寄存器间接寻址

    + 寄存器$R_i$中给出的不是一个操作数，而是操作数所在主存单元的地址，即$EA=(R_i)$。
    + 寄存器间接寻址的指令执行：
        1. 取指令，访存$1$次。
        2. 执行指令，先访问寄存器获得地址，再根据地址在主存中访问，访存$1$次。
        3. 暂不考虑如何存结果。
        4. 共访存$2$次。
    + 优点：与一般间接寻址相比速度更快。
    + 缺点：指令的执行阶段需要访问主存（因为操作数在主存中）。

    #### 基址寻址

    ![image-20230602154030847](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230602154030847.png)

    + 以程序的起始存放地址作为“起点”
    + 将$CPU$中基址寄存器$(Base-address\,Register,BR)$的内容加上指令格式中的形式地址$A$，而形成操作数的有效地址，即$EA=(BR)+A$。
    + 分为隐式基址寄存器（专用寄存器$BR$）和显式基址寄存器（需要指定某通用寄存器为基址寄存器）。
    + 基址寄存器是面向操作系统的，其**内容由操作系统或管理程序确定，用户不可改变**。在程序执行过程中，基址寄存器的内容不变（作为基地址），形式地址$A$可变（作为偏移量，使用补码表示）。
    + 当采用通用寄存器作为基址寄存器时，可**由用户决定哪个寄存器作为基址寄存器，但其内容仍由操作系统确定**。
    + 优点：
        + 可扩大寻址范围（基址寄存器的位数大于形式地址$A$的位数）。
        + 便于程序“浮动”,用户不必考虑自己的程序存于主存的哪一空间区域，故有利于多道程序并发运行，以及可用于编制浮动程序。

    #### 变址寻址

    ![image-20230602162559021](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230602162559021.png)

    + 程序员自己决定从哪里作为“起点”
    + 有效地址$EA$等于指令字中的形式地址$A$与变址寄存器$IX$的内容相加之和，即$EA=(IX)+A$。
    + 其中$IX$为变址寄存器$(Index\,Register)$（专用），也可用通用寄存器作为变址寄存器。
    + 与基址寄存器不同的是，**变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变（作为偏移量）**，形式地址$A$不变（作为基地址）。
    + 优点：
        + 可扩大寻址范围（变址寄存器的位数大于形式地址$A$的位数）。
        + 在数组处理过程中，可设定$A$为数组的首地址，不断改变变址寄存器$IX$的内容，便可很容易形成数组中任一数据的地址，特别适合编制循环程序。
    + 变址寻址与基址寻址配合使用：$EA=A+(BR)+(IX)$。
    + 变址寻址与间接寻址配合使用：
        + 先变址后间址，$EA=(A+(IX))$。
        + 先间址后变址，$EA=(A)+(IX)$。

    #### 相对寻址

    ![image-20230602163006370](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230602163006370.png)

    + 以程序计数器PC所指地址作为“起点”
    + 把程序计数器$PC$的内容加上指令格式中的形式地址$A$而形成操作数的有效地址，即$EA=(PC)+A$，其中$A$是相对于$PC$所指地址(下一条指令的地址)的**位移量**，可正可负，补码表示。
    + A补码表示
    + 由于取指时$PC$会默认加上一个指令字长（$(PC)+1\rightarrow PC$），所以相对寻址所提供的相对地址是以下条指令在内存中首地址为基准位置的偏移量。
    + 优点：
        + 操作数的地址不是固定的，它随着$PC$值的变化而变化，并且与指令地址之间总是相差一个固定值，因此便于程序浮动(一段代码在整个程序内部的浮动)。
        + 相对寻址广泛应用于转移指令。
    + 所以转移指令基本上使用相对寻址方式。无条件转移指令会在指令周期中对$PC$进行两次修改操作，一起是取指周期后自动加一，一个是执行周期后转移修改。有条件指令如果条件满足则修改两次，条件不满足则只用修改一次。

    

    #### 堆栈寻址

    ![image-20230602165931815](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230602165931815.png)

    + 操作数存放在堆栈中，隐含使用堆栈指针$(Stack\,Pointer,SP)$作为操作数地址。
    + 堆栈是存储器（或专用寄存器组）中一块特定的按“后进先出（$LIFO$）”原则管理的存储区，该存储区中被读/写单元的地址是用一个特定的寄存器给出的,该寄存器称为堆栈指针（$SP$）。
    + 寄存器做堆栈就是硬堆栈，成本高，主存做堆栈就是软堆栈
        + ![image-20230602170327094](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230602170327094.png)

    

    

    ## 程序的机器代码表示

    ### 考试要求

    2022新增考点

    + 只需关注x86汇编语言：若考察其他汇编语言题目会详细注释
    + 题目给出某段简单程序的C语言、汇编语言、机器语言表示。
        + 能结合C语言看懂汇编语言的关键语句（看懂常见指令、选择结构、循环结构、函数调用)
    + 汇编语言、机器语言一一对应，**要能结合汇编语言分析机器语言指令的格式、寻址方式**
    + 不会考：将C语言人工翻译为汇编语言或机器语言

    

    ### x86汇编语言指令基础

    ![image-20230602215842885](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230602215842885.png)

    #### 相关寄存器

    ![image-20230602213720838](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230602213720838.png)

    * $E=Extended=32bit$,看到$E$表示是32位
    * 上四个寄存器$(EAX\;EBX\;ECX\;EDX)$称为通用寄存器,其中X=未知
        * $EAX\;EBX\;ECX\;EDX$有$32bit$(有$E$);$AX\;BX$等有$16bit$;$AH,AL,BH,BL$等有$8bit$
    * 中间两个寄存器$(ESI\;EDI)$是变址寄存器,用于线性表和字符串的处理
        * $S =Source,D=Destination$
    * 最后两个寄存器是堆栈寄存器,用于实现函数调用

    ### 常用指令

    #### 数据转移-$mov$指令

    + 基本格式: 【$mov $ 目标操作数$d$ 源操作数$s$】
        + mov指令功能：将源操作数s复制到目的操作数d所指的位置
        + ![image-20230602212653814](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230602212653814.png)
        + $d:destination$($n.$目的地);$s:source$($n.$来源,来源地)
    + 常见格式:
        + $mov\,eax,ebx$
            + 将寄存器$ebx$的值复制到寄存器$eax$
            + 寄存器寻址→寄存器寻址
        + $mov\,eax,5$
            + 将**立即数**$5$复制到寄存器$eax$
            + 立即数寻址→寄存器寻址
        + $mov\,eax,dword\,ptr [af996h]$
            + 将内存地址$af996h$所指的$32bit$值复制到寄存器$eax$
            + [] 表示里面是个地址,并且一般前面还会指明数据长度
                + []里面如果没有写直接的地址,是寄存器($EAX\;EBX\;ECX\;EDX$等),这表示寄存器间接寻址,即先把寄存器中存放的主存地址取出在去主存中取数据
                + []里面还可以加减表示地址偏移
            + $af996h$中$h$表示16进制
            + $dword\;ptr$等表示内存读写长度,常见如下
                + $dword\;ptr$——双字，$32bit$
                + $word \;ptr$——单字，$16bit$
                + $byte \;ptr$——字节，$8bit$
                + **若未指明主存读写长度，默认$32bit$**
            + 直接寻址(+基址寻址)→寄存器寻址(主存→寄存器)
            + **此处是$dword\,ptr [af996h]$→$eax$,不要搞混了;mov指令都是后面移到前面**
        + $mov\,byte\,ptr\,[af996h],5$
            + 将立即数5复制到内存地址$af996h$所指的一字节中
            + 立即数寻址→直接寻址(+基址寻址)

    #### 常见算术运算指令

    | 功能   | 英文全称   | 汇编指令     | 对应功能                                          |
    | ------ | ---------- | ------------ | ------------------------------------------------- |
    | 加     | $add$      | $add\; d,s$  | 计算$d+s$,结果存入$d$                             |
    | 减     | $subtract$ | $sub \;d,s$  | 计算$d-s$,结果存入$d$                             |
    | 乘     | $multiply$ | $mul \;d,s$  | 无符号数$d*s$,乘积存入$d$                         |
    | 乘     | $multiply$ | $imul \;d,s$ | 有符号数$d*s$,乘积存入$d$                         |
    | 除     | $divide$   | $div\;  s$   | 无符号数除法$edx:eax/s$,商存入$eax$,余数存入$edx$ |
    | 除     | $divide$   | $idiv \;s$   | 有符号数除法$edx:eax/s$,商存入$eax$,余数存入$edx$ |
    | 取负数 | $negative$ | $neg\; d$    | 将$d$取负数，结果存入$d$                          |
    | 自增+  | $increase$ | $inc\; d$    | 将$d++$,结果存入$d$                               |
    | 自减-  | $decrease$ | $dec\; d$    | 将$d–$,结果存入$d$                                |

    **其中,目标操作数$d$不能为常量,只能来自于寄存器和主存**

    **x86中不允许两个操作数同时来自于主存**

    $edx:eax/s$:进行除法操作前要对被除数32位进行位扩展为64位再进行除法操作,$edx:eax$表示高32位存放在edx中低32为存放在eax中

    

    #### 常见逻辑运算指令

    | 功能 | 英文全称      | 汇编指令    | 对应功能                                      |
    | ---- | ------------- | ----------- | --------------------------------------------- |
    | 与   | $and$         | $and\;d,s$  | 将$d、s$逐位相与,结果放回$d$                  |
    | 或   | $or$          | $or \;d,s$  | 将$d、s$逐位相或,结果放回$d$                  |
    | 非   | $not$         | $not\; d$   | 将$d$逐位取反,结果放回$d$                     |
    | 异或 | $exclusiveor$ | $xor \;d,s$ | 将$d、s$逐位异或,结果放回$d$                  |
    | 左移 | $shiftleft$   | $shl \;d,s$ | 将$d$逻辑左移s位,结果放回$d$(通常$s$是常量)   |
    | 右移 | $shiftright$  | $shr \;d,s$ | 将$d$逻辑右移$s$位,结果放回$d$(通常$s$是常量) |

    

    

    

    #### 循环指令

    push,pop、call、ret

    

    

    #### 函数调用

    push、pop、call、ret

    

    

    ### $AT\&T$格式 $V.S.\;Intel$格式

    ![image-20230602222704201](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230602222704201.png)

    

    

    ###  选择语句

    + 程序计数器$PC(Program\;Counter)$:每取出一条指令，PC都会自动+“1”,指向下一条即将执行的指令
        + Intel x86处理器中,PC也被称为$IP(Instruction\;Pointer)$

    + 无条件转移指令–jmp指令

        + 格式: jum <地址>

            + jmp 128
                + #地址>可以用常数给出
            + jmp eax
                + <地址>可以来自于寄存器
            + jmp[999]
                + <地址>可以来自于主存

            + jum NEXT
                + <地址>可以用‘标号’锚定
                + ![image-20230602224308094](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230602224308094.png)

    + 条件转移指令–jxxx指令
        + ![image-20230602224517273](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230602224517273.png)
        + 一般与cmp指令一起使用
        + 格式: jxxx target
            + 其中，XXX表示特定的条件，target表示跳转的目标位置，可以是标签或相对/绝对的地址。
        + JXXX指令根据条件标志位的状态决定是否进行跳转，下面是几个常用的JXXX指令及其条件：
            1. JE（Jump if Equal）：如果ZF（零标志位）为1，则跳转。
            2. JNE（Jump if Not Equal）：如果ZF为0，则跳转。
            3. JB/JNAE（Jump if Below/Not Above or Equal）：如果CF（进位标志位）为1，则跳转（用于无符号数比较）。
            4. JNB/JAE（Jump if Not Below/Above or Equal）：如果CF为0，则跳转（用于无符号数比较）。
            5. JL/JNGE（Jump if Less/Not Greater or Equal）：如果SF（符号标志位）为1，则跳转（用于有符号数比较）。
            6. JNL/JGE（Jump if Not Less/Greater or Equal）：如果SF为0，则跳转（用于有符号数比较）。

    ​	

    + 操作数比较指令–cmp指令
        + 格式:cmp d s
            + 其中，d表示比较的目标操作数，s表示比较的源操作数。两个操作数可以是寄存器、内存地址或立即数。
        + CMP指令执行的过程如下：
            1. 将目标操作数和源操作数进行减法运算，但不保存结果。
                + CMP指令执行的是d- s的减法运算。
            2. 根据减法运算的结果设置标志位，包括零标志位（ZF）、进位标志位（CF）、符号标志位（SF）等。
        + 标志位的设置依赖于减法运算的结果：
            - 如果减法运算的结果为零，ZF被设置为1；否则，ZF被设置为0。
            - 如果减法运算中发生了进位（即结果无法用一个字节表示），CF被设置为1；否则，CF被设置为0。
            - 如果减法运算结果为负数（最高位为1），SF被设置为1；否则，SF被设置为0。
        + 通过CMP指令的结果，程序可以根据标志位进行条件判断，从而执行不同的操作。例如，可以使用JNE（Jump if not equal）指令来检查ZF标志位，如果ZF为0，则跳转到指定的目标位置。
        + 简单的示例，展示CMP指令的使用：

    ```mathematica
    MOV AX, 42    ; 将值42移动到寄存器AX中
    CMP AX, 30    ; 比较AX中的值与30
    JL LessThan   ; 如果AX < 30，则跳转到标签LessThan
    JG GreaterThan ; 如果AX > 30，则跳转到标签GreaterThan
    JE Equal      ; 如果AX = 30，则跳转到标签Equal
    
    LessThan:
        ; AX < 30 的情况下的处理
    
    GreaterThan:
        ; AX > 30 的情况下的处理
    
    Equal:
        ; AX = 30 的情况下的处理
    ```

    

    ### 循环语句

    #### 条件转移指令

    使用条件转移指令实现循环,一般有四个步骤

    1. 循环前的初始化
    2. 是否直接跳过循环
    3. 循环主体
    4. 是否继续循环

    ![image-20230602230357105](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230602230357105.png)

    

    #### loop循环

    在汇编语言中，LOOP指令用于实现循环控制结构，使程序可以重复执行一段代码块。LOOP指令会自动地根据CX（或ECX或RCX）寄存器中的计数值进行循环迭代。

    LOOP指令的语法如下：

    + LOOP target

    其中，target表示循环的目标位置，可以是标签或相对/绝对的地址。

    LOOP指令执行的过程如下：

    1. 从CX寄存器中读取计数值（或ECX或RCX，具体取决于汇编指令集的位数）。
    2. 将计数值减1。
    3. 如果计数值不为零，则跳转到目标位置，继续执行循环内的指令。
    4. 如果计数值为零，则循环结束，继续执行下一条指令。

    LOOP指令通常与DEC（递减）指令结合使用，用于实现循环计数器的递减。在每次循环迭代中，DEC指令会递减CX寄存器中的计数值，然后根据计数值是否为零来决定是否跳转到目标位置。

    以下是一个简单的示例，展示了LOOP指令的使用：


    ```markdown
    MOV CX, 5       ; 初始化CX寄存器为5，作为循环计数器
    LoopStart:
        ; 循环内的指令
        ; ...
    
        LOOP LoopStart   ; 循环迭代，跳转回LoopStart标签
    
        ; 循环结束后的指令
    ```
    
    在上述示例中，循环从LoopStart标签开始，根据CX寄存器中的计数值来控制循环的执行次数。每次循环迭代，CX寄存器的计数值会递减，然后根据计数值是否为零决定是否跳转回LoopStart标签。当计数值为零时，循环结束，继续执行循环结束后的指令。
    
    需要注意的是，LOOP指令是根据CX寄存器的计数值进行循环迭代的。因此，在使用LOOP指令前需要确保CX寄存器中已经正确初始化为循环的初始计数值。
    
    ![image-20230602230931375](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230602230931375.png)


​    

    **【补充】：**
    
    在汇编语言中，LOOPNZ（Loop if Not Zero）和LOOPZ（Loop if Zero）是两条特殊的循环指令，它们根据ZF（零标志位）的状态来控制循环的执行。
    
    1. LOOPNZ（Loop if Not Zero）指令：
        LOOPNZ指令用于执行循环迭代，只要ZF标志位为0（即结果不为零），就会重复执行循环内的代码块。
        LOOPNZ指令的语法如下：


    ```
    LOOPNZ target
    ```
    
    其中，target表示循环的目标位置，可以是标签或相对/绝对的地址。
    
    LOOPNZ指令执行的过程如下：


        1. 从CX寄存器中读取计数值（或ECX或RCX，具体取决于汇编指令集的位数）。
        2. 将计数值减1。
        3. 如果计数值不为零且ZF标志位为0，则跳转到目标位置，继续执行循环内的指令。
        4. 如果计数值为零或ZF标志位为1，则循环结束，继续执行下一条指令。
    
    2. LOOPZ（Loop if Zero）指令：
        LOOPZ指令用于执行循环迭代，只要ZF标志位为1（即结果为零），就会重复执行循环内的代码块。
        LOOPZ指令的语法如下：


    ```
    LOOPZ target
    ```
    
    其中，target表示循环的目标位置，可以是标签或相对/绝对的地址。
    
    LOOPZ指令执行的过程如下：


        1. 从CX寄存器中读取计数值（或ECX或RCX，具体取决于汇编指令集的位数）。
        2. 将计数值减1。
        3. 如果计数值不为零且ZF标志位为1，则跳转到目标位置，继续执行循环内的指令。
        4. 如果计数值为零或ZF标志位为0，则循环结束，继续执行下一条指令。
    
    这两条指令通常与DEC（递减）指令结合使用，用于实现循环计数器的递减和根据ZF标志位进行循环判断。
    
    以下是一个简单的示例，展示了LOOPNZ和LOOPZ指令的使用：


    ```markdown
    MOV CX, 5       ; 初始化CX寄存器为5，作为循环计数器
    LoopStart:
        ; 循环内的指令
        ; ...
    
        LOOPNZ LoopStart   ; 循环迭代，只要ZF为0，则跳转回LoopStart标签
    
        ; 循环结束后的指令
    ```
    
    在上述示例中，循环从LoopStart标签开始，根据CX寄存器中的计数值和ZF标志位的状态来决定是否跳转回LoopStart标签进行循环迭代。当计数值为零或ZF标志位为1时，循环结束，继续执行循环结束后的指令。
    
    ## 指令集计算机
    
    ### 复杂指令集计算机
    
    + 即$Complex\,Instruction\,Set\,Computer$，$CISC$。
    + 一条指令完成一个复杂的基本功能。
    + 代表：$x86$架构，主要用于笔记本和台式机。
    + $80-20$规律：典型程序中$80\%$的语句仅仅使用处理机$20\%$的指令。
    
    ### 精简指令集计算机
    
    + 即$Reduced\,Innstruction\,Set\,Computer$，$RISC$。
    + 一条指令完成一个基本动作，多条指令组合完成一个复杂的基本功能。
    + 代表：$ARM$架构，主要用于手机和平板。
    
    |  对比项目\类别   |                 CISC                 |                 RISC                 |
    | :--------------: | :----------------------------------: | :----------------------------------: |
    |     指令系统     |              复杂，庞大              |              简单，精简              |
    |     指令数目     |            一般大于200条             |            一般小于100条             |
    |     指令字长     |                不固定                |                 定长                 |
    |    可访存指令    |               不加限制               |          只有Load/Store指令          |
    | 各种指令执行时间 |               相差较大               |       绝大多数在一个周期内完成       |
    | 各种指令使用频度 |               相差很大               |             大都比较常用             |
    |  通用寄存器数量  |                 较少                 |                  多                  |
    |     目标代码     | 难以用优化编译生成高效的目标代码程序 | 采用优化的编译程序，生成代码较为高效 |
    |     控制方式     |              微程序控制              |        组合逻辑（硬布线）控制        |
    |      利用率      |                  低                  |                  高                  |
    |    指令流水线    |         可以通过一定方式实现         |               必须实现               |
    |      兼容性      |                  强                  |                  弱                  |
    |       速度       |                  慢                  |                  快                  |

# 第五章 中央处理器$(CPU)$

## 导读

### 【考纲内容】

1. **CPU 的功能和基本结构**                                                       
2. **指令执行过程**
3. **数据通路的功能和基本结构**
4. **控制器的功能和工作原理**
5. **异常和中断机制**
    1. 异常和中断的基本概念,异常和中断的分类; 异常和中断的检测与响应

6. **指令流水线**
    + 指令流水线的基本概念
    + 指令流水线的基本实现
    + 结构冒险、数据冒险和控制冒险的处理
    + 超标量和动态流水线的基本概念

7. **多处理器基本概念**
    + $SISD$、$SIMD$、$MIMD$、向量处理器的基本概念
    + 硬件多线程的基本概念
    + 多核$(multi-core)$处理器的基本概念
    + 共享内存多处理器 $(SMP) $的基本概念

### 【知识导图】

![img](http://res.ptpress.cn/36AC35AB87F046638825B525E7461D78.png)

![img](http://res.ptpress.cn/AE377BFDA3CC41C58E31B10C083A6ACF.png)

![img](http://res.ptpress.cn/0ECBAB73C5B0462282B64370F38841D7.png)

![img](http://res.ptpress.cn/31B7D7A28541465F8ED83ED0BFD6D922.png)

![img](http://res.ptpress.cn/D27FEA23ED4E4E349133D0D1136B1B49.png)

![img](http://res.ptpress.cn/E7F58AB909C74113B87FDA486B3FE01D.png)

![img](http://res.ptpress.cn/B1E5799F550A46C7B10A6A8888E5FF31.png)

![image-20230603095230601](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603095230601.png)

![img](http://res.ptpress.cn/23C5A832CE9D497797DAE3E3A5EEAC23.png)

![img](http://res.ptpress.cn/27C7442F819549B5BE55A3427B590CAC.png)

![img](http://res.ptpress.cn/CC9FD1FC8E21462AB2DA312E22E7C149.png)

![img](http://res.ptpress.cn/DABCD40FB97049B9A69A3A3E2989570C.png)

![img](http://res.ptpress.cn/A49C1C1C425142009CE514B3DBD18DD9.png)

![img](http://res.ptpress.cn/897A9D9405864D7280040DECC2523212.png)

![img](http://res.ptpress.cn/F3D19288780642AF985FE0D671613D4A.png)

![img](http://res.ptpress.cn/B2FBB242C124458D87EA49977291E49D.png)

![img](http://res.ptpress.cn/967CF1FA3A71418482699C75341D3EDD.png)

![image-20230603095542154](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603095542154.png)



![img](http://res.ptpress.cn/292CC4CB6D0649C4998F669D2AAB1654.png)

![image-20230603095807976](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603095807976.png)



### 【复习提示】

中央处理器是计算机的中心,也是本书的难点。其中,数据通路的分析,指令执行阶段的节拍与控制信号的安排、流水线技术与性能分析易出综合题。而关于各种寄存器的特点、指令执行的各种周期与特点、控制器的相关概念、流水线的相关概念也极易出选择题。

在学习本章时,请读者思考以下问题:

1) 指令和数据均存放在内存中,计算机如何从时间和空间上区分它们是指令还是数据?

2) 什么是指令周期、机器周期和时钟周期? 它们之间有何关系?

3) 什么是微指令? 它和第 4 章谈到的指令有什么关系?

4) 什么是指令流水线? 指令流水线相对于传统体系结构的优势是什么?

## $CPU$基本概念

### CPU功能

#### CPU总功能

1. 指令控制。
    + 完成取指令、分析指令和执行指令的操作,即程序的顺序控制。
2. 操作控制。
    + 一条指令的功能往往是由若干操作信号的组合来实现的
    + $CPU$管理并产生由内存取出的每条指令的操作信号,把各种操作信号送往相应的部件,从而控制这些部件按指令的要求进行动作。
3. 时间控制。
    + 对各种操作加以时间上的控制。时间控制要为每条指令按时间顺序提供应有的控制信号。
4. 数据加工。
    + 对数据进行算术和逻辑运算。
5. 中断处理。
    + 对计算机运行过程中出现的异常情况和特殊请求进行处理。

#### 运算器功能

+ 对数据进行加工。
+ 主要部件是$ALU$和$ACC$。

#### 控制器功能

协调并控制计算机各部件执行程序的指令序列,基本功能包括取指令、分析指令、执行指令:

1. 取指令:
    + 自动形成指令地址。
    + 自动发出取指令的命令。
    + $(PC)+"1"\rightarrow PC$。
2. 分析指令:
    + 操作码译码（对操作码分析本条指令要完成什么操作）。
    + 产生操作数的有效地址。
3. 执行指令:
    + 根据分析指令得到的“操作命令”和“操作数地址”。
    + 形成操作信号控制序列,控制运算器、存储器以及$I/O$设备完成相应的操作。
4. 中断处理:
    + 管理总线及输入输出。
    + 处理异常情况（如掉电）。
    + 特殊请求（如打印机请求打印一行字符）。

+ 控制器部件向系统中的部件提供它们运行所需要的控制信号。
+ 控制器部件从数据总线接收指令信息。
+ 控制器部件从运算器部件接收指令转移地址。
+ 控制器部件送出指令地址到地址总线。

### $CPU$结构

![image-20230603112823392](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603112823392.png)

#### 运算器结构

![image-20230603112327224](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603112327224.png)

1. 算术逻辑单元$ALU$:主要功能是进行算术/逻辑运算。
2. 通用寄存器组$X$:如$AX(AH,AL)$、$BX(BX,BL)$、$CX(CH,Cl)$、$DX(DX,DL)$、$SP$等,用于存放操作数（包括源操作数、目的操作数及中间结果）和各种地址信息等。$SP$是堆栈指针,用于指示栈顶的地址。
3. 内部总线:
    + 专用数据通路方式:
        + 根据指令执行过程中的数据和地址的流动方向安排多条连接线路。
        + 寄存器有多少位就有多少根线连着$ALU$,寄存器将操作数的所有位并行的传输到$ALU$中
        + 如果直接用导线连接,相当于多个寄存器同时并且一直向$ALU$传输数据,解决方法:
            1. 使用多路选择器$MUX$根据控制信号选择一路输出解决方法。
            2. 使用三态门可以控制每一路是否输出,$1$允许,$0$不允许。
        + 性能较高,基本不存在数据冲突现象,但结构复杂,硬件量大,不易实现。
    + $CPU$内部单总线方式:
        + 将所有寄存器的输入端和输出端都连接到一条公共的通路上。
        + 结构简单,容易实现,但数据传输存在较多冲突的现象,性能较低。
        + 为了解决冲突用暂存寄存器解决。
4. 暂存寄存器$R$:用于暂存从主存读来的数据,这个数据不能存放在通用寄存器中,否则会破坏其原有内容。
    + 若两个操作数分别来自主存和$R_0$,最后结果存回$R_0$,那么从主存中取来的操作数直接放入暂存器,就不会破坏运算前$R_0$的内容。
5. 累加寄存器$ACC$:它是一个通用寄存器,用于暂时存放$ALU$运算的结果信息,用于实现加法运算。
6. 程序状态字寄存器$PSW$:保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息,如溢出标志（$OF$） 、符号标志（$SF$）、零标志（$ZF$）、进位标志（$CF$）等,$PSW$中的这些位参与并决定微操作的形成。
    + **Overflow Flag (OF)**:溢出标志位,用于指示算术运算是否产生了溢出。当进行有符号数运算时,如果结果超过了有符号数的表示范围,则OV标志位被设置为1。
    + **Sign Flag (SF)**:符号标志位,用于指示运算结果的符号。当运算结果为负数时,SF标志位被设置为1。
    + **Zero Flag (ZF)**:零标志位,用于指示运算结果是否为零。当运算结果为零时,ZF标志位被设置为1。
    + **Carry Flag (CF)**:进位标志位,用于指示无符号数运算是否产生了进位。当进行无符号数相加时,如果最高位产生了进位,CF标志位被设置为1。
    + **Parity Flag (P)**:奇偶标志位,用于指示运算结果的二进制表示中1的个数是否为偶数。当运算结果中1的个数为偶数时,P标志位被设置为1。
    + **Auxiliary Carry Flag (AC)**:辅助进位标志位,用于指示低位到高位的进位。当进行BCD码（二进制编码的十进制数）运算时,如果低四位到高四位产生了进位,AC标志位被设置为1。
7. 移位器（移位寄存器）$SR$:对运算结果进行移位运算。拥有移位逻辑的寄存器。
8. 计数器（计数寄存器）$CT$:控制乘除运算的操作步数。拥有计数逻辑的寄存器。

#### 控制器结构

$PC$(取指令)$\to$$IR$(分析指令)$\to$$CU$(执行指令)

![image-20230603112149297](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603112149297.png)

1. 程序计数器$PC(Program\,Counter)$:用于指出下一条指令在主存中的存放地址。$CPU$就是根据$PC$的内容去主存中取指令的。因程序中指令（通常）是顺序执行的,所以$PC$有自增功能。
2. 指令寄存器$IR(Instruction\,Register)$:用于保存当前正在执行的那条指令。
3. 指令译码器$ID(Instruction\;Decoder)$:仅对**操作码**字段进行译码,向控制器提供特定的操作信号。
4. 操作控制器$OC$:用来产生各种操作控制信号。
5. 微操作信号发生器:根据$IR$的内容（指令）、$PSW$的内容（状态信息）及时序信号,产生控制整个计算机系统所需的各种控制信号,其结构有组合逻辑型和存储逻辑型两种。
6. 时序系统$TG(Timing\;Generator)$（时序产生器）:用于产生各种时序信号,它们都是由统一时钟（$CLOCK$）分频得到。
7. 存储器地址寄存器$MAR$:用于存放所要访问的主存单元的地址。
8. 存储器数据寄存器$MDR$:用于存放向主存写入的信息或从主存中读出的信息。



## 指令执行

### 指令周期

#### 指令周期定义

+ 指令周期:$CPU$从主存中每取出并执行一条指令所需的全部时间:
    + 取指周期:取指、分析。
    + 执行周期。
    + ![image-20230603113042749](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603113042749.png)
+ **指令周期**常常用若干机器周期来表示,机器周期又叫$CPU$周期。如取指令、取有效地址、执行指令这就是三个机器周期,是一个指令周期。
+ 一个**机器周期**又包含若干**时钟周期**（也 称为节拍、$T$周期或$CPU$时钟周期,它是$CPU$操作的最基本单位）。

![image-20230603113447201](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603113447201.png)


+ 每个指令周期内机器周期数可以不等,每个机器周期内的节拍数也可以不等。

    + 空指令$NOP$: 指令周期=取值周期
    + 加法指令$ADD$:指令周期=取值周期+执行周期
    + 乘法指令$MUL$:指令周期=取值周期+执行周期(较长)
    + 具有间接寻址的指令:指令周期=取值周期+间址周期+执行周期
    + 带有中断周期的指令:指令周期=取值周期+间址周期+执行周期+中断周期
    + ![image-20230603113844682](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603113844682.png)

+ 指令周期流程:
    1. 进入取指周期。
    2. 判断是否有间址。
    3. 若有则进入间址周期,结束后进入执行周期。
    4. 若无则直接进入执行周期。
    5. 判断是否有中断。
    6. 若有则进入中断周期,结束后进入下一条指令的指令周期。
    7. 若无则直接进入下一条指令的指令周期。

![image-20230603144007541](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603144007541.png)

#### 标志触发器

为了区别不同的工作周期,$CPU$内设了四个标志触发器,以一状态位为有效:

+ 取指令$FE$:取指周期。
+ 取地址$IND$:间址周期。
+ 存取操作数或结果$EX$:执行周期。
+ 存程序断点$INT$:中断周期。

#### 相关周期区别

四种周期:

+ 指令周期:$CPU$从主存中每取出并执行一条指令所需的全部时间。指令周期可变。
+ 时钟周期:通常称为节拍或$T$周期,它是$CPU$操作的最基本单位。时钟周期不变。
+ $CPU$周期也称机器周期:一个机器周期包含若干时钟周期。是$CPU$进行一次操作的时间。由于$CPU$内部操作的速度较快,而$CPU$访问一次存储器的时间较长,因此机器周期通常由存取周期来确定,往往是通过一次总线事务访问一次主存或$I/O$的时间。机器周期可变。
+ 存取周期:指存储器进行两次独立的存储器操作（连续两次读或写操作）所需的最小间隔时间。存取周期往往为固定值。
+ 机器周期:通过一次总线事务访问一次主存或 $I/O$的时间定为一个机器周期。所以机器周期往往与访存周期相等。

### 数据流

指令周期一共包含四个机器周期,但是指令不同可能只有部分周期,如零地址指令只有取指和执行周期。

#### 取指周期

根据$PC$内容（无论是普通指令还是转移指令）从内存中取出指令代码并放入$IR$中。

![image-20230603144936047](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603144936047.png)

<span style="color:orange">注意:</span>取指操作是控制器固化的自动执行的操作。

1. 当前指令地址送至存储器地址寄存器,记做:$(PC)\rightarrow MAR$。
2. $MAR$将地址码发送到地址总线。
3. 地址总线将地址发送给存储器,等待使用地址。
4. $CU$发出控制读信号给控制总线。
5. 控制总线将控制读的信号发送给存储器。启动存储器做读操作,这是是**读信号**,记做:$1\rightarrow R$。
    + $R$(头上没有横杠)表示高电平激活,这里$1$表示高电平
6. 存储器根据地址总线传来的地址信息和控制总线传来的控制读信息来进行读操作,从中读出数据。并将地址所指的数据发送给数据总线。
7. 数据总线将数据送入$MDR$,记做:$M(MAR)\rightarrow MDR$。
    + $M(MAR)$指主存$(Memory)$中$MAR$存储地址所指的数据
8. 将$MDR$中数据（此时是指令内容）**复制**送入$IR$,记做:$(MDR)\rightarrow IR$。
9. $CU$发出控制信号,控制$PC$形成下一条指令地址,默认是加一,记做:$(PC)+1\rightarrow PC$。

#### 间址周期

根据间接地址取操作数有效地址。

![image-20230603145659982](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603145659982.png)

1. $IR$将指令的地址码送入$MAR$,记做:$Ad(IR)\rightarrow MAR$或$Ad(MDR)\rightarrow MAR$。
    + 由于取指周期$(MDR)\rightarrow IR$时$MDR$是复制一份地址码送入$IR$的,此时$MDR$中还留有地址码
2. $MAD$将地址码发送到地址总线。
3. 地址总线将地址发送给存储器,等待使用地址。
4. $CU$发出控制读信号给控制总线。
5. 控制总线将控制读信息发送到存储器中。启动主存做**读操作**,记做:$1\rightarrow R$。
6. 存储器根据地址总线传来的地址信息和控制总线传来的控制读信息来进行读操作,从中读出数据。并将地址所指的数据发送给数据总线。
7. 数据总线将数据送入$MDR$,记做:$M(MAR)\rightarrow MDR$。此时$MDR$保存的是操作数的地址而不是操作数本身。
8. 将有效地址送至指令的地址码字段,记做:$MDR\rightarrow Ad(IR)$。
    + 这一步只有部分$CPU$会有
    + 这一步会将有效地址覆盖于原指令的间接地址

#### 执行周期

执行周期的任务是根据$IR$中的指令字的操作码和操作数通过$ALU$操作产生执行结果。不同指令的执行周期操作不同,因此没有统一的数据流向。

这里$MDR$访存取数得到操作数,此时$MDR$中的内容才是操作数。

#### 中断周期

+ 中断:暂停当前任务去完成其他任务。为了能够恢复当前任务,需要**保存断点**。
+ 一般使用**堆栈**来保存断点,这里用$SP$表示栈顶地址,假设$SP$指向栈顶元素,进栈操作是先修改指针,后存入数据。

![image-20230603150844450](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603150844450.png)

1. $CU$控制将**$SP$减$1$**,即将一个空元素进栈然后对其操作,并修改后的地址送入$MAR$,记做:$(SP)-1\rightarrow SP$,$(SP)\rightarrow MAR$。本质上是将断点存入某个存储单元,假设其地址为$a$,故可记做:$a\rightarrow MAR$。
    + <span style="color:orange">注意:</span>中断周期中的进栈操作是将$SP$减$1$,这和传统意义上的进栈操作相反,原因是计算机的堆栈中从高向低地址增加,所以进栈操作是减$1$而不是加$1$。
2. $MAR$将地址码发送到地址总线。
3. 地址总线将地址发送给存储器,等待使用地址。
4. $CU$发出控制写信号给控制总线。
5. 控制总线将控制写信息发送到存储器中。启动主存做**写操作**,记做:$1\rightarrow W$。
6. 将断点（$PC$内容）送入$MDR$,记做:$(PC)\rightarrow MDR$。
7. 将$MDR$内容传入数据总线。
8. 数据总结将内容发送存储器。存储器将内容写入其中,记为$(MDR)\rightarrow M$。
9. $CU$控制将中断服务程序的入口地更新（由向量地址形成部件产生）送入$PC$:向量地址$\rightarrow PC$。

### 指令执行方案

一个指令周期通常要包括多个时间段（执行步骤）,每个步骤完成指令的一部分功能,几个依次执行的步骤完成这条指令的全部功能。

1. 单指令周期:
    + 对所有指令都选用相同的执行时间来完成。
    + 指令之间串行执行。
    + 指令周期取决于执行时间最长的指令的执行时间。
    + 执行周期内控制信号不变。
    + 缺点:对于那些本来可以在更短时间内完成的指令,要使用这个较长的周期来完成,会降低整个系统的运行速度。
    + 优点:实施简单,只用程序计数器$PC$就能实现。
2. 多指令周期:
    + 对不同类型的指令选用不同的执行步骤来完成。
    + 指令之间串行执行。
    + 可选用不同个数的时钟周期来完成不同指令的执行过程。
    + 缺点:需要更复杂的硬件设计。
    + 优点:系统运行速度更高,效率更高。
3. 流水线方案:
    + 在每一个时钟周期启动一条指令,尽量让多条指令同时运行,但各自处在不同的执行步骤中。

## 数据通路

+ 数据通路就是数据在功能部件之间传送的路径。
+ 由控制部件产生的控制信号建立数据通路。
+ 数据通路的基本结构:
    + $CPU$内部单总线方式。
        + ALU工作时需要配合暂存寄存器
    + $CPU$内部多总线方式。
    + 专用数据通路方式。

### CPU内部单总线方式

+ **内部总线**是指同一部件,如$CPU$内部连接各寄存器及运算部件之间的总线。
+ **系统总线**是指同一台计算机系统的各部件,如$CPU$、内存、通道和各类$I/O$接口间互相连接的总线。
+ 使用一根总线连接部件的输入和输出。
+ 一个时钟内只允许一次操作。
+ 实现简单。
+ 容易冲突,且效率较低。

对于$ALU$这种是一个组合逻辑电路的部件,其运算过程中必须保持两个输入端的内容不变。如果使用内部单总线方式,因此为了得到两个不同的操作数,$ALU$的一个输入端与总线相连,另一个输入端需通过一个寄存器与总线相连,第一个传入值的输入端需要用寄存器保存数据等待第二个数的输入,避免数据发生变化。此外,$ALU$的唯一的输出端也不能直接与内部总线相连,否则其输出又会通过总线反馈到输入端,影响运算结果,因此输出端需通过一个暂存器（用来暂存结果的寄存器）或三态门（控制与总线的打开与关闭）与总线相连。

<span style="color:orange">注意:</span>**哪些控制信号有效是关键得分点一定要写上**

![image-20230603154752818](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603154752818.png)

1. 寄存器之间数据传送,比如把$PC$内容送至$MAR$,实现传送操作的流程及控制信号为:
    1. $(PC)\rightarrow Bus$:$PCout$有效,$PC$内容送总线。
    2. $Bus\rightarrow MAR$:$MARin$有效,总线内容送$MAR$。
2. **主存与$CPU$之间的数据传送**,比如$CPU$从主存读取指令,实现传送操作的流程及控制信号为:
    1. $(PC)\rightarrow Bus\rightarrow MAR$:$PCout$和$IMARin$有效,现行指令地址$\rightarrow MAR$。
    2. $1\rightarrow R$:$CU$通过控制总线发出**读命令**。
    3. $MEM(MAR)\rightarrow MDR$:$MDRinE$有效,根据$MAR$地址取值送到$MDR$。
        + 此时$MDRin$也常写成$MDRinE$,因为$MDRin$指的$CPU$内部总线的控制信号,而此时主存送数据到$MDR$时使用的是外部总线,一般使用的不是$MDRin$的控制信号
    4. $MDR\rightarrow Bus\rightarrow IR$:$MDRout$和$IRin$有效,现行指令$\rightarrow IR$。
3. **执行算术或逻辑运算**,比如一条加法指令,微操作序列及控制信号为:
    1. $Ad(IR)\rightarrow Bus\rightarrow MAR$:$MDRout$和$IMARin$有效。
    2. $1\rightarrow R$:$CU$发读命令。
    3. $MEM(MAR)\rightarrow$外部数据总线$\rightarrow MDR$:$MDRinE$有效。
        + 同上,使用的是外部数据总线
    4. $MDR\rightarrow Bus\rightarrow Y$:$MDRout$和$Yin$有效,操作数$\rightarrow Y$。
    5. $(ACC)+(Y)\rightarrow Z$:$ACCout$和$ALUin$有效,$CU$向$ALU$发送加命令。
        + $(ACC)+(Y)$这一步是在$ALU$中计算,计算结果放入寄存器$Z$中
        + 寄存器$Y$和$ALU$之间有一根专用数据通路,不会走数据总线
    6. $Z\rightarrow ACC$:$Zout$和$ACCin$有效,结果$\rightarrow ACC$。

**【例题】:**

设有如图所示的单总线结构,分析指令$ADD\; (R0),R1$的指令流程和控制信号

![image-20230603154837161](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603154837161.png)

**【解析】:$ADD\; (R0),R1$**中

+ $(R0)$部分是目的操作数,由于有括号则可知需先将$R0$中数据取出得到主存中存放有效数的地址,然后根据地址去主存中取得有效数
+ $R1$部分是源操作数,直接取得有效数即可
+ $ADD\;d\;s$指$d+s$的结果存放到$d$(所指地址的)中
    则完整功能为$((R0))+(R1)\rightarrow(R0)$,其中包括取指周期,间址周期,执行周期



**【解】:**

完整功能为$((R0))+(R1)\rightarrow(R0)$,其中包括取指周期,间址周期,执行周期

**取址周期:**公共操作

| 时序 | 微操作                                  | 有效控制信号         |
| ---- | --------------------------------------- | -------------------- |
| 1    | $(PC) \rightarrow MAR$                  | $PCout,MARin$        |
| 2    | $M(MAR)→MDR$<br />$(PC) \rightarrow PC$ | $MemR,MARout,MARinE$ |
| 3    | $(MDR) \rightarrow IR$                  | $MDRout,IRin$        |
| 4    | 指令译码                                | /                    |

**间址周期:**完成取数操作,被加数在主存中,加数已经放在寄存器$R1$中

| 时序 | 微操作                  | 有效控制信号         |
| ---- | ----------------------- | -------------------- |
| 1    | $(R0)  \rightarrow MAR$ | $R0out,MARin$        |
| 2    | $M(MAR)→MDR$            | $MemR,MARout,MARinE$ |
| 3    | $(MDR)  \rightarrow Y$  | $MDRout,Yin$         |

**执行周期:**完成取数操作,被加数在主存中,加数己经放在寄存器$R1$中。

| 时序 | 微操作                      | 有效控制信号                           |
| ---- | --------------------------- | -------------------------------------- |
| 1    | $(R1)  + (Y) \rightarrow Z$ | $R1out,ALUin,CU$向$ALU$发$ADD$控制信号 |
| 2    | $(Z)→MDR$                   | $Zout,MDRin$                           |
| 3    | $(MDR)  \rightarrow M(MAR)$ | $MemW,MDRoutE,MARout$                  |

### CPU内部多总线方式

+ 使用多根总线连接部件的输入和输出。
+ 效率相对于单总线而言得到了提升。

### 专用数据通路方式

+ 对于各种部件使用专用的通路进行连接。专用通路就是将总线分散到各个地方。
+ 连接多,实现困难。
+ 专用数据通路是指针对特定的操作或指令进行优化设计的数据通路,以提高指令执行的效率和速度。

专用数据通路方式的主要特点是针对特定的操作或指令进行优化,通过直接连接相应的功能单元,减少数据传输的路径和延迟,从而提高数据的传输速度和系统的整体性能。

以下是几种常见的专用数据通路方式:

1. **乘法器和除法器数据通路**:对于乘法和除法操作,通常会采用专门的乘法器和除法器单元。这些单元与其他功能单元（如寄存器、ALU等）直接连接,形成专用的数据通路,以提高乘除操作的速度和效率。
2. **浮点数数据通路**:针对浮点数运算,通常会设计专用的浮点数单元和浮点数数据通路。这些单元包括浮点加减器、浮点乘除器等,与其他功能单元相连接,形成专门用于浮点数运算的数据通路。
3. **向量处理器数据通路**:在一些特定的应用中,需要进行大规模的向量计算,如图形处理、科学计算等。为了提高向量操作的效率,可以设计专门的向量处理器单元和数据通路,以支持并行的向量操作。
4. **高速缓存数据通路**:高速缓存是用于加速存储器访问的重要组件。在CPU中,高速缓存通常与其他功能单元直接相连,形成专用的数据通路,以实现快速的缓存访问和数据交换。

![image-20230603161842951](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603161842951.png)



**【例题】:**

下图是一个简化的 $CPU $与主存连接结构示意图 ( 图中省略了所有的多路选择器 ),其中
有一个累加寄存器 ($ACC $)、一个状态数据寄存器和其他 4 个寄存器: 主存地址寄存器
($MAR $)、主存数据寄存器 ($MDR $)、程序寄存器 ($PC $) 和指令寄存器 ($IR $),各部件及
其之间的连线表示数据通路,箭头表示信息传递方向。

![image-20230603162149568](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603162149568.png)

要求:

1) 请写出图中 a、b、c、d 四个寄存器的名称

2) 简述图中取指令的数据通路

3) 简述数据在运算器和主存之间进行存/取访问的数据通路
    + 假设地址已在$MAR $中


4) 简述完成指令$LDA\;X$ 的数据通路
    + $X $为主存地址,$LDA $的功能为$(X) \rightarrow ACC $
5) 简述完成指令 $ADD\;Y$ 的数据通路

  +  $Y$立为主存地址,$ADD $的功能为$(ACC) + (Y) \rightarrow ACC $

6) 简述完成指令 $STA\;Z $的数据通路

  +  $Z $为主存地址,$STA $的功能为$(ACC) \rightarrow Z $



**【解】:**

1.  请写出图中 a、b、c、d 四个寄存器的名称
    1. $d$能自动$“+1”$,是$PC$
    2. $PC$内容是地址,需要送给$MAR$,则$c$是$MAR$
    3. $b$与微操作信号发生器相连,是$IR$
    4. 与主存相连的寄存器是$MAR$和$MDR$,$c$是$MAR$,则$a$是$MDR$

2.  简述图中取指令的数据通路
    + $(PC) \rightarrow MAR$
    + $M(MAR) \rightarrow MDR$
        + $1 \rightarrow R$
    + $(MDR)  \rightarrow IR$
    + $OP(IR) \rightarrow $微操作发生器
    + $(PC)+1 \rightarrow PC$
3.  简述数据在运算器和主存之间进行存/取访问的数据通路
    + ![image-20230603164301374](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603164301374.png)
    + 取:
        + $M(MAR) \rightarrow MDR$
            + $1 \rightarrow R$
        + $(MDR) \rightarrow ALU  \rightarrow  ACC$
    + 存:
        + $(ACC) \rightarrow MDR$
        + $(MDR) \rightarrow M(MAR)$
            + $1 \rightarrow W$

4.  简述完成指令$LDA\;X$ 的数据通路
    + $X  \rightarrow MAR$
    + $M(MAR) \rightarrow MDR$
        + $1 \rightarrow R$
    + $(MDR) \rightarrow ALU  \rightarrow  ACC$

5.  简述完成指令 $ADD\;Y$ 的数据通路
    + $Y  \rightarrow MAR$
    + $M(MAR) \rightarrow MDR$
        + $1 \rightarrow R$
    + $(MDR) \rightarrow ALU,(ACC)  \rightarrow  ALU$
    + $ALU \rightarrow ACC$

6.  简述完成指令 $STA\;Z $的数据通路
    + $Z  \rightarrow MAR$
    + $(ACC)  \rightarrow  MDR$
    + $(MDR) \rightarrow M(MAR)$

## 控制器

$CU$的设计包括硬布线和微程序两种,微程序比较重要,硬布线了解即可。

### 控制器输入输出

输入:

1. 指令寄存器:$OP(IR)\rightarrow CU$,控制信号的产生与操作码有关。
2. 时钟:一个时钟脉冲发一个操作命令或一组需要同时执行的操作命令。
3. 标志:如条件转移指令,根据相应的标志位决定下一步操作。
4. 外来信号:如中断请求信号$INTR$、总线请求信号$HRQ$。

$CU$的输入信号来源如下:

1. 经指令译码器译码产生的指令信息。
    1. 指令寄存器:$OP(IR)\rightarrow CU$,控制信号的产生与操作码有关

2. 目前的机器周期
    1. $FE、IND、EX、INT$(事实上这四个触发器集成在CU内部)

3. 时序系统产生的节拍信号。
    1. 时钟:一个时钟脉冲发一个操作命令或一组需要同时执行的操作命令。

4. 来自执行单元的反馈信息即标志。
    1. 可能来自运算器的$PSW$、$ACC$的符号位等
    2. 也可能来自$I/O$设备、主存


前三者是主要因素。

![image-20230603210419448](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603210419448.png)

输出:

1. $CPU$内部的控制信号:寄存器之间的数据传输、$PC$的修改、控制$ALU$进行相应的运算。
2. 到控制总线的控制信号:
    + 到存储器:访存控制信号$MREQ$、读命令$RD$、写命令$WR$。
    + 到$I/O$设备:访问$I/O$设备的控制信号$I/O$。
    + 中断响应信号$INTA$。
    + 总线响应信号$HLDA$。

### 硬布线

微操作控制信号由组合逻辑电路根据当前的指令码、状态和时序,即时产生。

#### 设计步骤

1. 分析每个阶段的微操作序列。

    1. 取址$FE$:所有指令都一样

        1. $PC\rightarrow MAR$:将$PC$地址交给$MAR$。
        2. $1\rightarrow R$:主存发出读命令。只需要存储器空闲就能发出。
        3. $M(MAR)\rightarrow MDR$:将地址指向指令交给$MDR$。要$MAR$准备好,在$1$的后面。
        4. $MDR\rightarrow IR$:将指令交给$IR$。把$MDR$有指令,在$3$后面。
        5. $OP(IR)\rightarrow ID$:编译指令。$IR$中要有指令,在$4$后面。
        6. $(PC)+1\rightarrow PC$:$PC$自加$1$。因为操作完就可以更新,所以在$1$后面就可以了。

    2. 间址$IND$:所有指令都一样

        1. $Ad(IR)\rightarrow MAR$:获取$IR$指令中的地址交给$MAR$。
        2. $1\rightarrow R$:主存发出读命令。
        3. $M(MAR)\rightarrow MDR$:取出对应的值放到$MDR$中。
        4. $MDR\rightarrow Ad(IR)$:将$MDR$的地址值放入$IR$的指令中。

    3. 执行$EX$

        1. $CLA$（$clear$）$X$:$ACC$清零

            1. $0→AC$

        2. $LDA\;X$:取数指令,把$X$所指内容取到$ACC$

            1. $Ad(IR)→MAR$
            2. 1→R
            3. M(MAR)→MDR
            4. MDR→AC

        3. $JMP$（$jump$）$X$:无条件转移

            1. Ad(IR)→PC

        4. $BAN$（$branch\,ACC\,Negative$）$X$:条件转移,当$ACC$为负时转移到$X$

            1. $A_{0} \cdot A d(I R)+\overline{A_{0}} \cdot(P C) \rightarrow P C$

                + $A_{0} $指$A$的符号位,符号位为0指$A$为负数,跳转到$X$

                

    4. 中断$INT$

        1. $a\rightarrow MAR$:将$a$保存到$MAR$中。
        2. $1\rightarrow W$:主存发出写命令。存储器空闲就可以。
        3. $0\rightarrow EINT$:硬件关中断。安排在第一个周期就可以。
        4. $(PC)\rightarrow MDR$:将当前程序计数器保存的位置暂存到$MDR$,等待后期恢复。内部数据通路空闲就可以。
        5. $MDR\rightarrow M(MAR)$:将$MDR$的数据保存到$a$这个地址。在$4$之后。
        6. 向量地址$\rightarrow PC$:将$PC$送到中断服务地址。只用$PC$改好就可以,在$4$之后。

2. 选择$CPU$的控制方式:产生不同微操作命令序列所用的时序控制方式:

    1. 同步控制方式:
        + 整个系统所有的控制信号均来自一个统一的时钟信号。
        + 通常以最长的微操作序列和最烦琐的微操作作为标准,采取完全统一的、具有相同时间间隔和相同数目的节拍作为机器周期来运行不同的指令。
        + 同步控制方式的优点是控制电路简单,缺点是运行速度慢。
    2. 异步控制方式:
        + 异步控制方式不存在基准时标信号。
        + 各部件按自身固有的速度工作,通过应答方式进行联络。
        + 异步控制方式的优点是运行速度快,缺点是控制电路比较复杂。
    3. 联合控制方式:
        + 对各种不同的指令的微操作实行大部分采用同步控制、小部分采用异步控制的办法。

3. 安排微操作时序的原则:

    1. 微操作的先后顺序不得随意更改
    2. 被控对象不同的微操作尽量安排在一个节拍内完成
    3. 占用时间较短的微操作尽量安排在一个节拍内完成并允许有先后顺序

4. 电路设计。

    1. 列出操作时间表。
    2. 写出微操作命令的最简表达式。
    3. 画出逻辑图。

#### 指令类别

1. 非访存指令:

    1. $CLA$（$clear$）:$ACC$清零。
    2. $COM$（$complement$）:$ACC$取反。
    3. $SHR$（$shift$）:算术右移。
    4. $CSL$（$cyclic\,shift$）:循环左移。
    5. $STP$（$stop$）:停机。

    ![image-20230603211542126](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603211542126.png)

2. 访存指令:

    1. $ADD$:加法指令,隐含$ACC$。
    2. $STA$:存数指令,隐含$ACC$。
    3. $LDA$:取数指令,隐含$ACC$。

    ![image-20230603211648526](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603211648526.png)

3. 转移指令:

    1. $JMP$（$jump$）:无条件转移。
    2. $BAN$（$branch\,ACC\,Negative$）:条件转移。

    ![image-20230603211759854](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603211759854.png)

#### 基本微操作时序

首先对于取指周期,基本上的流程如下:

1. $PC\rightarrow MAR$:将$PC$地址交给$MAR$。
2. $1\rightarrow R$:主存发出读命令。只需要存储器空闲就能发出。
3. $M(MAR)\rightarrow MDR$:将地址指向指令交给$MDR$。要$MAR$准备好,在$1$的后面。
4. $MDR\rightarrow IR$:将指令交给$IR$。把$MDR$有指令,在$3$后面。
5. $OP(IR)\rightarrow ID$:编译指令。$IR$中要有指令,在$4$后面。
6. $(PC)+1\rightarrow PC$:$PC$自加$1$。因为操作完就可以更新,所以在$1$后面就可以了。

所以没有依赖的可以尽量往前放,顺序可以变为$123645$。

因为$12$没有相互依赖,所以可以都安排在$T0$时间；$36$在$1$的后面,且$36$之间用到的设备不一样从而不会冲突,所以都安排在$T1$；而$4$和$5$时间都较短,所以可以都安排在$T2$。

然后是间址周期:

1. $Ad(IR)\rightarrow MAR$:获取$IR$指令中的地址交给$MAR$。
2. $1\rightarrow R$:主存发出读命令。
3. $M(MAR)\rightarrow MDR$:取出对应的值放到$MDR$中。
4. $MDR\rightarrow Ad(IR)$:将$MDR$的地址值放入$IR$的指令中。

与取指周期一致,$2$可以跟$1$一起,而$34$都依赖于$1$,所以$12$是$T0$,$3$是$T1$,$4$是$T2$。

执行周期省略,最后是中断周期,假设中断时要保存的地址为$a$:

1. $a\rightarrow MAR$:将$a$保存到$MAR$中。
2. $1\rightarrow W$:主存发出写命令。存储器空闲就可以。
3. $0\rightarrow EINT$:硬件关中断。安排在第一个周期就可以。
4. $(PC)\rightarrow MDR$:将当前程序计数器保存的位置暂存到$MDR$,等待后期恢复。内部数据通路空闲就可以。
5. $MDR\rightarrow M(MAR)$:将$MDR$的数据保存到$a$这个地址。在$4$之后。
6. 向量地址$\rightarrow PC$:将$PC$送到中断服务地址。只用$PC$改好就可以,在$4$之后。

$1$、$2$、$3$都在$T0$,而$456$依次为$T1$、$T2$、$T3$。

这些操作由中断隐指令完成。中断隐指令不是一条指令,而是指一条指令的中断周期由硬件完成的一系列操作

#### 组合逻辑设计

![image-20230603212124990](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603212124990.png)

![image-20230603212157617](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603212157617.png)

![image-20230603212308100](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603212308100.png)

#### 硬布线控制器的特点

- 指令越多,设计和实现就越复杂,因此一般用于$RISC$(精简指令集系统)
- 如果扩充一条新的指令,则控制器的设计就需要大改,因此扩充指令较困难。
- 由于使用纯硬件实现控制,因此执行速度很快。微操作控制信号由组合逻辑电路即时产生。

### 微程序控制器

事先把微操作控制信号存储控制存储器中,将每一条机器指令编写成一个微程序,这些微程序可以存到一个控制存储器中,用寻址用户程序机器指令的办法来寻址每个微程序中的微指令。

+ 在微程序控制器中,控制部件向执行部件发出的控制信号称为微命令。
+ 微命令执行的操作称为微操作。
+ 微指令则是若干微命令的集合。
+ 若干微指令的有序集合称为微程序。

#### 微程序构成

+ 相关概念
    + **微指令（Microinstruction）**:微指令是微程序的最小执行单位,是对硬件层面的微操作进行编码的指令。它包含了对CPU中各个部件的控制信号、操作码和地址等信息。每条微指令对应着一个或多个微操作。
    + **指令（Instruction）**:指令是在机器语言中表示一条操作的基本单位。它是对特定操作的功能描述,由操作码和操作数组成。在微程序控制器中,指令被解码后会生成对应的一系列微指令。
    + **微操作（Microoperation）**:微操作是对硬件中的某个具体操作进行编码的指令,它是微指令的基本执行单位。例如,将数据从寄存器加载到ALU、将运算结果存储到寄存器等都可以视为一个微操作。
    + **微程序（Microprogram）**:微程序是一系列微指令的集合,用于实现特定的指令集和操作序列。它是对指令执行过程进行细化和抽象的一种表示方式。微程序通常以存储器的形式存在,存储着每条指令对应的微指令序列。
    + ![image-20230603213035541](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603213035541.png)

+ 完成一条机器指令分为多个微操作命令,微操作命令即微命令,是微操作的控制信号。微操作是微命令的执行过程。
+ 微命令分为:
    + 相容性微命令:可以同时产生、共同完成某些微操作的微命令。
    + 互斥性微命令:在机器中不允许同时出现的微命令。
+ 对于相容性的微命令可以合并为一条微指令,而互斥性微命令只能单独为一条微指令。
+ 微指令是若干微命令的集合。微周期通常指从控制存储器中读取一条微指令并执行相应的微操作所需的时间。
+ 假设微指令的一个二进制位对应一个微操作命令,所有的微命令都合并为微指令,微指令再合并为一个微程序保存到$ROM$中,从而每一条机器指令对应一条微程序。
+ 微指令基本格式:
    + 操作控制:微操作码:产生控制信号。
    + 顺序控制:微地址码:产生下一条指令地址。
    + ![image-20230603213222529](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603213222529.png)
+ 每条指令取指周期的操作是相同的,所以将取指令操作的微命令统一编成一个微程序,而每条机器指令所对应的具体操作再单独编写一个对应的微程序。
+ 执行公用的取指微程序从主存中取出机器指令后,由机器指令的操作码字段指出各个微程序的入口地址（初始微地址）。

#### 微程序控制器结构

在控制单元$CU$内部:

![image-20230603214556204](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603214556204.png)

+ 存储器:

    + 主存储器用于存放程序和数据,在$CPU$外部,由$RAM$实现。

    + 控制存储器$CM(Control\;Memory)$用于存放微程序,在$CPU$内部,由$ROM$实现。
        + $ROM$非易失性,数据不会丢失即微程序由厂商设计且出厂前就会把微指令写好
        + 决定了$CPU$对指令集的支持和执行效率
        + 通过适当设计微指令和微程序,可以实现复杂的指令集和灵活的指令执行
        + $CM$的访问速度和容量对$CPU$性能和指令执行速度也有重要影响。


+ 寄存器:

    + 地址译码器:将地址码转换微存储单元控制信号。

    + 微地址寄存器$CMAR$(别名$\mu PC$):接收微地址形成部件送来的微地址,为在$CM$中读取微指令作准备。

    + 微指令寄存器$CMDR$(别名$\mu IR$):用于存放从$CM$中取出的微指令,它的位数同微指令字长相等。

    + 微地址形成部件:产生初始微地址和后继微地址,以保证微指令的连续执行。

    + 顺序逻辑单元:为了保证指令联系执行,控制形成下一条微指令,拥有一个标志位标识顺序执行还是跳转和一个时钟信号$CLK$。


控制流程:

1. 机器指令操作码$OP$送到微地址形成部件形成微地址。
2. 将初始微地址送到顺序逻辑单元,判断顺序执行还是跳转。
3. 送到$CMAR$保存微地址。
4. 将微地址从$CMAR$送到地址译码器中译码。
5. 形成控制单元后送到$CM$中取出微指令。
6. 将微指令送到$CMDR$中。
7. 根据微指令中的下一条指令地址送到顺序逻辑单元,判断顺序执行还是跳转。
8. 返回结果后$CMDR$送到$CPU$内部和系统总线,产生控制信号。

微程序个数:

+ 默认一条机器指令对应一个微程序。
    + 物理上,取指址周期、执行周期看起来像是两个微程序,但逻辑上应该把它们看作一个整体。因此,“一条指令对应一个微程序”的说法是正确的

+ 取指周期微程序默认是公共的（即单独拿出来公用）,故如果某指令系统中有$n$条机器指令,则$CM$中**微程序段**的个数至少是$n+1$个（加一个取指的公共微程序）。
    + 也可以说**微程序**的个数至少是$n$个

+ 间址周期微程序和中断周期微程序不一定是公共的。若公共的,如果这台计算机指令系统中有$n$条机器指令,则$CM$中**微程序**的个数是$n+3$个。若题目中没有提到间址,就不考虑间址,所以是$n+2$个。





#### 微指令格式

![image-20230603215903874](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603215903874.png)

1. 水平型微指令:
    + 一次能定义并执行多个并行操作。
    + 基本格式是:操作控制+判别测试+后继地址。
    + 优点:微程序短,执行速度快。
    + 缺点:操作控制字段比较长导致微指令长,编写微程序较麻烦。
2. 垂直型微指令:
    + 类似机器指令操作码的方式,由微操作码字段规定微指令的功能。一条指令对应一个操作。
    + 基本格式:微操作码+目的地址+源地址。
    + 优点:微操作码短导致微指令短、简单、规整,便于编写微程序。
    + 缺点:微程序长,执行速度慢,工作效率低。
3. 混合型微指令:
    + 在垂直型的基础上增加一些不太复杂的并行操作。
    + 微指令较短,仍便于编写。
    + 微程序也不长,执行速度加快。

水平型微指令的求法。

+ 操作控制:
    + 若是直接编码方式,则微命令数就是操作控制字段位数。
    + 若是字段直接编码方式,则会分$n$个组,每组$n_i$种状态,则总位数就是$\sum\limits_{i=1}^n\log_2(n_i+1)$（全$0$空出）。如$2,3,4$,则一共需要$2+2+3=7$位。
+ 判别测试:
    + 直接编码方式,有几个外部条件,就取几位。
    + 如果是字段直接编码,有$N$个外部条件就有$n$位,$2^n\geqslant N+1$,加$1$是因为还有无条件转移的情况。
+ 后继地址:
    + 求出前面两项后,直接根据微指令字长减去。
    + 根据$CM$的容量的前一项确认,$2^N\times M$容量就是$N$位。

#### 微指令编码

微指令的编码方式又称为微指令的控制方式,它是指如何对微指令的控制字段进行编码,以形成控制信号。编码的目标是在保证速度的情况下,尽量缩短微指令字长。

1. 直接编码（直接控制）方式:
    + 在微指令的操作控制字段中,每一位二进制位代表一个微操作命令。
    + 某位为“$1$”表示该控制信号有效,为$1$的指令同时执行；若“$0$”则代表此时该位指向的命令不运行。
    + 优点:简单、直观,执行速度快,操作并行性好。
    + 缺点:微指令字长过长,$n$个微命令就要求微指令的操作字段有$n$位,造成控存容量极大。
    + ![image-20230603220208151](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603220208151.png)
2. 字段直接编码方式:
    + 将微指令的控制字段分成若干“段”,每段经译码后发出控制信号。
    + 微命令字段分段的原则:
        1. 因为每组译码后可以通过每位$1\&0$的不同来让每组中的操作互斥,而不同组则很难完成互斥,所以**互斥性微命令分在同一段内**；因为命令在不同的组可以同时执行,所以**相容性微命令分在不同段内**。
            1. 例如$001\&011$是相容性微命令,可以并行发出,$001\&100$是互斥性微命令,不可以并行发出
        2. 每个小段中包含的信息位不能太多,否则将增加译码线路的复杂性和译码时间。
        3. 一般每个小段还要留出一个状态,表示本字段不发出任何微命令。因此,当某字段的长度为$3$位时,最多只能表示$7$个互斥的微命令,通常用$000$表示不操作。
    + 优点:可以缩短微指令字长。
    + 缺点:要通过译码电路后再发出微命令,因此比直接编码方式慢。
3. 字段间接编码方式:
    + 一个字段的某些微命令需由另一个字段中的某些微命令来解释(两层译码),由于不是靠字段直接译码发出的微命令,故称为字段间接编码,又称隐式编码。
    + 优点:可进一步缩短微指令字长。
    + 缺点:运行速度更慢；削弱了微指令的并行控制能力,故通常作为字段直接编码方式的辅助手段。

#### 微指令地址

1. 直接由微指令的**下地址字段**指出:微指令格式中设置一个下地址字段,由微指令的下地址字段直接指出后继微指令的地址,这种方式又称为**断定方式**。
2. 根据机器指令的**操作码**形成:当机器指令取至指令寄存器后,微指令的地址由操作码经微地址形成部件形成。
3. **增量计数器法**:$(CMAR)+1\rightarrow CMAR$,适用于指令**连续存放**的情况。
4. 分支转移:指令分为三个字段:
    1. 操作控制字段:指明操作控制类型。
    2. 转移方式:指明判别条件。
    3. 转移地址:指明转移成功后的去向。
5. 通过测试网络:一个测试网络产生。

![image-20230603221103255](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603221103255.png)

6. 由硬件产生微程序入口地址:
    + 第一条微指令地址:专门硬件产生。
    + 中断周期:硬件产生中断周期微程序首地址。

#### 微程序控制单元设计

设计步骤:

1. 分析每个阶段的微操作序列。
2. 写出对应机器指令的微操作命令及节拍安排:
    1. 写出每个周期所需要的微操作（参照硬布线）。
    2. 补充微程序控制器特有的微操作:
        + 取指周期:$Ad(CMDR)\rightarrow CMAR$；$OP(IR)\rightarrow CMAR$。
        + 执行周期:$Ad(CMDR)\rightarrow CMAR$。
3. 确定微指令格式:
    + 根据微操作个数决定采用何种编码方式,以确定微指令的操作控制字段的位数。
    + 由微指令数确定微指令的顺序控制字段的位数。
    + 最后按操作控制字段位数和顺序控制字段位数就可确定微指令字长。
4. 编写微指令码点:根据操作控制字段每一位代表的微操作命令,编写每一条微指令的码点。

| 节拍安排 | 取指周期-硬布线控制器的节拍安排 | 取指周期-微程序控制器的节拍安排 |
| :------: | :-----------------------------: | :-----------------------------: |
|    T0    |             PC→MAR              |             PC→MAR              |
|    T0    |               1→R               |               1→R               |
|    T1    |           M(MAR)→MDR            |           M(MAR)→MDR            |
|    T1    |            (PC)+1→PC            |            (PC)+1→PC            |
|    T2    |             MDR→IR              |             MDR→IR              |
|    T2    |            OP(IR)→ID            |      OP(IR)→微地址形成部件      |

根据读出转入微指令的过程,变为:

| 节拍安排 | 取指周期-硬布线控制器的节拍安排 | 取指周期-微程序控制器的节拍安排 |
| :------: | :-----------------------------: | :-----------------------------: |
|    T0    |             PC→MAR              |             PC→MAR              |
|    T0    |               1→R               |               1→R               |
|    T1    |           M(MAR)→MDR            |          Ad(CMDR)→CMAR          |
|    T1    |            (PC)+1→PC            |                                 |
|    T2    |             MDR→IR              |           M(MAR)→MDR            |
|    T2    |            OP(IR)→ID            |            (PC)+1→PC            |
|    T3    |                                 |          Ad(CMDR)→CMAR          |
|    T4    |                                 |             MDR→IR              |
|    T4    |                                 |      OP(IR)→微地址形成部件      |

#### 硬布线与微程序

| 对比项目\类别 |                         微程序控制器                         |                         硬布线控制器                         |
| :-----------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   工作原理    | 微操作控制信号以微程序的形式存放在控制存储器中,执行指令时读出即可 | 微操作控制信号由组合逻辑电路根据当前的指令码、状态和时序,即时产生 |
|   执行速度    |                    慢（从CM中读取微指令）                    |                              快                              |
|    规整性     |                            较规整                            |                         烦琐、不规整                         |
|   应用场合    |                           CISC CPU                           |                           RISC CPU                           |
|   易扩充性    |                          易扩充修改                          |                             困难                             |

#### 微程序设计分类

+ 静态微程序设计:无需改变,采用$ROM$。
+ 动态微程序设计动态通过改变微指令和微程序改变机器指令,有利于仿真,采用$EPROM$。
+ 毫微程序设计:微程序设计用微程序解种机器指令,毫微程序设计用毫微程序解释微程序。

## 指令流水线

### 流水线基本概念

#### 指令流水线定义

一条指令大致分为取指(取指令)、分析、执行三个阶段（或者取指$IF$、译码/读寄存器$ID$、执行/计算地址$EX$、访存$MEM$、结果写回寄存器$WB$）

+ 取指:根据PC内容访问主存储器,取出一条指令送到R中。
+ 分析:对指令操作码进行译码,按照给定的寻址方式和地址字段中的内容形成操作数的有效地址EA,并从有效地址EA中取出操作数。
+ 执行:根据操作码字段,完成指令规定的功能,即把运算结果写到通用寄存器或主存中。

设三个阶段时间相等且   都为$t$,一共有$n$条指令:

1. 顺序执行:
    + 顺序执行所有指令。
    + 总耗时$3nt$。
    + 传统冯·诺依曼机采用顺序执行方式,又称串行执行方式。
    + 优点:控制简单,硬件代价小。
    + 缺点:执行指令的速度较慢,在任何时刻,处理机中只有一个指令在指令,各功能部件利用率都很低。
    + ![image-20230603221536498](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603221536498.png)
2. 一次重叠执行方式:
    + 在执行第$k$条指令的同时取第$k+1$条指令。
    + 总耗时$(1+2n)t$。
    + 优点:程序的执行时间缩短了$1/3$,各功能部件的利用率明患提高。
    + 缺点:需要付出硬件上较大开销的代价控制过程也比顺件执行复杂了。
    + ![image-20230603221715427](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603221715427.png)
3. 二次重叠执行方式:
    + 分析第$k$条指令的同时取$k+1$条指令,执行$k$条指令时分析$k+1$条指令与取$k+2$条指令。
    + 总耗时$(2+n)t$。
    + 与顺序执行方式相比,指令的执行时间缩短近$2/3$。
    + 这是一种理想的指令执行方式,处理机中同时有$3$条指令在执行。
    + ![image-20230603221758315](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603221758315.png)
4. 指令流水方式:多次重叠执行方式就是流水线方式。

#### 流水线表示

1. 指令执行过程图:

    + 横坐标为时间,纵坐标为指令序列。
    + 每一行就是一条指令序列。
    + 主要用于分析指令执行过程以及影响流水线的因素。

    ![image-20230603222006424](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603222006424.png)

2. 时空图:

    + 横坐标为时间,纵坐标为空间,即不同的阶段所对应的不同硬件资源,如:取指、译码、执行、存结果。
    + 每一斜着的一列就是一条指令序列。
    + 主要用于分析流水线的性能。

    ![image-20230603221919024](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603221919024.png)



#### 流水线的性能指标

1. 吞吐率:
    + 指在单位时间内流水线所完成的任务数量,或是输出结果的数量。
    + 设任务数为$n$,处理完成$n$个任务所用的时间为$T_k$,则计算流水线吞吐率$TP$的最基本的公式为$TP=\dfrac{n}{T_k}$。
    + 在最理想情况下:
        + 令每个指令分为$k$个阶段,每个阶段所需时间为$\Delta t$一般等于一个时钟周期,则$T_k=(k+n-1)\Delta t$,所以$TP=\dfrac{n}{(k+n-1)\Delta t}$。
            + 在最理想情况下取一个机器周期=一个时钟周期
            + 当连续输入的任务$n\to \infty$时,得最大吞吐率为$TP_{max}=\frac{1}{\Delta t}$
    + 第一个指令执行阶段称为装入时间,最后一个指令执行的阶段称为排空时间。
    + ![image-20230603222647289](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603222647289.png)
2. 加速比:
    + 完成同样一批任务,不使用流水线所用的时间与使用流水线所用的时间之比。
    + 在最理想情况下:
        + 设$T_0$表示不使用流水线时的执行时间,即顺序执行所用的时间；$T_k$表示使用流水线时的执行时间,则计算流水线加速比$S$的基本公式为$S=\dfrac{T_0}{T_k}$。
        + 单独完成一个任务需要$k\Delta t$,则顺序完成时间$T_0=nk\Delta t$。又$T_k=(k+n-1)\Delta t$,所以$S=\dfrac{nk\Delta t}{(k+n-1)\Delta t}=\dfrac{kn}{k+n-1}$。
            + 当连续输入的任务$n\to \infty$时,得最大加速比为$S_{max}=k$

![image-20230603222919889](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603222919889.png)

3. 效率:

    + 流水线的设备利用率称为流水线的效率。

    + 在时空图上,流水线的效率定义为完成$n$个任务占用的时空区有效面积与$n$个任务所用的时间与k个流水段所围成的时空区总面积之比。（时空图中用到的类平行四边形面积除以围成矩形的面积）。

    + 流水线效率$E$的基本公式为$E=\dfrac{T_0}{kT_k}=\dfrac{n}{k+n-1}$。
        + 当连续输入的任务$n\to \infty$时,得最大效率为$E_{max}=1$
    + ![image-20230603223135052](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603223135052.png)

#### 指令集要求

1. 指令长度一致。
2. 指令格式规整,保证源寄存器位置相同。
3. 让$Load/Store$指令唯一访问存储器。
4. 数据和指令在存储器种对齐存放。

### 流水线影响因素

+ 理想情况:各阶段花费时间相同,每个阶段结束后能立即进入下一阶段。
+ 机器周期一般分为五段:取指$IF$、译码$ID$、执行$EX$、访存$M$、写回$WB$。
+ 假如各部件实际耗时:$100ns$、$80ns$、$70ns$、$50ns$、$50ns$,为方便流水线的设计,将每个阶段的耗时取成一样,以**最长耗时**为准。即此处应将机器周期设置为$100ns$。
+ 流水线每一个功能段部件后面都要有一个缓冲寄存器,或称为**锁存器**,其作用是保存本流水段的执行结果,提供给下一流水段使用。

![image-20230603223645213](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603223645213.png)

+ $CISC $中$ID$中数据来源于寄存器
+ $ID$中读和$WB$中写可能存在冲突

#### 结构相关（资源冲突）—互斥问题

![image-20230603224708919](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603224708919.png)

+ 由于多条指令在同一时刻争用同一资源而形成的冲突称为结构相关。
+ 解决办法:
    1. 后一相关指令暂停一周期。
    2. 单独设置数据存储器和指令寄存器。
        1. ![image-20230603224807896](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603224807896.png)

#### 数据相关（数据冲突）—同步问题

![image-20230603224851784](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603224851784.png)

+ 数据相关指在一个程序中,存在必须等前一条指令执行完才能执行后一条指令的情况,则这两条指令即为数据相关。
+ 数据的基本操作:读、写。
+ 冲突的基本类型:
    + 写后读$RAW$:没有写完就读取,按序发射,按序完成只会出现写后读的错误。
    + 读后写$WAR$:乱序发射,优化手段导致指令顺序不符合编写程序时预想的逻辑顺序。
    + 写后写$WAW$:存在多个功能部件时,后一条指令先于前一条指令完成。
+ 解决办法:
    1. 把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期,直到数据相关问题消失后再继续执行。可分为硬件阻塞（$stall$）和软件插入“$NOP$”（空指令）两种方法。
        + 每个空指令也有完整的五个阶段
        + ![image-20230603225205192](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603225205192.png)
    2. 数据旁路技术:计算得到结果后不写回,直接当作输入使用。
        + ![image-20230603225324884](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603225324884.png)
    3. 编译优化:通过编译器调整指令顺序来解决数据相关。
        + 后续指令不依赖之前的计算结果时提前执行

#### 控制相关（控制冲突）

![image-20230603225534316](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603225534316.png)

+ 当流水线遇到转移指令和其他改变$PC$值的指令而造成断流时,会引起控制相关。
+ 主要针对转移指令。
+ 解决办法:
    1. 分支预测,尽早判别转移是否发生,尽早生成转移目标地址。
        1. 简单预测:永远猜$True$或$False$
        2. 动态预测:根据历史情况动态调整
    2. 预取转移成功和不成功两个控制流方向上的目标指令。
    3. 加快和提前形成条件码。
    4. 提高转移方向的猜准率。

### 流水线分类

+ 根据流水线使用的级别的不同：
    + **部件功能级流水线**就是将复杂的算术逻辑运算组成流水线工作方式。例如，可将浮点加法操作分成求阶差、对阶、尾数相加以及结果规格化等4个子过程。
    + **处理机级流水线**是把一条指令解释过程分成多个子过程，如前面提到的取指、译码、执行、访存及写回$5$个子过程。
    + **处理机间流水线**是一种流水线，其中每一个处理机完成某一专门任务，各个处理机所得到的结果需存放在与下一个处理机所共享的存储器中。
+ 按流水线可以完成的功能：
    + **单功能流水线**指只能实现一种固定的专门功能的流水线。
    + **多功能流水线**指通过各段间的不同连接方式可以同时或不同时地实现多种功能的流水线。
+ 按同一时间内各段之间的连接方式：
    + **静态流水线**指在同一时间内，流水线的各段只能按同一种功能的连接方式工作。
    + **动态流水线**指在同一时间内，当某些段正在实现某种运算时，另一些段却正在进行另一种运算。这样对提高流水线的效率很有好处，但会使流水线控制变得很复杂。
+ 按流水线的各个功能段之间是否有反馈信息：
    + **线性流水线**中，从输入到输出，每个功能段只允许经过一次，不存在反馈回路。
    + **非线性流水线**存在反馈回路，从输入到输出过程中，某些功能段将数次通过流水线，这种流水线适合进行线性递归的运算。

### 流水线多发

1. 超标量技术：
    + 每个时钟周期内可并发多条独立指令。
    + 要配置多个功能部件。
    + 不能调整指令的执行顺序。
    + 可以结合动态调度技术优化。
    + ![image-20230603230212709](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603230212709.png)
2. 超流水技术：
    + 在一个时钟周期内再分段。
    + 在一个时钟周期内单个功能部件使用多次。
    + 不能调整指令的执行顺序，靠编译来优化。
    + ![image-20230603230251081](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603230251081.png)
3. 超长指令字：
    + 由**编译程序**挖掘出指令间**潜在**的并行性，将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字(可达几百位)。
    + 需要更大的$Cache$。
    + ![image-20230603230302644](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603230302644.png)

## 多处理器

### 指令数据流结构

#### SISD

+ 单指令流和单数据流系统，即传统冯·诺依曼体系结构。
+ 只有一个处理器和存储器，一次性只执行一条指令。
+ 使用流水线技术，所以设置多个功能部件，采用多模块交叉存储器。

#### SIMD

+ 单指令流和多数据流系统。同时对多个数据进行处理，一般称为数据级并行技术。
+ 有一个指令控制部件和多个处理单元。
+ 每个处理单元有自己的地址寄存器。
+ 一个顺序程序被编译后可能串行也可能并行。
+ 适合循环结构，不适合选择结构。
+ 包括阵列处理器和向量处理器系统。向量处理器系统是一种实现了直接操作一维数组（向量）指令集的$CPU$，而串行处理器只能处理单一数据集。其基本理念是将从存储器中收集的一组数据按顺序放到一组向量寄存器中，然后以流水化的方式对它们依次操作，最后将结果写回寄存器。向量处理器在特定工作环境中极大地提升了性能，尤其是在数值模拟或者相似的领域中。

#### MISD

多指令流和单数据流系统，这种计算机**实际上不存在**。

#### MIMD

+ 多指令流和多数据流系统，是一种并行程度更高的线程级并行或线程级以上并行计算模式。
+ 包括多处理器和多计算机系统。
+ 多计算机系统中的每个计算机节点都具有各自的私有存储器，并且具有独立的主存地址空间，不能通过存取指令来访问不同节点的私有存储器，而要通过消息传递进行数据传送，也称消息传递$MIMD$。
+ 多处理器系统是共享存储多处理器（$SMP$）系统的简称，它具有共享的单一地址空间，通过存取指令来访问系统中的所有存储器，也称共享存储$MIMD$。

### 硬件多线程

为减少线程切换的开销，产生硬件多线程。在支持便件多线程的$CPU$中，必须为每个线程提供单独的通用寄存器组、单独的程序计数器等，线程的切换只需激活选中的寄存器，从而省略了与存储器数据交换的环节。

#### 细粒度多线程

多个线程之间轮流交叉执行指令，多个线程之间的指令是不相关的，可以乱序并行执行。

在这种方式下，处理器能在每个时钟周期切换线程。

| 时钟 | 当前执行指令所属线程 |
| :--: | :------------------: |
|  1   |          A           |
|  2   |          B           |
|  3   |          A           |
|  4   |          C           |
|  5   |          B           |

#### 粗粒度多线程

仅在一个线程出现了较大开销的阻塞时，才切换线程，如$Cache$缺失。

在这种方式下，当发生流水线阻塞时，必须清除被阻塞的流水线，新线程的指令开始执行前需要重载流水线，因此，线程切换的开销比细粒度多线程更大。

| 时钟 | 当前执行指令所属线程 |
| :--: | :------------------: |
|  1   |          A           |
|  2   |          A           |
|  3   |          B           |
|  4   |          B           |
|  5   |          C           |

#### 同时多线程

同时多线程（$SMT$）是上述两种多线程技术的变体。它在实现指令级并行的同时，实现线程级并行，也就是说，它在同一个时钟周期中，发射多个不同线程中的多条指令执行。

| 时钟 | 当前执行指令所属线程 |
| :--: | :------------------: |
|  1   |          AB          |
|  2   |          AC          |
|  3   |          BC          |

### 多核处理器

+ 多核处理器是指将多个处理单元集成到单个$CPU$中，每个处理单元称为一个核，可以同时执行多个运算。
+ 每个核可以有自己的$Cache$，也可以共享同一个$Cache$。
+ 所有核一般都是对称的，并且共享主存储器，因此多核属于共享存储的对称多处理器。

### 共享内存多处理器

具有共享的单一物理地址空间的多处理器被称为共享内存多处理器（$SMP$）。处理器通过存储器中的共享变量互相通信，所有处理器都能通过存取指今访向任何存储器的位置。

注意，即使这些系统共享同一个物理地址空间，它们仍然可在自己的虚拟地址空间中单独地运行程序。

+ 统一存储访问（$UMA$）多处理器：
    + 每个处理器对所有存储单元的访问时间是大致相同的，即访问时间与哪个处理器提出访存请求及访问哪个字无关。
    + 根据处理器与共享存储器之间的连接方式，分为基于总线、基于交叉开关网络和基于多级交换网络连接等几种处理器。
    + 需要解决$Cache$一致性问题。
+ 非统一存储访问（$NUMA$）多处理器：
    + 某些访存请求要比其他的快，具体取决于哪个处理器提出了访问请求以及访问哪个字，这是由于主存被分割并分配给了同一机器上的不同处理器或内存控制器。
    + 处理器中不带高速缓存时，被称为$NC-NUMA$；处理器中带有一致性高速缓存时，被称为$CC-NUMA$。
    + 拓展性更强。





# 第六章 总线

## 导读

### 【考纲内容】

1. 总线的基本概念
2. 总线的组成及性能指标
3. 总线事务和定时

### 【知识导图】

![img](http://res.ptpress.cn/D816F5B9C6F14DE1A3A63D36339CF2B5.png)

![img](http://res.ptpress.cn/DD257E2C470D4EA5A18F65A6A02387F8.png)

![img](http://res.ptpress.cn/F62DE87767674434B8F93C22BF83602A.png)

![image-20230603100034995](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603100034995.png)







### 【复习提示】

本章的知识点较少,通常以选择题的形式出现,特别是总线的特点、猝发传输方式、性能指标、定时方式及常见的总线标准等。总线带宽的计算也可能结合其他章节出综合题。

在学习本章时,请读者思考以下问题;

1) 引入总线结构有什么好处?

2) 引入总线结构会导致什么问题? 如何解决?

## 总线概述

### 总线基本定义

![image-20230604092021861](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230604092021861.png)

+ 总线是一组能为多个部件**分时共享**的公共信息传送线路。是总线复用方式。
    + 共享是指总线上可以挂接多个部件,各个部件之间互相交换的信息都可以通过这组线路分时共享。
    + 分时是指同一时刻只允许有一个部件向总线发送信息,如果系统中有多个部件,则它们只能分时地向总线发送信息。

+ 早期计算机外部设备少时大多采用分散连接方式,不易实现随时增减外部设备。为了更好地解决$I/O$设备和主机之间连接的灵活性问题,计算机的结构从分散连接发展为总线连接。
+ 总线特性：
    1. 机械特性：尺寸、形状、管脚数、排列顺序。
    2. 电气特性：传输方向和有效的电平范围。
    3. 功能特性：每根传输线的功能（地址、数据、控制）。
    4. 时间特性：信号的时序关系

### 总线分类

+ 数据传输格式：
    + 串行总线：
        + 串行总线中，数据位依次串行发送和接收，通过一条物理线路传输。每个数据位都在时钟信号的控制下被逐位传输，形成连续的数据流。
        + 优点：只需要一条传输线,成本低廉,广泛应用于长距离传输；应用于计算机内部时,可以节省布线空间。
        + 缺点：在数据发送和接收的时候要进行拆卸和装配,要考虑串行并行转换的问题。
    + 并行总线：
        + 在并行总线中，数据位按照字节或字的方式并行发送和接收，需要多个物理线路进行传输。每个数据位都有独立的线路进行传输，因此可以实现高带宽的数据传输。
        + 优点：总线的逻辑时序比较简单,电路实现起来比较容易。
        + 缺点：信号线数量多,占用更多的布线空间;远距离传输成本高昂；由于工作频率较高时,并行的信号线之间会产生严重电磁影响导致无法使用,对每条线等长的要求也越来越高,所以无法持续提升工作频率。
            + 由于并行总线可能产生电磁影响,串行总线则没有,并行总线不一定比串行总线快
+ 总线功能（连接部件）：
    + 片内总线：片内总线是芯片内部的总线。
        它是$CPU$芯片内部寄存器与寄存器之间、寄存器与$ALU$之间的公共连接线。
    + 系统总线：系统总线是计算机系统内各功能部件（$CPU$、主存、$I/O$接口）之间相互连接的总线。按系统总线传输信息内容的不同,又可分为：
        + 数据总线$DB$：传输各功能部件之间的数据信息,包括指令和操作数；位数（根数）与机器字长、存储字长有关；双向。
            + 数据总线的主要功能是在内存、寄存器、输入输出设备和其他组件之间传输数据。
        + 地址总线$AB$：传输地址信息,包括主存单元或$I/O$端口的地址；位数（根数与主存地址大小及设备数量有关）；单向。
            + 地址总线的主要功能是将CPU发出的读取或写入操作的目标地址传递给内存或外设。
        + 控制总线$CB$：传输控制信息；一根控制线传输一个信号；有出：$CPU$送出的控制命令；有入：主存（或外设）返回$CPU$的反馈信号。
            + 控制总线的主要功能是在计算机系统中传递各种控制信息，协调各个组件的操作。
    + 通信总线：通信总线是用于计算机系统之间或计算机系统与其他系统（如远程通信设备、测试设备）之间信息传送的总线,通信总线也称为外部总线。
+ 时序控制方式：
    + 同步总线。
    + 异步总线。

### 总线结构

+ 单总线结构：

    + ![image-20230604093146814](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230604093146814.png)
    + $CPU$、主存、$I/O$设备（通过$I/O$接口）都连接在一组总线上,允许$I/O$设备之间、$I/O$设备和$CPU$之间或$I/O$设备与主存之间直接交换信息。
    + 单总线并不是指只有一根信号线,系统总线按传送信息的不同可以细分为地址总线、数据总线和控制总线。
    + 优点：结构简单,成本低,易于接入新的设备。
    + 缺点：带宽低、负载重,多个部件只能争用唯一的总线,且不支持并行传输操作。

+ 双总线结构：

    + ![image-20230604093211385](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230604093211385.png)
    + 双总线结构有两条总线,一条是主存总线,用于$CPU$、主存和通道之间进行数据传送；另一条是$I/O$总线（因为$I/O$速度较慢）,用于多个外部设备与通道之间进行数据传送。
    + 通道是具有特殊功能的处理器,能对$I/O$设备进行统一管理。通道程序放在主存中。
        + 双总线结构中的通道通常包括两个主要的通道：
            + **数据通道（$Data Channel$）**：数据通道用于传输数据信息。它是一个双向通道，用于在$CPU$和主存储器之间传输数据。当$CPU$需要从主存储器读取数据时，数据通道将数据从主存储器传输到$CPU$；当$CPU$需要将数据写入主存储器时，数据通道将数据从$CPU$传输到主存储器。数据通道通常是宽度与数据总线相匹配的并行通道，可以同时传输多个数据位。
            + **地址通道（Address Channel）**：地址通道用于传输内存地址信息。它是一个单向通道，用于将$CPU$发出的读写操作的目标地址传递给主存储器。当$CPU$需要读取或写入特定内存位置时，地址通道将相应的地址信息传输给主存储器。地址通道的宽度由地址总线决定，决定了$CPU$可以寻址的内存空间大小。
    + 支持突发（猝发）传送：送出一个地址,收到多个**地址连续**的数据。
    + 优点：将较低速的$I/O$设备从单总线上分离出来,实现存储器总线和$I/O$总线分离。
    + 缺点：需要增加通道等硬件设备。

+ 三总线结构：

    + ![image-20230604093407364](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230604093407364.png)
    + 三总线结构是在计算机系统各部件之间采用三条各自独立的总线来构成信息通路,分别为：
        + 主存总线：$CPU$和主存之间的连接。
        + $I/O$总线：$CPU$和$I/O$接口之间连接。
        + $DMA$总线：$Direct\,Memory\,Access$,直接内存访问,连接外设与主存。能直接连接主存的就是**高速外设**,如磁盘机,而无法直接连接主存的就是低速外设,如打印机和显示器。
            + $DMA$总线允许外部设备（如硬盘、网络接口卡等）直接访问系统内存，而无需通过中央处理器（$CPU$）的干预。这种直接访问方式可以显著提高数据传输的效率，减少$CPU$的负载。$DMA$总线通常是一个独立的通道，与$CPU$的数据总线和地址总线是分离的。
    + 优点：提高了$I/O$设备的性能,使其更快地响应命令,提高系统吞吐量。
    + 缺点：系统工作效率较低。

+ 四总线结构(考试不考,但这才是现代常用的结构)：

    + ![image-20230604093645813](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230604093645813.png)

    + 四总线结构一共四条总线：

        + $CPU$总线（局部总线）：$CPU$与$Cache$。
        + 系统总线：$CPU$和主存。
        + 高速总线：连接$SCSI$、图形、多媒体、局域网。
        + 扩充总线（扩展总线型）：连接传真机、扩展总线接口、调制解调器、串行接口。

    + 桥接器：桥接器（$Bridge$）是用于连接不同类型总线的关键组件。它的主要作用是在不同的总线之间进行数据缓冲和控制信号的转换和传递，以实现不同总线系统的互联互通。

        + 桥接器通常用于连接以下两种类型的总线：

            1. **前端总线（Front-Side Bus，FSB）**：前端总线是与中央处理器（CPU）直接连接的总线，用于与CPU进行通信。它是高速的并行总线，负责传输数据、地址和控制信号。桥接器的一个端口与前端总线相连接，可以接收来自CPU的数据和指令，同时将数据和指令传递给后面的总线。
            2. **后端总线（Back-Side Bus，BSB）**：后端总线是与主存储器（Memory）和其他外部设备连接的总线，用于与这些设备进行数据传输。后端总线的特点可能与前端总线不同，如宽度、速度或协议等方面的差异。桥接器的另一个端口与后端总线相连接，可以接收来自后端总线的数据和指令，同时将数据和指令传递给前面的总线。
        + 桥接器的功能包括：

            1. **地址转换**：桥接器可以将来自前端总线的内存地址转换为适用于后端总线的地址格式。这涉及到地址映射和地址重定向等操作，确保正确地访问目标设备。
            2. **数据传输**：桥接器负责在前端总线和后端总线之间进行数据传输。它接收来自前端总线的读取或写入请求，并将数据传递给后端总线相应的设备。反之，它也接收来自后端总线的数据，并将其传输到前端总线供CPU使用。
            3. **控制信号转发**：桥接器将来自前端总线的控制信号转发到后端总线，以启动相应的操作。同时，它也将来自后端总线的控制信号转发到前端总线，以通知CPU或其他相关设备。

    + 越靠近$CPU$总线速度越快,$CPU$总线>系统总线>高速总线>扩充总线。

    + 每级总线的设计遵循总线标准。

### 性能指标

#### 传输周期

也称为总线周期。**一次总线操作所需的时间**（包括申请阶段、寻址阶段、传输阶段和结束阶段），大多数时候由若干个总线时钟周期构成。

申请阶段:总线的申请阶段是指在计算机系统中，设备或组件请求使用总线进行数据传输或访问共享资源的过程。在这个阶段，设备向总线控制器发送请求，请求获得对总线的控制权。

#### 时钟周期

即机器的时钟周期。计算机有一个统一的时钟，以控制整个计算机的各个部件，总线也要受此时钟的控制。

现在的计算机中，总线时钟周期也有可能由桥接器提供

总线周期与总线时钟周期的关系:

+ 大多数情况下，一个总线周期包含多个总线时钟周期
+ 有的时候，一个总线周期就是一个总线时钟周期
+ 有的时候，一个总线时钟周期可包多个总线周期
    + 例如总线分别在一个总线时钟周期的上升沿下降沿进行数据传输

#### 工作频率

总线上各种操作的频率，为总线周期的倒数。

若总线周期=$N$个时钟周期，则总线的工作频率=时钟频率$\div N$。

#### 时钟频率

即机器的时钟频率，为时钟周期的倒数。若时钟周期为$T$，则时钟频率为$1/T$。

实际上指一秒内有多少个时钟周期。

#### 总线宽度

又称为总线位宽，它是总线上同时能够传输的数据位数，通常是指**数据总线**的根数，如$32$根称为$32$位（$bit$）总线。

#### 总线带宽

可理解为总线的**数据传输率**，即单位时间内总线上可传输数据的位数，通常用每秒钟传送信息的字节数来衡量，单位可用字节/秒（$B/s$）表示。

总线带宽=总线工作频率×总线宽度（$bit/s$）=总线工作频率×(总线宽度$\div8$)（$B/s$）=总线宽度÷总线周期（$bit/s$）=总线宽度$\div8\div$总线周期（$B/s$）。

总线带宽是指总线本身所能达到的**最高传输速率**。

在计算实际的有效数据传输率时，要用实际传输的数据量除以耗时。

#### 总线复用

总线复用是指一种信号线在不同的时间传输不同的信息。可以使用较少的线传输更多的信息，从而节省了空间和成本。

#### 信号线数

地址总线、数据总线和控制总线三种总线数的总和称为信号线数。

## 总线仲裁(不考,了解)

### 总线仲裁基本概念

+ 解决多个设备争用总线的问题。
+ 同一时刻只能有一个设备控制总线传输操作，可以有一个或多个设备从总线接收数据
+ 将总线上所连接的各类设备按其对总线有无控制功能分为：
    + 主设备：获得总线控制权的设备。
    + 从设备：被主设备访问的设备，只能响应从主设备发来的各种总线命令。
+ 总线仲裁原因：
    + 总线作为一种共享设备，不可避免地会出现同一时刻有多个主设备竞争总线控制权的问题。
+ 总线仲裁的定义：多个主设备同时竞争总线控制权时，以某种方式选择一个主设备优先获得总线控制权称为总线仲裁。

### 总线控制流程

+ 在总线控制中，申请使用总线的设备向总线控制器发出**总线请求**，由总线控制器进行裁决。
+ 若经裁决允许该设备使用总线，就由总线控制器向该设备发出**总线允许**信号。
+ 该设备收到信号后发出**总线忙**信号，通知其他设备总线已被占用。
+ 该设备使用完总线时，将**总线忙**信号撤销，释放总线。

### 总线仲裁分类

+ 集中仲裁方式：
    + “总线忙”信号的建立者是获得总线控制权的设备。
    + 工作流程：
        1. 主设备发出请求信号。
        2. 若多个主设备同时要使用总线，则由总线控制器的判优、仲裁逻辑按一定的优先等级顺序确定哪个主设备能使用总线。
        3. 获得总线使用权的主设备开始传送数据。
    + 链式查询方式。
    + 计数器定时查询方式。
    + 独立请求方式。
+ 分布仲裁方式

#### 链式查询方式

+ 总线与控制线：
    + 数据线。
    + 地址线。
    + 控制线：
        + $BG$：总线允许（响应），$1$条。
        + $BR$：总线请求，$1$条。
        + $BS$：总线忙，$1$条。
+ 流程：
    + 总线上所有的部件共用一根总线请求线，当有部件请求使用总线时，需经此线发总线请求信号到总线控制器。
    + 由总线控制器检查总线是否忙，若总线不忙，则立即发总线响应信号，经总线响应线$BG$串行地从一个部件传送到下一个部件，依次查询。
    + 若响应信号到达的部件无总线请求，则该信号立即传送到下一个部件；若响应信号到达的部件有总线请求，则信号被截住，不再传下去。
+ 优先级：离总线控制器越近的部件，其优先级越高，离总线控制器越远的部件，其优先级越低。
+ 优点：链式查询方式优先级固定。只需很少几根控制线就能按一定优先次序实现总线控制，结构简单，扩充容易。
+ 缺点：
    + 对硬件电路的故障敏感。
    + 优先级不能改变。
    + 容易发生饥饿，当优先级高的部件频繁请求使用总线时，会使优先级较低的部件长期不能使用总线。

#### 计数器定时查询方式

+ 总线与控制线：
    + 数据线。
    + 地址线。
    + 设备地址线。
    + 控制线：
        + 设备地址线：传输设备地址，$\lceil\log_2n\rceil$条。
        + $BR$：总线请求，$1$条。
        + $BS$：总线忙，$1$条。
        + 若设备有$n$个，则需要$\lceil\log_2n\rceil+2$条控制线。（还有$BS$、$BR$）
+ 结构特点：用一个计数器控制总线使用权，相对链式查询方式多了一组设备地址线，少了一根总线响应线$BG$；它仍共用一根总线请求线。**不需要总线允许**信号。
+ 过程：
    + 当总线控制器收到总线请求信号，判断总线空闲时，计数器开始计数，计数值通过设备地址线发向各个部件。
    + 当地址线上的计数值与请求使用总线设备的地址一致时，该设备获得总线控制权。
    + 同时，中止计数器的计数及查询。
+ 优点：
    + 计数初始值可以改变优次序：
        + 计数每次从“$0$”开始，设各的优先级就按顺序排列，固定不变。
        + 计数从上一次的终点开始，此时设备使用总线的优先级相等。
        + 计数器的初值还可以由程序设置。
    + 对电路的故障没有链式敏感。
+ 缺点:
    + 增加了控制线数。
    + 控制相对比链式查询相对复杂。

#### 独立请求方式

+ 总线与控制线：
    + 数据线。
    + 地址线。
    + 控制线：
        + $BG$：总线允许，$n$条。
        + $BR$：总线请求，$n$条。
        + $BS$：总线忙，$1$条。
        + 若设备有$n$个，则需要$2n+1$条控制线。其中$+1$为$BS$线，用于设备向总线控制部件反馈已经使用完毕总线。
+ 结构特点：每一个设备均有一对总线请求线$BR_i$和总线允许线$BG_i$。由排队器控制优先级。
+ 过程：
    + 当总线上的部件需要使用总线时，经各自的总线请求线发送总线请求信号，在总线控制器中排队。
    + 当总线控制器按一定的优先次序决定批准某个部件的请求时，则给该部件发送总线响应信号。
+ 优点：
    + 响应速度快，总线允许信号$BG$直接从控制器发送到有关设备，不必在设备间传递或者查询。
    + 对优先次序的控制相当灵活。
+ 缺点：
    + 控制线数量多。
    + 总线的控制逻辑更加复杂。

#### 分布仲裁方式

+ 特点：不需要中央仲裁器，每个潜在的主模块都有自己的仲裁器和仲裁号，多个仲裁器竞争使用总线。
+ 过程：
    + 当设备有总线请求时，它们就把各自唯一的仲裁号发送到共享的仲裁总线上。
    + 每个仲裁器将从仲裁总线上得到的仲裁号与自己的仲裁号进行比较。
    + 如果仲裁总线上的号优先级高，则它的总线请求不予响应，并撤销它的仲裁号。
    + 最后，获胜者的仲裁号保留在仲裁总线上。

+ 1. 信息相符合的输入设备按命令进行一系列的内部操作，且必须在$T_3$的上升沿来之前将$CPU$所需的数据送到数据总线上。
      2. 执行：$CPU$在$T_3$时钟周期内，将数据线上的信息传送到其内部寄存器电中。
      3. 撤销：$CPU$在$T_4$的上升沿撤销读命令，输入设备不再向数据总线上传送数据，撤销它对数据总线的驱动。
+ 优点：
    + 传送速度快，具有较高的传输速率。
    + 总线控制逻辑简单。
+ 缺点：
    + 主从设备属于强制性同步。
    + 不能及时进行数据通信的有效性检验，可靠性较差。
+ 同步通信适用于总线长度较短及总线所接部件的存取时间比较接近的系统。

## 总线操作与定时

占用总线的一对设备进行数据传输的方法。

### 总线传输阶段

1. 申请分配阶段：由需要使用总线的主模块（或主设备）提出申请，经总线仲裁机构决定将下一传输周期的总线使用权授予某一申请者。也可将此阶段细分为传输请求和总线仲裁两个阶段。
2. 寻址阶段：获得使用权的主模块通过总线发出本次要访问的从模块的**地址**及有关**命令**，启动参与本次传输的从模块。
3. 传输阶段：主模块和从模块进行数据交换，可单向或双向进行数据传送。
4. 结束阶段：主模块的有关信息均从系统总线上撤除，让出总线使用权。

### 总线定时

总线定时是指总线在双方交换数据的过程中需要时间上配合关系的控制，这种控制称为总线定时，它的实质是一种协议或规则。

#### 同步定时方式

![image-20230604100439520](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230604100439520.png)

+ 也称为同步通信。
+ 系统采用一个统一的时钟信号来协调发送和接收双方的传送定时关系。
+ 时钟产生相等的时间间隔，每个间隔构成一个总线周期。
+ 在一个总线周期中，发送方和接收方可进行一次数据传送。
+ 因为采用统一的时钟，每个部件或设备发送或接收信息都在固定的总线传送周期中，一个总线的传送周期结束，下一个总线传送周期开始。
+ 上升沿：数字电平从$0$变为$1$的一瞬间。
+ 下升沿：数字电平从$1$变为$0$的一瞬间。
+ 读命令过程(设$CPU$作为主设备，某个输入设备作为从设备)：
    1. 取指：$CPU$在$T_1$时刻的上升沿给出地址信息。
    2. 间址：在$T_2$的上升沿给出读命令（低电平有效），与地址信息相符合的输入设备按命令进行一系列的内部操作，且必须在$T_3$的上升沿来之前将$CPU$所需的数据送到数据总线上。
    3. 执行：$CPU$在$T_3$时钟周期内，将数据线上的信息传送到其内部寄存器电中。
    4. 撤销：$CPU$在$T_4$的上升沿撤销读命令，输入设备不再向数据总线上传送数据，撤销它对数据总线的驱动。
+ 优点：
    + 传送速度快，具有较高的传输速率。
    + 总线控制逻辑简单。
+ 缺点：
    + 主从设备属于强制性同步。
    + 不能及时进行数据通信的有效性检验，可靠性较差。
+ 同步通信适用于总线长度较短及总线所接部件的存取时间比较接近的系统。

#### 异步定时方式

+ 也称为异步通信。
+ 在异步定时方式中，没有统一的时钟，也没有固定的时间间隔，完全依靠传送双方相互制约的“握手”信号来实现定时控制。
+ 主设备提出交换信息的“请求”信号，经接口传送到从设备；从设备接到主设备的请求后，通过接口向主设备发出“回答”信号。
+ 根据“请求”和“回答”信号的撤销足否互锁，分为：
    1. 不互锁方式：
        + ![image-20230604101138172](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230604101138172.png)
        + 主设备发出“请求”信号后，不必等到接到从设备的“回答”信号，而是经过一段时间，便撤销“请求”信号。
        + 而从设备在接到“请求”信号后，发出“回答”信号，并经过段时间，自动撤销“回答”信号。
        + 双方的不存在互锁关系。
        + 速度快。
        + 可靠性最差。
    2. 半互锁方式：
        + ![image-20230604101208714](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230604101208714.png)
        + 主设备发出“请求”信号后，必须待接到从设备的“回答”信号后，才撤销“请求”信号，有互锁的关系。
        + 而从设备在接到“请求”信号后，发出“回答”信号，但不必等待获知主设备的“请求”信号已经撤销，而是隔一段时间后自动撤销“回答”信号，不存在互锁关系。
        + 若从设备故障，则会一直停留。
    3. 全互锁方式：
        + ![image-20230604101549500](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230604101549500.png)
        + 主设备发出“请求”信号后，必须待从设备“回答”后，才撤销“请求”信号。
        + 从设备发出“回答”信号，必须待获知主设备“请求”货报销后，再撤销其“回答”信号。
        + 双方存在互锁关系。
        + 最可靠
        + 速度最慢
+ 优点：总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换，自动适应时间的配合。
+ 缺点：
    + 比同步控制方式稍复杂。
    + 速度比同步定时方式慢。

#### 半同步通信

**半同步通信**（Half-Duplex Communication）是一种通信模式，其中通信的两个实体可以在同一时间交替地发送和接收数据，但不能同时进行发送和接收。在半同步通信中，通信双方共享同一个通信信道，并在某个时刻进行数据的传输。当一方发送数据时，另一方处于接收状态，反之亦然。这种方式适用于一些需要简单的双向通信的场景，如对话式通信或半双工通信。

同步与异步的混合，统一时钟的基础上，增加一个“等待”响应信号$\overline{WAIT}$。

![image-20230604101754584](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230604101754584.png)

#### 分离式通信

**分离式通信**（Full-Duplex Communication）是一种通信模式，其中通信的两个实体可以同时进行数据的发送和接收，彼此独立进行。在分离式通信中，通信双方拥有独立的发送和接收通道，并且可以在同一时间同时进行数据的传输。这种方式适用于需要高效的双向通信的场景，如网络通信、电话通信等。

即分离事务通信：

+ 上述三种通信的共同点：一个总线传输周期（以输入数据为例）：
    + 主模块发地址、命令，使用总线。
    + 从模块准备数据，不使用总线，总线空闲。
    + 从模块向主模块发数据，使用总线。
+ 分离式通信的一个总线传输周期：
    + 子周期一：主模块申请占用总线，使用完后后放弃总线的使用权。
    + 子周期二：从模块申请占用总线，将各种信息发送至总线上。
+ 特点：
    1. 各模块均有权申请占用总线。
    2. 采用同步方式通信，不等对方回答。
    3. 各模块准备数据时，不占用总线。
    4. 总线利用率提高。

## 总线标准(不考,了解)

### 总线标准概念

+ 总线标准是国际上公布或推荐的互连各个模块的标准，它是把各种不同的模块组成计算机系统时必须遵守的规范。
+ 按总线标准设计的接口可视为通用接口，在接口的两端，任何一方只需根据总线标准的要求完成自身方面的功能要求，而无须了解对方接口的要求。
+ 系统总线标准：$ISA$、$EISA$、$VESA$、$PCI$、$PCI-Express$等。
+ 设备总线标准：$IDE$、$AGP$、$RS-232C$、$USB$、$SATA$、$SCSI$、$PCMCIA$等。
+ 局部总线标准：在$ISA$总线和$CPU$总线之间增加的一级总线或管理层，如$PCI$、$PCI-E$、$VESA$、$AGP$等，可以节省系统的总带宽。
+ 即插即用（$Plug-and-Play$）的作用是自动配置（低层）计算机中的板卡和其他设备，然后告诉对应的设备都做了什么。把物理设备和软件（设备驱动程序）相配合，并操作设备，在每个设备和它的驱动程序之间建立通信信道。
+ 热插拔（$hot-plugging$或$Hot\,Swap$）即带电插拔，热插拔功能就是允许用户在不关闭系统，不切断电源的情况下取出和更换损坏的硬盘、电源或板卡等部件，从而提高了系统对灾难的及时恢复能力、扩展性和灵活性等，例如一些面向高端应用的磁盘镜像系统都可以提供磁盘的热插拔功能。

### 标准总览

这是重点，下面的具体介绍可以随便看看：

| 总线标准  |                          全称                           | 工作频率 | 数据线 |       最大速度        |      特点      |
| :-------: | :-----------------------------------------------------: | :------: | :----: | :-------------------: | :------------: |
|    ISA    |             Industry Standard Architecture              |   8MHz   |  8/16  |         8MB/s         |    系统总线    |
|   EISA    |                      Extended ISA                       |   8MHz   |   32   |        32MB/s         |    系统总线    |
|    PCI    |            Peripheral Component Interconnect            | 33/66MHz | 32/64  |      133/528MB/s      |    局部总线    |
|    AGP    |                Accelerated Graphics Port                |          |        | X1:266MB/s X8:2.1GB/s |    局部总线    |
|   VESA    |         Video Electronics Standard Architecture         |  33MHz   |   32   |        132MB/s        |    局部总线    |
|   PCI-E   |                   PCI-Express (3GI0)                    |          |        |      10GB/s以上       |      串行      |
|    USB    |                  Universal Serial Bus                   |          |        |       1280MB/s        | 设备总线、串行 |
|  RS-232C  |                  Recommended Standard                   |          |        |        20Kbps         |  串行通信总线  |
| IDE（ATA) |              Integrated Drive Electronics               |          |        |        100MB/s        |  硬盘光驱接口  |
|   SATA    |          Serial Advanced Technology Attachment          |          |        |        600MB/s        |  串行硬盘接口  |
|  PCMCIA   | Personal Computer Memory Card International Association |          |        |        90Mbps         |  便携设备接口  |
|   SCSI    |             Small Computer System Interface             |          |        |        640MB/s        |  智能通用接口  |

### 系统总线标准

| 总线标准 |              全称              | 工作频率 | 数据线 | 最大速度 |   特点   |
| :------: | :----------------------------: | :------: | :----: | :------: | :------: |
|   ISA    | Industry Standard Architecture |   8MHz   |  8/16  |  8MB/s   | 系统总线 |
|   EISA   |          Extended ISA          |   8MHz   |   32   |  32MB/s  | 系统总线 |

+ $ISA$和$EISA$都是并行系统总线。
+ $ISA$数据传送需要$CPU$或$DMA$接口来管理，传输速率过低、$CPU$占用率高、占用硬件中断资源，不支持总线仲裁。
+ $EISA$从$CPU$中分离出了总线控制权，支持多个总线主控器和突发传送。
+ 被$PCI$淘汰了。

### 局部总线标准

#### PCI

| 总线标准 |               全称                | 工作频率 | 数据线 |  最大速度   |   特点   |
| :------: | :-------------------------------: | :------: | :----: | :---------: | :------: |
|   PCI    | Peripheral Component Interconnect | 33/66MHz | 32/64  | 133/528MB/s | 局部总线 |

$PCI$也是并行局部总线，可以将高速外部设备直接挂到$CPU$总线上。

特点：

1. 高性能:不依附于某个具体的处理器，支持突发传送。
2. 良好的兼容性。
3. 支持即插即用。
4. 支持多主设备。
5. 具有与处理器和存储器子系统完全并行操作的能力。
6. 提供数据和地址奇偶校验的能力。
7. 可扩充性好,可采用多层结构提高驱动能力。
8. 采用多路复用技术，减少了总线引脚个数。

#### AGP

| 总线标准 |           全称            | 工作频率 | 数据线 |       最大速度        |   特点   |
| :------: | :-----------------------: | :------: | :----: | :-------------------: | :------: |
|   AGP    | Accelerated Graphics Port |          |        | X1:266MB/s X8:2.1GB/s | 局部总线 |

$AGP$即加速图形接口，是并行局部总线，是显卡专用的局部总线。

#### PCI-E

| 总线标准 |        全称        | 工作频率 | 数据线 |  最大速度  | 特点 |
| :------: | :----------------: | :------: | :----: | :--------: | :--: |
|  PCI-E   | PCI-Express (3GI0) |          |        | 10GB/s以上 | 串行 |

+ 点对点串行。
+ 支持双向传输模式，可以运行全双工模式。
+ 支持热插拔。

#### VESA

| 总线标准 |                  全称                   | 工作频率 | 数据线 | 最大速度 |   特点   |
| :------: | :-------------------------------------: | :------: | :----: | :------: | :------: |
|   VESA   | Video Electronics Standard Architecture |  33MHz   |   32   | 132MB/s  | 局部总线 |

即视频局部总线，为了传输活动图形。

### 设备总线标准

#### USB

| 总线标准 |         全称         | 工作频率 | 数据线 | 最大速度 |      特点      |
| :------: | :------------------: | :------: | :----: | :------: | :------------: |
|   USB    | Universal Serial Bus |          |        | 1280MB/s | 设备总线、串行 |

$USB$属于设备总线，是设备和设备控制器之间的接口。

特点：

1. 可以热插拔、即插即用。
2. 具有很强的连接能力和很好的可扩充性。采用菊花链形式将众多外设连接起来，可使用$USB$集线器链式连接$127$个外设。
3. 标准统一。以前大家常见的是$IDE$接口的硬盘，串口的鼠标键盘，并口的打印机扫描仪，可是有了$USB$之后，这些应用外设统统可以用同样的标准与个人电脑连接，这时就有了$USB$硬盘、$USB$鼠标、$USB$打印机等等。
4. 高速传输。
5. 连接电缆轻巧，可为低压（$5V$）外设供电。

#### IS-232C

| 总线标准 |         全称         | 工作频率 | 数据线 | 最大速度 |     特点     |
| :------: | :------------------: | :------: | :----: | :------: | :----------: |
| RS-232C  | Recommended Standard |          |        |  20Kbps  | 串行通信总线 |

应用于串行二进制交换的数据终端设备（$DTE$）和数据通信设备（$DCE$）。

#### IDE（ATA）

| 总线标准  |             全称             | 工作频率 | 数据线 | 最大速度 |     特点     |
| :-------: | :--------------------------: | :------: | :----: | :------: | :----------: |
| IDE（ATA) | Integrated Drive Electronics |          |        | 100MB/s  | 硬盘光驱接口 |

硬盘、光驱都通过$IDE$接口与主板连接。

#### SATA

| 总线标准 |                 全称                  | 工作频率 | 数据线 | 最大速度 |     特点     |
| :------: | :-----------------------------------: | :------: | :----: | :------: | :----------: |
|   SATA   | Serial Advanced Technology Attachment |          |        | 600MB/s  | 串行硬盘接口 |

#### PCMCIA

| 总线标准 |                          全称                           | 工作频率 | 数据线 | 最大速度 |     特点     |
| :------: | :-----------------------------------------------------: | :------: | :----: | :------: | :----------: |
|  PCMCIA  | Personal Computer Memory Card International Association |          |        |  90Mbps  | 便携设备接口 |

#### SCSI

| 总线标准 |              全称               | 工作频率 | 数据线 | 最大速度 |     特点     |
| :------: | :-----------------------------: | :------: | :----: | :------: | :----------: |
|   SCSI   | Small Computer System Interface |          |        | 640MB/s  | 智能通用接口 |

1. $IDE$工作需要$CPU$参与，而$SCSI$通过独立高速$SCSI$卡控制读写，$CPU$就不需要等待。
2. $SCSI$扩充性高。

### 视频线标准

#### VGA

即$Video\,Graphics\,Array$，也称为$D-sub$端口，传输模拟信号，所以要先将数字信号转换为模拟信号。

#### DIV

即$Digital\,Visual\,Interface$，传输数字信号，但是在分辨率$1024\times768$以下时与$VGA$差别不大。

#### HDMI

 即$High\,Definition\,Multimedia\,Interface$，可以传输音讯，源于$DVI$技术，分为三种类型：

+ $A$型：高清电视，投影仪等。
+ $C$型：平板电脑，$MP4$等。
+ $D$型：智能手机，平板电脑等。

# 第七章 输入输出$(I/O)$系统

## 导读

### 【考纲内容】

1. $I/O$接口($I/O$控制器)
    + $I/O$接口的功能和基本结构:$I/O$端口及其编址

2. $I/O$方式
    + 程序查询方式
    + 程序中断方式
        + 中断的基本概念、中断响应过程、中断处理过程
        + 多重中断和中断屏蔽的概念
    + $DMA $方式,$DMA $控制器的组成,$DMA $传送过程

### 【知识导图】

![img](http://res.ptpress.cn/E32C16AC9AA2428993797C71CA1125CA.png)

![img](http://res.ptpress.cn/050A2E52793840DAA3C46BAD14DC8833.png)

![img](http://res.ptpress.cn/8F1BA494D6C94FC7AD7C93C880680202.png)

![image-20230603100141352](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603100141352.png)





### 【复习提示】

$I/O$方式是本章的重点和难点,每年不仅会以选择题的形式考查基本概念和原理,而且可能会以综合题的形式考查,特别是各种$I/O$方式效率的相关计算,中断方式的各种原理、特点、处理过程、中其屏蔽,$DMA $方式的特点、传输过程、与中断方式的区别等。

在学习本章时,请读者思考以下问题;

1) $I/O$设备有哪些编址方式? 各有何特点?

2) $CPU$ 响应中断应具备哪些条件?

## 输入输出基本概念

### I/O系统发展

1. 早期,$CPU$和$I/O$串行工作,分散连接：
    + 程序查询方式：由$CPU$通过程序不断查询$I/O$设备是否已做好准备,从而控制$I/O$设备与主机交换信息。
2. 接口模块和$DMA$阶段,$CPU$和$I/O$并行工作,总线连接：
    + 中断方式：只在$I/O$设备准备就绪并向$CPU$发出中断请求时才予以响应。
    + $DMA$方式：主存和/O设备之间有一条直接数据通路,当主存和$I/O$设备交换信息时,无需调用中断服务程序。
3. 具有$I/O$通道结构,在系统中设有通道控制部件,每个通道都挂接若干外设,主机在执行$I/O$命令时,只需启动有关通道,通道将执行通道程序,从而完成$I/O$操作。
    + ![image-20230604105549240](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230604105549240.png)
4. 具有$I/O$处理机。

### I/O系统组成

1. $I/O$软件：
    + 包括驱动程序、用户程序、管理程序、升级补丁等。
    + 通常采用$I/O$指令和通道指令实现$CPU$和$I/O$设备的信息交换：
    + $I/O$指令：
        + $CPU$指令的一部分。
        + 机器指令的一部分。
        + 反映$CPU$与$I/O$设备交换信息的特点。
        + 分为操作码（表明识别$I/O$指令）+命令码（执行的操作）+设备码（操作的设备）。（与一般指令格式不同）
    + 通道指令（通道程序）：
        + 通道自身的指令。
        + 指出数据的首地址、传送字数、操作作命令。
        + 通道指令提前编制好放在**主存**中。
        + 通道指令由**通道**执行。由$CPU$执行启动$I/O$设备的指令,通道执行通道指令代替$CPU$对$I/O$设备进行管理。
        + 只有具备通道的$I/O$系统才能执行。
    + ![image-20230604105857595](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230604105857595.png)
2. $I/O$硬件：
    + $I/O$接口。
    + 设备控制器：通过设备控制器,$I/O$设备与主板的系统总线相联。
    + 外设。
    + ![image-20230604105655485](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230604105655485.png)



## 外部设备

外部设备也称外围设备,是除了主机以外的、能直接或间接与计算机交换信息的装置。

### 输入设备

用于向计算机系统输入命令和文本、数据等信息的部件。键盘和鼠标是最基本的输入设备。

#### 键盘

+ 键盘是最常用的输入设备,通过它可发出命令或输入数据。
+ 键盘通常以矩阵的形式排列按键,每个键用符号标明它的含义和作用。
+ 每个键相当于一个开关,当按下键时,电信号连通；当松开键时,弹簧把键弹起,电信号断开。
+ 键盘输入信息可分为三个步骤：
    1. 查出按下的是哪个键。
    2. 将该键翻译成能被主机接收的编码,如$ASCII$码。
    3. 将编码传送给主机。

#### 鼠标

+ 鼠标是常用的定位输入设备,它把用户的操作与计算机屏幕上的位置信息相联系。
+ 常用的鼠标有机械式和光电式两种。
+ 工作原理：当鼠标在平面上移动时,其底部传感器把运动的方向和距离检测出来,从而控制光标做相应运动。

### 输出设备

用于将计算机系统中的信息输出到计算机外部进行显示、交换等的部件。显示器和打印机是最基本的输出设备。

#### 显示器

按显示设备所用的显示器件分类：

+ 阴极射线管（$CRT$）显示器：
    + $CRT$显示器主要由电子枪、偏转线圈、荫罩、高压石墨电极和荧光粉涂层及玻璃外壳$5$部分组成。
    + 具有可视角度大、无坏点、色彩还原度高、色度均匀、可调节的多分辨率模式、响应时间极短~等目前$LCD$难以超过的优点~。
        + ~~时代变了~~
+ 液晶显示器（$LCD$）：
    + 利用液晶的电光效应,由图像信号电压直接控制薄膜晶体管,再间接控制液品分子的光学特性来实现图像的显示。
    + 体积小、重量轻、省电、无辐射、绿色环保、画面柔、不伤眼等。
+ $LED$显示器：通过控制半导体发光二极管进行显示,用来显示文字、图形、图像等各种信息。
+ $LCD$、$LED$是两种不同的显示技术,$LCD$是由液态晶体组成的显示屏,而$LED$则是由发光二极管组成的显示屏。与$LCD$相比,$LED$显示器在亮度、功耗、可视角度和刷新速率等方面都更具优势。

按所显示的信息内容分类：

+ 字符显示器：
    + 显示字符的方法以点阵为基础。点阵是指由$m\times n$个点组成的阵列。点阵的多少取决于显示字符的质量和字符窗口的大小。字符窗口是指每个字符在屏幕上所占的点数,它包括字符显示点阵和字符间隔。
    + 将点阵存入由$ROM$构成的字符发生器中,在$CRT$进行光栅扫描的过程中,从字符发生器中依次读出某个字符的点阵,按照点阵中$0$和$1$代码不同控制扫描电子束的开或关,从而在屏幕上显示出字符。对应于每个字符窗口,所需显示字符的$ASCII$代码被存放在视频存储器$VRAM$中,以备刷新。
    + ![image-20230604111214850](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230604111214850.png)
    + ![image-20230604111416820](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230604111416820.png)
+ 图形显示器：
    + 将所显示图形的一组坐标点和绘图命令组成显示文件存放在缓冲存储器中,缓存中的显示文件传送给矢量（线段）产生器,产生相应的模拟电压,直接控制电子束在屏幕上的移动。为了在屏幕上保留持久稳定的图像,需要按一定的频率对屏幕进行反复刷新。
    + 这种显示器的优点是分辨率高且显示的曲线平滑。目前高质量的图形显示器采用这种随机扫描方式。
    + 缺点是当显示复杂图形时,会有闪烁感。
    + 按扫描方式不同可分为：光栅扫描显示器、随机扫描显示器。
+ 图像显示器。

参数：

+ 屏幕大小：以对角线长度表示,常用的有$12\sim29$英寸等。
+ 分辨率：所能表示的像素个数,屏幕上的每一个光点就是一个像素,以宽、高的像素的乘积表示,例如,$800\times600$、$1024\times768$和$1280\times1024$等。
+ 灰度级：指黑白显示器中所显示的像素点的亮暗差别,在彩色显示器中则表现为颜色的不同,灰度级越多,图像层次越清楚逼真,典型的有$8$位（$256$级）、$16$位等。$n$位可以表示$2^n$种不同的亮度或颜色。
    + 即每个像素点需要多少个比特位表示

+ 刷新：光点只能保持极短的时间便会消失,为此必须在光点消失之前再重新扫描显示一遍,这个过程称为刷新。
+ 刷新频率：单位时间内扫描整个屏幕内容的次数,按照人的视觉生理,刷新频率大于$30Hz$时才不会感到闪烁,通常显示器刷新频率在$60$到$120Hz$。
+ 显示存储器（$VRAM$）：也称**刷新存储器**,为了不断提高刷新图像的信号,必须把一帧图像信息存储在刷新存储器中。其存储容量由图像分辨率和灰度级决定,分辨率越高,灰度级越多,刷新存储器容量越大。
    + $VRAM$容量=分辨率×灰度级位数。显存的理论最小值
    + $VRAM$带宽=分辨率×灰度级位数×帧频。即显存带宽,单位为$MB/s$
    + 现代计算机中,显存除了作为当前帧的缓存还会用于保存即将渲染的图像数据
    + 集成显卡计算机中,通常分配一片内存作为显存

每个存储汉字数据的汉字内码占$2B$,表示汉字形体的字形码以$16\times16$点阵表示,为$32B$大小。

#### 打印机

打印机是计算机的输出设备之一,用于将计算机处理结果打印在相关介质上。

按印字原理不同可分为：

+ 击打式打印机：
    + 利用机械动作使印字机构与色带和纸相撞而打印字符。
    + 优点：设备成本低；印字质量好。
    + 缺点：噪声大；速度慢。
+ 非击打式打印机:
    + 采用电、磁、光、喷墨等物理、化学方法来印刷字符。
    + 优点：速度快；噪声小。
    + 缺点：成本高。

按打印机工作方式不同可分为：

+ 串行打印机：
    + 逐字打印。
    + 速度慢。
+ 行式打印机：
    + 逐行打印。
    + 速度快。

按工作方式可分为：

+ 针式打印机：
    + 原理：在联机状态下,主机发出打印命令,经接口、检测和控制电路,间歇驱动纵向送纸和打印头横向移动,同时驱动打印机间歇冲击色带,在纸上打印出所需内容。
    + 特点：针式打印机擅长“多层复写打印”,实现各种票据或蜡纸等的打印。它工作原理简单,造价低廉,耗材（色带）便宜,但打印分辨率和打印速度不够。
+ 喷墨式打印机：
    + 原理：带电的喷墨雾点经过电极偏转后,直接在纸上形成所需字形。彩色喷墨打印机基于三基色原理,即分别喷射$3$种颜色墨滴,按一定的比例混合出所要求的颜色。
    + 特点：打印噪声小,可实现高质量彩色打印,通常打印速度比针式打印机快；但防水性差,高质量打印需要专用打印纸。
+ 激光打印机：
    + 原理：计算机输出的二进制信息,经过调制后的激光束扫描,在感光鼓上形成潜像,再经过显影、转印和定影,便在纸上得到所需的字符或图像。
    + 特点：打印质量高、速度快、噪声小、处理能力强；但耗材多、价格较贵、不能复写打印多份,且对纸张的要求高。激光打印机是将激光技术和电子显像技术相结合的产物。感光鼓（也称为硒鼓)是激光打印机的核心部件。

### 外存设备

+ 是指除计算机内存及$CPU$缓存等以外的存储器。硬磁盘、光盘等是最基本的外存设备。
+ 计算机的外存储器又称为辅助存储器,目前主要使用磁表面存储器。
+ 所谓“磁表面存储”,是指把某些磁性材料薄薄地涂在金属铝或塑料表面上作为载磁体来存储信息。磁盘存储器、磁带存储器和磁鼓存储器均属于磁表面存储器。
+ 磁表面存储器的优点:
    1. 存储容量大,位价格低。
    2. 记录介质可以重复使用。
    3. 记录信息可以长期保存而不丢失,甚至可以脱机存档。
    4. 非破坏性读出,读出时不需要再生。
+ 磁表面存储器的缺点:
    1. 存取速度慢。
    2. 机械结构复杂。
    3. 对工作环境要求较高。
+ 原理：当磁头和磁性记录介质有相对运动时,通过电磁转换完成读/写操作。
+ 编码方法：按某种方案（规律）,把一连串的二进制信息变换成存储介质磁层中一个磁化翻转状态的序列,并使读/写控制电路容易、可靠地实现转换。
+ 磁记录方式：通常采用调频制（$FM$）和改进型调频制（$MFM$）的记录方式。

#### 磁盘存储器

+ 磁盘设备的组成：
    + 存储区域：一块硬盘含有若干个记录面,每个记录面划分为若干条磁道,而每条磁道又划分为若干个扇区。
    + **扇区**（也称块）是磁盘读写的最小单位,也就是说磁盘按块存取。
        + 磁头数（$Heads$）：即记录面数,表示硬盘总共有多少个磁头,磁头用于读取/写入盘片上记录面的信息,一个记录面对应一个磁头。
        + 柱面数（$Cylinders$）：表示硬盘每一面盘片上有多少条磁道,一个盘组中,不同记录面的相同编号（位置）的诸磁道构成一个圆柱面。
        + 扇区数（$Sectors$）：表示每一条磁道上有多少个扇区。
    + 硬盘存储器：
        + 硬盘存储器由磁盘驱动器、磁盘控制器和盘片组成。
        + 磁盘驱动器：核心部件是磁头组件和盘片组件,温彻斯特盘是一种可移动头固定盘片的硬盘存储器。
        + 磁盘控制器：是硬盘存储器和主机的接口,主流的标准有$IDE$、$SCSI$、$SATA$等。
+ 磁盘的性能指标：
    + 磁盘容量：一个磁盘所能存储的字节总数称为磁盘容量。
        + 非格式化容量是指磁记录表面可以利用的磁化单元总数。
        + 格式化容量是指按照某种特定的记录格式所能存储信息的总量。
    + 记录密度：指盘片单位面积上记录的二进制的信息量。
        + 道密度：沿磁盘半径方向单位长度上的磁道数。
        + 位密度：磁道单位长度上能记录的二进制代码位数。
        + 面密度：位密度和道密度的乘积。
        + 磁盘最里面的位密度最大,最外面的位密度最低。注意虽然每一道的道密度不同,但是每一道所含的数据量是一样的。
    + 平均存取时间=寻道时间（磁头移动到目的磁道）+旋转延迟时间（磁头定位到所在扇区）+传输时间（传输数据所花费的时间）。
    + 数据传输率：磁盘存储器在单位时间内向主机传送数据的字节数,称为数据传输率。
+ 磁盘地址：
    + 主机向磁盘控制器发送寻址信息,磁盘的地址=驱动器号+柱面（磁道）号+盘面号+扇区号。
    + 若系统中有$4$个驱动器,每个驱动器带一个磁盘,每个磁盘$256$个磁道、$16$个盘面,每个盘面划分为$16$个扇区,则每个扇区地址要$18$位二进制代码：驱动器号（$2bit$）+柱面（磁道）号（$8bit$）+盘面号（$4bit$）+扇区号（$4bit$）。
+ 磁盘工作过程：
    + 硬盘的主要操作是寻址、读盘、写盘。每个操作都对应一个控制字,硬盘工作时,第一步是取控制字,第二步是执行控制字。
    + 硬盘属于机械式部件,其读写操作是串行的,不可能在同一时刻既读又写,也不可能在同一时刻读两组数据或写两组数据。

#### 磁盘阵列

+ $RAID$（廉价冗余磁盘阵列）是将多个独立的物理磁盘组成一个独立的逻辑盘,数据在多个物理盘上分割交叉存储、并行访问,具有更好的存储性能、可靠性和安全性。
+ $RAID$的分级如下所示。在$RAID1$到$RAID5$的几种方案中,无论何时有磁盘损坏,都可以随时拔出受损的磁盘再插入好的磁盘,而数据不会损坏：
    + $RAID0$：无冗余和无校验的磁盘阵列。
    + $RAID1$：镜像磁盘阵列。
    + $RAID2$：采用纠错的海明码的磁盘阵列。
    + $RAID3$：位交叉奇偶校验的磁盘阵列。
    + $RAID4$：块交叉奇偶校验的磁盘阵列。
    + $RAID5$：无独立校验的奇偶校验磁盘阵列。

#### 光盘存储器

+ 光盘存储器是利用光学原理读/写信息的存储装置,它采用聚焦激光束对盘式介质以非接触的方式记录信息。
+ 光盘存储系统：
    + 光盘片：
        + 透明的聚合物基片。
        + 铝合金反射层。
        + 漆膜保护层的固盘。
    + 光盘驱动器。
    + 光盘控制器。
    + 光盘驱动软件。
+ 特点：
    + 存储密度高。
    + 携带方便。
    + 成本低。
    + 容量大。
    + 存储期限长。
    + 容易保存。
+ 光盘的类型如下：
    + $CD-ROM$：只读型光盘,只能读出其中内容,不能写入或修改。
    + $CD-R$：只可写入一次信息,之后不可修改。
    + $CD-RW$：可读可写光盘,可以重复读写。
    + $DVD-ROM$：高容量的$CD-ROM$,$DVD$表示通用数字化多功能光盘。

#### 固态硬盘

+ 在微小型高档笔记本电脑中,采用高性能$Flash\,Memory$作为硬盘来记录数据,这种“硬盘”称固态硬盘。
+ 固态硬盘除了需要$Flash\,Memory$外,还需要其他硬件和软件的支持。
+ 闪存（$Flash\,Memory$）是在$E2PROM$的基础上发展起来的,本质上是只读存储器。



## I/O接口

即$I/O$控制器,是主机和外设之间的交接界面,通过接口可以实现主机和外设之间的信息交换。

### 接口基本概念

#### $I/O$接口的功能

+ 数据缓冲：通过数据缓冲寄存器$(DBR)$达到主机和外设工作速度的匹配
+ 错误或状态监测：通过状态寄存器反馈设备的各种错误、状态信息,供$CPU$查用
+ 控制和定时：接收从控制总线发来的控制信号、时钟信号
+ 数据格式转换：串-并、并-串等格式转换
+ 与主机和设备通信：实现主机$I/O$接口$I/O$设备之间的通信

#### $I/O$接口的基本结构

![image-20230604112917133](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230604112917133.png)

1. 主机侧-内部接口：内部接口与系统总线相连,实质上是与内存、$CPU$相连。~数据的传输方式只能是并行传输。~
    + ~~时代变了~~,从$2000$年后总线技术慢慢从并行向串行转换,所以数据的传输方式也有可能是串行传输
2. 设备侧-外部接口：外部接通过接口电缆与外设相连,外部接口的数据传输可能是串行方式,因此$I/O$接口需具有串/并转换功能。
3. $CPU$与$I/O$接口之间通过数据线、地址线、命令线、状态线和控制线连接。
    1. **数据线**：数据线用于在 $CPU $和 $I/O $接口之间传输数据。它们承载着从 $CPU $发送到 $I/O$ 接口（或从 $I/O$ 接口发送到 $CPU$）的**读写数据、状态字、控制字、中断类型字**。数据线的宽度（即位数）决定了一次可以传输的数据量,通常是以字节或字（多字节）为单位。
    2. **地址线**：地址线用于指示要访问的内存地址或$ I/O $设备的寄存器地址。$CPU $通过地址线向$ I/O $接口发送地址信息,以指示它希望访问的特定位置。地址线的位数决定了$ CPU $可以寻址的内存或 $I/O$ 空间的大小。
    3. **命令线**：命令线用于向 $I/O$ 接口发送特定的命令或操作码,指示所需的操作类型。例如,$CPU $可以通过命令线发送读取命令以从 $I/O $设备读取数据,或发送写入命令以向$ I/O $设备写入数据。命令线上的信号可以根据具体的系统设计和标准而有所不同。
    4. **状态线**：状态线用于从 $I/O$ 接口向 $CPU $报告特定的状态或条件。例如,$I/O$ 接口可以通过状态线向 $CPU$ 报告数据传输完成、设备准备就绪或发生错误等状态。$CPU$ 可以通过检查状态线上的信号来了解 $I/O$ 设备的状态并作出相应的处理。
    5. **控制线**：控制线用于传递控制信号,指示 I/O 设备的特定操作或状态。这些信号可以包括读取、写入、复位、使能等操作。控制线的状态可以触发 I/O 设备执行相应的操作。CPU 通过控制线向 I/O 设备发送控制信号,以控制数据的流动和设备的行为。
        + 读写$I/O$端口的信号和中断请求信号
4. $I/O$接口与外部设备通过数据线相连,$I/O$接口向外设通过命令线传递命令,外设向$I/O$接口通过状态线传递状态。
5. 控制寄存器、状态寄存器在使用时间上是错开的,因此有的$I/O$接口中可将二者合二为一
6. $I/O$控制器中的各种寄存器也被称为$I/O$端口
    + 如数据缓存端口(数据缓冲寄存器),控制端口(控制寄存器)、状态端口(状态寄存器)
    + $CPU$同外设之间的信息传送实质是对接口中的某些寄存器（即端口）进行读或写。



#### $I/O$接口类型

+ 按数据传送方式：
    + 并行接口：一个字节或一个字所有位同时传送。
    + 串行接口：一位一位地传送。
    + 这里所说的数据传送方式指的是外设和接口一侧的传送方式~,而在主机和接口一侧,数据总是并行传送的。~接口要完成数据格式转换。
        + 同上,时代变了
+ 按主机访问$I/O$设备的控制方式：
    + 程序查询接口。
    + 中断接口。
    + $DMA$接口。
+ 按功能选择的灵活性：
    + 可编程接口。
    + 不可编程接口。

### $I/O$端口与$I/O$地址

+ $I/O$端口是指接口电路中可以被$CPU$直接访问的**寄存器**。
+ 接口$Interface$：
    + 端口$Port$：实际上是寄存器：
        + 数据端口：可读可写。
        + 控制端口：只写。
        + 状态端口：只读。
+ 控制逻辑。

$I/O$端口要想能够被$CPU$访间,必须要有端口地址,每一个端口都对应着一个端口地址。

#### 统一编址

![image-20230604114325925](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230604114325925.png)

+ 把$I/O$端口当做存储器的单元进行地址分配,用统一的访存指令就可以访问$I/O$端口,又称**存储器映射方式**。
+ $RISC$机器常用
+ 靠不同的地址码区分内存$I/O$设备,$I/O$地址要求相对固定在地址的某部分。
+ 如系统总线中地址线共$10$根,则可以访问的存储单元个数为$1024$个,假设要给$10$个$I/O$端口编址:
    + $0$到$9$表示$I/O$地址,$10$到$1023$为主存单元地址。
    + $0$到$1013$表示主存单元地址,$1014$到$1023$为$I/O$地址。
    + $10$到$19$表示$I/O$地址,$0$到$9、20$到$1023$为主存单元地址。
+ 优点：
    + 不需要专门的输入/输出指令,可使$CPU$访问$I/O$的**访存指令**,操作更灵活、更方便。
    + 使端口有较大的编址空间。
+ 缺点：
    + 端口占用了主存地址空间,使内存容量变小。
    + 利用存储器编址的$I/O$设备进行数据输入/输出操作,执行速度较慢。

#### 独立编址

![image-20230604114438733](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230604114438733.png)

+ $I/O$端口地址与存储器地址无关,独立编址$CPU$需要设置专门的$I/O$指令访问端口,又称**$I/O$映射方式**。
+ 靠不同的指令区分内存和$I/O$设备,只能用专门的$I/O$。指令访问$I/O$端口
+ 优点：
    + 使用专门的$I/O$指令,程序编制清晰,便于理解。
    + $I/O$端口地址位数少,地址译码快
    + $I/O$端口的地址不占用主存地址空间
+ 缺点：
    + $I/O$指令少,一般只能对端口进行传送操作,程序灵活性差。
    + 需要$CPU$提供存储器读/写、$I/O$设备读/两组控制信号,增加了控制的复杂性。



## I/O方式

即主机和$I/O$设备之间的数据传送的控制方式。

### 程序查询方式

![image-20230604103850347](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230604103850347.png)

+ **独占查询（Polling）**：

    - 独占查询是一种基本的 I/O 方式,其中 CPU 不断地查询 I/O 设备的状态,以确定是否就绪进行数据的传输或接收。
    - CPU 使用指令周期中的一部分时间来轮询（查询） I/O 设备的状态,通常通过读取状态寄存器或者查询状态线来获取设备的状态信息。
    - 如果 I/O 设备就绪,CPU 就会执行相应的数据传输或接收操作；如果设备不就绪,CPU 将继续查询直到设备就绪为止。
    - 独占查询方式需要占用大量的 CPU 时间,因为 CPU 必须不断地查询设备的状态,这可能导致 CPU 的效率较低。

+ **定时查询（Timing）**：

    - 定时查询是一种改进的 I/O 方式,其中 CPU 在设定的时间间隔内周期性地查询 I/O 设备的状态。
    - CPU 在规定的时间间隔内发出查询请求,然后继续执行其他任务,直到查询结束后再次发起查询。
    - 定时查询方式使用定时器或者计数器来控制查询的时间间隔,可以更好地利用 CPU 的时间,避免不必要的查询操作,提高了 CPU 的效率。
    - 如果 I/O 设备就绪,CPU 就会执行相应的数据传输或接收操作；如果设备不就绪,CPU 将等待下一次查询时机。

+ $x86$中的$I/O$指令实例:

    + $IN\;R_d,R_s$:把$I/O$端口$R_s$的数据输入到$CPU$寄存器$R_d$
    + $OUT\;R_d,R_s$:把$CPU$寄存器$R_s$的数据输出到$I/O$端口$R_d$

+ 过程：

    1. $CPU$执行初始化程序,并预置传送参数：设置计数器、设置数据首地址。
    2. 向$I/O$接口发送命令字,启动$I/O$设备。
    3. $CPU$从接口读取设备状态信息。
    4. $CPU$不断查询$I/O$设备状态,直到外设准备就绪。$CPU$一旦启动$I/O$,必须停止现行程序的运行,并在现行程序中插入一段程序。
        + 主要特点：$CPU$有“踏步”等待现象,$CPU$与$I/O$串行工作。
    5. 状态就绪后传输一次数据,一般为一个字。
    6. 修改地址和计数器参数。
    7. 判断传送是否结束（一般计数器为$0$时结束）。如果没有结束则转第三步,直到计数器为$0$。

    ![image-20230604143044885](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230604143044885.png)

+ 优点：接口设计简单、设备量少。

+ 缺点：$CPU$在信息传送过程中要花费很多时间用于查询和等待,而且在一段时间内只能和一台外设交换信息,效率大大降低。

### 程序中断方式

![image-20230604103918755](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230604103918755.png)

**工作流程:**

1. 中断请求：中断源向$CPU$发送中断请求信号。
2. 中断响应：响应中断的条件。
    + 中断判优：多个中断源同时提出请求时通过中断判优逻辑响应一个中断源。
3. 中断处理：
    + 中断隐指令。
    + 中断服务程序。

#### 中断和异常

+ 程序中断是指在计算机执行现行程序的过程中,出现某些急需处理的异常情况或特殊请求,$CPU$暂时中止现行程序,而转去对这些异常情况或特殊请求进行处理,在处理完毕后$CPU$又自动返回到现行程序的断点处,继续执行原程序。
+ 中断（广义中断）：
    + 内中断（异常、例外、陷入）$CPU$内部与当前执行的指令有关：
        + 自愿中断：指令中断（自陷）。
        + 强迫中断：硬件故障（终止）、软件中断（故障）。
    + 外中断（中断）$CPU$外部与当前执行的指令有关：
        + 外设请求。
        + 人工干预。
        + **非屏蔽中断 ($NMI$)**：关中断时也会被相应(如断点等)
            - 非屏蔽中断是一种高优先级中断,它无法被屏蔽或禁用。它具有最高的中断优先级,即使在处理器处于关中断状态下,非屏蔽中断仍然可以触发。
            - 非屏蔽中断通常用于处理严重的系统错误或紧急事件,如硬件故障、电源问题、系统崩溃等。由于其高优先级和不可屏蔽性,它们需要立即被处理,以确保系统的稳定性和可靠性。
        + **可屏蔽中断**($INTR$)：关中断时不会被相应
            - 可屏蔽中断是一种低优先级中断,可以通过设置中断屏蔽标志位或关中断操作来屏蔽或禁用。处理器可以根据需要允许或禁止可屏蔽中断的响应。
            - 可屏蔽中断常用于处理一般的外部事件,如设备输入、定时器中断、键盘输入等。这些中断在大多数情况下可以被屏蔽,以便控制系统的中断响应和处理。

+ 在**关中断**状态下,中断请求信号被屏蔽,不会触发相应的中断服务例程。这意味着当关中断状态被激活时,任何中断请求都会被忽略,直到中断被重新允许。
    + 关中断作用:实现原子操作
+ 中$PSW$中**关中断信号位**$IF(Interrupt\;Flag)$
    + $IF=1$表示开中断,允许中断
    + $IF=0$表示关中断,不允许中断
+ 异常由指令在执行种产生,而中断不与指令相关,也不阻止指令的完成。
+ 异常的检测由$CPU$完成,不需要外部信号通知。中断必须$CPU$通过总线获取中断源标记信息才能知道中断的类型。
+ 异常是不可屏蔽的中断,而通过$INTR$信号线发出的中断是可屏蔽的中断。

#### 中断请求

+ 中断请求标记：
    + 每个中断源向$CPU$发出中断请求的时间是随机的。
    + 为了记录中断事件并区分不同的中断源,中断系统需对每个中断源设置中断请求标记触发器$INTR$,当其状态为“$1$"时,表示中断源有请求。
    + 这些触发器可组成中断请求标记寄存器,该寄存器可集中在$CPU$中,也可分散在各个中断源中。
    + 对于外中断,$CPU$是在统一的时刻即每条指令执行阶段结束前向接口发出中断查询信号,以获取$I/O$的中断请求,也就是说,$CPU$响应中断的时间是在每条指令执行阶段的结束时刻。
+ 中断判优,即多个中断发生时处理顺序的训责：
    + 中断判优既可以用硬件实现,也可用软件实现。
    + 硬件实现是通过**硬件排队器**实现的,它既可以设置在$CPU$中,也可以分散在各个中断源中。
        + ![image-20230604150152846](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230604150152846.png)
    + 软件实现是通过查询程序实现的。
        + ![image-20230604150602762](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230604150602762.png)
+ 中断优先级：
    1. 硬件故障中断属于最高级,其次是软件中断。
    2. 非屏蔽中断优于可屏蔽中断。
    3. $DMA$请求优于$I/O$设备传送的中断请求。
    4. 高速设备优于低速设备。
    5. 输入设备优于输出设备。
    6. 实时设备优于普通设备。

#### 中断响应$INTA$

响应$INTR$输入

+ $CPU$响应中断必须满足以下三个条件：
    + 中断源有中断请求。
    + $CPU$允许中断即开中断。
    + 一条指令执行完毕,且没有更紧迫的任务。

中断隐指令指$CPU$在响应中断后在执行中断服务程序前的准备操作。由硬件实现,不是指令系统的真实指令,没有操作码,也不能被用户使用。

#### 中断处理

![image-20230604151849948](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230604151849948.png)

1. 关中断。
2. 保存断点。
3. 识别中断源并引出中断服务程序。
4. 保存现场和中断屏蔽字。现场是用户可见的寄存器的内容,由软件实现。屏蔽字是$CPU$中断响应开始保存到栈或专门寄存器,由硬件实现。
5. 执行中断服务程序（中断事件处理）。
6. 恢复现场和屏蔽字。
7. 开中断。
8. 中断返回。

+ 中断隐指令的主要任务（$1$到$3$）：
    1. 关中断：在中断服务程序中,为了保护中断现场（即$CPU$主要寄存器中的内容）期间不被新的中断所打断,必须关中断,从而保证被中断的程序在中断服务程序执行完毕之后能接着正确地执行下去。即通过硬件自动完成中断触发器置零。
    2. 保存断点：为了保证在中断服务程序执行完毕后能正确地返回到原来的程序,必须将原来程序的断点（即程序计数器$PC$的内容）保存起来。可以存入**堆栈寄存器**,也可以存入指定单元。
    3. 引出中断服务程序：引出中断服务程序的实质就是取出中断服务程序的入口地址(起始地址)并传送给程序计数器$PC$。
        + 软件查询法。
        + 硬件向量法：每个中断有类型号,每个中断类型号对应一个中断服务程序,每个程序有一个入口地址,$CPU$需要找到这个地址,这就是中断向量。由中断向量地址形成硬件产生中断向量地址（中断类型号）,再由向量地址找到入口地址。系统种保存中断向量的存储器就是中断向量表。（**中断向量**就是服务程序的入口地址,**中断向量地址**是入口地址的地址）
            + ![image-20230604151209303](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230604151209303.png)
+ 中断服务程序的任务（$4$到$8$）：
    1. 保护现场：
        + 保存程序断点$PC$,已由中断隐指令完成。
        + 二是保存**通用寄存器**和**状态寄存器**的内容,由中断服务程序完成。
            + 例如保存$ACC$寄存器的值
        + 可以使用堆栈,也可以使用特定存储单元。
    2. 中断服务（设备服务）：主体部分,如通过程序控制需打印的字符代码送入打印机的缓冲存储器中。
        + 此时可能修改$ACC$寄存器的值
    3. 恢复现场：通过出栈指令或取数指令把之前保存的信息送回寄存器中。
        + 恢复$ACC$寄存器的值
    4. 中断返回：通过中断返回指令回到原程序断点处。

#### 多重中断技术

+ 单重中断：执行中断服务程序时不响应新的中断请求。
+ 多重中断：又称中断嵌套,执行中断服务程序时可响应新的中断请求。

|    &nbsp;    |     单重中断     |     多重中断     |
| :----------: | :--------------: | :--------------: |
|  中断隐指令  |      关中断      |      关中断      |
|    &nbsp;    |  保存断点（PC)   |  保存断点（PC)   |
|    &nbsp;    |    送中断向量    |    送中断向量    |
| 中断服务程序 |     保护现场     | 保护现场和屏蔽字 |
|    &nbsp;    |        -         | 开中断,中断嵌套  |
|    &nbsp;    | 执行中断服务程序 | 执行中断服务程序 |
|    &nbsp;    |        -         |      关中断      |
|    &nbsp;    |     恢复现场     | 恢复现场和屏蔽字 |
|    &nbsp;    |      开中断      |      开中断      |
|    &nbsp;    |     中断返向     |     中断返回     |

+ 中断屏蔽技术：主要用于多重中断,$CPU$要具备多重中断的功能,须满足下列条件：
    + 在中断服务程序中提前设置开中断指令。
    + 优先级别高的中断源有权中断优先级别低的中断源。
+ 所有屏蔽触发器组合在一起,便构成一个屏蔽字寄存器,屏蔽字寄存器的内容称为屏蔽字。
+ 中断屏蔽标志可以改变多个中断服务程序**执行完**的次序。但是不能改变开始执行的次序,因为中断请求响应顺序由排队器控制。
    + ![image-20230604152424741](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230604152424741.png)

+ 屏蔽字设置规律：
    + $1$表示屏蔽该中断源的请求,$0$表示可以正常申请。
    + 每个中断源对应一个屏蔽字（在处理该中断源的中断服务程序时,屏蔽寄存器中的内容为该中断源对应的屏蔽字）。
    + 屏蔽字中$1$越多,优先级越高。每个屏蔽字中至少有一个$1$（至少要能屏蔽自身的中断）。
        + 即自己不可以中断自己
+ 在保护现场关中断,在执行中断处理程序时开中断。

#### 程序中断方式实现

![image-20230604153034078](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230604153034078.png)

1. $CPU$遇到$I/O$指令,就去启动外设,然后$CPU$再回来执行现有程序,外部设备进行准备。
2. 外设准备完成后向$CPU$发出中断请求,$CPU$接收后进行响应,进行中断隐指令操作：关中断、保存断电、引出中断服务程序。$CPU$响应中断,运行中断服务程序：保护现场、中断服务程序控制数据传送。外设准备下一个请求。
3. $CPU$通过中断服务程序进行中断返回,若从K个程序开始中断,则返回到$K+1$个程序。

### $DMA$方式

![image-20230604105126389](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230604105126389.png)

$DMA$方式优先级高于中断方式,这样处理速度更快。

#### $DMA$控制器

+ 因为每一个数据都要中断一次,对于快速$I/O$设备有大量数据时$CPU$需要大量中断服务。
+ 所以使用硬件——$DMA$控制器控制大量数据传输。
+ **直到完成一整块的数据读写才会向$CPU$发送一次中断请求**
+ 在$DMA$方式中,当$I/O$设备需要进行数据传送时,通过$DMA$控制器（$DMA$接口）向$CPU$提出$DMA$传送请求,$CPU$响应之后将让出系统总线,由$DMA$控制器**接管**总线进行数据传送。其主要流程如下：
    1. 接受外设发出的$DMA$请求,并向$CPU$发出**总线**请求。
    2. 在每个**存储周期**（机器周期）后$CPU$检查是否存在$DMA$请求,若有则响应此总线请求,发出总线响应倍号,接管总线控制权,进入$DMA$操作周期。
    3. 确定传送数据的主存单元地址及长度,并能自动修改主存地址计数和传送长度计数。
    4. 规定数据在主存和外设间的传送方向,发出读写等控制信号,执行数据传送操作。
    5. 向$CPU$报告$DMA$操作的结束,发出中断。

$DMA$控制时,$CPU$对主存没有控制权,而$DMA$有。

![dma](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/dma.png)

如上图为$DMA$控制器内部结构:

+ 控制/状态逻辑：由控制和时序电路及状态标志组成,用于指定传送方向,修改传送参数,并对$DMA$请求信号和$CPU$响应信号进行协调和同步。
+ $DMA$请求触发器：每当$I/O$设备准备好数据后给出一个控制信号,使$DMA$请求触发器置位（为$1$）。
+ 主存地址计数器$AR$：存放交换的数据的主存地址,能自动加减$1$。
+ 传送长度计数器$WC$：用来记录传送数据的长度,计数溢出时,数据即传送完毕,自动发中断请求信号。
+ 数据缓冲寄存器：用于暂存每次传送的数据。
+ 中断机构：当一个数据块传送完毕后触发中断机构,向$CPU$提出中断请求。

#### $DMA$传送过程

![image-20230604160123696](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230604160123696.png)

$CPU$只在开始和结尾参与控制,$DMA$控制整个传输过程：

内存→数据总线→$DMAC$（$DMA$控制器）→外设。

+ 预处理：

    + 主存起始地址$\rightarrow$主存地址寄存器$AR$。
    + $I/O$设备地址$\rightarrow DAR$。
    + 传送数据个数$\rightarrow $传送长度计数器$WC$。
    + 启动$I/O$设备

+ 数据传送：继续执行主程序同时完成一批数据的传送。以数据输入为例：

    1. 设备将数据输入数据缓冲寄存器$DR$中。
    2. 写满后向$DMA$请求触发器发送$DMA$请求。
    3. $DMA$控制器向$CPU$申请总线控制权发送$HRQ$信号。
    4. $CPU$将总线控制权交给$DMA$控制器,发送$HLDA$信号,$DMA$控制器接管总线。
    5. $DMA$控制器将地址从主存地址计数器上送到地址线上,将数据从数据缓冲寄存器$DMAC$送到数据线上。
    6. 修改地址和长度参数并返回**传送长度计数器**和主存地址计数器中。

    7. 若传送长度计数器溢出（传输结束）,则向中断机构发出溢出信号,中断机构经总线向$CPU$发出中断信号。

+ 后处理：

    + 中断服务程序
    + 做$DMA$结束处理

+ 继续执行主程序。

#### $DMA$传送方式

+ 主存和$DMA$控制器之间有一条专用数据通路,因此主存和$I/O$设备之间交换信息时,不通过$CPU$。
+ 但当$I/O$设备和$CPU$同时访问主存时,可能发生冲突,为了有效地使用主存,$DMA$控制器与$CPU$通常采用以下三种方法使用主存：
    1. 停止$CPU$访问主存：
        + 控制简单。
        + $CPU$处于不工作状态或保持状态。
        + 未充分发挥$CPU$对主存的利用率。
        + ![image-20230604160332699](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230604160332699.png)
    2. $DMA$和$CPU$交替访存：将一个$CPU$周期分为两个周期,一个给$DMA$使用一个给$CPU$使用：
        + 不需要总线使用权的申请、建立和归还过程。
        + 硬件逻辑更为复杂。
        + ![image-20230604160408365](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230604160408365.png)
    3. 周期挪用（周期窃取）：
        + 周期指主存的存取周期
        + $CPU$此时不访存：不冲突。
        + $CPU$正在访存：存取周期结束让出总线给$DMA$。
        + $CPU$、$DMA$同时请求访存：$DMA$的$I/O$访存优先,挪用几个存取周期。传输一个字后立刻释放总线。
        + ![image-20230604160504385](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230604160504385.png)

#### $DMA$方式特点

+ 主存和$DMA$接口之间有一条直接数据通路——$DMA$总线。
+ 由于$DMA$方式传送数据不需要经过$CPU$,因此不必中断现行程序,$I/O$与主机并行工作,程序和传送并行工作。
+ $DMA$方式具有下列特点:
    1. 它使主存与$CPU$的固定联系脱钩,主存既可被$CPU$访问,又可被外设访问。
    2. 在数据块传送时,主存地址的确定、传送数据的计数等都由硬件电路直接实现。
    3. 主存中要开辟专用缓冲区,及时供给和接收外设的数据。
    4. $DMA$传送速度快,$CPU$和外设并行工作,提高了系统效率。
    5. $DMA$在传送开始前要通过程序进行预处理,结束后要通过中断方式进行后处理。
    6. 不用保护和恢复现场。
    7. 不能立即响应,所以不适合键盘和鼠标这种情景。



### $I/O$方式对比

|  &nbsp;  | $CPU$与外设 | 传送与主程序 |
| :------: | :---------: | :----------: |
| 程序查询 |    串行     |     串行     |
| 程序中断 |    并行     |     串行     |
|  $DMA$   |    并行     |     并行     |

|  &nbsp;  |                中断                |                $DMA$                 |
| :------: | :--------------------------------: | :----------------------------------: |
| 数据传送 | 软件控制,程序的切换→保存和恢复现场 | 硬件控制,$CPU$只需进行预处理和后处理 |
| 请求资源 |           $CPU$处理时间            |              总线使用权              |
|   响应   |           指令周期结束后           |      机器周期结束后,总线事务后       |
|   场景   |         $CPU$控制,低速设备         |       $DMA$控制器控制,高速设备       |
|  优先级  |       非屏蔽中断高于屏蔽中断       |                 最高                 |
| 异常处理 |           能处理异常事件           |              仅传送数据              |
