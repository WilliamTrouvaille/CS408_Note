# 第四章 指令系统

指令和数据是应用上的概念，同一个数据可以被解释为数据也可以被解释为指令。同一串二进制代码，可以是指令，也可以是数据，这决定于我们的程序设计。如$1000100111011000$被应用为数据时，它等于$89D8H$，$H$表示是十六进制。当被应用为指令时，它指的是$MOV\,AX,\,BX$。数据和指令的区分方式在第一章已经说明。

## 指令格式

指如何使用二进制代码表示指令。

操作码+寻址特征码（有多少种寻址方式）+地址码。

### 指令定义

+ 指令（又称机器指令）：是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。
+ 指令系统是计算机软硬件的界面。指令系统指的是计算机执行的机器指令的集合；这里要注意的是微指令是微程序级命令，属于硬件范畴；伪指令是由若干的机器指令组成的指令序列，属于软件范畴；然而机器指令介于两者之间，处于软硬件的交界面；而机器指令集又称为指令系统；所以回答是指令系统。
+ 一台计算机的所有指令的集合构成该机的指令系统，也称为**指令集**。**一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令。**
+ 一条指令通常要包括操作码字段（$OP$）和地址码字段（$A$）两部分。
+ 操作码指出该指令要执行什么操作，地址码指出指令要操作的数据的地址。
+ 指令地址由$PC$给出。
+ 定长指令字结构：所有指令长度相等。执行速度块，控制简单。
+ 变长指令字结构：指令长度随指令功能而异。

### 地址码

+ 一条指令的执行分为三步，如果是两个操作数则四次访存：
    1. 取指令。
    2. 取两个操作数。
    3. 放回结果。
+ 访存是指访问内存，$ACC$在运算器中，访问$ACC$不是访问内存。如果数据在$Cache$中则不用访存。

指令类型：

+ 四地址指令：操作码+操作数$A_1$地址+操作数$A_2$地址+结果地址$A_3$+下指令地址$A_4$。
    + $(A_1)OP(A_2)\rightarrow A_3$。
+ 三地址指令：操作码+操作数$A_1$地址+操作数$A_2$地址+结果地址$A_3$。
    + 下一条指令的寻址靠程序计数器$PC$完成。
    + 一共访存四次。
    + $(A_1)OP(A_2)\rightarrow A_3$。
+ 二地址指令：操作码+操作数$A_1$地址+操作数$A_2$地址。
    + 将结果存到操作数$A_1$地址或操作数$A_2$地址中。取指令，取数$A_1$和$A_2$，存放到$A_1$或$A_2$。一共访存四次。$(A_1)OP(A_2)\rightarrow A_1$。
    + 若使用累加器$ACC$暂存结果则只用访存三次，取指令，取数$A_1$和$A_2$，暂存到$ACC$。$(A_1)OP(A_2)\rightarrow ACC$。
+ 一地址指令（单地址指令）：操作码+操作数地址：
    + 只需要一个操作数的指令操作，如加一、减一、取反、求补等。取出指令、取出数、操作、放回，只需要三次访存。$OP(A)\rightarrow A$。
    + 隐含约定的目的地址的双操作数指令，如目的地址为累加器$ACC$的地址。取指令和取数，只需要两次访存。$(ACC)OP(A)\rightarrow ACC$。
+ 零地址指令：只有操作码：
    + 不需要操作数。如空操作、停机、关中断等。
    + 堆栈计算机，两个操作数隐含存放在栈顶和次栈顶，计算结果压回栈顶。
+ 用硬件资源减少地址码字段的优势：
    + 扩大指令寻址范围。
    + 缩短指令字长。
    + 减少访存次数。

### 指令字长

+ 固定：指令字长=存储字长。
+ 可变：按字节的倍数变化。
+ 指令字长取决于：
    1. 操作码长度。
    2. 操作数地址长度。
    3. 操作数地址个数。



机器字长：$CPU$进行一次整数运算所能处理的二进制数据的位数（通常和$ALU$直接相关）

存储字长：一个存储单元中的二进制代码位数（通常和$MDR$位数相同）

### 操作码

#### 定长操作码

+ 指令字的最高位部分分配固定的若干位表示操作码。
+ 若有$n$位操作码，则有$2^n$条指令。
+ 优点：能简化计算机硬件设计，提高指令译码和识别速度。
+ 缺点：指令数量增加时会占用更多固定位，留给表示操作数地址的位数有限。
+ 一般这种操作码用于指令字长较长的情况。
+ 控制器的译码电路设计简单，但灵活性较低

#### 可变长操作码

+ 控制器的译码电路设计复杂，但灵活性较高

##### 拓展操作码

定长指令字结构+可变长操作码

+ 拓展操作码是可变长操作码实现的一种，让操作码长度随地址码减少而增加。
+ 操作码的位数至少为当种指令总条数的二对数。如指令总长度为$32$位，二地址指令有$27$条，则二地址指令的操作码至少有$27=2^4+11=5$位，否则不能操作这么多地址。
    + ![image-20230601224859074](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230601224859074.png)
    + 在设计扩展操作码指令格式时，必须注意以下两点：
        + **不允迕短码是长码的前缀**，即短操作码不能与长操作码的前面部分的代码相同。
        + 各指令的操作码一定不能重复。
    + 通常情况下，对使用频率较高的指令，分配较短的操作码；对使用频率较低的指令，分配较长的操作码，从而尽可能减少指令译码和分析的时间。
+ 优点：在指令字长有限的前提下能保持比较丰富的指令种类。
+ 缺点：增加了指令译码和分析的难度，使控制器的设计复杂化。

![image-20230601225659206](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230601225659206.png)

+ 假设指令字长为$16$位，前$4$位为基本操作码字段$OP$，另有$3$个$4$位长的地址字段$A_1$、$A_2$和$A_3$。$4$位基本操作码若全部用于三地址指令，则有$16$条。
+ 但至少须将当前位的$1111$留作扩展操作码之用，即三地址指今为$15$条($0000\sim 1110$)。所以目前就留下来了前$4$位操作数为$1111$的指令，这是只有四位操作码。
+ 然后将留下来的指令的操作码位拓展为八位，将$A_1$的位也用作操作码，即将$1111\,0000\,A_1\,A_2 \sim 1111\,1011\,A_1\,A_2$(这里的$A_1\,A_2$表示二地址指令中的操作数1和操作数2,下同)作为二地址指令，二地址指令为$12$条。同样将$1111\,11**$的指令作为下一个拓展操作码备用。
+ 同样将留下来的指令的操作码拓展为十二位，将$A_1A_2$的位用作操作码，即将$1111\,1100\,0000\,A_1 \sim 1111\,1111\,1101\,A_1$作为一地址指令，一地址指令为$62$条。同样将$1111\,1111\,111*$的指令作为下一个拓展操作码备用。
+ 最后将操作码拓展为十六位，将$A_1A_2A_3$全部作为操作码，即将$1111\,1111\,1110\,0000$到$1111\,1111\,1111\,1111$作为零地址指令，零地址指令为$32$条。

假设地址长度为$n$，上一层留出$m$种状态，则下一层可以拓展出$m\times2^n$种状态。所以也可以形成任意种不同拓展方法。

### 操作类型

1. 数据传输：
    1. $MOV$：寄存器之间的传送。
    2. $LOAD$：把存储器的数据放到$CPU$寄存器中。
    3. $STORE$：把$CPU$寄存器的数据放到存储器中。
2. 算术逻辑：
    1. 算术：加$ADD$、减$SUB$、比较$CMP$、乘$MUL$、除$DIV$、自加一$INC$、自减一$DEC$、求补、浮点运算、十进制运算。
    2. 逻辑：与$AND$、或$OR$、非$NOT$、异或$XOR$、位操作、位测试、位清除、位求反。
3. 移位操作：
    1. 算术移位。
    2. 逻辑移位。
    3. 循环移位（带进位和不带进位）。
4. 转移操作：调用指令必须保存下一条指令的地址，当子程序结束时要返回主程序继续执行，而转移指令不用返回执行。
    1. 无条件转移：$JMP$。将地址码送入$PC$。
    2. 条件转移：$BRANCH$，如$JZ$：结果为$0$；$JO$：结果溢出；$JC$：结果进位。
    3. 调用$CALL$和返回$RET$。
    4. 陷阱$TRAP$和陷阱指令。（意外事故的中断）
5. 输入输出操作。