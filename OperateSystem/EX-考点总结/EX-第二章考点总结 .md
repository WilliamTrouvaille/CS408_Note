# EX-第二章 进程管理考点总结

## 导读

### 【考纲内容】

1. 进程与线程
    + 进程与线程的基本概念
    + 进程/线程的状态与转换
    + 线程的实现：内核支持的线程、线程库支持的线程
    + 进程与线程的组织与控制
    + 进程间通信：共享内存、消息传递、管道
2. $CPU$调度与上下文切换

    + 调度的基本概念
    + 调度的目标

    + 调度的实现：调度器/调度程序、调度的时机与调度方式（抢占式/非抢占式）、闲逛进程、内核级线程与用户级线程调度
    + 典型调度算法
        + 先来先服务调度算法
        + 短作业\短进程\短线程优先调度算法
        + 时间片轮转调度算法
        + 优先级调度算法
        + 高响应比优先调度算法
        + 多级队列调度算法
        + 多级反馈队列调度算法
    + 上下文及其切换机制
3. 同步与互斥
    + 同步与互斥的基本概念
    + 基本的实现方法：软件方法、硬件方法
    + 锁
    + 信号量
    + 条件变量
    + 经典同步问题
        + 生产者-消费者问题
        + 读者-写者问题
        + 哲学家进餐问题
4. 死锁
    1. 死锁的基本概念
    2. 死锁预防
    3. 死锁避免
    4. 死锁检测和解除

### 【复习提示】

综合题：利用信号量进行进程同步（必考）。

选择题：进程的概念、进程调度、信号量机制实现同步和互斥、进程死锁、信号量机制实现同步和互斥。

## 选择题考点总结

### 进程与线程概述

1.   进程相关概念：建议结合马克思主义基本原理学习（？
     1.   程序：一个指令序列。进程和程序的根本区别在于其动态性。
     2.   **进程控制块$PCB(Process\;Control\;Block)$**：系统为每个运行的程序配置的数据结构，用来描述进程的各种信息，如程序代码存放位置。$PCB$是进程存在的唯一标志。
     3.   **进程实体/进程映像**：$PCB$、程序段、数据段三个部分。
     4.   进程：是进程实体的运行过程，是系统进行**资源分配和调度**的一个独立单位。
     5.   程序段/代码段：包括程序代码，程序运行时使用、产生的运算数据，往往是**只读的**。只读代表不是临界资源，**可以被多个进程同时访问**。
     6.   数据段：存放程序运行过程中处理的各种数据。如全局变量、静态变量、宏定义的常量。
     7.   堆：用来存放动态分配的变量，如调用`malloc`函数动态地向高地址分配空间。
     8.   栈：用来实现函数调用，保存局部变量、函数传递参数，从用户空间的高地址向低地址增长。
2.   进程特征

     1.   动态性：是进程最基本的特征，进程是程序的一次执行过程，是动态地产生、变化和消亡的。
     2.   并发性：内存中有多个进程实体，各进程可并发执行。

     3.   独立性：进程是资源分配、接受调度、能独立运行、独立获得资源、独立接受调度的基本单位。
     4.   异步性：各进程按各自独立的、不可预知的速度向前推进。异步性会导致并发程序执行结果的不确定性，操作系统要提供“进程同步机制”来解决异步问题。
     5.   结构性：每个进程都会配置一个$PCB$，结构上看，进程由程序段、数据段、$PCB$组成。
3.   进程组织：当一个系统中存在多个$PCB$时，需要以适当的方式组织$PCB$。

     1.   链接方式：按照进程状态将$PCB$分为多个队列。操作系统持有指向各个**队列**的指针。
     2.   索引方式：根据进程状态将$PCB$分为多个索引表。操作系统持有指向各个**索引表**的指针。
4.   进程状态：挂起态不常考，重点掌握阻塞相关内容。

     1.   运行态：占有$CPU$并已经在$CPU$上运行。单核$CPU$中同一时刻只会有一个进程处于运行态；多核$CPU$情况下，可能有多个进程处于运行态。
     2.   就绪态：已经具备运行条件（除处理机外的一切所需资源），但是由于没有空闲$CPU$，导致暂时不能运行。
     3.   **阻塞态/等待态**：因等待某一事件而暂时不能运行，只有分配其他资源到位才能考虑分配$CPU$。进程映像还在**内存**。**即使$CPU$空闲也不能运行**。
     4.   **创建态/新建态**：为进程分配所需的内存空间等系统资源，将转为就绪态。申请空白$PCB$的时候不考虑申请失败的情况。
     5.   **终止态/结束态**：进程运行结束或出现错误后，操作系统回收进程资源，并撤销$PCB$，以防止内存泄漏。
     6.   挂起态：暂时不能获得服务，进程映像调到**外存**等待（对应进程的$PCB$还在内存中等待并允许被修改）。分为
          1.   就绪挂起态：准备好后在外存中，只要允许可以随时进入内存。
          2.   阻塞挂起态：等待事件在外存中，必须等待一定时间发生。
5.   进程状态转换：重点掌握五状态模型。**不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态**。

     1.   运行态$\to$阻塞态：进程主动用系统调用的方式申请某种系统资源（如请求$I/O$），或请求等待某个事件发生。
          1.   例如需要等待事件的发生（如等待键盘响应）、自我阻塞等。
          2.   进入阻塞态是**进程主动请求**，只能在运行时才能发出这种请求，故（不考虑阻塞挂起）除了运行态没有其他进入阻塞态的方法。
     2.   阻塞态$\to$就绪态：申请的资源被分配或等待的事件发生，被动发生，由操作系统完成。
     3.   运行态$\to$就绪态：**时间片结束**或**处理机被抢占**。

6.   进程控制：是对系统中的所有进程实施有效的管理，具有创建新进程、撤销已有进程、实现进程状态转换功能。通过将$PCB$指针放入各种状态的进程队列中转换进程状态来实现控制。进程控制具体由**原语**实现。（进程控制原语见下）
     1.   父子进程：允许一个进程创建另一个进程，此时创建者称为父进程，被创建的进程称为子进程。子进程可以继承父进程所拥有的资源，当子进程被撤销时，应将其从父进程那里获得的资源归还给父进程。此外，在撤销父进程时，必须同时撤销其所有的子进程。
          1.   父进程创建子进程后，父进程与子进程同时执行（并发）。
          2.   主程序调用子程序后，主程序暂停在调用点，子程序开始执行，直到子程序返回，主程序才开始执行。
          3.   ※父进程和子进程**可以共享一部分资源**，但是**不能共享虚拟地址空间**，因为是逻辑地址且其有不同的$PCB$用于区分进程。
7.   进程通信：两个进程之间的数据交互。为了保证安全，一个进程不能直接访问另一个进程的地址空间，但是又必须有进程通信。
     1.   共享存储：分配一个可以共同使用的共享空间，进程对其的使用必须是互斥的（使用同步互斥工具如$PV$操作）。
          1.   基于数据结构的实现：共享空间只能放固定的数据结构如数组等。速度慢，限制多，是低级通信方式。
          2.   基于存储区的实现：内存中划出一块共享存储区，数据的形式、存放位置都由进程控制而非操作系统。速度更快，限制少，是高级通信方式。

     2.   信息传递：进程间的数据交换以格式化的消息为单位，进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。消息包括消息头和消息体。消息头又包括：发送进程$ID$、接受进程$ID$、消息类型、消息长度等格式化的信息
          1.   直接通信方式：消息直接挂到接受进程的信息缓冲队列上。
          2.   间接通信方式：消息先发送到中间实体（信箱）中，因此也称为信箱通信方式。如计算机网络中的电子邮件系统。

     3.   管道通信：消息传递的特殊方式，管道指用于链接各自一个的读写进程的一个共享文件，又名$pipe$文件，其实就是内存中开辟一个大小**固定**的缓冲区。两个进程使用生产者-消费者的方式进行通信。数据以字符流的形式写入管道。
          1.   ※管道只能往单向方向通信：只能使用半双工的通信，**同一时间段**内只能**单向**传输，若要**双向同时**通信则必须设置两个管道。
          2.   如果没有**写满**则不允许读，如果没有**读空**则不允许写，所以**读写都可能被堵塞**。
          3.   管道中的数据一旦被读出，就彻底消失：当多个进程读同一个管道时，可能会错乱。通常有两种解决方案。
               1.   一个管道允许多个写进程一个读进程($2014$年$408$真题高教社官方答案)。以这个说法为主。
               2.   允许有多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据($Linux$的方案)。但这个说法也没错。


### 进程控制原语

1.   ※过程创建（创建态$\to$就绪态）：申请空白$PCB$。向$PCB$填写进程的信息。系统为进程分配除处理机外的一切所需资源。进程转为就绪态。
     1.   用户登录：分时系统中，用户登录成功，系统会为其建立一个新进程。
     2.   作业调度：多道批处理系统中，有新的作业进入内存时，会为其创建一个新进程。
     3.   提供服务：用户向系统提出请求时，会创建一个新进程来处理请求。
     4.   应用请求：由用户进程主动请求创建一个子进程。
2.   进程终止（就绪态/阻塞态/运行态$\to$终止态）：根据标识符从$PCB$集合中找到欲终止进程的$PCB$​。若进程还在运行，则立刻剥夺其$CPU$交给其他进程。若是普通的终止，父进程终止时会将其子进程交给$init$进程收养。若是终止整个进程组的进程，则终止其所有子进程。将进程所有的资源交给父进程或操作系统并从所在队列或链表中删除$PCB$。
     1.   正常结束：任务完成，进程自己请求终止（$exit$系统调用）。
     2.   异常结束：内部异常，如存储区越界、保护错、运行超时等。例如整数除以$0$、非法使用特权指令。
     3.   外界干预：外部请求而终止运行。如操作员或操作系统干预、父进程请求、父进程终止。
3.   进程阻塞（运行态$\to$​阻塞态）：找到对应的$PCB$，**保护进程运行现场**，将$PCB$状态信息设置为阻塞态，暂停进程。将$PCB$插入事件等待队列，将处理机资源调度给其他就绪态进程。
     1.   需要等待系统分配资源。
     2.   需要等待相互合作的其他进程完成工作。
4.   进程唤醒（阻塞态$\to$**就绪态**）：找到对应的$PCB$，将$PCB$从等待队列中移除，设置进程为就绪态。将$PCB$插入就绪队列，等待被调度。
     +   发生了等待的事件（因什么事件被阻塞就应该被什么事件唤醒），所以进程阻塞和进程唤醒应该是成对出现的。
5.   进程切换（运行态$\to$​就绪态/终止态）：将处理机上下文信息，包括程序计数器$PC$和其他寄存器信息存入$PCB$。$PCB$移入相应队列。选择另一个进程执行，并更新其$PCB$。更新内存管理的数据结构。根据$PCB$恢复新进程所需的运行环境。
     1.   运行态$\to$就绪态：当前时间片到，有更高优先级进程到达
     2.   运行态$\to$终止态：当前进程终止。

### 线程

#### 线程概述

1.   线程：线程由线程$ID$、程序计数器$PC$、寄存器集合和堆栈组成。线程是**$CPU$执行的基本单元**，是程序执行流的最小单位，是**处理机的分配单元**。进程只作为**除$CPU$之外的系统资源**的分配单元，即**打印机等都是分配给线程**而不是进程。
2.   线程属性
     1.   线程是处理机调度的单位：线程不拥有系统资源，但可以访问隶属于进程的资源，共享进程的地址空间，同一进程的不同线程间共享进程的资源。**没有独立地址空间**。
     2.   动态性是进程最重要的特性，以此来区分文件形式的静态程序。
     3.   线程也有就绪、阻塞、运行三种基本状态。
     4.   同一进程中的线程切换，不会引起进程切换；不同进程中的线程切换，会引起进程切换。
3.   线程与进程
     1.   系统分配调度：进程是**资源分配**的基本单位，线程是**调度**的基本单位。同一进程中，线程切换不会导致进程切换，在不同进程进行线程切换才会引起进程切换
     2.   拥有资源：进程都是拥有资源的基本单位，线程除了必备的资源不拥有系统资源。线程可以拥有同进程的所有资源，且同进程的所有线程共享进程地址空间。
     3.   并发性：进程和线程之间均可并发。
     4.   系统开销：进程间并发，需要切换进程的运行环境，系统开销较大。线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小。且同一进程多个线程共享进程地址空间，所以线程同步通信非常容易。
     5.   地址空间和其他资源：进程间不可见，同一进程的线程间可见
     6.   通信：进程间通信$IPC$需要进程同步和互斥来保证一致性，线程间可以通过共享进程地址空间直接读写进程数据段如全局变量。
4.   线程的状态与转换：与进程的状态与转换类似。
     1.   线程控制块$TCB$（$Thread\;Control\;Block$）：是与进程的控制块$PCB$相似的子控制块，只是$TCB$中所保存的线程状态比$PCB$中保存少而已。**只有内核级线程才有$TCB$**。
     2.   线程表：将多个$TCB$组织成一张线程表。通过线程表，操作系统可以集中管理和跟踪所有线程的状态、上下文和其他重要信息。它提供了一种有效的方式来实现线程的创建、销毁、调度和同步。线程表的结构和内容可能因操作系统的不同而有所差异，但它们的基本功能和作用是相似的。

#### 线程实现

线程实现：线程库（$thread\;library$）是为程序员提供创建和管理线程的$API$。线程库中的线程都是单例模式，所以不同的进程使用线程库中的同名线程都是同一个线程。

1.   用户级线程$ULT(User-Level\;Thread)$：由应用程序通过线程库实现，所有的线程管理工作都由应用程序负责（包括线程切换）。用户级线程中，线程切换可以在**用户态**下即可完成，**无需操作系统干预**。用户级线程不需要内核的支持，与系统平台无关，对线程管理的代码是属于用户程序的一部分。
     1.   用户级线程对用户不透明，**对操作系统透明**：在操作系统内核看来，并意识不到用户级线程的存在。
     2.   优点
          1.   线程切换不需要转换到内核空间，节省了模式切换的开销。
          2.   调度算法可以是进程专用的，不同的进程可根据自身的需要，对自己的线程选择不同的调度算法。
          3.   用户级线程的实现与操作系统平台无关，对线程管理的代码是属于用户程序的一部分。
     3.   缺点
          1.   当线程执行一个系统调用时，不仅该线程被阻塞，而且**进程内的所有线程都被阻塞**。
          2.   不能发挥多处理机的优势，内核每次分配给一个进程的仅有一个$CPU$，因此进程中仅有一个线程能执行。
2.   内核级线程$KLT(Kernel-Level\;Thread)$：管理工作均由操作系统内核完成，内核级线程的切换必然需要在**核心态**下才能完成。**操作系统只能看见内核级线程**，所以只有内核级线程才是处理机分配的单位。
     1.   优点
          1.   能发挥多处理机的优势，内核能同时调度同一进程中的多个线程并行执行。
          2.   如果进程中的一个线程被阻塞，内核可以调度该进程中的其他线程占用处理机，也可运行其他进程中的线程。
          3.   内核支持线程具有很小的数据结构和堆栈，线程切换比较快、开销小。
          4.   内核本身也可采用多线程技术，可以提高系统的执行速度和效率。
     2.   缺点：**同一进程**中的线程切换，需要从用户态**转到核心态**进行，系统开销较大。因为用户进程的线程在用户态运行，而线程调度和管理是在内核实现的。
3.   组合方式：内核支持多个内核级线程的建立、调度和管理，同时允许用户程序建立、调度和管理用户级线程。一些内核级线程对应多个用户级线程，这是用户级线程通过时分多路复用内核级线程实现的。同一进程中的多个线程可以同时在多处理机上并行执行，且在阻塞一个线程时不需要将整个进程阻塞。


#### 多线程模型

组合方式同时支持用户线程和内核线程，对于用户级线程如何映射到内核级线程的问题出现了“多线程模型”问题

1.   多对一模型：多个用户级线程映射到一个内核级线程。每个用户进程只对应一个内核级线程，多个用户级线程共用一个线程控制块。
     1.   由于只有一个内核级线程，用户级线程的“多”对操作系统透明，操作系统内核只能感到一个调度单位（一个内核级线程）的存在。**该进程的一个线程被阻塞后该进程与该进程中其他线程也都被阻塞**。
     2.   优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高。
     3.   缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。
2.   一对一模型：一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程，操作系统给每个用户线程建立一个线程控制块。
     1.   优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。
     2.   缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。
3.   多对多模型：在同时支持用户级线程和内核级线程的系统中，可以使用二者结合的方式，将$n$个用户级线程映射到$m$个内核级线程上（$n\ge m$ ）。
     +   克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。

### 处理机调度

#### 处理机调度概述

1.   处理机：包括中央处理器，主存储器，输入输出接口，加接外围设备就构成完整的计算机系统。处理机是处理计算机系统中存储程序和数据，并按照程序规定的步骤执行指令的部件。
2.   处理机调度：在多道程序设计系统中，内存中有多道程序运行，他们相互争夺处理机这一重要的资源。处理机调度就是从就绪队列中，按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程并发地执行。
3.   处理机调度的层次：从上往下，发生频率依次递增。
     1.   作业调度/高级调度：按照某种规则，从后备队列中选择合适的**作业**将其调入内存，并为其创建进程。多道批处理系统多具备，其他系统一般不需要。调入的时机需要操作系统来确定，但调出的时机必然是**作业运行结束**才调出、
          +   外存$\to$内存（面向作业）；无$\to$创建态$\to$就绪态。
     2.   内存调度/中级调度：按照某种规则，从**挂起队列**中选择合适的进程将其数据调回内存。
          +   外存→内存（面向进程）；挂起态→就绪态。
     3.   进程调度/低级调度：按照某种规则，从**就绪队列**中选择一个进程为其分配处理机。
          +   内存→$CPU$；就绪态→运行态。
4.   评价指标
     1.   $CPU$利用率：$CPU$忙碌时间占总时间的比例。$CPU$是计算机系统中最重要和昂贵的资源之一，所以应尽可能使$CPU$保持“忙”状态，使这一资源利用率最高
          +   $CPU$利用率$=CPU$忙碌（运行）时间$\div$进程运行总时间。
     2.   系统吞吐量：单位时间内完成**作业**的数量。

          + 系统吞吐量$=$总共完成多少道作业$\div$总时间。
     3.   周转时间：从作业**被提交到系统**开始到**作业完成**为止的时间间隔。
          1.   周转时间包括四个部分：后三项在一个作业的整个处理过程中，可能发生多次。

               1. 作业在外存后备队列上等待作业调度（高级调度）的时间。
               2. 进程在就绪队列上等待进程调度（低级调度）的时间。
               3. 进程在$CPU$上执行的时间。
               4. 进程等待$I/O$操作完成的时间。
          2.   （作业）周转时间$=$作业完成时间$-$作业提交时间。
          3.   平均周转时间$=$各作业周转时间之和$\div $作业数。
          4.   带权周转时间$=$作业周转时间$\div$作业实际运行的时间$\geqslant1$。是一个比值，越靠近$1$越合理。
          5.   平均带权周转时间$=$各作业带权周转时间之和$\div$作业数。
     4.   等待时间：指进程或作业处于等待处理机状态时间之和。
          1.   对于进程来说，等待时间就是指进程建立后等待被服务的时间之和。在等待$I/O$完成的期间其实进程也是在被服务的，所以不计入等待时间。
               +   等待时间$=$周转时间$-$运行时间。
          2.   对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。一个作业总共需要被$CPU$服务多久，被$I/O$设备服务多久一般是确定不变的，因此**调度算法只会影响作业或进程的等待时间**。
               +   等待时间$=$周转时间$-$运行时间$-I/O$操作时间。
     5.   响应时间：从用户提交请求到首次产生响应所用的时间。主要用于交互式系统。

#### 进程调度概述

进程调度是最低级的调度也是其他调度的基础，是内核程序。进程调度就是上面三级调度里面的那个进程调度。

**进程切换是有代价的**，因此如果**过于频繁**的进行进程调度和切换，会使整个系统的效率降低。

1.   调度程序（调度器）：用于调度和分派$CPU$的组件称为调度程序。
     1.   排队器：将系统中的所有就绪进程按照一定的策略排成一个或多个队列，以便于调度程序选择。每当有一个进程转变为就绪态时，排队器便将它插入到相应的就绪队列中。
     2.   分派器：依据调度程序所选的进程，将其从就绪队列中取出，将$CPU$分配给新进程。
     3.   上下文切换器：在上下文切换时，需要执行大量`load`和`store`指令，以保存寄存器的内容，因此会花费较多时间。在对处理机进行切换时，会发生两对上下文的切换操作
          1.   第一对，将当前进程的上下文保存到其$PCB$中，再装入分派程序的上下文，以便分派程序运行。
          2.   第二对，移出分派程序的上下文，将新选进程的$CPU$现场信息装入处理机的各个相应寄存器。
2.   进程调度的时机
     1.   需要进行进程调度和切换
          1.   当前运行程序**主动**放弃处理机（非剥夺调度）：进程正常终止、出现异常终止、进程主动请求阻塞（如等待$I/O$）。
          2.   当前运行程序**被动**放弃处理机（剥夺式调度）：分配时间片用完、有更紧急的事件需要处理（如$I/O$中断）、优先级更高进程进入就绪队列、中断处理结束、自陷处理结束。
     2.   不能进行进程调度和切换
          1.   在**处理中断**的过程中：中断处理过程复杂，很难做到在中断处理过程中进行进程切换；中断与硬件密切相关，不属于某一进程。
          2.   进程在操作系统**内核程序临界区**中。
          3.   在**原子操作**过程中（**原语**）：原子操作不可中断，更不能切换进程，要一气呵成（如修改$PCB$中进程状态标志，并把$PCB$放到相应队列）。
3.   进程调度的方式：针对操作系统是否可以剥夺进程处理机分类
     1.   非剥夺调度方式，又称非抢占方式：只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。适合于早期的批处理系统。
     2.   剥夺调度方式，又称抢占方式：当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过**时钟中断**）。适合于分时操作系统、实时操作系统。
4.   调度程序
     1.   调度程序决定：调度算法、**分配时间片大小**。
     2.   触发调度程序的时机：创建新进程、进程退出、运行进程阻塞、$I/O$中断发生（可能唤醒某些阻塞进程）。
     3.   调度策略：非抢占式调度策略、抢占式调度策略（**时钟中断**）。
     4.   调度程序的处理对象：不支持内核级线程的操作系统，调度程序的处理对象是**进程**；支持内核级线程的操作系统，调度程序的处理对象是**内核线程**。
5.   闲逛进程：优先级最低，没有就绪进程时才会运行闲逛进程，只要有进程就绪，就会立即让出处理机。由系统内核创建和管理的。主要目的是让$CPU$保持忙碌以防止进程调度器进入无限循环的情况。闲逛进程不需要$CPU$之外的资源，它不会被阻塞。
6.   线程调度
     1.   用户级线程调度：用户级线程对内核透明，所以内核还是和以前一样，选择一个**进程**，并给予时间控制。由进程中的调度程序决定哪个线程运行。用户级线程的线程切换在同一进程中进行，仅需少量的机器指令。
     2.   内核级线程调度：。内核选择一个特定**线程**运行，通常不用考虑该线程属于哪个进程。对被选择的线程赋予一个时间片，如果超过了时间片，就会强制挂起该线程。内核级线程的线程切换需要完整的上下文切换、修改内存映像、使高速缓存失效，这就导致了若干数量级的延迟。

#### ※※调度算法

调度算法的调度对象是作业或进程，调度算法只会影响作业或进程的等待时间。

1.   先来先服务调度算法$FCFS$：按照作业/进程到达的先后顺序进行服务。非抢占式。不会导致饥饿。既可用于作业调度，又可用于进程调度。

     1.   对短作业不利：排在长作业/进程后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。**不能作为分时系统和实时系统的主要调度策略**。
     2.   对长作业有利，适用于长作业类型：利于$CPU$繁忙型作业，不利于$I/O$繁忙型作业。$CPU$繁忙型更接近于长作业，少$I/O$所以少中断；$I/O$繁忙型则相反。

2.   短作业优先调度算法$SJF$（$Shortest \;Job\; First$）：最短的作业/进程优先得到服务。非抢占式。会导致**短**作业/进程饥饿。即可用于作业调度，也可用于进程调度。

     1.   对短作业有利，对长作业不利
     2.   一般来说（默认）$SJF$的平均等待时间、平均周转时间，但是严格意义上并不一定最少，最好先判断其他选项。

3.   高响应比优先调度算法$HRRN$（$Highest \;Response \;Ratio\; Next$）：在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务。非抢占式。不会导致饥饿。即可用于作业调度，也可用于进程调度，但是主要用于作业调度。

     1.   响应比：其中$T_W$表示等待时间，$T_s$表示服务时间。
          $$
          R_P=\dfrac{T_W+T_s}{T_s}\geqslant1
          $$

     2.   等待时间相同时，要求服务时间短的优先，有利于短作业。

     3.   要求服务时间相同时，等待时间长的优先。

     4.   对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而**避免了长作业饥饿**的问题。

4.   优先级调度算法$PS$（$Priority Scheduling Algorithm$）：选择优先级最高的作业/进程。抢占式、非抢占式都有，看题目表述。会导致低优先级进程饥饿。既可用于作业调度，也可用于进程调度。

     1.   优先级顺序：**$I/O$繁忙型作业要高于计算繁忙型作业**（以防数据丢失），系统进程的优先权应高于用户进程优先权，前台进程高于后台进程（即交互性进程高于非交互性进程）。
     2.   根据优先级是否可以动态改变可以分为：静态优先级（固定不变）、动态优先级（动态调整）。

5.   时间片轮转调度算法$RR$（$Round -Robin\;Scheduling\;Algorithm$）：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片。若进程未在一个时间片内执行完（**时钟中断**），则剥夺处理机，将进程重新放到**就绪队列**队尾重新排队。属于**抢占式**。用于进程调度。不会导致饥饿。

     1.   响应快，适用于分时操作系统。
     2.   时间片太大退化为先来先服务算法$FCFS$，时间片太小频繁的进程切换增加时间开销。

6.   多级反馈队列调度算法$MFQ$：对时间片轮转调度算法和优先级调度算法的折中权衡，动态调整进程优先级和时间片大小。属于**抢占式**。用于进程调度。会导致饥饿。

     1.   除了可能导致饥饿外，一般不认为$MFQ$算法有缺点。
     2.   ※设计多级反馈队列调度算法时需要考虑的因素有：就绪队列的数量、就绪队列的优先级、各就绪队列的调度算法、进程在就绪队列间的迁移条件。

---

小结

1.   导致饥饿的算法：短作业优先调度算法$SJF$（长作业），优先级调度算法$PS$（低优先级进程），多级反馈队列调度算法$MFQ$。
2.   抢占式：优先级调度算法$PS$，时间片轮转调度算法$RR$，多级反馈队列调度算法$MFQ$。
3.   非抢占式：先来先服务调度算法$FCFS$，短作业优先调度算法$SJF$，高响应比优先调度算法$HRRN$。

### 同步与互斥

#### 进程同步与互斥概述

1.   **同步**：亦称**直接制约关系**。同步是由于并发进程之间需要协调完成同一个任务时引起的一种关系，是一个进程等待另一个进程向它直接发送消息或数据时的一种制约关系。各并发执行的进程以各自**独立的、不可预知的**速度向前推进，即进程具有异步性的特征。
2.   互斥：由并发进程之间竞争系统的临界资源引起的，是一个进程等待另一个进程已经占有的必须互斥使用的资源时的一种制约关系。
3.   临界资源：一个时间段内只允许一个进程使用的资源称为临界资源。许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。临界资源访问如下
     1.   进入区：负责检查是否可进入临界区，若可进入则应设置**正在访问临界资源**的标志（上锁），以阻止其他进程同时进入临界区。
     2.   临界区（临界段）：实际访问临界资源的代码。**临界区不是临界资源**。
     3.   退出区：负责解除**正在访问临界资源**的标志（解锁）。
     4.   剩余区：做其他处理。
4.   互斥访问：前三个准则必须满足。
     1.   空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。
     2.   忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待。
     3.   有限等待：对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）。
     4.   让权等待：当进程不能进入临界区时，应立即释放处理机，防止进程处于忙等待状态。
5.   互斥锁（$mutex \;lock$）：一个进程在进入临界区时应获得锁，在退出临界区时释放锁。函数$acquire($)获得锁，而函数$release()$释放锁。$acquire()$或$release()$的执行必须是原子操作，因此互斥锁通常采用硬件机制来实现。
     +   存在忙等待现象：违反了**让权等待**的原则，进程时间片用完才下处理机。
6.   硬件实现：
     1.   中断屏蔽：利用“开/关中断指令”实现。因为开/关中断指令只能运行在内核态，只适用于操作系统内核进程。不适用于多处理机，不适用于用户进程。
     2.   硬件指令
          1.   $TSL$指令（$Test\;And\;Set\;Lock$）：把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作。
          2.   $Swap$指令：也叫$Exchange$指令。功能和$TSL$指令差不多。

#### 进程互斥软件实现

变量`turn`用来表示允许进入临界区的进程编号，布尔型数组`flag[]`数组中各个元素用来标记各进程想进入临界区的意愿

1.   单标志法：两个进程在**访问完临界区**后会把使用临界区的权限转交给另一个进程，也就是说**每个进程进入临界区的权限只能被另一个进程赋予**。设置一个公用整型变量`turn`用来表示允许进入临界区的进程编号，若`turn=0`则允许$P_0$进入临界区。

     +   违背了**空闲让进**的原则。

2.   双标志先检查法：设置一个布尔型数组`flag[]`，数组中各个元素用来标记各进程想进入临界区的意愿。例如`flag[0]=ture`意味着$0$号进程$P_0$现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志`flag[i]`设为`true`，之后开始访问临界区。

     +   违反**忙则等待**原则。

3.   双标志后检查法：先将自己标志位设置为`true`再检查对方的标志位，若对方也为`true`则等待，否则进入临界区。

     +   违背了**空闲让进**和**有限等待**原则。

4.   $Peterson$算法：主动让对方先使用临界区。每个进程再设置自己的标志后再设置一个变量`turn`不允许进入标志的值，再同时检测另一个进程的状态标志位与不允许进入标志。

     +   未遵循**让权等待**的原则。


#### 信号量

所有同步操作详解见大题部分。

1.   信号量：就是一个变量，可以用一个信号量来表示系统中某种资源的数量。信号量可以是一个整数，也可以是更复杂的记录型变量。
2.   原语：一种特殊的程序段，其执行只能一气呵成，不可被中断。由关中断/开中断指令实现。
3.   `wait(S)`原语（$P$操作）：用于**申请**一个命名的信号量$S$，并尝试将其值减一。如果$S$的值大于等于$1$，则减一后继续执行后续指令。如果$S$的值为$0$，表示资源已被占用，申请的进程将进入阻塞状态，等待其他进程通过`signal(S)`原语释放资源。
4.   `signal(S)`原语（$V$操作）：用于**释放**一个命名的信号量$S$，并尝试将其值加一。如果有进程正等待$S$，则唤醒其中一个进程，使其从阻塞状态转为就绪状态。如果没有进程在等待$S$，或者$S$的值大于等于$1$，则加一后继续执行后续指令。
5.   整型信号量：用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。对信号量的操作只有三种，即初始化、$P$操作、$V$操作。
     +   不满足**让权等待**原则。
6.   记录型信号量：带等待队列的整型信号量。可以在资源已分配完毕时自动阻塞并插入该类资源的等待队列中。
     +   **遵循了让权等待**原则，不会出现忙等现象。
7.   信号量数值
     1.   $value>0$表示某类可用资源的数量，每次$P$操作，意味着请求分配一个单位的资源。
     2.   $value\ge0$表示某类资源已经没有，或者说还有因请求该资源而被阻塞的进程。
     3.   $value\le0$时的绝对值，表示等待进程数目。

#### 管程

1.   管程：定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据。
2.   ※管程组成：如果在选项中看到**管程外**这个字眼，那就是错误的，管程的组成都是基于**管程内部**的。
     1.   局部于管程的**共享数据结构**（临界区）与**其说明**。
     2.   对该数据结构进行操作的一组过程或函数。没有对过程的说明。
     3.   对局部于管程的**共享数据**设置初始值的语句。也没有对赋值语句的说明，只对共享数据设置初始值。
     4.   **管程名字**。
3.   管程的基本特征
     1.   管程里面的数据只能被管程里面的过程/函数访问。
     2.   一个进程只有通过调用管程内的过程才能进入管程访问**共享数据**。这里只能访问共享数据，**无法访问私有数据**。
     3.   每次仅允许一个进程在管程内执行某个内部过程。同一时刻内管程内函数只能被一个进程使用。
     4.   管程是被进程调用的，管程是语法范围，无法创建和撤销。
     5.   管程不仅能实现进程间的互斥，而且能实现进程间的同步。
4.   条件变量：通过条件变量来实现阻塞进程。由于一个进程被阻塞的原因可能有多个，所以管程中设置多个条件变量，每个条件变量保存一个等待队列，用于记录因该条件变量而阻塞的所有进程。对条件变量只有两个操作：`wait`和`signal`。所以管程调用这两个操作时都**不用**判断条件，直接阻塞或唤醒。
     1.   `x.wait`：当`x`对应的条件不满足时，正在调用管程的进程调用`x.wait`将自己插入`x`条件的等待队列，并释放管程，此时其他进程可以使用该管程。
     2.   `x.signal`：`x`对应的条件发生了变化，则调用`x.signal`，唤醒一个因`x`条件而阻塞的进程。
5.   条件变量与信号量
     1.   相似点：条件变量的$wait/signal$操作类似于信号量的$PV$操作，可以实现进程的阻塞/唤醒。
     2.   不同点：条件变量是“**没有值**”的，仅实现了“**排队等待**”功能（所以一旦调用就不用判断，直接阻塞或释放）；而信号量是“有值”的，信号量的值反映了剩余资源数，而在管程中，剩余资源数用共享数据结构记录。

### 死锁

#### 死锁概述

1.   死锁：在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象。
2.   死锁发生的原因：系统资源的竞争、进程推进顺序非法。信号量的使用不当也会造成死锁。
     +   例如生产者-消费者问题中，如果实现互斥的$P$操作在实现同步的$P$操作之前，就有可能导致死锁。所以建议用互斥信号量把操作包起来。
3.   死锁发生的条件：只要其中任一条件不成立，死锁就不会发生。
     1.   **互斥条件**：只有对必须互斥使用的资源的争抢才会导致死锁，如哲学家的筷子、打印机设备。
     2.   **不剥夺条件：**进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。
     3.   **请求和保持条件**：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有。此时请求进程被阻塞，但又对自己已有的资源保持不放。
     4.   **循环等待条件**：存在一种进程资源的循环等待链，链中的每一个进程己获得的资源同时被下一个进程所请求。
          1.   **发生死锁时一定会有循环等待，但是发生循环等待时未必死锁**，循环等待是死锁的必要不充分条件。
          2.   如果同类资源数大于$1$，则即使有循环等待，也未必发生死锁，但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了。
4.   死锁的处理策略
     1.   预防死锁：破坏死锁产生的四个必要条件中的一个或几个
     2.   避免死锁：用某种方法防止系统进入不安全状态，从而避免死锁。例如银行家算法。
     3.   死锁的检测和解除：允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。
5.   预防死锁：破坏死锁产生的四个必要条件中的一个或几个。是**不允许死锁发生**的静态策略。
     1.   破坏互斥条件：把只能互斥使用的资源改造为允许共享使用。例如$SPOOLing$技术（把独占设备在逻辑上改造成共享设备）。缺点是很多时候都无法破坏互斥条件。
     2.   破坏不剥夺条件：当某进程请求新资源得不到满足时，它必须**立即释放**保持的所有资源，待以后需要时再重新申请；或当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源**强行剥夺**。
          +   缺点是实现复杂、可能造成前一阶段工作的失效（故这种方法一般只适用于易保存和恢复状态的资源，如$CPU$，不能用于打印机），可能导致**饥饿**。
     3.   破坏请求和保持条件：采用**静态分配方法**。即进程在必须运行前一次申请完它所需要的全部资源，否则不能运行。缺点是资源利用率极低，可能导致某些进程**饥饿**。
     4.   破坏循环等待条件：采用**顺序资源分配法**。即给资源编号并规定每个进程必须按编号递增的顺序请求资源，且同类资源（即编号相同的资源）一次申请完成。缺点是不方便增加新的设备、可能会导致资源浪费。

6.   避免死锁：用某种方法防止系统进入不安全状态，从而避免死锁。是不允许死锁发生的动态策略。
     1.   安全序列：指如果系统按照这种序列分配资源，则每个进程都能顺利完成。安全序列可能有多个。
     2.   安全状态：至少能找出一个安全序列的状态。如果系统处于安全状态，就**一定不会发生死锁**。
     3.   不安全状态：分配了资源之后，系统中找不出任何一个安全序列。意味着之后可能所有进程都无法顺利的执行下去。如果系统发生了死锁说明系统一定处于不安全状态；如果系统进入不安全状态，就**不一定**发生死锁。
     4.   银行家算法：将剩余资源数与最多还需要对比，满足条件的进程全部加入安全序列，然后把归还的资源相加，进行下一轮的比较。相关数据结构如下
          1.   长度为$m$的一维数组 $Available$表示当前系统中还有多少**可用资源**。
          2.   $n\times m$的矩阵$Max$表示所有进程对各种资源的**最大需求数。**
          3.   $n\times m$的矩阵$Allocation$表示对所有进程的**资源分配情况**。
          4.   $n\times m$的矩阵$Need[i，j]=Max-Allocation$矩阵，表示各进程**还需要多少各类资源。**
          5.   长度为$m$的一维数组$Request_i$表示进程$P_i$**本次申请的各种资源量。**
          6.   长度为$m$的一维数组向量$Work$表示**执行安全性算法时系统中的剩余可用资源数目**。

7.   检测解除死锁：**允许死锁的发生**，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。
     1.   检测死锁：使用**资源分配图**对系统进行检测。简单来说就是求图的**拓扑排序**（即检测图中有无环）。
          1.   进程结点：一般使用圆圈表示，一个圆圈对应一个进程。
          2.   资源结点：一般使用方框表示，对应一类资源，一类资源可能有多个。
          3.   请求边：进程结点$\to$资源结点。每条边代表一个请求。
          4.   分配边：资源节点$\to$进程结点。每条边代表一个资源的分配。

     2.   资源分配图的性质
          1.   资源分配图中出现环路，满足了循环等待的必要条件，**可能发生死锁**。
          2.   没有环路，破坏了循环等待条件，一定不会发生死锁。

     3.   解除死锁：一旦检测出死锁的发生，就应该立即解除死锁。并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程。
          1.   资源剥夺法：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。
          2.   撤销进程法（或称终止进程法）：强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。
          3.   进程回退法：让一个或多个死锁进程回退到足以避免死锁的地步。这要求系统要记录进程的历史信息，设置还原点。

     4.   确定挂起或撤销的进程的指标
          1.   进程优先级。
          2.   已执行多长时间。
          3.   还要多久能完成。
          4.   进程已经使用了多少资源。
          5.   进程是交互式的还是批处理式的。


## $PV$大题总结

### 问题分类

1.   生产者消费者问题——进程间关系为“生产资源-消费资源”。

2.   理发师问题——进程间关系为“服务-被服务”。
3.   读者写者问题——同类进程不互斥、异类进程互斥。
       +   从未考过但是大纲明确要求。
4.   哲学家进餐问题——只有一类进程，每个进程需要同时拥有多种资源才能运行。
5.   单纯的同步问题——前驱后继图。

### 解题思路

1.   确定函数的个数（有几类进程？）：梳理题目中有几个进程，一个进程对应一个函数。根据动作是否一致区分是否为统一进程。
2.   确定函数的动作：
     1.   动作是什么：在函数内部，用中文描述动作（允许用中文的伪代码形式答题）。
          +   伪代码也要打分号，不要忘记打分号。
     2.   动作的次数：只做一次，不加$while$；还是重复进行，$while(TRUE)$。
3.   确定函数是否在每个动作之前需要进行$P$操作，如果需要进行$P$操作，则一定有与之对应的$V$操作，需要思考这个$V$操作应该被放在哪。
     1.   消耗资源型的$P$操作：题目一般会显性给出，例如每次动作需要消耗一个缓冲区空间（$P$操作减少缓冲区空间，$V$操作增加缓冲区空间，缓冲区无空间时无法进行动作）。
          +   实现同步的$P$操作一定要在实现互斥的$P$操作之前，可以理解为要先拿到这个空间再上锁。即**用实现互斥的$P$操作把动作夹在里面**。
     2.   互斥型的$P$操作：需要注意隐含的互斥关系，例如缓冲区的互斥访问$P(mutex)$。
4.   确定信号量$Semaphore$的个数：所有$PV$操作定义完成后，再确定信号量$Semaphore$的个数。
     +   定义完再思考每个信号量的初值是多少。
     +   使用注释对定义的信号量$Semaphore$进行解释。
5.   检查是否发生死锁：连续进行多个$P$操作的地方是否会发生死锁（只有一个$P$操作不会发生死锁）。
     +   某信号量的$PV$连续出现（中间没有夹杂别的$P$操作），则不会发生死锁：破坏了死锁条件请求和保持。
     +   实现同步的$P$操作一定要在实现互斥的$P$操作之前，可以理解为要先拿到这个空间再上锁。
6.   （以上步骤先在草稿纸上进行）检查符合题意没问题后将答案誊写到答题卡上，并写上相应的注释。
     +   草稿纸上的语言可以比较通俗，空位满位什么的搞不清楚就在草稿纸上写清楚点缸有空，缸中水这样的。

### 生产者 - 消费者类型

#### 生产者 - 消费者类型（1）

![image-20230828115006942](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308281150064.png)

1.   确定函数的个数：生产车间$A$和生产车间$B$虽然都是生产车间，但是它们俩执行的动作不一致，故不是同一个进程，即生产车间$A$和生产车间$B$需要对应不同的函数。
     +   进程 = 生产车间$A $+ 生产车间$B$ + 装配车间$C$。

2.   确定函数的动作
     1.   动作是什么
          +   进程$P_1$和$P_2$分别生产$A$、$B$两种零件，并将分别把它们送到货架$F1$、$F2$上。
          +   $C$从货架上分别取出$A$、$B$后，组装成$A$ + $B$。
     2.   动作的次数：$P_1$、$P_2$和$C$都是不断重复$\to while(TRUE)$。

3.   确定函数是否在每个动作之前需要进行$P$操作：如果需要进行$P$操作，则一定有与之对应的$V$操作；需要思考这个$V$操作应该被放在哪里。

     1.   $P_1$生产$A$零件之前不需要消耗资源。
          +   $P_1$将$A$放到$F1$前需要消耗$1$个$F1$货架（$A$缓冲区）的剩余容量$\to C$从$F1$上取$A$后会释放$1$个$F1$货架的剩余容量。
          +   $empty1$对应货架$F1$上的空闲空间，初值为$10$；$ full1$对应货架$F1$上面的$A$产品，初值为$0$。
     2.   $P_2$生产$B$零件之前不需要消耗资源。
          +   $P_2$将$B$放到F2前需要消耗$1$个$F2$货架（$B$缓冲区）的剩余容量$\to C$从$F2$上取$B$后会释放$1$个$F2$货架的剩余容量。
          +   $empty2$对应货架$F2$上的空闲空间，初值为$10$；$full2$对应货架$F2$上面的$B$产品，初值为$0$。

     3.   $C$从$F1$取$A$前需要消耗$1$个$F1$货架上的$A$产品$\to P_1$把$A$放到$F1$后释放$1$个$F1$货架上的$A$产品。
          +   $C$从$F2$取$B$前需要消耗$1$个$F2$货架上的$B$产品$\to P_2$把$B$放到$F2$后释放$1$个$F2$货架上的$B$产品。
          +   $C$组装成$A+B$前不需要消耗资源。

     4.   $P_1$和$C$对$F1$的访问是互斥的（$mutex1$）；$P_2$和$C$对$F2$的访问是互斥的（$mutex2$）。

4.   确定信号量的个数：$empty1 = empty2 = 10$，$full1 = full2 = 0$，$mutex1 = mutex2 = 1$。

5.   检查是否发生死锁：连续进行多个$P$操作的地方是否会发生死锁（只有一个$P$操作不会发生死锁）。
     +   先$P$同步信号量（$empty1$、$empty2$、$full1$、$full2$），再$P$互斥信号量（$mutex1$、$mutex2$）。

![image-20230828115303663](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308281153236.png)

#### 生产者 - 消费者类型（2）

![image-20230828121437525](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308281214633.png)

1.   确定函数的个数（2），确定函数的动作：老和尚`喝水`。小和尚`取水、`
2.   动作是什么：
     1.   老和尚：（取桶）、从缸中打水、喝水。
     2.   小和尚：（取桶）、从井中打水、放水。
3.   动作的次数：不断重复$\to while(TRUE)$。
4.   确定函数是否在每个动作之前需要进行`P`操作，实现同步的`P`操作一定要在实现互斥的`P`操作之前：
     1.   老和尚打水前消耗1个桶 → 老和尚喝水后增加1个桶：老和尚喝水前消耗1个水缸里的水 → 小和尚打水后增加1个水缸里的水
     2.   小和尚打水前消耗1个桶 → 小和尚放水后增加1个桶：小和尚打水前消耗1个水缸的剩余容量 → 老和尚喝水后增加1个水缸的剩余容量
     3.   小和尚之间对井的访问是互斥的（`mutex1`）；老和尚间和小和尚间、老和尚和小和尚对水缸的访问是互斥的（`mutex2`）
5.   确定信号量的个数：互斥访问信号量为1，其余为资源数量
6.   检查是否发生死锁：
     1.   如果老和尚和小和尚都是先对tong进行P操作（先进行取水桶操作），则可能发生：三个老和尚同时取水，并取得水桶（此时完成了三个P(tong)，则tong = 0），但是水缸中没有水（full = 0），即老和尚进程被阻塞在P（full）；而若干个小和尚想去打水，水桶却被取光（tong = 0），即小和尚进城被阻塞在P(tong)，这样就形成了死锁
     2.   同理，也可能发生三个小和尚分别拿着桶，而水缸中水满（empty = 0），被阻塞在P（empty）；而老和尚苦于没有水桶，被阻塞在P（tong）
     3.   解决方法：调整老和尚进程和小和尚进程的取桶顺序
          +   老和尚先判断水缸中有没有水，水缸有水的情况下才去取桶喝水，即先P（full）再P（tong）
          +   小和尚先判断水缸中有没有剩余容量，水缸中有剩余容量的情况下才去取桶打水，即先（empty）再P（tong）

![23August28-203245-1693225965-07aadabe-9997-444f-8a22-52cf809430f8](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282033927.png)

#### 生产者 - 消费者类型（3）

1.   确定函数的个数（2）：
     +   所有生产者动作一致，故所有生产者视为一类进程
     +   所有消费者动作一致，故所有消费者视为一类进程

2.   确定函数的动作：

     1.   动作是什么：
          1.   P生产产品，并将产品放入缓冲区
          2.   C从缓冲区取10个产品

     2.   动作的次数：P和C都是不断重复$\to while(TRUE)$。

3.   确定函数是否在每个动作之前需要进行P操作：

     1.   P生产产品前不需要消耗资源
          +   P将产品放入缓冲区前需要消耗1个缓冲区剩余容量 → C从缓冲区取10个产品后增加10个缓冲区剩余容量（每取出1个产品，增加1个缓冲区容量，通过for循环实现）
     2.   C从缓冲区取10个产品前需要消耗10个缓冲区产品数量（`for`循环实现） → P将产品放入缓冲区后增加1个缓冲区产品数量
     3.   P和C对缓冲区的访问是互斥的（`mutex`）
     4.   多个C之间P操作是互斥的：如果只是简单的使用for循环设置在取10个产品前，则可能发生多个C轮流的取产品

![image-20231104162438147](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202311041624320.png)

### 理发师问题

1.   即服务与被服务的关系。区别：需要额外设置变量记录当前等待的顾客有多少个，且该变量的访问是要互斥进行的，即需要夹在PV操作中。
2.   理发师问题实际上是生产者 - 消费者问题的变式：生产者 - 消费者问题：生产者生产资源，消费者消费资源；缓冲区限制资源上限。理发师问题：将顾客和服务员分别视为一种资源。
     1.   顾客：每个顾客到店时，生产一个顾客资源；在被服务前，消耗一个服务员资源
     2.   服务员：提供服务前，消耗一个顾客资源；确定有顾客时，生产一个服务员资源；再提供服务

#### 理发师问题（1）

![23August28-212531-1693229131-27b4137a-7c05-466f-86ca-c7807f6b4062](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282125663.png)

特点：

1.   顾客无上限
2.   服务员在没有顾客的时候可以休息，通过`P(customer)`实现

![image-20231104164250817](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202311041642936.png)

#### 理发师问题（2）

![23August28-213808-1693229888-3d5ee02f-d0c8-4c14-8e9a-7f31f51e6b02](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282138483.png)

特点：顾客到店时，会检查`waiting`变量是否小于`m`，即等待数量有上限

![image-20231104163801346](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202311041638441.png)

#### 理发师问题（3）

![23August28-214003-1693230003-c0f04c89-2818-4b34-b8ea-65e8e0db7295](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282140847.png)

特点：

1.   在没有顾客时，服务员不能休息，必须忙等，即不断的轮询（`while`）检查`waiting`变量，判断当前是否有正在等待的顾客
2.   此情况下无需申明`customer`变量，即服务员无需阻塞
3.   用`waiting`变量判断服务员当前是否需要为顾客提供服务

![image-20231104164154012](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202311041641129.png)

### 读者 - 写者问题

1.   第一个进程上锁，最后一个进程解锁：通过`count`变量记录该进程当前的数量
     +   读者写者问题主要是解决互斥
     +   他的访问关系分为两种类型，一种是可以同时访问（读和读），另一种是必须互斥访问（写和读，写和写)
     +   因为多种关系，所以引入了计数器`count`

2.   同类进程不互斥，不同类进程互斥（读者 - 写者问题的最主要特点）

3.   写者进程不用判断是否自己是第一个/最后一个进程

#### 读者 - 写者问题（1）

![image-20230828215600872](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282156992.png)

1.   从南往北的车只要有一辆占据，其余从南到北的车就可以一直使用该路；从北往南的车同上（同类的进程可以共享资源，不同类的进程互斥资源）

2.   声明`count1`变量和`count2`变量分别用于记录当前`P1/P2`有几个进程正在使用该临界资源，初始为`0`

3.   在每个进程开始时，通过`count`是否为`0`判断自己是不是第一个进程，如果是，则对临界资源进行上锁

4.   进行`count++`，表示自己正在使用临界资源，并在使用完临界资源后进行`count--`

5.   在每个进程结束时，通过`count`是否为0判断自己是不是最后一个进程，如果是，则对临界资源进行解锁

![image-20231104165104780](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202311041651797.jpg)

#### 读者 - 写者问题(2)

![image-20230828220732681](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282207808.png)

1、2、3种不同的录像片对应不同的进程，不同进程互斥访问录像厅（临界资源），统一进程共享录像厅 

![image-20230828221532455](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282215677.png)

#### 读者 - 写者（写优先）

![23August28-225328-1693234408-4a367299-7bfb-435e-a5a0-d38b2d62802e](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282253634.png)

![image-20230828225713745](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282257993.png)

### 哲学家进餐

+   特征：只有一类进程，且该类进程只有同时拥有多种资源才能进行
+   哲学家问题关键点是限制并行，主要是三种思路

    1.   限制申请条件（对应破坏死锁循环等待条件)：解法一不通用，不建议使用

         +   比如规定单号哲学家先取左筷子，双号先取右筷子

    2.   信号量限制并行数（对应破坏死锁发生的循环等待条件）：解法二通用，但并发度不高，也不建议使用，参考`2.4`小题第8题确定最大进程数

         +   如`P89`代码就是同一时间只能有一个哲学家就餐（禁止并行）

    3.   限制哲学家只有能够取得两个筷子的时候才会就餐（对应破死锁条件)：解法三很通用，且并发度高，暴力美学

         +   `P(Lock);if(检查是否全满足);V(Lock);`
+   第三个思路最通用：

    +   通常的思路为
        1.   将每种资源通过int类型的变量定义（使用变量将资源数量具象化）
        2.   在进程开始运行时，先使用`P(mutex)`操作实现对各种资源进行互斥的访问，目的是逐一判断当前进程所需的各种资源是否满足运行的需要
        3.   如果资源都满足，则拿走这些资源（一口气拿走），然后`V(mutex)`，再执行动作
    +   循环条件下：如果只要有一个资源不满足，则`V(mutex)`，然后结束此次循环，进行下一次循环（`continue`）；
    +   只进行一次：如果只要有一个资源不满足，则使用`goto`语句返回函数的第一句重新进行判断（手动实现循环）
    +   其中`2.`实现同一时间只可能有一个进程在进行判断/拿走临界资源
    +   最后完成动作归还资源时也要进行上锁，保证归还动作一气呵成的完成

![image-20231104165837850](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202311041658998.png)

##### 哲学家进餐（1）

![image-20230828223900539](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202308282239653.png)

1.   变量`bowl`表示剩余碗的数量
     +   数组a中`a[i] = 1`表示第i个哲学家的左手有筷子，`a[(i + 1) % n] = 1`表示第i个哲学家的右手有筷子
         +   需要对右手边的筷子进行取模操作，第n个哲学家的右手边筷子就是第1个哲学家左手的筷子

2.   `P（mutex）`实现对临界资源的上锁

3.   判断`bowl`变量和左右筷子是否都在，任意条件不满足则`V（mutex）`（解锁）并结束循环；条件都满足时，则对这两个变量进行 - 1操作，表示取出该临界资源

4.   `V（mutex）`实现对临界资源的解锁

5.   进餐（即自己的主体动作）

6.   归还拥有的临界资源：另一个哲学家进行上锁并判断

![image-20231104165749167](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202311041657256.png)

### 单纯的同步问题

这类题通常会给一个前驱后继图，让你根据图实现同步关系，送分题，不需要过多关注。

1.   前驱关系其实是多组同步.进程$P_1$中有句代码$S_1$，$P_2$中有句代码$S_2$……$P_n$中有句代码$S_m$。
2.   其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作）因此
     1.   要为每一对前驱关系各设置一个同步变量。
     2.   在“前操作”之后对相应的同步变量执行$V$操作.类似表示当前动作$S_i$已经完成。
     3.   在“后操作”之前对相应的同步变量执行$P$操作.类似检测前一个动作$S_i$是否完成。

![pintu-fulicat.com-1699088453909](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/202311041701505.jpg)
