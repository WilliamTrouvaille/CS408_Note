# 第五章 中央处理器$(CPU)$

## 导读

### 【考纲内容】

1. **CPU 的功能和基本结构**                                                       
2. **指令执行过程**
3. **数据通路的功能和基本结构**
4. **控制器的功能和工作原理**
5. **异常和中断机制**
    1. 异常和中断的基本概念，异常和中断的分类; 异常和中断的检测与响应

6. **指令流水线**
    + 指令流水线的基本概念
    + 指令流水线的基本实现
    + 结构冒险、数据冒险和控制冒险的处理
    + 超标量和动态流水线的基本概念

7. **多处理器基本概念**
    + $SISD$、$SIMD$、$MIMD$、向量处理器的基本概念
    + 硬件多线程的基本概念
    + 多核$(multi-core)$处理器的基本概念
    + 共享内存多处理器 $(SMP) $的基本概念

### 【知识导图】

![img](http://res.ptpress.cn/36AC35AB87F046638825B525E7461D78.png)

![img](http://res.ptpress.cn/AE377BFDA3CC41C58E31B10C083A6ACF.png)

![img](http://res.ptpress.cn/0ECBAB73C5B0462282B64370F38841D7.png)

![img](http://res.ptpress.cn/31B7D7A28541465F8ED83ED0BFD6D922.png)

![img](http://res.ptpress.cn/D27FEA23ED4E4E349133D0D1136B1B49.png)

![img](http://res.ptpress.cn/E7F58AB909C74113B87FDA486B3FE01D.png)

![img](http://res.ptpress.cn/B1E5799F550A46C7B10A6A8888E5FF31.png)

![image-20230603095230601](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603095230601.png)

![img](http://res.ptpress.cn/23C5A832CE9D497797DAE3E3A5EEAC23.png)

![img](http://res.ptpress.cn/27C7442F819549B5BE55A3427B590CAC.png)

![img](http://res.ptpress.cn/CC9FD1FC8E21462AB2DA312E22E7C149.png)

![img](http://res.ptpress.cn/DABCD40FB97049B9A69A3A3E2989570C.png)

![img](http://res.ptpress.cn/A49C1C1C425142009CE514B3DBD18DD9.png)

![img](http://res.ptpress.cn/897A9D9405864D7280040DECC2523212.png)

![img](http://res.ptpress.cn/F3D19288780642AF985FE0D671613D4A.png)

![img](http://res.ptpress.cn/B2FBB242C124458D87EA49977291E49D.png)

![img](http://res.ptpress.cn/967CF1FA3A71418482699C75341D3EDD.png)

![image-20230603095542154](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603095542154.png)



![img](http://res.ptpress.cn/292CC4CB6D0649C4998F669D2AAB1654.png)

![image-20230603095807976](C:/Users/willi/AppData/Roaming/Typora/typora-user-images/image-20230603095807976.png)



### 【复习提示】

中央处理器是计算机的中心，也是本书的难点。其中，数据通路的分析,指令执行阶段的节拍与控制信号的安排、流水线技术与性能分析易出综合题。而关于各种寄存器的特点、指令执行的各种周期与特点、控制器的相关概念、流水线的相关概念也极易出选择题。

在学习本章时，请读者思考以下问题:

1) 指令和数据均存放在内存中，计算机如何从时间和空间上区分它们是指令还是数据?

2) 什么是指令周期、机器周期和时钟周期? 它们之间有何关系?

3) 什么是微指令? 它和第 4 章谈到的指令有什么关系?

4) 什么是指令流水线? 指令流水线相对于传统体系结构的优势是什么?

## $CPU$基本概念

### CPU功能

#### CPU总功能

1. 指令控制。
    + 完成取指令、分析指令和执行指令的操作，即程序的顺序控制。
2. 操作控制。
    + 一条指令的功能往往是由若干操作信号的组合来实现的
    + $CPU$管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作。
3. 时间控制。
    + 对各种操作加以时间上的控制。时间控制要为每条指令按时间顺序提供应有的控制信号。
4. 数据加工。
    + 对数据进行算术和逻辑运算。
5. 中断处理。
    + 对计算机运行过程中出现的异常情况和特殊请求进行处理。

#### 运算器功能

+ 对数据进行加工。
+ 主要部件是$ALU$和$ACC$。

#### 控制器功能

协调并控制计算机各部件执行程序的指令序列，基本功能包括取指令、分析指令、执行指令:

1. 取指令:
    + 自动形成指令地址。
    + 自动发出取指令的命令。
    + $(PC)+"1"\rightarrow PC$。
2. 分析指令:
    + 操作码译码（对操作码分析本条指令要完成什么操作）。
    + 产生操作数的有效地址。
3. 执行指令:
    + 根据分析指令得到的“操作命令”和“操作数地址”。
    + 形成操作信号控制序列，控制运算器、存储器以及$I/O$设备完成相应的操作。
4. 中断处理:
    + 管理总线及输入输出。
    + 处理异常情况（如掉电）。
    + 特殊请求（如打印机请求打印一行字符）。

+ 控制器部件向系统中的部件提供它们运行所需要的控制信号。
+ 控制器部件从数据总线接收指令信息。
+ 控制器部件从运算器部件接收指令转移地址。
+ 控制器部件送出指令地址到地址总线。

### $CPU$结构

![image-20230603112823392](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603112823392.png)

#### 运算器结构

![image-20230603112327224](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603112327224.png)

1. 算术逻辑单元$ALU$:主要功能是进行算术/逻辑运算。
2. 通用寄存器组$X$:如$AX(AH,AL)$、$BX(BX,BL)$、$CX(CH,Cl)$、$DX(DX,DL)$、$SP$等，用于存放操作数（包括源操作数、目的操作数及中间结果）和各种地址信息等。$SP$是堆栈指针，用于指示栈顶的地址。
3. 内部总线:
    + 专用数据通路方式:
        + 根据指令执行过程中的数据和地址的流动方向安排多条连接线路。
        + 寄存器有多少位就有多少根线连着$ALU$,寄存器将操作数的所有位并行的传输到$ALU$中
        + 如果直接用导线连接，相当于多个寄存器同时并且一直向$ALU$传输数据，解决方法:
            1. 使用多路选择器$MUX$根据控制信号选择一路输出解决方法。
            2. 使用三态门可以控制每一路是否输出，$1$允许，$0$不允许。
        + 性能较高，基本不存在数据冲突现象，但结构复杂，硬件量大，不易实现。
    + $CPU$内部单总线方式:
        + 将所有寄存器的输入端和输出端都连接到一条公共的通路上。
        + 结构简单，容易实现，但数据传输存在较多冲突的现象，性能较低。
        + 为了解决冲突用暂存寄存器解决。
4. 暂存寄存器$R$:用于暂存从主存读来的数据，这个数据不能存放在通用寄存器中，否则会破坏其原有内容。
    + 若两个操作数分别来自主存和$R_0$,最后结果存回$R_0$,那么从主存中取来的操作数直接放入暂存器，就不会破坏运算前$R_0$的内容。
5. 累加寄存器$ACC$:它是一个通用寄存器，用于暂时存放$ALU$运算的结果信息，用于实现加法运算。
6. 程序状态字寄存器$PSW$:保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息，如溢出标志（$OF$） 、符号标志（$SF$）、零标志（$ZF$）、进位标志（$CF$）等，$PSW$中的这些位参与并决定微操作的形成。
    + **Overflow Flag (OF)**:溢出标志位，用于指示算术运算是否产生了溢出。当进行有符号数运算时，如果结果超过了有符号数的表示范围，则OV标志位被设置为1。
    + **Sign Flag (SF)**:符号标志位，用于指示运算结果的符号。当运算结果为负数时，SF标志位被设置为1。
    + **Zero Flag (ZF)**:零标志位，用于指示运算结果是否为零。当运算结果为零时，ZF标志位被设置为1。
    + **Carry Flag (CF)**:进位标志位，用于指示无符号数运算是否产生了进位。当进行无符号数相加时，如果最高位产生了进位，CF标志位被设置为1。
    + **Parity Flag (P)**:奇偶标志位，用于指示运算结果的二进制表示中1的个数是否为偶数。当运算结果中1的个数为偶数时，P标志位被设置为1。
    + **Auxiliary Carry Flag (AC)**:辅助进位标志位，用于指示低位到高位的进位。当进行BCD码（二进制编码的十进制数）运算时，如果低四位到高四位产生了进位，AC标志位被设置为1。
7. 移位器（移位寄存器）$SR$:对运算结果进行移位运算。拥有移位逻辑的寄存器。
8. 计数器（计数寄存器）$CT$:控制乘除运算的操作步数。拥有计数逻辑的寄存器。

#### 控制器结构

$PC$(取指令)$\to$$IR$(分析指令)$\to$$CU$(执行指令)

![image-20230603112149297](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603112149297.png)

1. 程序计数器$PC(Program\,Counter)$:用于指出下一条指令在主存中的存放地址。$CPU$就是根据$PC$的内容去主存中取指令的。因程序中指令（通常）是顺序执行的，所以$PC$有自增功能。
2. 指令寄存器$IR(Instruction\,Register)$:用于保存当前正在执行的那条指令。
3. 指令译码器$ID(Instruction\;Decoder)$:仅对**操作码**字段进行译码，向控制器提供特定的操作信号。
4. 操作控制器$OC$:用来产生各种操作控制信号。
5. 微操作信号发生器:根据$IR$的内容（指令）、$PSW$的内容（状态信息）及时序信号，产生控制整个计算机系统所需的各种控制信号，其结构有组合逻辑型和存储逻辑型两种。
6. 时序系统$TG(Timing\;Generator)$（时序产生器）:用于产生各种时序信号,它们都是由统一时钟（$CLOCK$）分频得到。
7. 存储器地址寄存器$MAR$:用于存放所要访问的主存单元的地址。
8. 存储器数据寄存器$MDR$:用于存放向主存写入的信息或从主存中读出的信息。



## 指令执行

### 指令周期

#### 指令周期定义

+ 指令周期:$CPU$从主存中每取出并执行一条指令所需的全部时间:
    + 取指周期:取指、分析。
    + 执行周期。
    + ![image-20230603113042749](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603113042749.png)
+ **指令周期**常常用若干机器周期来表示，机器周期又叫$CPU$周期。如取指令、取有效地址、执行指令这就是三个机器周期，是一个指令周期。
+ 一个**机器周期**又包含若干**时钟周期**（也 称为节拍、$T$周期或$CPU$时钟周期，它是$CPU$操作的最基本单位）。

![image-20230603113447201](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603113447201.png)


+ 每个指令周期内机器周期数可以不等，每个机器周期内的节拍数也可以不等。

    + 空指令$NOP$: 指令周期=取值周期
    + 加法指令$ADD$:指令周期=取值周期+执行周期
    + 乘法指令$MUL$:指令周期=取值周期+执行周期(较长)
    + 具有间接寻址的指令:指令周期=取值周期+间址周期+执行周期
    + 带有中断周期的指令:指令周期=取值周期+间址周期+执行周期+中断周期
    + ![image-20230603113844682](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603113844682.png)

+ 指令周期流程:
    1. 进入取指周期。
    2. 判断是否有间址。
    3. 若有则进入间址周期，结束后进入执行周期。
    4. 若无则直接进入执行周期。
    5. 判断是否有中断。
    6. 若有则进入中断周期，结束后进入下一条指令的指令周期。
    7. 若无则直接进入下一条指令的指令周期。

![image-20230603144007541](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603144007541.png)

#### 标志触发器

为了区别不同的工作周期，$CPU$内设了四个标志触发器，以一状态位为有效:

+ 取指令$FE$:取指周期。
+ 取地址$IND$:间址周期。
+ 存取操作数或结果$EX$:执行周期。
+ 存程序断点$INT$:中断周期。

#### 相关周期区别

四种周期:

+ 指令周期:$CPU$从主存中每取出并执行一条指令所需的全部时间。指令周期可变。
+ 时钟周期:通常称为节拍或$T$周期，它是$CPU$操作的最基本单位。时钟周期不变。
+ $CPU$周期也称机器周期:一个机器周期包含若干时钟周期。是$CPU$进行一次操作的时间。由于$CPU$内部操作的速度较快，而$CPU$访问一次存储器的时间较长，因此机器周期通常由存取周期来确定，往往是通过一次总线事务访问一次主存或$I/O$的时间。机器周期可变。
+ 存取周期:指存储器进行两次独立的存储器操作（连续两次读或写操作）所需的最小间隔时间。存取周期往往为固定值。
+ 机器周期:通过一次总线事务访问一次主存或 $I/O$的时间定为一个机器周期。所以机器周期往往与访存周期相等。

### 数据流

指令周期一共包含四个机器周期，但是指令不同可能只有部分周期，如零地址指令只有取指和执行周期。

#### 取指周期

根据$PC$内容（无论是普通指令还是转移指令）从内存中取出指令代码并放入$IR$中。

![image-20230603144936047](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603144936047.png)

<span style="color:orange">注意:</span>取指操作是控制器固化的自动执行的操作。

1. 当前指令地址送至存储器地址寄存器，记做:$(PC)\rightarrow MAR$。
2. $MAR$将地址码发送到地址总线。
3. 地址总线将地址发送给存储器，等待使用地址。
4. $CU$发出控制读信号给控制总线。
5. 控制总线将控制读的信号发送给存储器。启动存储器做读操作，这是是**读信号**,记做:$1\rightarrow R$。
    + $R$(头上没有横杠)表示高电平激活,这里$1$表示高电平
6. 存储器根据地址总线传来的地址信息和控制总线传来的控制读信息来进行读操作，从中读出数据。并将地址所指的数据发送给数据总线。
7. 数据总线将数据送入$MDR$，记做:$M(MAR)\rightarrow MDR$。
    + $M(MAR)$指主存$(Memory)$中$MAR$存储地址所指的数据
8. 将$MDR$中数据（此时是指令内容）**复制**送入$IR$，记做:$(MDR)\rightarrow IR$。
9. $CU$发出控制信号，控制$PC$形成下一条指令地址，默认是加一，记做:$(PC)+1\rightarrow PC$。

#### 间址周期

根据间接地址取操作数有效地址。

![image-20230603145659982](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603145659982.png)

1. $IR$将指令的地址码送入$MAR$，记做:$Ad(IR)\rightarrow MAR$或$Ad(MDR)\rightarrow MAR$。
    + 由于取指周期$(MDR)\rightarrow IR$时$MDR$是复制一份地址码送入$IR$的,此时$MDR$中还留有地址码
2. $MAD$将地址码发送到地址总线。
3. 地址总线将地址发送给存储器，等待使用地址。
4. $CU$发出控制读信号给控制总线。
5. 控制总线将控制读信息发送到存储器中。启动主存做**读操作**，记做:$1\rightarrow R$。
6. 存储器根据地址总线传来的地址信息和控制总线传来的控制读信息来进行读操作，从中读出数据。并将地址所指的数据发送给数据总线。
7. 数据总线将数据送入$MDR$，记做:$M(MAR)\rightarrow MDR$。此时$MDR$保存的是操作数的地址而不是操作数本身。
8. 将有效地址送至指令的地址码字段，记做:$MDR\rightarrow Ad(IR)$。
    + 这一步只有部分$CPU$会有
    + 这一步会将有效地址覆盖于原指令的间接地址

#### 执行周期

执行周期的任务是根据$IR$中的指令字的操作码和操作数通过$ALU$操作产生执行结果。不同指令的执行周期操作不同，因此没有统一的数据流向。

这里$MDR$访存取数得到操作数，此时$MDR$中的内容才是操作数。

#### 中断周期

+ 中断:暂停当前任务去完成其他任务。为了能够恢复当前任务，需要**保存断点**。
+ 一般使用**堆栈**来保存断点，这里用$SP$表示栈顶地址，假设$SP$指向栈顶元素，进栈操作是先修改指针，后存入数据。

![image-20230603150844450](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603150844450.png)

1. $CU$控制将**$SP$减$1$**，即将一个空元素进栈然后对其操作，并修改后的地址送入$MAR$，记做:$(SP)-1\rightarrow SP$，$(SP)\rightarrow MAR$。本质上是将断点存入某个存储单元，假设其地址为$a$，故可记做:$a\rightarrow MAR$。
    + <span style="color:orange">注意:</span>中断周期中的进栈操作是将$SP$减$1$，这和传统意义上的进栈操作相反，原因是计算机的堆栈中从高向低地址增加，所以进栈操作是减$1$而不是加$1$。
2. $MAR$将地址码发送到地址总线。
3. 地址总线将地址发送给存储器，等待使用地址。
4. $CU$发出控制写信号给控制总线。
5. 控制总线将控制写信息发送到存储器中。启动主存做**写操作**，记做:$1\rightarrow W$。
6. 将断点（$PC$内容）送入$MDR$，记做:$(PC)\rightarrow MDR$。
7. 将$MDR$内容传入数据总线。
8. 数据总结将内容发送存储器。存储器将内容写入其中，记为$(MDR)\rightarrow M$。
9. $CU$控制将中断服务程序的入口地更新（由向量地址形成部件产生）送入$PC$:向量地址$\rightarrow PC$。

### 指令执行方案

一个指令周期通常要包括多个时间段（执行步骤），每个步骤完成指令的一部分功能，几个依次执行的步骤完成这条指令的全部功能。

1. 单指令周期:
    + 对所有指令都选用相同的执行时间来完成。
    + 指令之间串行执行。
    + 指令周期取决于执行时间最长的指令的执行时间。
    + 执行周期内控制信号不变。
    + 缺点:对于那些本来可以在更短时间内完成的指令，要使用这个较长的周期来完成，会降低整个系统的运行速度。
    + 优点:实施简单，只用程序计数器$PC$就能实现。
2. 多指令周期:
    + 对不同类型的指令选用不同的执行步骤来完成。
    + 指令之间串行执行。
    + 可选用不同个数的时钟周期来完成不同指令的执行过程。
    + 缺点:需要更复杂的硬件设计。
    + 优点:系统运行速度更高，效率更高。
3. 流水线方案:
    + 在每一个时钟周期启动一条指令，尽量让多条指令同时运行，但各自处在不同的执行步骤中。

## 数据通路

+ 数据通路就是数据在功能部件之间传送的路径。
+ 由控制部件产生的控制信号建立数据通路。
+ 数据通路的基本结构:
    + $CPU$内部单总线方式。
        + ALU工作时需要配合暂存寄存器
    + $CPU$内部多总线方式。
    + 专用数据通路方式。

### CPU内部单总线方式

+ **内部总线**是指同一部件，如$CPU$内部连接各寄存器及运算部件之间的总线。
+ **系统总线**是指同一台计算机系统的各部件，如$CPU$、内存、通道和各类$I/O$接口间互相连接的总线。
+ 使用一根总线连接部件的输入和输出。
+ 一个时钟内只允许一次操作。
+ 实现简单。
+ 容易冲突，且效率较低。

对于$ALU$这种是一个组合逻辑电路的部件，其运算过程中必须保持两个输入端的内容不变。如果使用内部单总线方式，因此为了得到两个不同的操作数，$ALU$的一个输入端与总线相连，另一个输入端需通过一个寄存器与总线相连，第一个传入值的输入端需要用寄存器保存数据等待第二个数的输入，避免数据发生变化。此外，$ALU$的唯一的输出端也不能直接与内部总线相连，否则其输出又会通过总线反馈到输入端，影响运算结果，因此输出端需通过一个暂存器（用来暂存结果的寄存器）或三态门（控制与总线的打开与关闭）与总线相连。

<span style="color:orange">注意:</span>**哪些控制信号有效是关键得分点一定要写上**

![image-20230603154752818](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603154752818.png)

1. 寄存器之间数据传送，比如把$PC$内容送至$MAR$，实现传送操作的流程及控制信号为:
    1. $(PC)\rightarrow Bus$:$PCout$有效，$PC$内容送总线。
    2. $Bus\rightarrow MAR$:$MARin$有效，总线内容送$MAR$。
2. **主存与$CPU$之间的数据传送**，比如$CPU$从主存读取指令，实现传送操作的流程及控制信号为:
    1. $(PC)\rightarrow Bus\rightarrow MAR$:$PCout$和$IMARin$有效，现行指令地址$\rightarrow MAR$。
    2. $1\rightarrow R$:$CU$通过控制总线发出**读命令**。
    3. $MEM(MAR)\rightarrow MDR$:$MDRinE$有效，根据$MAR$地址取值送到$MDR$。
        + 此时$MDRin$也常写成$MDRinE$,因为$MDRin$指的$CPU$内部总线的控制信号,而此时主存送数据到$MDR$时使用的是外部总线,一般使用的不是$MDRin$的控制信号
    4. $MDR\rightarrow Bus\rightarrow IR$:$MDRout$和$IRin$有效，现行指令$\rightarrow IR$。
3. **执行算术或逻辑运算**，比如一条加法指令，微操作序列及控制信号为:
    1. $Ad(IR)\rightarrow Bus\rightarrow MAR$:$MDRout$和$IMARin$有效。
    2. $1\rightarrow R$:$CU$发读命令。
    3. $MEM(MAR)\rightarrow$外部数据总线$\rightarrow MDR$:$MDRinE$有效。
        + 同上,使用的是外部数据总线
    4. $MDR\rightarrow Bus\rightarrow Y$:$MDRout$和$Yin$有效，操作数$\rightarrow Y$。
    5. $(ACC)+(Y)\rightarrow Z$:$ACCout$和$ALUin$有效，$CU$向$ALU$发送加命令。
        + $(ACC)+(Y)$这一步是在$ALU$中计算,计算结果放入寄存器$Z$中
        + 寄存器$Y$和$ALU$之间有一根专用数据通路,不会走数据总线
    6. $Z\rightarrow ACC$:$Zout$和$ACCin$有效，结果$\rightarrow ACC$。

**【例题】:**

设有如图所示的单总线结构,分析指令$ADD\; (R0),R1$的指令流程和控制信号

![image-20230603154837161](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603154837161.png)

**【解析】:$ADD\; (R0),R1$**中

+ $(R0)$部分是目的操作数,由于有括号则可知需先将$R0$中数据取出得到主存中存放有效数的地址,然后根据地址去主存中取得有效数
+ $R1$部分是源操作数,直接取得有效数即可
+ $ADD\;d\;s$指$d+s$的结果存放到$d$(所指地址的)中
则完整功能为$((R0))+(R1)\rightarrow(R0)$,其中包括取指周期,间址周期,执行周期



**【解】:**

完整功能为$((R0))+(R1)\rightarrow(R0)$,其中包括取指周期,间址周期,执行周期

**取址周期:**公共操作

| 时序 | 微操作                                  | 有效控制信号         |
| ---- | --------------------------------------- | -------------------- |
| 1    | $(PC) \rightarrow MAR$                  | $PCout,MARin$        |
| 2    | $M(MAR)→MDR$<br />$(PC) \rightarrow PC$ | $MemR,MARout,MARinE$ |
| 3    | $(MDR) \rightarrow IR$                  | $MDRout,IRin$        |
| 4    | 指令译码                                | /                    |

**间址周期:**完成取数操作，被加数在主存中，加数已经放在寄存器$R1$中

| 时序 | 微操作                  | 有效控制信号         |
| ---- | ----------------------- | -------------------- |
| 1    | $(R0)  \rightarrow MAR$ | $R0out,MARin$        |
| 2    | $M(MAR)→MDR$            | $MemR,MARout,MARinE$ |
| 3    | $(MDR)  \rightarrow Y$  | $MDRout,Yin$         |

**执行周期:**完成取数操作，被加数在主存中，加数己经放在寄存器$R1$中。

| 时序 | 微操作                      | 有效控制信号                           |
| ---- | --------------------------- | -------------------------------------- |
| 1    | $(R1)  + (Y) \rightarrow Z$ | $R1out,ALUin,CU$向$ALU$发$ADD$控制信号 |
| 2    | $(Z)→MDR$                   | $Zout,MDRin$                           |
| 3    | $(MDR)  \rightarrow M(MAR)$ | $MemW,MDRoutE,MARout$                  |

### CPU内部多总线方式

+ 使用多根总线连接部件的输入和输出。
+ 效率相对于单总线而言得到了提升。

### 专用数据通路方式

+ 对于各种部件使用专用的通路进行连接。专用通路就是将总线分散到各个地方。
+ 连接多，实现困难。
+ 专用数据通路是指针对特定的操作或指令进行优化设计的数据通路，以提高指令执行的效率和速度。

专用数据通路方式的主要特点是针对特定的操作或指令进行优化，通过直接连接相应的功能单元，减少数据传输的路径和延迟，从而提高数据的传输速度和系统的整体性能。

以下是几种常见的专用数据通路方式：

1. **乘法器和除法器数据通路**：对于乘法和除法操作，通常会采用专门的乘法器和除法器单元。这些单元与其他功能单元（如寄存器、ALU等）直接连接，形成专用的数据通路，以提高乘除操作的速度和效率。
2. **浮点数数据通路**：针对浮点数运算，通常会设计专用的浮点数单元和浮点数数据通路。这些单元包括浮点加减器、浮点乘除器等，与其他功能单元相连接，形成专门用于浮点数运算的数据通路。
3. **向量处理器数据通路**：在一些特定的应用中，需要进行大规模的向量计算，如图形处理、科学计算等。为了提高向量操作的效率，可以设计专门的向量处理器单元和数据通路，以支持并行的向量操作。
4. **高速缓存数据通路**：高速缓存是用于加速存储器访问的重要组件。在CPU中，高速缓存通常与其他功能单元直接相连，形成专用的数据通路，以实现快速的缓存访问和数据交换。

![image-20230603161842951](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603161842951.png)



**【例题】:**

下图是一个简化的 $CPU $与主存连接结构示意图 ( 图中省略了所有的多路选择器 )，其中
有一个累加寄存器 ($ACC $)、一个状态数据寄存器和其他 4 个寄存器: 主存地址寄存器
($MAR $)、主存数据寄存器 ($MDR $)、程序寄存器 ($PC $) 和指令寄存器 ($IR $)，各部件及
其之间的连线表示数据通路，箭头表示信息传递方向。

![image-20230603162149568](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603162149568.png)

要求:

1) 请写出图中 a、b、c、d 四个寄存器的名称

2) 简述图中取指令的数据通路

3) 简述数据在运算器和主存之间进行存/取访问的数据通路
    + 假设地址已在$MAR $中


4) 简述完成指令$LDA\;X$ 的数据通路
    + $X $为主存地址，$LDA $的功能为$(X) \rightarrow ACC $
5) 简述完成指令 $ADD\;Y$ 的数据通路
  +  $Y$立为主存地址，$ADD $的功能为$(ACC) + (Y) \rightarrow ACC $
6) 简述完成指令 $STA\;Z $的数据通路
  +  $Z $为主存地址，$STA $的功能为$(ACC) \rightarrow Z $



**【解】:**

1.  请写出图中 a、b、c、d 四个寄存器的名称
    1. $d$能自动$“+1”$,是$PC$
    2. $PC$内容是地址,需要送给$MAR$,则$c$是$MAR$
    3. $b$与微操作信号发生器相连,是$IR$
    4. 与主存相连的寄存器是$MAR$和$MDR$,$c$是$MAR$,则$a$是$MDR$

2. 简述图中取指令的数据通路
    + $(PC) \rightarrow MAR$
    + $M(MAR) \rightarrow MDR$
        + $1 \rightarrow R$
    + $(MDR)  \rightarrow IR$
    + $OP(IR) \rightarrow $微操作发生器
    + $(PC)+1 \rightarrow PC$
3. 简述数据在运算器和主存之间进行存/取访问的数据通路
    + ![image-20230603164301374](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603164301374.png)
    + 取:
        + $M(MAR) \rightarrow MDR$
            + $1 \rightarrow R$
        + $(MDR) \rightarrow ALU  \rightarrow  ACC$
    + 存:
        + $(ACC) \rightarrow MDR$
        + $(MDR) \rightarrow M(MAR)$
            + $1 \rightarrow W$

4. 简述完成指令$LDA\;X$ 的数据通路
    + $X  \rightarrow MAR$
    + $M(MAR) \rightarrow MDR$
        + $1 \rightarrow R$
    + $(MDR) \rightarrow ALU  \rightarrow  ACC$

5. 简述完成指令 $ADD\;Y$ 的数据通路
    + $Y  \rightarrow MAR$
    + $M(MAR) \rightarrow MDR$
        + $1 \rightarrow R$
    + $(MDR) \rightarrow ALU,(ACC)  \rightarrow  ALU$
    + $ALU \rightarrow ACC$

6. 简述完成指令 $STA\;Z $的数据通路
    + $Z  \rightarrow MAR$
    + $(ACC)  \rightarrow  MDR$
    + $(MDR) \rightarrow M(MAR)$

## 控制器

$CU$的设计包括硬布线和微程序两种，微程序比较重要，硬布线了解即可。

### 控制器输入输出

输入：

1. 指令寄存器：$OP(IR)\rightarrow CU$，控制信号的产生与操作码有关。
2. 时钟：一个时钟脉冲发一个操作命令或一组需要同时执行的操作命令。
3. 标志：如条件转移指令，根据相应的标志位决定下一步操作。
4. 外来信号：如中断请求信号$INTR$、总线请求信号$HRQ$。

$CU$的输入信号来源如下：

1. 经指令译码器译码产生的指令信息。
    1. 指令寄存器：$OP(IR)\rightarrow CU$，控制信号的产生与操作码有关

2. 目前的机器周期
    1. $FE、IND、EX、INT$(事实上这四个触发器集成在CU内部)

3. 时序系统产生的节拍信号。
    1. 时钟：一个时钟脉冲发一个操作命令或一组需要同时执行的操作命令。

4. 来自执行单元的反馈信息即标志。
    1. 可能来自运算器的$PSW$、$ACC$的符号位等
    2. 也可能来自$I/O$设备、主存


前三者是主要因素。

![image-20230603210419448](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603210419448.png)

输出：

1. $CPU$内部的控制信号：寄存器之间的数据传输、$PC$的修改、控制$ALU$进行相应的运算。
2. 到控制总线的控制信号：
    + 到存储器:访存控制信号$MREQ$、读命令$RD$、写命令$WR$。
    + 到$I/O$设备:访问$I/O$设备的控制信号$I/O$。
    + 中断响应信号$INTA$。
    + 总线响应信号$HLDA$。

### 硬布线

微操作控制信号由组合逻辑电路根据当前的指令码、状态和时序，即时产生。

#### 设计步骤

1. 分析每个阶段的微操作序列。

    1. 取址$FE$:所有指令都一样

        1. $PC\rightarrow MAR$：将$PC$地址交给$MAR$。
        2. $1\rightarrow R$：主存发出读命令。只需要存储器空闲就能发出。
        3. $M(MAR)\rightarrow MDR$：将地址指向指令交给$MDR$。要$MAR$准备好，在$1$的后面。
        4. $MDR\rightarrow IR$：将指令交给$IR$。把$MDR$有指令，在$3$后面。
        5. $OP(IR)\rightarrow ID$：编译指令。$IR$中要有指令，在$4$后面。
        6. $(PC)+1\rightarrow PC$：$PC$自加$1$。因为操作完就可以更新，所以在$1$后面就可以了。

    2. 间址$IND$:所有指令都一样

        1. $Ad(IR)\rightarrow MAR$：获取$IR$指令中的地址交给$MAR$。
        2. $1\rightarrow R$：主存发出读命令。
        3. $M(MAR)\rightarrow MDR$：取出对应的值放到$MDR$中。
        4. $MDR\rightarrow Ad(IR)$：将$MDR$的地址值放入$IR$的指令中。

    3. 执行$EX$

        1. $CLA$（$clear$）$X$：$ACC$清零

            1. $0→AC$

        2. $LDA\;X$:取数指令，把$X$所指内容取到$ACC$

            1. $Ad(IR)→MAR$
            2. 1→R
            3. M(MAR)→MDR
            4. MDR→AC

        3. $JMP$（$jump$）$X$：无条件转移

            1. Ad(IR)→PC

        4. $BAN$（$branch\,ACC\,Negative$）$X$：条件转移,当$ACC$为负时转移到$X$

            1. $A_{0} \cdot A d(I R)+\overline{A_{0}} \cdot(P C) \rightarrow P C$

                + $A_{0} $指$A$的符号位,符号位为0指$A$为负数,跳转到$X$

                

    4. 中断$INT$

        1. $a\rightarrow MAR$：将$a$保存到$MAR$中。
        2. $1\rightarrow W$：主存发出写命令。存储器空闲就可以。
        3. $0\rightarrow EINT$：硬件关中断。安排在第一个周期就可以。
        4. $(PC)\rightarrow MDR$：将当前程序计数器保存的位置暂存到$MDR$，等待后期恢复。内部数据通路空闲就可以。
        5. $MDR\rightarrow M(MAR)$：将$MDR$的数据保存到$a$这个地址。在$4$之后。
        6. 向量地址$\rightarrow PC$：将$PC$送到中断服务地址。只用$PC$改好就可以，在$4$之后。

2. 选择$CPU$的控制方式：产生不同微操作命令序列所用的时序控制方式：

    1. 同步控制方式：
        + 整个系统所有的控制信号均来自一个统一的时钟信号。
        + 通常以最长的微操作序列和最烦琐的微操作作为标准，采取完全统一的、具有相同时间间隔和相同数目的节拍作为机器周期来运行不同的指令。
        + 同步控制方式的优点是控制电路简单，缺点是运行速度慢。
    2. 异步控制方式：
        + 异步控制方式不存在基准时标信号。
        + 各部件按自身固有的速度工作，通过应答方式进行联络。
        + 异步控制方式的优点是运行速度快，缺点是控制电路比较复杂。
    3. 联合控制方式：
        + 对各种不同的指令的微操作实行大部分采用同步控制、小部分采用异步控制的办法。

3. 安排微操作时序的原则：

    1. 微操作的先后顺序不得随意更改
    2. 被控对象不同的微操作尽量安排在一个节拍内完成
    3. 占用时间较短的微操作尽量安排在一个节拍内完成并允许有先后顺序

4. 电路设计。

    1. 列出操作时间表。
    2. 写出微操作命令的最简表达式。
    3. 画出逻辑图。

#### 指令类别

1. 非访存指令：

    1. $CLA$（$clear$）：$ACC$清零。
    2. $COM$（$complement$）：$ACC$取反。
    3. $SHR$（$shift$）：算术右移。
    4. $CSL$（$cyclic\,shift$）：循环左移。
    5. $STP$（$stop$）：停机。

    ![image-20230603211542126](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603211542126.png)

2. 访存指令：

    1. $ADD$：加法指令，隐含$ACC$。
    2. $STA$：存数指令，隐含$ACC$。
    3. $LDA$：取数指令，隐含$ACC$。

    ![image-20230603211648526](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603211648526.png)

3. 转移指令：

    1. $JMP$（$jump$）：无条件转移。
    2. $BAN$（$branch\,ACC\,Negative$）：条件转移。

    ![image-20230603211759854](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603211759854.png)

#### 基本微操作时序

首先对于取指周期，基本上的流程如下：

1. $PC\rightarrow MAR$：将$PC$地址交给$MAR$。
2. $1\rightarrow R$：主存发出读命令。只需要存储器空闲就能发出。
3. $M(MAR)\rightarrow MDR$：将地址指向指令交给$MDR$。要$MAR$准备好，在$1$的后面。
4. $MDR\rightarrow IR$：将指令交给$IR$。把$MDR$有指令，在$3$后面。
5. $OP(IR)\rightarrow ID$：编译指令。$IR$中要有指令，在$4$后面。
6. $(PC)+1\rightarrow PC$：$PC$自加$1$。因为操作完就可以更新，所以在$1$后面就可以了。

所以没有依赖的可以尽量往前放，顺序可以变为$123645$。

因为$12$没有相互依赖，所以可以都安排在$T0$时间；$36$在$1$的后面，且$36$之间用到的设备不一样从而不会冲突，所以都安排在$T1$；而$4$和$5$时间都较短，所以可以都安排在$T2$。

然后是间址周期：

1. $Ad(IR)\rightarrow MAR$：获取$IR$指令中的地址交给$MAR$。
2. $1\rightarrow R$：主存发出读命令。
3. $M(MAR)\rightarrow MDR$：取出对应的值放到$MDR$中。
4. $MDR\rightarrow Ad(IR)$：将$MDR$的地址值放入$IR$的指令中。

与取指周期一致，$2$可以跟$1$一起，而$34$都依赖于$1$，所以$12$是$T0$，$3$是$T1$，$4$是$T2$。

执行周期省略，最后是中断周期，假设中断时要保存的地址为$a$：

1. $a\rightarrow MAR$：将$a$保存到$MAR$中。
2. $1\rightarrow W$：主存发出写命令。存储器空闲就可以。
3. $0\rightarrow EINT$：硬件关中断。安排在第一个周期就可以。
4. $(PC)\rightarrow MDR$：将当前程序计数器保存的位置暂存到$MDR$，等待后期恢复。内部数据通路空闲就可以。
5. $MDR\rightarrow M(MAR)$：将$MDR$的数据保存到$a$这个地址。在$4$之后。
6. 向量地址$\rightarrow PC$：将$PC$送到中断服务地址。只用$PC$改好就可以，在$4$之后。

$1$、$2$、$3$都在$T0$，而$456$依次为$T1$、$T2$、$T3$。

这些操作由中断隐指令完成。中断隐指令不是一条指令，而是指一条指令的中断周期由硬件完成的一系列操作

#### 组合逻辑设计

![image-20230603212124990](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603212124990.png)

![image-20230603212157617](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603212157617.png)

![image-20230603212308100](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603212308100.png)

#### 硬布线控制器的特点

- 指令越多，设计和实现就越复杂，因此一般用于$RISC$(精简指令集系统)
- 如果扩充一条新的指令，则控制器的设计就需要大改，因此扩充指令较困难。
- 由于使用纯硬件实现控制，因此执行速度很快。微操作控制信号由组合逻辑电路即时产生。

### 微程序控制器

事先把微操作控制信号存储控制存储器中，将每一条机器指令编写成一个微程序，这些微程序可以存到一个控制存储器中，用寻址用户程序机器指令的办法来寻址每个微程序中的微指令。

+ 在微程序控制器中，控制部件向执行部件发出的控制信号称为微命令。
+ 微命令执行的操作称为微操作。
+ 微指令则是若干微命令的集合。
+ 若干微指令的有序集合称为微程序。

#### 微程序构成

+ 相关概念
    + **微指令（Microinstruction）**：微指令是微程序的最小执行单位，是对硬件层面的微操作进行编码的指令。它包含了对CPU中各个部件的控制信号、操作码和地址等信息。每条微指令对应着一个或多个微操作。
    + **指令（Instruction）**：指令是在机器语言中表示一条操作的基本单位。它是对特定操作的功能描述，由操作码和操作数组成。在微程序控制器中，指令被解码后会生成对应的一系列微指令。
    + **微操作（Microoperation）**：微操作是对硬件中的某个具体操作进行编码的指令，它是微指令的基本执行单位。例如，将数据从寄存器加载到ALU、将运算结果存储到寄存器等都可以视为一个微操作。
    + **微程序（Microprogram）**：微程序是一系列微指令的集合，用于实现特定的指令集和操作序列。它是对指令执行过程进行细化和抽象的一种表示方式。微程序通常以存储器的形式存在，存储着每条指令对应的微指令序列。
    + ![image-20230603213035541](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603213035541.png)

+ 完成一条机器指令分为多个微操作命令，微操作命令即微命令，是微操作的控制信号。微操作是微命令的执行过程。
+ 微命令分为：
    + 相容性微命令：可以同时产生、共同完成某些微操作的微命令。
    + 互斥性微命令：在机器中不允许同时出现的微命令。
+ 对于相容性的微命令可以合并为一条微指令，而互斥性微命令只能单独为一条微指令。
+ 微指令是若干微命令的集合。微周期通常指从控制存储器中读取一条微指令并执行相应的微操作所需的时间。
+ 假设微指令的一个二进制位对应一个微操作命令，所有的微命令都合并为微指令，微指令再合并为一个微程序保存到$ROM$中，从而每一条机器指令对应一条微程序。
+ 微指令基本格式：
    + 操作控制：微操作码：产生控制信号。
    + 顺序控制：微地址码：产生下一条指令地址。
    + ![image-20230603213222529](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603213222529.png)
+ 每条指令取指周期的操作是相同的，所以将取指令操作的微命令统一编成一个微程序，而每条机器指令所对应的具体操作再单独编写一个对应的微程序。
+ 执行公用的取指微程序从主存中取出机器指令后，由机器指令的操作码字段指出各个微程序的入口地址（初始微地址）。

#### 微程序控制器结构

在控制单元$CU$内部:

![image-20230603214556204](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603214556204.png)

+ 存储器：

    + 主存储器用于存放程序和数据，在$CPU$外部，由$RAM$实现。

    + 控制存储器$CM(Control\;Memory)$用于存放微程序，在$CPU$内部，由$ROM$实现。
        + $ROM$非易失性,数据不会丢失即微程序由厂商设计且出厂前就会把微指令写好
        + 决定了$CPU$对指令集的支持和执行效率
        + 通过适当设计微指令和微程序，可以实现复杂的指令集和灵活的指令执行
        + $CM$的访问速度和容量对$CPU$性能和指令执行速度也有重要影响。


+ 寄存器：

    + 地址译码器：将地址码转换微存储单元控制信号。

    + 微地址寄存器$CMAR$(别名$\mu PC$)：接收微地址形成部件送来的微地址，为在$CM$中读取微指令作准备。

    + 微指令寄存器$CMDR$(别名$\mu IR$)：用于存放从$CM$中取出的微指令，它的位数同微指令字长相等。

    + 微地址形成部件：产生初始微地址和后继微地址，以保证微指令的连续执行。

    + 顺序逻辑单元：为了保证指令联系执行，控制形成下一条微指令，拥有一个标志位标识顺序执行还是跳转和一个时钟信号$CLK$。


控制流程：

1. 机器指令操作码$OP$送到微地址形成部件形成微地址。
2. 将初始微地址送到顺序逻辑单元，判断顺序执行还是跳转。
3. 送到$CMAR$保存微地址。
4. 将微地址从$CMAR$送到地址译码器中译码。
5. 形成控制单元后送到$CM$中取出微指令。
6. 将微指令送到$CMDR$中。
7. 根据微指令中的下一条指令地址送到顺序逻辑单元，判断顺序执行还是跳转。
8. 返回结果后$CMDR$送到$CPU$内部和系统总线，产生控制信号。

微程序个数：

+ 默认一条机器指令对应一个微程序。
    + 物理上，取指址周期、执行周期看起来像是两个微程序，但逻辑上应该把它们看作一个整体。因此，“一条指令对应一个微程序”的说法是正确的

+ 取指周期微程序默认是公共的（即单独拿出来公用），故如果某指令系统中有$n$条机器指令，则$CM$中**微程序段**的个数至少是$n+1$个（加一个取指的公共微程序）。
    + 也可以说**微程序**的个数至少是$n$个

+ 间址周期微程序和中断周期微程序不一定是公共的。若公共的，如果这台计算机指令系统中有$n$条机器指令，则$CM$中**微程序**的个数是$n+3$个。若题目中没有提到间址，就不考虑间址，所以是$n+2$个。





#### 微指令格式

![image-20230603215903874](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603215903874.png)

1. 水平型微指令：
    + 一次能定义并执行多个并行操作。
    + 基本格式是：操作控制+判别测试+后继地址。
    + 优点：微程序短，执行速度快。
    + 缺点：操作控制字段比较长导致微指令长，编写微程序较麻烦。
2. 垂直型微指令：
    + 类似机器指令操作码的方式，由微操作码字段规定微指令的功能。一条指令对应一个操作。
    + 基本格式：微操作码+目的地址+源地址。
    + 优点：微操作码短导致微指令短、简单、规整，便于编写微程序。
    + 缺点：微程序长，执行速度慢，工作效率低。
3. 混合型微指令：
    + 在垂直型的基础上增加一些不太复杂的并行操作。
    + 微指令较短，仍便于编写。
    + 微程序也不长，执行速度加快。

水平型微指令的求法。

+ 操作控制：
    + 若是直接编码方式，则微命令数就是操作控制字段位数。
    + 若是字段直接编码方式，则会分$n$个组，每组$n_i$种状态，则总位数就是$\sum\limits_{i=1}^n\log_2(n_i+1)$（全$0$空出）。如$2,3,4$，则一共需要$2+2+3=7$位。
+ 判别测试：
    + 直接编码方式，有几个外部条件，就取几位。
    + 如果是字段直接编码，有$N$个外部条件就有$n$位，$2^n\geqslant N+1$，加$1$是因为还有无条件转移的情况。
+ 后继地址：
    + 求出前面两项后，直接根据微指令字长减去。
    + 根据$CM$的容量的前一项确认，$2^N\times M$容量就是$N$位。

#### 微指令编码

微指令的编码方式又称为微指令的控制方式，它是指如何对微指令的控制字段进行编码，以形成控制信号。编码的目标是在保证速度的情况下，尽量缩短微指令字长。

1. 直接编码（直接控制）方式：
    + 在微指令的操作控制字段中，每一位二进制位代表一个微操作命令。
    + 某位为“$1$”表示该控制信号有效，为$1$的指令同时执行；若“$0$”则代表此时该位指向的命令不运行。
    + 优点：简单、直观，执行速度快，操作并行性好。
    + 缺点：微指令字长过长，$n$个微命令就要求微指令的操作字段有$n$位，造成控存容量极大。
    + ![image-20230603220208151](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603220208151.png)
2. 字段直接编码方式：
    + 将微指令的控制字段分成若干“段”，每段经译码后发出控制信号。
    + 微命令字段分段的原则：
        1. 因为每组译码后可以通过每位$1\&0$的不同来让每组中的操作互斥，而不同组则很难完成互斥，所以**互斥性微命令分在同一段内**；因为命令在不同的组可以同时执行，所以**相容性微命令分在不同段内**。
            1. 例如$001\&011$是相容性微命令,可以并行发出,$001\&100$是互斥性微命令,不可以并行发出
        2. 每个小段中包含的信息位不能太多，否则将增加译码线路的复杂性和译码时间。
        3. 一般每个小段还要留出一个状态，表示本字段不发出任何微命令。因此，当某字段的长度为$3$位时，最多只能表示$7$个互斥的微命令，通常用$000$表示不操作。
    + 优点：可以缩短微指令字长。
    + 缺点：要通过译码电路后再发出微命令，因此比直接编码方式慢。
3. 字段间接编码方式：
    + 一个字段的某些微命令需由另一个字段中的某些微命令来解释(两层译码)，由于不是靠字段直接译码发出的微命令，故称为字段间接编码，又称隐式编码。
    + 优点：可进一步缩短微指令字长。
    + 缺点：运行速度更慢；削弱了微指令的并行控制能力，故通常作为字段直接编码方式的辅助手段。

#### 微指令地址

1. 直接由微指令的**下地址字段**指出：微指令格式中设置一个下地址字段，由微指令的下地址字段直接指出后继微指令的地址，这种方式又称为**断定方式**。
2. 根据机器指令的**操作码**形成：当机器指令取至指令寄存器后，微指令的地址由操作码经微地址形成部件形成。
3. **增量计数器法**：$(CMAR)+1\rightarrow CMAR$，适用于指令**连续存放**的情况。
4. 分支转移：指令分为三个字段：
    1. 操作控制字段：指明操作控制类型。
    2. 转移方式：指明判别条件。
    3. 转移地址：指明转移成功后的去向。
5. 通过测试网络：一个测试网络产生。

![image-20230603221103255](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603221103255.png)

6. 由硬件产生微程序入口地址：
    + 第一条微指令地址：专门硬件产生。
    + 中断周期：硬件产生中断周期微程序首地址。

#### 微程序控制单元设计

设计步骤：

1. 分析每个阶段的微操作序列。
2. 写出对应机器指令的微操作命令及节拍安排：
    1. 写出每个周期所需要的微操作（参照硬布线）。
    2. 补充微程序控制器特有的微操作：
        + 取指周期：$Ad(CMDR)\rightarrow CMAR$；$OP(IR)\rightarrow CMAR$。
        + 执行周期：$Ad(CMDR)\rightarrow CMAR$。
3. 确定微指令格式：
    + 根据微操作个数决定采用何种编码方式，以确定微指令的操作控制字段的位数。
    + 由微指令数确定微指令的顺序控制字段的位数。
    + 最后按操作控制字段位数和顺序控制字段位数就可确定微指令字长。
4. 编写微指令码点：根据操作控制字段每一位代表的微操作命令，编写每一条微指令的码点。

| 节拍安排 | 取指周期-硬布线控制器的节拍安排 | 取指周期-微程序控制器的节拍安排 |
| :------: | :-----------------------------: | :-----------------------------: |
|    T0    |             PC→MAR              |             PC→MAR              |
|    T0    |               1→R               |               1→R               |
|    T1    |           M(MAR)→MDR            |           M(MAR)→MDR            |
|    T1    |            (PC)+1→PC            |            (PC)+1→PC            |
|    T2    |             MDR→IR              |             MDR→IR              |
|    T2    |            OP(IR)→ID            |      OP(IR)→微地址形成部件      |

根据读出转入微指令的过程，变为：

| 节拍安排 | 取指周期-硬布线控制器的节拍安排 | 取指周期-微程序控制器的节拍安排 |
| :------: | :-----------------------------: | :-----------------------------: |
|    T0    |             PC→MAR              |             PC→MAR              |
|    T0    |               1→R               |               1→R               |
|    T1    |           M(MAR)→MDR            |          Ad(CMDR)→CMAR          |
|    T1    |            (PC)+1→PC            |                                 |
|    T2    |             MDR→IR              |           M(MAR)→MDR            |
|    T2    |            OP(IR)→ID            |            (PC)+1→PC            |
|    T3    |                                 |          Ad(CMDR)→CMAR          |
|    T4    |                                 |             MDR→IR              |
|    T4    |                                 |      OP(IR)→微地址形成部件      |

#### 硬布线与微程序

| 对比项目\类别 |                         微程序控制器                         |                         硬布线控制器                         |
| :-----------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   工作原理    | 微操作控制信号以微程序的形式存放在控制存储器中，执行指令时读出即可 | 微操作控制信号由组合逻辑电路根据当前的指令码、状态和时序，即时产生 |
|   执行速度    |                    慢（从CM中读取微指令）                    |                              快                              |
|    规整性     |                            较规整                            |                         烦琐、不规整                         |
|   应用场合    |                           CISC CPU                           |                           RISC CPU                           |
|   易扩充性    |                          易扩充修改                          |                             困难                             |

#### 微程序设计分类

+ 静态微程序设计：无需改变，采用$ROM$。
+ 动态微程序设计动态通过改变微指令和微程序改变机器指令，有利于仿真，采用$EPROM$。
+ 毫微程序设计：微程序设计用微程序解种机器指令，毫微程序设计用毫微程序解释微程序。

## 指令流水线

### 流水线基本概念

#### 指令流水线定义

一条指令大致分为取指(取指令)、分析、执行三个阶段（或者取指$IF$、译码/读寄存器$ID$、执行/计算地址$EX$、访存$MEM$、结果写回寄存器$WB$）

+ 取指：根据PC内容访问主存储器，取出一条指令送到R中。
+ 分析：对指令操作码进行译码，按照给定的寻址方式和地址字段中的内容形成操作数的有效地址EA,并从有效地址EA中取出操作数。
+ 执行：根据操作码字段，完成指令规定的功能，即把运算结果写到通用寄存器或主存中。

设三个阶段时间相等且   都为$t$，一共有$n$条指令：

1. 顺序执行：
    + 顺序执行所有指令。
    + 总耗时$3nt$。
    + 传统冯·诺依曼机采用顺序执行方式，又称串行执行方式。
    + 优点：控制简单，硬件代价小。
    + 缺点：执行指令的速度较慢，在任何时刻，处理机中只有一个指令在指令，各功能部件利用率都很低。
    + ![image-20230603221536498](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603221536498.png)
2. 一次重叠执行方式：
    + 在执行第$k$条指令的同时取第$k+1$条指令。
    + 总耗时$(1+2n)t$。
    + 优点：程序的执行时间缩短了$1/3$，各功能部件的利用率明患提高。
    + 缺点：需要付出硬件上较大开销的代价控制过程也比顺件执行复杂了。
    + ![image-20230603221715427](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603221715427.png)
3. 二次重叠执行方式：
    + 分析第$k$条指令的同时取$k+1$条指令，执行$k$条指令时分析$k+1$条指令与取$k+2$条指令。
    + 总耗时$(2+n)t$。
    + 与顺序执行方式相比，指令的执行时间缩短近$2/3$。
    + 这是一种理想的指令执行方式,处理机中同时有$3$条指令在执行。
    + ![image-20230603221758315](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603221758315.png)
4. 指令流水方式：多次重叠执行方式就是流水线方式。

#### 流水线表示

1. 指令执行过程图：

    + 横坐标为时间，纵坐标为指令序列。
    + 每一行就是一条指令序列。
    + 主要用于分析指令执行过程以及影响流水线的因素。

    ![image-20230603222006424](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603222006424.png)

2. 时空图：

    + 横坐标为时间，纵坐标为空间，即不同的阶段所对应的不同硬件资源，如：取指、译码、执行、存结果。
    + 每一斜着的一列就是一条指令序列。
    + 主要用于分析流水线的性能。

    ![image-20230603221919024](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603221919024.png)



#### 流水线的性能指标

1. 吞吐率：
    + 指在单位时间内流水线所完成的任务数量，或是输出结果的数量。
    + 设任务数为$n$，处理完成$n$个任务所用的时间为$T_k$，则计算流水线吞吐率$TP$的最基本的公式为$TP=\dfrac{n}{T_k}$。
    + 在最理想情况下:
        + 令每个指令分为$k$个阶段，每个阶段所需时间为$\Delta t$一般等于一个时钟周期，则$T_k=(k+n-1)\Delta t$，所以$TP=\dfrac{n}{(k+n-1)\Delta t}$。
            + 在最理想情况下取一个机器周期=一个时钟周期
            + 当连续输入的任务$n\to \infty$时，得最大吞吐率为$TP_{max}=\frac{1}{\Delta t}$
    + 第一个指令执行阶段称为装入时间，最后一个指令执行的阶段称为排空时间。
    + ![image-20230603222647289](https://trouvaille-oss.oss-cn-beijing.aliyuncs.com/picList/image-20230603222647289.png)
2. 加速比：
    + 完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比。
    + 设$T_0$表示不使用流水线时的执行时间，即顺序执行所用的时间；$T_k$表示使用流水线时的执行时间，则计算流水线加速比$S$的基本公式为$S=\dfrac{T_0}{T_k}$。
    + 单独完成一个任务需要$k\Delta t$，则顺序完成时间$T_0=nk\Delta t$。又$T_k=(k+n-1)\Delta t$，所以$S=\dfrac{nk\Delta t}{(k+n-1)\Delta t}=\dfrac{kn}{k+n-1}$。
3. 效率：
    + 流水线的设备利用率称为流水线的效率。
    + 在时空图上，流水线的效率定义为完成$n$个任务占用的时空区有效面积与$n$个任务所用的时间与k个流水段所围成的时空区总面积之比。（时空图中用到的类平行四边形面积除以围成矩形的面积）。
    + 流水线效率$E$的基本公式为$E=\dfrac{T_0}{kT_k}=\dfrac{n}{k+n-1}$。

#### 指令集要求

1. 指令长度一致。
2. 指令格式规整，保证源寄存器位置相同。
3. 让$Load/Store$指令唯一访问存储器。
4. 数据和指令在存储器种对齐存放。

### 流水线影响因素

+ 理想情况：各阶段花费时间相同，每个阶段结束后能立即进入下一阶段。
+ 机器周期一般分为五段：取指$IF$、译码$ID$、执行$EX$、访存$M$、写回$WB$。
+ 假如各部件实际耗时：$100ns$、$80ns$、$70ns$、$50ns$、$50ns$，为方便流水线的设计，将每个阶段的耗时取成一样，以最长耗时为准。即此处应将机器周期设置为$100ns$。
+ 流水线每一个功能段部件后面都要有一个缓冲寄存器，或称为锁存器，其作用是保存本流水段的执行结果，提供给下一流水段使用。

#### 结构相关（资源冲突）

+ 由于多条指令在同一时刻争用同一资源而形成的冲突称为结构相关。
+ 解决办法：
    1. 后一相关指令暂停一周期。
    2. 单独设置数据存储器和指令寄存器。

#### 数据相关（数据冲突）

+ 数据相关指在一个程序中，存在必须等前一条指令执行完才能执行后一条指令的情况，则这两条指令即为数据相关。
+ 数据的基本操作：读、写。
+ 冲突的基本类型：
    + 写后读$RAW$：没有写完就读取，按序发射，按序完成只会出现写后读的错误。
    + 读后写$WAR$：乱序发射，优化手段导致指令顺序不符合编写程序时预想的逻辑顺序。
    + 写后写$WAW$：存在多个功能部件时，后一条指令先于前一条指令完成。
+ 解决办法:
    1. 把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行。可分为硬件阻塞（$stall$）和软件插入“$NOP$”（空指令）两种方法。
    2. 数据旁路技术：计算得到结果后不写回，直接当作输入使用。
    3. 编译优化：通过编译器调整指令顺序来解决数据相关。

#### 控制相关（控制冲突）

+ 当流水线遇到转移指令和其他改变$PC$值的指令而造成断流时，会引起控制相关。
+ 主要指转移指令。
+ 解决办法：
    1. 尽早判别转移是否发生，尽早生成转移目标地址。
    2. 预取转移成功和不成功两个控制流方向上的目标指令。
    3. 加快和提前形成条件码。
    4. 提高转移方向的猜准率。
